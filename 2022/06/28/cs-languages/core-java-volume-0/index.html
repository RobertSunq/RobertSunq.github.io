<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="java, book">
    <meta name="description" content="java核心技术学习笔记, 系统化的整理java的相关应用知识">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>java核心技术——卷1 | Qing</title>
    <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 5.4.2">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Qing</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/solution" class="waves-effect waves-light">

      
      <i class="fas fa-flag" style="zoom: 0.6;"></i>
      
      <span>题解系列</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/solution/leetcode">
          
          <i class="fas fa-pen" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Leetcode</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Qing</div>
        <div class="logo-desc">
            
            这个人没啥子特点 喜欢一切随缘咯 ( •̀ ω •́ )✧
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-flag"></i>
			
			题解系列
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/solution/leetcode " style="margin-left:75px">
				  
				   <i class="fa fas fa-pen" style="position: absolute;left:50px" ></i>
			      
		          <span>Leetcode</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/RobertSunq/RobertSunq.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/RobertSunq/RobertSunq.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('哟！你知道密码不？')).toString(CryptoJS.enc.Hex)) {
                alert('好可惜你不知道哎，那只能回到主页咯！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/22.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">java核心技术——卷1</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%8E%9F%E5%88%9B/">
                                <span class="chip bg-color">原创</span>
                            </a>
                        
                            <a href="/tags/java/">
                                <span class="chip bg-color">java</span>
                            </a>
                        
                            <a href="/tags/book/">
                                <span class="chip bg-color">book</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/cs-languages/" class="post-category">
                                cs-languages
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-06-28
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-04-23
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    39.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    150 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="JAVA核心技术——卷1"><a href="#JAVA核心技术——卷1" class="headerlink" title="JAVA核心技术——卷1"></a>JAVA核心技术——卷1</h1><blockquote>
<p>说明：java核心技术 —— 卷Ⅰ</p>
<p>当然这本书很厚，讲解的也很详细。所有呢，我没有准备将所有的知识点在我的这份文章中书写记录，在这里只记录部分我觉得需要备忘的知识。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/RobertSunq/data/tree/master/qing/blog/hexo/corejava/book/api">书中涉及到的java基础类和接口的解析链接</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/RobertSunq/data/tree/master/qing/blog/hexo/corejava/book/code">书中涉及到的示例代码链接</a> 拷贝自 <a target="_blank" rel="noopener" href="http://horstmann.com/corejava">http://horstmann.com/corejava</a></p>
</blockquote>
<h2 id="Java程序设置环境"><a href="#Java程序设置环境" class="headerlink" title="Java程序设置环境"></a>Java程序设置环境</h2><h3 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/downloads/">download-link</a></p>
<p>以下以 <code>jdk_path</code> 代表 <code>java</code> 安装目录</p>
</blockquote>
<table>
<thead>
<tr>
<th>术语</th>
<th>缩写</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Java Development Kit (Java开发工具包)</td>
<td>JDK</td>
<td>编写Java程序的程序员使用的软件</td>
</tr>
<tr>
<td>Java Runtime Enviroment (Java运行时环境)</td>
<td>JRE</td>
<td>运行Java程序的用户使用的软件</td>
</tr>
<tr>
<td>Server JRE (服务器JRE)</td>
<td>——</td>
<td>在服务器上运行Java程序的软件</td>
</tr>
<tr>
<td>Standard Edition (标准版)</td>
<td>SE</td>
<td>用于桌面或简单服务器应用的Java平台</td>
</tr>
<tr>
<td>Enterprise Edition (企业版)</td>
<td>EE</td>
<td>用于复杂服务器应用的Java平台</td>
</tr>
<tr>
<td>Micro Edition (微型版)</td>
<td>ME</td>
<td>用于小型设备的Java平台</td>
</tr>
<tr>
<td>Java FX</td>
<td>——</td>
<td>用于图形化用户界面的一个备选工具包，在Java 11之前的某些Java SE发布版本中提供</td>
</tr>
<tr>
<td>OpenJDK</td>
<td>——</td>
<td>Java SE的一个免费开源实现</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="设置JDK"><a href="#设置JDK" class="headerlink" title="设置JDK"></a>设置JDK</h3><h4 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a>安装目录</h4><ul>
<li><p>在Windows中，设置自定义的安装目录，配置好环境变量即可。(最好路径中不要存在空格和中文)</p>
<ul>
<li>环境变量的配置略</li>
</ul>
</li>
<li><p>在Mac中，运行安装程序。会把软件安装到 <code>/Library/Java/JavaVirtualMachines/jdk-11.0.x.jdk/Contents/Home</code>。 通过 <code>which java</code> 查找</p>
</li>
<li><p>在Linux中</p>
<ul>
<li>使用 <code>.tar.gz</code>文件解压到选择的目录即可。 eg. <code>/opt</code></li>
<li>使用 <code>RPM</code> 文件安装， 需要检查是否安装在  <code>/usr/java/jdk-11.0.x</code> 目录</li>
<li>环境变量的配置：在 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code> 文件的最后一行添加 export <code>PATH=/usr/java/jdk-11.0.x/bin:$PATH</code></li>
</ul>
</li>
</ul>
<h4 id="安装库源文件和文档"><a href="#安装库源文件和文档" class="headerlink" title="安装库源文件和文档"></a>安装库源文件和文档</h4><p><strong>库源文件</strong></p>
<ol>
<li><p>确保JDK已经安装，而且<code>jdk_path/bin</code> 目录在可执行路径中</p>
</li>
<li><p>在主目录(<code>jdk_path</code>)中建立一个目录 <code>javasrc</code> 。 </p>
</li>
<li><p>将 <code>jdk_path/lib/zip</code> 解压到 <code>javasrc</code> 目录中 </p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> jdk_path
<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> javasrc
<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> javasrc
<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ jar xvf jdk_path/lib/zip
<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> <span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<blockquote>
<p>src.zip 文件中包含了所有公共类库的源代码。获取更多的源代码（编译器、虚拟机、原生方法、私有辅助类）, 访问 <a target="_blank" rel="noopener" href="https://openjdk.org/">https://openjdk.org/</a></p>
</blockquote>
<p> <strong>文档</strong> </p>
<ol>
<li>文档包含在一个压缩文件中，独立于JDK，可以直接从 <a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/downloads">https://www.oracle.com/java/technologies/downloads</a> 中下载对应版本的文档</li>
<li>解压压缩包并重命名</li>
<li>在浏览器中导航到 jdk_path/javadoc/index.html</li>
</ol>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> jdk_path
<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ jar xvf jdk-11.0.15.1_doc-all.zip
<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mv</span> docs javadoc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="运行一个程序"><a href="#运行一个程序" class="headerlink" title="运行一个程序"></a>运行一个程序</h3><ol>
<li>编写如下 Welcome.java 文件</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">book<span class="token punctuation">.</span>v1ch02</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @author: Robert Sunq
 * @date: 2022-06-29 0:03
 * @since: JDK-11
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Welcome</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> greeting <span class="token operator">=</span> <span class="token string">"Welcome to Core Java!"</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> greeting<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li>shell 中键入 <code>javac .\book\v1ch02\Welcome.java</code> <ol>
<li>如果你的代码中没有添加 <code>package</code> 则去掉命令中的路径，并在文件所在的目录下运行该命令</li>
<li>注意需要包含文件类型<code>.java</code></li>
</ol>
</li>
<li>键入  <code> java book.v1ch02.Welcome</code>  <ol>
<li>如果你的代码中没有添加 <code>package</code> 则不需要键入全路径来运行程序</li>
<li>出现错误<code>java.lang.ClassNotFoundException: ImageViewer</code> 则有可能是时引入<code>package</code>的原因，导致找不到 <code>.class</code> 文件来运行</li>
<li>注意 不要包含编译后的文件名 <code>.class</code></li>
</ol>
</li>
</ol>
<h3 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h3><p>Java 9引入了另一种使用Java的方法。<strong>JShell</strong>程序提供一个“读取-计算-打印循环”（Read-Evaluate-Print Loop, REPL）。键入一个Java表达式；JShell会自动评估输入，打印结果，等待下一个输入。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 键入在配置后java的全局环境后，键入 jshell 进入，之后会显示问候符</span>
<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ jshell
<span class="token operator">|</span>  欢迎使用 JShell -- 版本 <span class="token number">11.0</span>.15.1
<span class="token operator">|</span>  要大致了解该版本, 请键入: /help intro

<span class="token comment"># 键入表达式，将还会输入结果，即使没有键入 System.out.println</span>
jshell<span class="token operator">&gt;</span> <span class="token string">"core java"</span>.length<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token variable">$1</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">9</span>

<span class="token comment"># 之后可使用输出的变量名 $1 来使用于之后的计算</span>
jshell<span class="token operator">&gt;</span> <span class="token number">5</span> * <span class="token variable">$1</span> - <span class="token number">3</span>
<span class="token variable">$2</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">42</span>

<span class="token comment"># 当然也可以自定义变量</span>
jshell<span class="token operator">&gt;</span> int a <span class="token operator">=</span> <span class="token number">4</span>
a <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">4</span>

jshell<span class="token operator">&gt;</span> a
a <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">4</span>

<span class="token comment"># 键入部分名称后，可与使用  `tab` 来进行补全</span>
jshell<span class="token operator">&gt;</span> Math
Math          MathContext

签名:
java.lang.Math

<span class="token operator">&lt;</span>再次按 Tab 可查看文档<span class="token operator">&gt;</span>
jshell<span class="token operator">&gt;</span> Math.
E                 IEEEremainder<span class="token punctuation">(</span>    PI                abs<span class="token punctuation">(</span>              acos<span class="token punctuation">(</span>             addExact<span class="token punctuation">(</span>         asin<span class="token punctuation">(</span>             atan<span class="token punctuation">(</span>             atan2<span class="token punctuation">(</span>            cbrt<span class="token punctuation">(</span>             ceil<span class="token punctuation">(</span>             class
copySign<span class="token punctuation">(</span>         cos<span class="token punctuation">(</span>              cosh<span class="token punctuation">(</span>             decrementExact<span class="token punctuation">(</span>   exp<span class="token punctuation">(</span>              expm1<span class="token punctuation">(</span>            floor<span class="token punctuation">(</span>            floorDiv<span class="token punctuation">(</span>         floorMod<span class="token punctuation">(</span>         fma<span class="token punctuation">(</span>              getExponent<span class="token punctuation">(</span>      hypot<span class="token punctuation">(</span>
incrementExact<span class="token punctuation">(</span>   log<span class="token punctuation">(</span>              log10<span class="token punctuation">(</span>            log1p<span class="token punctuation">(</span>            max<span class="token punctuation">(</span>              min<span class="token punctuation">(</span>              multiplyExact<span class="token punctuation">(</span>    multiplyFull<span class="token punctuation">(</span>     multiplyHigh<span class="token punctuation">(</span>     negateExact<span class="token punctuation">(</span>      nextAfter<span class="token punctuation">(</span>        nextDown<span class="token punctuation">(</span>
nextUp<span class="token punctuation">(</span>           pow<span class="token punctuation">(</span>              random<span class="token punctuation">(</span><span class="token punctuation">)</span>          rint<span class="token punctuation">(</span>             round<span class="token punctuation">(</span>            scalb<span class="token punctuation">(</span>            signum<span class="token punctuation">(</span>           sin<span class="token punctuation">(</span>              sinh<span class="token punctuation">(</span>             sqrt<span class="token punctuation">(</span>             subtractExact<span class="token punctuation">(</span>    tan<span class="token punctuation">(</span>
tanh<span class="token punctuation">(</span>             toDegrees<span class="token punctuation">(</span>        toIntExact<span class="token punctuation">(</span>       toRadians<span class="token punctuation">(</span>        ulp<span class="token punctuation">(</span>
jshell<span class="token operator">&gt;</span> Math.l
log<span class="token punctuation">(</span>     log10<span class="token punctuation">(</span>   log1p<span class="token punctuation">(</span>

<span class="token comment"># 当然和常用的 shell 窗口一样 可与使用方向键来调整光标和查看历史命令</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Java的基本程序设计结构"><a href="#Java的基本程序设计结构" class="headerlink" title="Java的基本程序设计结构"></a>Java的基本程序设计结构</h2><h3 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h3><ul>
<li><strong>Java中区分大小写</strong></li>
<li>类的命名请遵循 <strong>驼峰法</strong></li>
<li>java虚拟机总是从 <strong>main</strong> 方法的代码作为类的执行入口</li>
<li>java中的注释有两种形式 <code>\\</code> 和 <code>\*  *\</code></li>
<li>Java 时一种 <strong>强类型语言</strong>，所以必须为每个变量声明一种类型</li>
</ul>
<h4 id="类型说明"><a href="#类型说明" class="headerlink" title="类型说明"></a>类型说明</h4><table>
<thead>
<tr>
<th>类型</th>
<th>存储需求</th>
<th>取值范围</th>
<th>包装类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td>4(字节)</td>
<td>-2147483648 — 2147483647</td>
<td><code>Integer</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td>2</td>
<td>-32768 — 32767</td>
<td><code>Short</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td>8</td>
<td>-9223372036854775808 — 9223372036854775807</td>
<td><code>Long</code></td>
</tr>
<tr>
<td><code>byte</code></td>
<td>1</td>
<td>-128 — 127</td>
<td><code>Byte</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td>4</td>
<td>+- 3.40282347E+23F(有效位数 6~7 位)</td>
<td><code>Float</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td>8</td>
<td>+- 1.79769313486231570E+308(有效位数 15位)</td>
<td><code>Double</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td>1</td>
<td></td>
<td><code>Char</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>1</td>
<td><code>false</code>  <code>true</code></td>
<td><code>Boolean</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p><strong><code>String</code></strong></p>
<ul>
<li>字符串，使用<code> ""</code> 包含起来的字符。 </li>
<li><strong>不可变</strong>，表示该对象中的值时不能修改的。<code>String greeting = "hello"; greeting = greeting.substring(0,3) + "p!";</code>注意这里字符串 <code>"hello"</code>是永远包含这几个代码单元序列的，并不能修改。第二步中只是使 <code>greeting </code> 引用向了另一个字符串而已。如同原本存放<code>3</code>数值变量的地方存放上了<code>4</code>.</li>
<li>不可变字符串的优点：<strong>编译器可以让字符串共享</strong>，字符串存放在公共的存储池中。</li>
<li>注意检测相等时用 :  <code>s.equals(t)</code> 比较字符串字面量上的相等； 如果使用 <code>==</code> 运算符则会检测两个字符串是否存放再同一个位置上，即是否引用向同一个内存地址，如果两个字符串再同一个位置必然相等，但是也有可能将内容相等的多个字符串副本放置到不同的位置上，所以<strong>千万不要</strong>使用 <code>== </code>来测试字符串的相等。</li>
</ul>
</li>
<li><p><code>Long</code></p>
<ul>
<li>长整型数值有一个后缀<code>L</code>或<code>l</code>（<code>40000000L</code>）。</li>
<li>十六进制数值有一个前缀<code>0x</code>或<code>0X</code>（<code>0xFFE</code>）。</li>
<li>八进制数值有一个前缀<code>0</code>（<code>010</code>）。</li>
<li>二进制数值有一个前缀<code>0b</code>或<code>0B</code>（<code>0b1001</code>）。Java7之后</li>
<li>还可以在数字字面量加下划线，<code>1_000_000</code>(或 `0b1111_0100_0010_0100_0000)表示100万。当然Java编译器在编译后会去除这些下划线。</li>
<li>注意：Java 没有任何无符号（<code>unsigned</code>）形式的<code>int long short byte</code>类型。</li>
</ul>
</li>
<li><p><code>Double</code>和<code>Float</code></p>
<ul>
<li><code>float</code>类型的数值只有一个后缀<code>F</code>或<code>f</code>（<code>3.14</code>）。通常都是使用<strong>双精度数值</strong><code>double</code>类型。只有少数情况会使用<code>float</code>，比如：需要<strong>单精度</strong>的库或者大量存储数据。</li>
<li>没有后缀的浮点数值（3.14）默认为<code>double</code>类型。当然也可以添加后缀<code>D</code>或<code>d</code>（<code>3.14D</code>）</li>
<li>也可以使用十六进制表示浮点数。<code>0.125 = 0x1.0p-3</code>，在十六进制表示中 <code>p</code>表示指数，而不是<code>e</code>。注意，尾数采用十六进制，指数采用十进制。指数的基数是<code>2</code>，而不是<code>10</code>。</li>
</ul>
</li>
<li><p><code>Unicode</code>和<code>Char</code></p>
<ul>
<li><code>... ...</code></li>
</ul>
</li>
</ul>
<h4 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h4><ol>
<li><p>变量</p>
<ul>
<li><p>声明与定义</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">double</span> salary<span class="token punctuation">;</span>
<span class="token keyword">int</span> vacationDays<span class="token punctuation">;</span>
vacationDays <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>从 <code>Java 10 </code>开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不需要在声明类型了，只需要使用关键字 <code>var</code> 而无需指定类型</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> vacationDays <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> greeting <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>常量</p>
<ul>
<li>使用关键字 <code>final</code>来指示常量。</li>
<li>关键字 <code>final</code>表示这个变量只能被赋值一次。</li>
<li>使用关键字 <code>static final</code>设置一个<strong>类常量</strong>，可以在一个类的多个方法中使用。如果被声明为 <code>public</code> 那么其他类也可以使用这个常量。</li>
</ul>
</li>
<li><p>枚举</p>
<ul>
<li><p>自定义<strong>枚举类型</strong>。<strong>枚举类型</strong>包括<strong>有限</strong>个命名的值。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">enum</span> <span class="token class-name">Size</span> <span class="token punctuation">{</span>SMALL<span class="token punctuation">,</span> MEDIUM<span class="token punctuation">,</span> LARGE<span class="token punctuation">,</span> EXTRA_LARGE<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">Size</span> s <span class="token operator">=</span> <span class="token class-name">Size</span><span class="token punctuation">.</span>MEDIUM<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ol>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul>
<li><code>+</code> 加 、<code>-</code> 减、 <code>*</code> 乘、 <code>%</code>  取余</li>
<li><code>/</code> 除<ul>
<li>使用关键字 <code>strictfp</code> 修饰类或者方法，表示类或者方法中将采用<strong>严格的浮点运算</strong>，即所有中的中间计算都进行截断为64位计算。<code>double x * y / z;</code> <code>x*y</code>将计算结果截取保存在64位寄存器中， 之后在除以<code>z</code> 将计算结果截取保存到64位寄存器中</li>
</ul>
</li>
</ul>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><code>int n = 123456; long m = n;</code></p>
<img src="/2022/06/28/cs-languages/core-java-volume-0/convert.png" class="" title="类型转换">

<p><strong>强制类型转换</strong></p>
<p>符合上图的类型转换会走到那个进行转换，如果进行反方向的就需要进行<strong>强制类型转换</strong>（cast）来完成，当然会有可能损失信息。</p>
<p><code>double x = 9.997; int nx = (int) x; // nx = 9</code></p>
<h4 id="关系比较符"><a href="#关系比较符" class="headerlink" title="关系比较符"></a>关系比较符</h4><p><code>&lt;</code> 、<code>&gt;</code>、<code>=</code>、<code>&lt;=</code>、<code>&gt;=</code></p>
<h4 id="逻辑比较符"><a href="#逻辑比较符" class="headerlink" title="逻辑比较符"></a>逻辑比较符</h4><p><code>&amp;&amp;</code>、<code>||</code>、<code>!</code></p>
<p>三元表达试： <code>condition ? expression1 : expression2</code></p>
<p>注意：在逻辑运算中，是按照<strong>短路</strong>方式来求值的。</p>
<ul>
<li><code>2 != 1 &amp;&amp; 3 != 2</code> 第一个表达式已经是<code> false</code>时 不会再计算第二个表达式</li>
<li><code>1 == 1 || 3 != 2</code> 第一个表达式已经是<code> true</code>时 不会再计算第二个表达式</li>
</ul>
<p><strong>位运算符</strong></p>
<p>处理整型类型时，可以直接对成组整数的各个位完成操作。可以使用掩码技术得到整数中的各个位。</p>
<p><code>&amp;</code> 与、<code>|</code> 或、<code>^</code> 同或 、<code>~</code> 按位取反、</p>
<p><code>&gt;&gt;</code> 右移，包含移动符号位，使用符号位填充高位</p>
<p><code>&lt;&lt;</code>左移，低位补 0</p>
<p><code>&gt;&gt;&gt;</code>无符号右移，高位填充 0</p>
<h4 id="联机文档"><a href="#联机文档" class="headerlink" title="联机文档"></a>联机文档</h4><blockquote>
<p>link : <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/index.html">https://docs.oracle.com/en/java/javase/11/docs/api/index.html</a></p>
</blockquote>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>读取“标准输入流” <code>System.in</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InputTest</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * @see book.api.ScannerApi
     * @see book.api.SystemApi
     * @see book.api.ConsoleApi
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 读取下一行，以回车作为分隔符，中断读入 (输入行中包括空格，也不会中断读入)</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你的名字是: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> name <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 读取一个单词， 空白符作为分隔符，中断读入</span>
        <span class="token comment">//  String next = scanner.next();</span>

        <span class="token comment">// 读取一个整数</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你多大了: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> age <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你好， "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">". 明年，你将 "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>age <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Java6 之后引入 console 从控制台读取隐形的密码输入。 IDEA 运行 System.console() 返回null时 用命令 javac 编译后  命令java 运行</span>
<span class="token comment">//        Console console = System.console();</span>
<span class="token comment">//        String username = console.readLine("用户名： ");</span>
<span class="token comment">//        char[] passwd = console.readPassword("密码: ");</span>
<span class="token comment">//        System.out.println("username : " + username + "密码 : "+ String.valueOf(passwd));</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><ul>
<li><code>System.out.println(x)</code><ul>
<li>将数值 <code>x</code>输出到控制台</li>
</ul>
</li>
<li><code>System.out.println(“Hello, %s. Next year, you'll be %d", name, age)</code><ul>
<li>以 <code>%</code> 字符开始的 **格式说明符 **都用后面相应的参数替换</li>
</ul>
</li>
</ul>
<p><strong>用于<code>printf</code>转换符</strong></p>
<table>
<thead>
<tr>
<th>转换符</th>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>d</code></td>
<td>十进制整数</td>
<td>100</td>
</tr>
<tr>
<td><code>x</code></td>
<td>十六进制整数</td>
<td>9f</td>
</tr>
<tr>
<td><code>o</code></td>
<td>八进制整数</td>
<td>200</td>
</tr>
<tr>
<td><code>f</code></td>
<td>定点浮点数</td>
<td>10.9</td>
</tr>
<tr>
<td><code>e</code></td>
<td>指数浮点数</td>
<td>1.59e+01</td>
</tr>
<tr>
<td><code>g</code></td>
<td>通用浮点数(<code>e </code>和<code>f</code>中较短的一个)</td>
<td>—–</td>
</tr>
<tr>
<td><code>a</code></td>
<td>十六进制浮点数</td>
<td>0x1.fccdp3</td>
</tr>
<tr>
<td><code>s</code></td>
<td>字符串</td>
<td>Hello</td>
</tr>
<tr>
<td><code>c</code></td>
<td>字符</td>
<td>H</td>
</tr>
<tr>
<td><code>b</code></td>
<td>布尔</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>h</code></td>
<td>散列码</td>
<td>43423</td>
</tr>
<tr>
<td><code>%</code></td>
<td>百分号</td>
<td>%</td>
</tr>
<tr>
<td><code>n</code></td>
<td>行分隔符</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>用于<code>printf</code>的标志</strong></p>
<table>
<thead>
<tr>
<th>转换符</th>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>打印正数和负数的符号</td>
<td>+2333.333</td>
</tr>
<tr>
<td><code>空格</code></td>
<td>在正数之前添加空格</td>
<td>|  2333.33|</td>
</tr>
<tr>
<td><code>0</code></td>
<td>数字前面补 0</td>
<td>002333.33</td>
</tr>
<tr>
<td><code>-</code></td>
<td>左对齐</td>
<td>|233.33  |</td>
</tr>
<tr>
<td><code>(</code></td>
<td>将负号括在括号内</td>
<td>(2333.33)</td>
</tr>
<tr>
<td><code>,</code></td>
<td>添加分组分隔符</td>
<td>2,333,33</td>
</tr>
<tr>
<td><code>#</code>(对于 <code>f</code> 格式)</td>
<td>包含小数点</td>
<td>3,333.</td>
</tr>
<tr>
<td><code>#</code>(对于 <code>x</code> 或 <code>0</code> 格式)</td>
<td>添加前缀 <code>0x</code> 或 <code>0</code></td>
<td>0xcafc</td>
</tr>
<tr>
<td><code>$</code></td>
<td>指定要格式化的参数索引。<br>eg. <code>%1$d %1$x</code>将以十进制和十六进制格式打印第一个参数<br><strong>注意 参数索引从 <code>1</code> 开始而不是 <code>0</code></strong></td>
<td>159 9F</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>格式化前面加说明的数值。<br>eg. <code>%d%&lt;x</code>将以十进制和十六进制格式打印同一个数值</td>
<td>159 9F</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>可以使用 <code>s</code> 转换符格式化任意的对象。对于实现了 <code>formattable</code> 接口的任意对象，将调用这个对象的 <code>formatTo</code> 方法；否则将对这个对象转换位字符串。即调用 <code>toString</code>方法。</p>
</blockquote>
<ul>
<li>对于上述的格式化字符串，也可以使用静态的 <code>String.format</code> 方法创建一个格式化的字符串</li>
</ul>
<p><strong>日期和时间的转换符</strong></p>
<p><code>printf</code>中的日期和时间格式化选项，已经过时，所以暂时不总结。替换方案 <code>java.time</code></p>
<table>
<thead>
<tr>
<th>转换符</th>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>tx</code> 或 <code>tx</code></td>
<td>时间日期(<code>T</code>强制大写)</td>
<td>—-</td>
</tr>
<tr>
<td><code>tc</code></td>
<td>完整的日期和时间</td>
<td>周五 7月 15 00:15:46 CST 2022</td>
</tr>
<tr>
<td>—-</td>
<td>—-</td>
<td>—-</td>
</tr>
</tbody></table>
<img src="/2022/06/28/cs-languages/core-java-volume-0/printf_format.png" class="" title="格式化输出">

<h4 id="文件输入和输出"><a href="#文件输入和输出" class="headerlink" title="文件输入和输出"></a>文件输入和输出</h4><p>读取文件，也是构造一个<code>Scanner</code>对象，如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Scanner</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">Path</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"myfile.txt"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 如果文件名中包含反斜杠符号，需要使用双反斜杠："c:\\mydirectory\\myfile.txt"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>输出文件，需要构造一个<code>PrintWriter</code>对象，在构造器中需要提供文件名和字符编码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token string">"myfile.txt"</span><span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>当指定一个相对文件名时，eg. “dir/myfile.txt” or “../myfile.txt”，文件位置时相对于<strong>Java</strong></p>
<p><strong>虚拟机</strong>启动目录的位置。</p>
<p>如果在命令行方式下执行 <code>java MyProg</code> 启动目录就是命令解释器的房前目录。</p>
<p>如果是集成开发环境，那么启动目录由IDE控制，使用 <code>String dir = System.getProperty("user.dir");</code>获取到调用的目录。</p>
<p>当然也可以使用据对路径。</p>
</blockquote>
<h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><h4 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 块作用域 */</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> k<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token comment">// k 的作用域只在 块作用域内</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 条件语句 */</span>
    <span class="token comment">// if (confition) statement</span>
    <span class="token comment">// if (confition) statement_1 else statement_2</span>
    <span class="token comment">// if (confition_1) statement_1 else if (confition_2) statement_2 else confition_3</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>yourSales <span class="token operator">&gt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>yourSales <span class="token operator">&gt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 2</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>yourSales <span class="token operator">&gt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>yourSales1 <span class="token operator">&gt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 2</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 3</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 循环 */</span>
    <span class="token comment">// while (condition) statement</span>
    <span class="token comment">// do statement while (confition)</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>balance <span class="token operator">&lt;</span> goal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token comment">// 2</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>balance <span class="token operator">&lt;</span> goal<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="确定循环"><a href="#确定循环" class="headerlink" title="确定循环"></a>确定循环</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token comment">/* 确定循环 */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// i</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 多重循环：switch 语句 */</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>choice<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> case 的标签可以是： </p>
<ul>
<li>char、byte、short、int的常量表达式；</li>
<li>枚举常量 <ul>
<li>可以不必再每个标签中指明枚举名，可以由switch表达式推导出来</li>
</ul>
</li>
<li>字符串字面量</li>
</ul>
<blockquote>
<p>警告：在<code>switch</code>结构中，如果条件可能触发多个<code>case</code>分支，如果在<code>case</code>分支语句的末尾没有<code>break</code>语句，那么就会接着执行下一个<code>case</code>分支语句。这种方式会引发错误。</p>
<p>如果使用了 <code>switch</code> 语句，在编译代码时可以考虑加上 <code>-Xlint:fallthrough</code> 选项，eg. <code>javac -Xlint:fallthrough Test.java</code>，这样如果某个分支最后缺少一个 <code>break</code> 语句，编译器就会给出一个警告信息。</p>
<p>如果正好想要使用这种 “直通式” 行为，可以在外围方法上加上一个注解 <code>@SuppressWarnings("fallthrough") </code>，这样就不会针对这个方法产生告警了。</p>
</blockquote>
<h4 id="中断控制流程的语句"><a href="#中断控制流程的语句" class="headerlink" title="中断控制流程的语句"></a>中断控制流程的语句</h4><ul>
<li><code>break</code>：用于退出循环和判断</li>
<li><code>continue</code>： 将控制转移到最内存循环的首部，即跳出当前循环体的剩余部分，立刻跳转到循环的首部。</li>
</ul>
<p>同时，Java 也提供了一种带**标签的<code>break</code>**，用于跳出多重嵌套的循环语句。有时候，在嵌套很深的循环语句中会发生一些不可预料的事情。此时可能更加希望完全跳出所有的嵌套循环之外。</p>
<p>下面有个示例说明<code>break</code>语句的工作状态。注意：标签必须放在希望跳出的最外层循环之前，并且必须紧跟着一个冒号。</p>
<blockquote>
<p>执行带标签的<code>break</code> 会跳转到带标签的语句块的末尾。</p>
<p>同样在<code>if</code>语句中也可以使用该方式跳出语句块。</p>
<p>同样也可以用带标签的<code>continue</code>，将跳到与标签匹配的循环首部。</p>
<p>注意：这里只能跳出语句块，不能跳入语句块。</p>
</blockquote>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Scanner</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">;</span>
<span class="token comment">// 注意该标签</span>
read_data<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 这个循环代码块中由标签标记</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 这个内循环中没有被标记</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" 输入数字 &gt;= 0:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        n <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> n <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span> read_data<span class="token punctuation">;</span>
            <span class="token comment">// 中断该标签的循环</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 此语句在标记的break之后立即执行</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 检查错误情况</span>
    <span class="token comment">// 处理错误情况</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 进行正常处理</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h3><p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用<code>java.math</code>包中的两个类：<code>BigInteger</code> 和 <code>BigDecimal</code>。这两个类可以处理包含任意长度数字序列的数值。</p>
<p>在使用大数类之后，就不能使用常用的算数运算符(eg. <code>+</code> 和 <code>*</code>)处理大数，而需要使用大数类中的 <code>add</code> 和 <code>multiply</code> 方法</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<p>存储相同类型值的序列</p>
</blockquote>
<h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h4><p>一种数据结构，用来存储同一类型值的集合，通过一个整数下标(<code>index</code>，或称索引)可以访问数组中的每一个值。</p>
<p>在声明数组变量时，需要指出数组类型（数组元素类型紧跟 <code>[]</code>）和数组变量的名字。</p>
<blockquote>
<p>注意：一旦创建了数组，就不能再改变它的长度。</p>
</blockquote>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 声明整型数组 a  并未创建</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span>
<span class="token comment">// or int a[];</span>

<span class="token comment">// 声明整型数组 a 并创建数组</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 声明并初始化，这个语法中不需要使用 new。 最后一个值后面允许使用逗号</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> small <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 也可以使用 使用 new 初始化</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> anonymous <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// java 中 允许创建有长度为 0 的数组</span>
<span class="token keyword">new</span> elementType<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h4><p>使用数组下标访问数组 <code>a[n]</code></p>
<p>在创建：</p>
<ul>
<li>数字数组，所有元素都初始化为 <code>0 </code></li>
<li><code>boolean</code> 数组， 所有元素都初始化 <code>false</code></li>
<li>对象数组，所有元素都初始化为 <code>null</code></li>
</ul>
<h4 id="for-each-循环"><a href="#for-each-循环" class="headerlink" title="for each 循环"></a><code>for each</code> 循环</h4><p><code>java</code> 中也可以使用语法糖来遍历数组中的每个元素</p>
<p><code>for (variable : collection) statement</code></p>
<p>当然<code>collection</code> 这以及和表达式必须是一个数组或者是一个实现了 <code>Iterable</code> 接口的类对象(eg. <code>ArrayList</code>)</p>
<blockquote>
<p><code>for each</code>循环语句的驯化变量将会遍历数组中的每个元素，而不是下标值。</p>
</blockquote>
<h4 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 允许将一个数组变量拷贝到另一个数组变量中，这时，</span>
<span class="token comment">// 两个变量将引用同一个数组， 因为这里是指向同一块内存空间。</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> smallPrimes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> luckyNumers <span class="token operator">=</span> smallPrimes<span class="token punctuation">;</span>

<span class="token comment">// 如果希望将一个数组的所有值拷贝到一个新的的胡祖中，要使用 Arrays 类的 copyOf 方法</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> copiedLuckyNumbers <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>luckyNumbers<span class="token punctuation">,</span> luckyNumbers<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 也可以使用这种方法来增大数组的大小</span>
luckyNumbers <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>luckyNumbers<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> luckyNumbers<span class="token punctuation">.</span>length<span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><blockquote>
<p>每一个 <code>Java</code> 应用程序都有一个带 <code>String arg[]</code> 参数的 <code>main</code> 方法。 这个参数表明 <code>mian</code> 方法将接收一个字符串数组，也就是命令行上指定的参数。</p>
</blockquote>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Message</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"-h"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello,"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"-g"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Goodbye,"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" "</span> <span class="token operator">+</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果使用下面的形式调用这个程序</p>
<p><code>java Message -g cruel world</code></p>
<p><code>args</code> 数组将包含以下内容 ：<code>args[0] = "-g", args[0] = "cruel", args[0] = "world"</code></p>
<p>这个程序会显示下面的消息：</p>
<p><code>Goodbye, cruel world!</code></p>
<blockquote>
<p>再 <code>Java</code> 应用程序的<code>main</code>方法中，程序名并没有存储再 <code>args</code> 数组中。例如，当从命令行使用下面的命令运行程序时 ： <code>java Message -h world</code>  <code>args[0]</code> 是 <code>"-h"</code>, 而不是 <code>Message</code> 或 <code>java</code></p>
</blockquote>
<h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><p>相对数值类型数组进行排序，可以使用 <code>Arrays</code> 类中的 <code>sort</code> 方法： <code>Arrays.sort(new int[1000]{...})</code> 这个方法使用了<strong>优化的快速排序</strong>(QuickSort)算法</p>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> magicSquare <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><code>for each</code> 循环语句不能自动处理二维数组的每一个元素。它会循环处理行，而这些行本身是一个一维数组。访问所有元素，需要使用两个嵌套的循环：</p>
<p>for (double[] row : a)</p>
<p>​	for (double value : row)</p>
<p>​		do something with value</p>
</blockquote>
<blockquote>
<p>想要快速打印一个二维数组的数据元素列表，可以调用 <code>System.out.println(Arrays.deepToString(a));</code></p>
</blockquote>
<h4 id="不规则数组"><a href="#不规则数组" class="headerlink" title="不规则数组"></a>不规则数组</h4><p><strong><code>Java</code>实际上没有多维数组</strong>，只有一维数组，多维数组又被解释为”数组的数组“</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> odds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>N_MAX <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;=</span> N_MAX<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    odds<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 生成一个三角形数据结构</span>
<span class="token comment">// 0</span>
<span class="token comment">// 0 0</span>
<span class="token comment">// 0 0 0</span>
<span class="token comment">// 0 0 0 0</span>
<span class="token comment">// 0 0 0 0 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h2><img src="/2022/06/28/cs-languages/core-java-volume-0/opp.png" class="" title="面向对象">

<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><strong>类</strong><ul>
<li>构造对象的模板或蓝图</li>
<li>由类<strong>构造</strong>对象的过程称之为创建类的<strong>实例</strong></li>
</ul>
</li>
<li><strong>封装</strong><ul>
<li>处理对象的一个重要改变，将数据和行为组合在一个包中。</li>
<li>对象中的数据称为<strong>实例字段</strong>，操作数据的过程称为<strong>方法</strong>。</li>
</ul>
</li>
</ul>
<h3 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h3><ul>
<li><p><strong>结构示意</strong></p>
<blockquote>
<p>在一个源文件中，只能由一个公共类，但可以由任意数目的非公共类。 </p>
</blockquote>
<ul>
<li>构造器与类名相同</li>
<li>每个类可以由一个及以上的构造器</li>
<li>构造器可以由0个，1个或多个参数</li>
<li>构造器没有返回值</li>
<li>构造器总是伴随着<code>new</code>操作符调用</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ClassName</span> <span class="token punctuation">{</span>
    field1<span class="token punctuation">;</span>
    field2<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    
    constructor1<span class="token punctuation">;</span>
    contructor2<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    
    method1<span class="token punctuation">;</span>
    method2<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="var关键词"><a href="#var关键词" class="headerlink" title="var关键词"></a><code>var</code>关键词</h4><p>Java 10 之后，如果可以从变量的初始值推导出它们的类型，那么可以用 <code>var</code> 关键字声明<strong>局部变量</strong>，而无须指定类型。注意：<code>var</code> 关键字只能用于方法中的<strong>局部变量</strong>。参数和字段的类型必须声明。</p>
<h4 id="null引用"><a href="#null引用" class="headerlink" title="null引用"></a><code>null</code>引用</h4><p>如果对<code>null</code>值应用一个方法，会产生一个 <code>NullPointerException</code>异常。</p>
<p>在 <code>Java 9</code>中，Object类提供了一个判断<code>null</code>的方法：</p>
<ul>
<li><p>“宽容型”处理<code>null</code>参数，将其转为一个默认值</p>
<p><code>String name = Objects.requireNonNullElse(n, "defuale");</code></p>
</li>
<li><p>“严格型”直接拒绝<code>null</code>参数</p>
<p><code>Objects.requireNonNull(n, "The name cannot be null");</code></p>
<p>会产生一个 <code>NullPointerException</code>异常</p>
</li>
</ul>
<h4 id="基于类的访问权限"><a href="#基于类的访问权限" class="headerlink" title="基于类的访问权限"></a>基于类的访问权限</h4><p>一个方法可以访问<strong>所属类的所有对象</strong>的私有数据。</p>
<h4 id="final实例字段"><a href="#final实例字段" class="headerlink" title="final实例字段"></a>final实例字段</h4><ul>
<li>修饰实例字段<ul>
<li>这样的字段必须在构造对象时初始化，在设置之后，就不能再进行修改。但是如果修饰是一个对象变量，对对象的引用不可以修改，不过这个对象的属性可以更改。</li>
</ul>
</li>
</ul>
<h3 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h3><ul>
<li><p>静态变量</p>
<ul>
<li>使用<code>static</code>修饰实例字段，这个类所有的实例将共享这个字段，如果被一个实例修改，其他所有实例获取到的也是修改的值。</li>
</ul>
</li>
<li><p>静态常量</p>
<ul>
<li>使用<code>static final</code>，类的所有实例共享且不允许被修改。</li>
</ul>
</li>
<li><p>静态方法</p>
<ul>
<li>使用<code>static</code>修改方法，只能访问类的静态字段，不能访问类的其他非静态属性</li>
<li>所需要的参数都需要显式的提供</li>
</ul>
</li>
<li><p>工厂方法</p>
<ul>
<li><p>使用静态<strong>工厂方法</strong>来构造对象，代理使用构造方法。例如 ： <code>LocalDate.now</code> 、<code>LocalDate.of</code> </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">NumberFormat</span> currencyFormatter <span class="token operator">=</span> <span class="token class-name">NumberFormat</span><span class="token punctuation">.</span><span class="token function">getCurrencyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">NumberFormat</span> percentFormatter <span class="token operator">=</span> <span class="token class-name">NumberFormat</span><span class="token punctuation">.</span><span class="token function">getPercentInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 为什么不使用 NumberFormat 的构造器方法去创建实例呢？这样使用的原因如下：</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>无法命名构造器</p>
<ul>
<li>构造器的名字必须与类名相同。但是，这里希望由两个不同的名字，分别得到货币实例和百分比实例。</li>
</ul>
</li>
<li><p>使用构造器时，无法改变所构造对象的类型。</p>
<ul>
<li>工厂方法是实际上返回的<code>DecimalFormat</code>类的对象，这是<code>NumberFormat</code>的一个子类（继承内容后续说明）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><blockquote>
<p>Java对对象采用的不是按照引用调用，实际上，<strong>对象引用是按照值传递的</strong></p>
<p>在传递对象类型的数据时，<strong>方法内获取的是对传递的对象引用的一个副本</strong>，而不是传递的原始对象引用。所以在方法内对这个对象引用改变为新的引用的时候，并不会影响到调用处的对象引用；方法结束后，方法内的引用副本就会被丢弃。</p>
</blockquote>
<ul>
<li>方法不能修改基本数据类型的参数（即数值型或布尔型）</li>
<li>方法可以改变对象参数的状态</li>
<li>方法不能让一个对象参数参数引用一个新的对象</li>
</ul>
<h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><h4 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h4><p>java中由三种初始化数据字段的方法：</p>
<ul>
<li><p>在构造器中设置值</p>
</li>
<li><p>在声明中赋值</p>
</li>
<li><p>初始化块</p>
<ul>
<li><p>在一个类的声明中，可以包含任意多个代码块。只要构造这个类的对象，这些块就会被执行。如下示例中：首先运行初始化块，然后才运行构造器的主体部分</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Employee</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> nextId<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">double</span> salary<span class="token punctuation">;</span>
    
    <span class="token comment">// 初始化块</span>
    <span class="token punctuation">{</span>
        id <span class="token operator">=</span> nextId<span class="token punctuation">;</span>
        nextId<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        name <span class="token operator">=</span> n<span class="token punctuation">;</span>
        salary <span class="token operator">=</span> s<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        name <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
        salary <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="构造器的执行步骤"><a href="#构造器的执行步骤" class="headerlink" title="构造器的执行步骤"></a>构造器的执行步骤</h4><ol>
<li>如果构造器的第一行调用了另一个构造器，则基于所提供得参数执行第二个构造器。</li>
<li>否则<ol>
<li>所有数据字段初始为其默认值（0，false或null）。</li>
<li>按照在类声明中出现的顺序，执行所有字段初始化方法和初始化块。</li>
</ol>
</li>
<li>执行构造器主体代码。</li>
</ol>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><h4 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h4><p>使用<strong>包</strong>将类组织在一个集合中，借助包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。</p>
<p>只用包的主要原因是确保<strong>类名的唯一性</strong>。</p>
<blockquote>
<p>在对据有包名且按照包路径放置的类进行编译或运行时，需要加上包路径（完全限定名），例如：</p>
<p>javac cn/qing/PayrollApp.java</p>
<p>java cn.qing.PayrollApp</p>
</blockquote>
<h4 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h4><p>为了使类能够被多个程序共享，需要做到以下几点：</p>
<ol>
<li><p>把类文件放到一个目录中，例如 <code>/home/user/classdir</code>。 需要注意，这个目录是包树状结构的<strong>基目录</strong>。如果希望增加 <code>com.qing.corejava.Employee</code>类，那么<code>Employee.class</code>类文件就必须位于子目录 <code>/home/user/classir/com/qing/corejava</code>中。</p>
</li>
<li><p>将<code>JAR</code>文件放在一个目录中，例如：<code>/home/user/archives</code>。</p>
</li>
<li><p>设置**类路径(class path)**。类路径是所有包含类文件的路径的集合。</p>
<p>在UNIX环境中，类路径中的各项之间用（:）分割：</p>
<p><code>/home/user/classdir:.:/home/user/archives/archive.jar</code></p>
<p>而在Windows环境中，则以分号（;）分割：</p>
<p><code>c:\classdir;.;c:\archives\archive.jar</code></p>
<p>不论是UNIX还是Windows，都用句点（.）表示当前目录。</p>
<p>类路径包括：</p>
<ul>
<li>基目录 <code>/home/user/classdir</code>或<code>c:\clases</code>；</li>
<li>当前目录（<code>.</code>）；</li>
<li><code>JAR</code>文件<code>/home/user/archives/archive.jar</code>或<code>c:\archives\archive.jar</code></li>
</ul>
<p>从Java 6 开始，可以在JAR文件目录中指定通配符，如下：</p>
<p><code>/home/user/classdir:.:/home/user/archives/'*'</code> 或者 <code>c:\classdir;.;c:\archives\*</code></p>
<p>在UNIX中，<code>*</code> 必须转义以放置<code>shell</code>扩展 。</p>
<p>archives目录中所有JAR文件（但不包括<code>.class</code>文件）都包含在这个类路径中。</p>
<p>类路径所列出的目录和归档文件是搜索类的<strong>起始点</strong>。</p>
<h4 id="设置类路径"><a href="#设置类路径" class="headerlink" title="设置类路径"></a>设置类路径</h4><p>最好使用 <code>-classpath</code>（或 <code>-cp</code>，或者Java 9中的 <code>--class-path</code>）选择指定类路径：</p>
<p><code>java -classpath /home/user/classdir:.:/home/user/archives/archive.jar MyProg</code>或</p>
<p><code>java -classpath c:\classdir;.;c:\archives\archive.jar MyProy</code></p>
<p>整个指令必须写在一行中。可以将这样一个长的命令行放在一个shell脚本或一个批处理文件中。</p>
<p>利用<code>-classpath</code>选项设置类路径是首选的方法，也可以通过设置<code>CLASSPATH</code>环境变量来指定。具体细节依赖于所使用的shell。在Bourne Again shell(bash)中，命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">CLASSPATH</span><span class="token operator">=</span>/home/user/classdir:.:/home/user/archives/archive.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在Windows中，命令如下:</p>
<pre class="line-numbers language-bat" data-language="bat"><code class="language-bat">set CLASSPATH=c:\classdir;.;c:\archives\archive.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>知道退出shell为止，类路径设置均有效。</p>
</li>
</ol>
<h3 id="JAR文件"><a href="#JAR文件" class="headerlink" title="JAR文件"></a><code>JAR</code>文件</h3><p><code>Java</code>归档(<code>JAR</code>)文件是一个压缩文件，使用了<code>ZIP</code>压缩格式，可以包含类文件，也可以包含图像和声音等其他类型文件。</p>
<h4 id="创建JAR文件"><a href="#创建JAR文件" class="headerlink" title="创建JAR文件"></a>创建<code>JAR</code>文件</h4><p>使用<code>jar</code>工具制作<code>JAR</code>文件（在默认的<code>JDK</code>安装中，这个工具位于<code>jdk/bin</code>目录下）。创建一个新的<code>JAR</code>文件常用命令如下：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">jar cvf jarFileName file1 file2 *.class <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>常用格式为 <code>jar options file1 file2 ...</code>   </p>
<p><code>options</code>具体参数说明如下</p>
<table>
<thead>
<tr>
<th>option</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>c</code></td>
<td>创建一个新的或者空的归档文件并加入文件。<br>如果指定的文件名是目录，<code>jar</code>程序将会对他们进行递归处理。</td>
</tr>
<tr>
<td><code>C</code></td>
<td>临时改变目录，例如：<br>    <code>jar cvf jarFileName.jar -C classes *.class</code><br>切换到<code>classes</code>子目录以便于增加类文件</td>
</tr>
<tr>
<td><code>e</code></td>
<td>在清单文件中创建一个入口点（请参看<a href="#%E5%8F%AF%E6%89%A7%E8%A1%8Cjar%E6%96%87%E4%BB%B6">可执行JAR文件</a>）</td>
</tr>
<tr>
<td><code>f</code></td>
<td>指定<code>JAR</code>文件名作为第二个命令行参数。如果没有这个参数，<code>jar</code>命令会将结果写至标准输出（在创建JAR文件时）或者从标准输出读取（在解压或者列出<code>JAR</code>文件内容时）</td>
</tr>
<tr>
<td><code>i</code></td>
<td>建立索引文件（用于加快大型归档中的查找）</td>
</tr>
<tr>
<td><code>m</code></td>
<td>将一个<font color="blue">清单文件</font>添加到一个<code>JAR</code>文件中。清单是对归档内容和来源的一个说明。每个归档有一个默认的清单文件。但是，如果想验证归档文件的内容，可以提供自己的清单文件。</td>
</tr>
<tr>
<td><code>M</code></td>
<td>不为条目创建清单文件</td>
</tr>
<tr>
<td><code>t</code></td>
<td>显示内容表</td>
</tr>
<tr>
<td><code>u</code></td>
<td>更新一个已有的<code>JAR</code>文件</td>
</tr>
<tr>
<td><code>v</code></td>
<td>生成详细的输出结果</td>
</tr>
<tr>
<td><code>x</code></td>
<td>解压文件。如果提供一个或多个文件名，之解压这些文件；否则，解压所有文件</td>
</tr>
<tr>
<td><code>0</code></td>
<td>存储，但不进行<code>ZIP</code>压缩</td>
</tr>
</tbody></table>
<h4 id="清单文件"><a href="#清单文件" class="headerlink" title="清单文件"></a>清单文件</h4><p>除了类文件、图像和其他资源外，每个<code>JAR</code>文件还包含一个<strong>清单文件</strong>（<code>manifest</code>），用于描述归档文件的特殊特性。</p>
<p>清单文件被命名为<code>MANIFEST.MF</code>，位于<code>JAR</code>的一个特殊的<code>MATE_INFO</code>子目录中，最小清单文件示例如下</p>
<img src="/2022/06/28/cs-languages/core-java-volume-0/MANIFEST.png" class="" title="MANIFEST">

<pre class="line-numbers language-none"><code class="language-none">Manifest-Version: 1.0
lines describing this archive

Name: Woozle.class
lines describing this file
Name: com/qing/mypkg/
lines describing this package<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>详细格式和信息参看： <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/10/docs/specs/jar/jar.html">https://docs.oracle.com/javase/10/docs/specs/jar/jar.html</a></p>
</blockquote>
<h4 id="可执行JAR文件"><a href="#可执行JAR文件" class="headerlink" title="可执行JAR文件"></a>可执行<code>JAR</code>文件</h4><p>使用<code>jar</code>命令中的<code>e</code>选项来指定程序的<strong>入口点</strong>，即通常需要在调用<code>java</code>程序启动器时指定的类：</p>
<p><code>jar cvfe MyProgram.jar cn.qing.mypkg.MainApplication files to add</code></p>
<p>或者，可以在清单文件中指定程序的主类，例如：</p>
<p><code>Main-Class: cn.qing.mypkg.MainApplication</code></p>
<p><strong>注意，不要为主类名增加扩展名。 即 .class</strong></p>
<blockquote>
<p>清单文件的最后一行必须以换行符结束。否则，清单文件将无法被正确地读取。</p>
<p>常见的一个错误是创建了一个只包含Main-Class行而没有行结束符的文本文件</p>
</blockquote>
<p>之后就可以使用已下命令来快速的启动程序：</p>
<p><code>java -jar MyProgam.jar</code></p>
<h4 id="多版本JAR文件"><a href="#多版本JAR文件" class="headerlink" title="多版本JAR文件"></a>多版本<code>JAR</code>文件</h4><p>在<code>Java 9</code>之后引入**多版本<code>JAR</code>**，其中可以包含面对不同<code>Java</code>版本的类文件，用来解决一个强封装的包在不同版本的<code>Java</code>环境上的运行。</p>
<p>为了保证向后兼容，额外的类文件放在<code>META-INF/versions</code>目录中：</p>
<pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">Application.class
BuidingBlocks.class
Util.class
META-INF
 |- MANIFEST.MF (with line Multi-Release: true)
 |- versions
 |- 9
 |  |- Application.class
 |  |- BuildingBlocks.class
 |- 10
    |- BuildingBlocks.class<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>Java 9</code>之后的版本就可以根据所需，从<code>version</code>中加载自己版本对应的类文件，而<code>Java 8</code>完全不知道<code>META_INF/versions</code>目录的存在，只会去加载最外层遗留的类</p>
<p>要增加不同版本的类文件，可以使用<code>--release</code>标志：</p>
<p><code>jar uf MyProgram.jar --release 9 Application.class</code></p>
<p>要从头构建一个多版本的<code>JAR</code>文件，就可以使用<code>-C</code>选项，对应每个版本要切换到一个不同的类文件目录：</p>
<p><code>jar cf MyProgram.jar -C bin/8 . --release 9 -C bin/9 Application.class</code></p>
<p>面向不同版本编译时，使用<code>--release</code>和<code>-d</code>来指定输出目录：</p>
<p><code>javac -d bin/8 --release 8 .....</code></p>
<p>在<code>Java 9</code> 中，<code>-d</code>选项会创建这个目录。</p>
<blockquote>
<p><code>--release</code>标志是<code>Java 9</code>之后新增的。在之前的版本中，许哟啊使用 <code>-source</code>、<code>-target</code>和<code>-boot-classpath</code>标志。</p>
</blockquote>
<h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p><code>javadoc</code>工具，可以由源文件中的注释生成一个<code>HTML</code>文件。</p>
<p><code>java</code>中的注释分两种 <code>\\</code>和<code>\*  *\</code> 两种方式。</p>
<p>第二种注释中可以添加<strong>自由格式文本</strong>，自由格式文本的<strong>第一句应该是一个概要性的句子</strong>。<code>javadoc</code>工具自动会将这些句子抽取出来形成文档。同时在自由文本中，可以使用<code>HTML</code>修饰符。</p>
<h4 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h4><p>类注释必须放在<code>import</code>	语句之后，类定义之前。</p>
<h4 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h4><p>每一个方法注释必须放在所描述的方法之前。除了通用标记之外，还可以使用下面的标记，还可以使用下面的标记：</p>
<ul>
<li><code>@param variable description</code></li>
<li><code>@return description</code></li>
<li><code>@throws class description</code></li>
</ul>
<h4 id="字段注释"><a href="#字段注释" class="headerlink" title="字段注释"></a>字段注释</h4><p>只需要对公共字段（通常指的是静态常量）建立稳定。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * The "Hearts" card suit
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> HEARTS <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="通用注释"><a href="#通用注释" class="headerlink" title="通用注释"></a>通用注释</h4><ul>
<li><p><code>@since text</code></p>
</li>
<li><p><code>@author name</code></p>
</li>
<li><p><code>@version text</code></p>
</li>
<li><p><code>@see</code>  <code>@link</code></p>
<p>这两个注释可以使用超链接，连接到<code>javadoc</code>文档中插入一个超链接，示例如下</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">\<span class="token operator">*</span><span class="token operator">*</span>
    <span class="token annotation punctuation">@see</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>qing<span class="token punctuation">.</span>corejava<span class="token punctuation">.</span></span>Employee</span>#<span class="token function">raiseSalary</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> 连接到一个具体的方法上
    <span class="token annotation punctuation">@see</span> <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"www.qing.cn/corejava.html"</span><span class="token class-name">The</span> <span class="token class-name">Core</span> <span class="token class-name">Java</span> home page<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">&gt;</span> 
    <span class="token annotation punctuation">@see</span> <span class="token string">"Core Java 2 volume 2"</span>
	<span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> <span class="token keyword">package</span><span class="token punctuation">.</span><span class="token keyword">class</span>#feature label<span class="token punctuation">}</span>
	<span class="token punctuation">{</span><span class="token annotation punctuation">@index</span> enrty<span class="token punctuation">}</span> java9 之后添加，标记为搜索框增加一个条目
 <span class="token operator">*</span>\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="包注释"><a href="#包注释" class="headerlink" title="包注释"></a>包注释</h4><p>包注释需要在每一个包目录中添加一个单独的文件。有如下两种选择</p>
<ol>
<li>提供一个名为<code>package-info.java</code>的文件，这个文件必须包含一个初始的以<code>/**</code>和<code>*/</code>界定的注释，后面是一个<code>package</code>语句。它不能包含更多的代码和注释。</li>
<li>提供一个名为<code>package.html</code>的<code>HTML</code>文件。会抽取标记<code>&lt;body&gt; ... &lt;/body</code>之间的所有文本。</li>
</ol>
<h4 id="注释抽取"><a href="#注释抽取" class="headerlink" title="注释抽取"></a>注释抽取</h4><p>假设希望<code>HTML</code>文件将放在名为<code>docDir</code>的目录下，执行以下步骤</p>
<ol>
<li><p>切换到包含想要生成文档的源文件的目录。如果有<strong>嵌套的包</strong>要生成文档，例如<code>com.qing.corejava</code>，就必须切换到包含子目录<code>com</code>的目录（如果提供了<code>overview.html</code>文件的话，就是这个文件所在的目录）</p>
</li>
<li><p>运行如下命令：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 如果是一个包</span>
$ javadoc -d docDir nameOfPackage
<span class="token comment"># 如果要为多个包生成文档</span>
$ javadoc -d docDir nameOfPackage1 nameOfPackage2
<span class="token comment"># 如果文件在无名的包中</span>
$ javadoc -d docDir *.java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<blockquote>
<p>更多参考见 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/javadoc/javadoc.htm">https://docs.oracle.com/javase/9/javadoc/javadoc.htm</a></p>
</blockquote>
<h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><ol>
<li><p><strong>一定要保证数据私有</strong></p>
</li>
<li><p><strong>一定要对数据进行初始化</strong></p>
<p><code>java</code>不会初始化局部变量，但是会对对象的实例字段进行初始化。</p>
</li>
<li><p><strong>不要在类中使用过多的基本类型</strong></p>
</li>
<li><p><strong>不是所有的字段都需要单独的字段访问器和字段更改器</strong></p>
</li>
<li><p><strong>分解有过多职责的类</strong></p>
</li>
<li><p><strong>类名和方法名要能够体现它们的职责</strong></p>
</li>
<li><p><strong>优先使用不可变的类</strong></p>
</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>基于已有的类创建新的类。继承已存在的类就是复用（继承）这些类的方法。而且可以增加一些新的方法和字段，使新类能够适应新的情况。</p>
<h3 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h3><h4 id="定义子类"><a href="#定义子类" class="headerlink" title="定义子类"></a>定义子类</h4><p><code>Java</code>中使用关键字<code>extends</code>来表示继承关系。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token comment">// ....</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>关键词 <code>extends</code>表明正在构造一个新类，它派生于一个已存在的类。这个已存在的类称为<strong>超类（<code>superclass</code>）</strong>、<strong>基类（<code>base class</code>）</strong>、或<strong>父类（<code>parent class</code>）</strong>；新的类称为<strong>子类（<code>subclass</code>）</strong>、<strong>派生类（<code>derived class</code>)<strong>或</strong>孩子类（<code>child class</code>）</strong></p>
<h4 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h4><p>超类中的有些方法对于子类并不一定适用。为此，需要提供一个新的方法来<strong>覆盖（<code>override</code>）</strong>超类中的这个方法。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> getSalary <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token comment">// 覆盖 超类 中的方法</span>
     <span class="token keyword">public</span> <span class="token keyword">int</span> getSalary <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而如果想在子类中访问父类中的某个方法或者变量时，可以使用特殊的关键字<code>super</code>:。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token comment">// 覆盖 超类 中的方法</span>
     <span class="token keyword">public</span> <span class="token keyword">int</span> getSalary <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>注意，这里的<code>super</code>不是一个对象的引用，例如，不能将值<code>super</code>赋给另一个对象变量。</p>
</blockquote>
<h4 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h4><p>由于子类的构造器不能访问超类中的私有字段，所以必须通过调用超类的构造器来初始化这些私有字段，同样这里利用的是<code>super</code>的特殊语法。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Manager</span> <span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> salary<span class="token punctuation">,</span> <span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> salary<span class="token punctuation">,</span> year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> year<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>bonus <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以简单对比下<code>this</code>和<code>super</code>的含义：</p>
<ul>
<li><code>this</code><ul>
<li>指示隐式参数的引用。</li>
<li>调用该类的其他构造器。</li>
</ul>
</li>
<li><code>super</code><ul>
<li>调用超类的方法。</li>
<li>调用超类的其他构造器。</li>
</ul>
</li>
</ul>
<p>这里简单引入下<strong>多态</strong>和<strong>动态绑定</strong>:</p>
<p>如下面的代码块中所示，变量 e 可以指示多种实际类型的，这种现象就是<strong>多态</strong>。在运行时能自动地选择适当的方法，就被称为<strong>动态绑定（<code>dynamic binding</code>）</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

staff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
staff<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span> e <span class="token operator">:</span> staff<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="继承层次"><a href="#继承层次" class="headerlink" title="继承层次"></a>继承层次</h4><p>由一个公共的超类派生出来的所有类的集合称为<strong>继承层次（<code>inheritance hierarchy</code>）</strong>，如下图所示，从某个特定的类到其祖先的路径称为类的<strong>继承链（<code>inheritance chain</code>）</strong>。</p>
<img src="/2022/06/28/cs-languages/core-java-volume-0/inheritance_hierarchy.png" class="" title="继承层次">

<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p><code>"is - a"</code>规则的另一种表达是**替换原则（<code>substitution principle</code>）。它指出程序中出现超类对象的任何地方都可以使用子类对象替换。例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Employee</span> e<span class="token punctuation">;</span>
e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Employ object expected</span>
e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK, Manager can be used as wll</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在<code>Java</code>程序语言中，对象变量是多态的（**<code>polymorphic</code>**）。</p>
<h4 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h4><p>简单概述下方法调用的过程， 下面以调用<code>x.f(args)</code>，隐式参数<code>x</code>声明为类<code>C</code>的一个对象。</p>
<ol>
<li><p>编译器查看对象的声明类型和方法名。</p>
<ul>
<li>编译器将会一一列举<code>C</code>类中所有名为f的方法和其超类中所有名为f而且可以访问的方法（超类的私有方法不可访问）。</li>
<li>此时，编译器已经知道所有可能被调用的候选方法。</li>
</ul>
</li>
<li><p>编译器确定方法调用中提供的参数类型。</p>
<ul>
<li><p>编译器根据方法名和具体的参数类型，选择一个与所提供参数类型完全匹配的方法。这个过程称为<strong>重载解析（<code>overloading resolution</code>）</strong>。</p>
<blockquote>
<p>方法的名字和参数列表称为方法的<strong>签名</strong>。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>如果是<code>private</code>方法、<code>static</code>方法、<code>final</code>方法或者构造器，那么编译器将可以准确地直到应该调用哪个方法。这个称为<strong>静态绑定（<code>static binding</code>）</strong>。</p>
</li>
<li><p>程序运行并且采用<strong>动态绑定</strong>调用方法时，虚拟机必须调用与x所引用对象的实际类型对应的那个方法。</p>
<ul>
<li><p>由于每次调用方法都需要完成搜索去找到对应的方法，这样开销比较大。因此，虚拟机预先为每个类计算了一个<strong>方法表（<code>method table</code>）</strong>，其中列出了所有方法的签名和要调用的实际方法。这样在真正调用的时候只需要查找这张表就可以了。</p>
<blockquote>
<p>在覆盖一个方法的时候，子类方法<strong>不能低于</strong>超类方法的<strong>可见性</strong>。特别是超类方法是<code>public</code>，子类方法也必须声明为<code>public</code>。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="阻止继承：final类和方法"><a href="#阻止继承：final类和方法" class="headerlink" title="阻止继承：final类和方法"></a>阻止继承：<code>final</code>类和方法</h4><p>不允许扩展的类被称为<code>final</code>类。</p>
<blockquote>
<p>对于<code>final</code>字段来说，构造对象之后就不允许改变其值了，但是如果将一个类声明为<code>final</code>，只有其中的方法自动的称为<code>final</code>，而不包括字段。</p>
</blockquote>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>在继承链上进行向下的强制类型转换，并且”谎报”对象宝航的内容，就有可能产生错误。例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

staff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
staff<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Manager</span> boss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span> staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>Java</code>运行到第七行的时候，将会注意到所给的实例与转换类型不匹配，就会产生一个<code>ClassCastException</code>异常。如果没有进程捕获处理这个异常，程序就会退出。所以可以通过下述方式，使用<code>instanceof</code>在转换之前检查能否转换。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Manager</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    boss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span> staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>但是如果使用一个超出<strong>继承链</strong>的强制转换就会编译错误。例如：<code>String c = (String) staff[1]</code></p>
<p>故，强制类型转换：</p>
<ul>
<li><p>只能在继承层次内进行强制类型转换。</p>
</li>
<li><p>在将超类强制转换成子类之前，应该使用<code>instanceof</code>进行检查</p>
<blockquote>
<p>如果 <code>x</code> 为 <code>null</code>， 测试 <code>x instanceof C</code> 。 不会产生异常，只是会返回 <code>false</code>。 这样是因为 <code>null</code>没有引用任何对象，当然也不会引用<code>C</code>类型的对象。</p>
</blockquote>
</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>主要用于在超类中定义，但是将实现交给子类去实现；同时，抽象方法在子类中必须被重写。由关键字**<code>abstract</code>**修饰。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// no implementation required</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须声明为抽象类。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"student"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同时即使不含抽象方法的类，也可以定义为抽象类。</p>
<p>注意：<strong>抽象类不能实例化</strong>，即不能创建这个类的对象，但是可以定义一个抽象类的<strong>对象变量</strong>，就是定义成变量去引用菲抽象子类的对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">Preson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span>

<span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// success</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="受保护访问"><a href="#受保护访问" class="headerlink" title="受保护访问"></a>受保护访问</h4><p>使用关键字<code>protected</code>修饰，被其修饰的字段和方法只能由同一个包中的类访问，不能通过派生子类来访问受保护的字段。</p>
<blockquote>
<p>事实上，<code>Java</code>中的受保护部分对所有子类及同一个包中的所有其他类都可见。与<code>C++</code>中的保护机制不同，<code>Java</code>中的<code>protected</code>概念要比<code>C++</code>中的安全性差。</p>
</blockquote>
<h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><ol>
<li><code>private</code>：仅对本类可见。</li>
<li><code>public</code>：仅对外部完全可见。</li>
<li><code>protected</code>：仅对本包和所有子类可见。</li>
<li>默认：不需要修饰符，对本包可见。</li>
</ol>
<h3 id="Object：所有类的超类"><a href="#Object：所有类的超类" class="headerlink" title="Object：所有类的超类"></a><code>Object</code>：所有类的超类</h3><p><code>Object</code>类是<code>Java</code>中所有类的始祖，在<code>Java</code>中每个类都扩展了<code>Object</code>，但是并不需要在类的定义中显式的去继承它。</p>
<h4 id="Object类型的变量"><a href="#Object类型的变量" class="headerlink" title="Object类型的变量"></a><code>Object</code>类型的变量</h4><ol>
<li>可以使用<code>Object</code>类去引用任何类型的对象，<code>Object obj = new Employee();</code>。</li>
<li>在<code>Java</code>中只有<strong>基本类型（<code>primitive type</code>）</strong>不是对象。</li>
<li>所有的数组类型，不管是对象数组还是基本类型的数组都扩展了<code>Object</code>类。</li>
</ol>
<h4 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a><code>equals</code>方法</h4><p><code>Object</code>类中实现的<code>equals</code>方法将确定两个对象引用是否相等。</p>
<p>但是对于一些状态检测的对象的相等性，更多的是去比较其包含的属性之间的相等状态，而不能只是简单的比较两个引用必须是一个对象。这里就需要对<code>equals</code>的方法进行重写。</p>
<p>同时子类中定义<code>equals</code>方法时，首先要调用超类的<code>euqals</code>方法。</p>
<p>如下示例来展示对<code>equals</code>方法的重写：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">double</span> salary<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">LocalDate</span> hireDay<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">double</span> salary<span class="token punctuation">,</span> <span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> salary<span class="token punctuation">;</span>
        hireDay <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> otherObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// a quick test to see if the objects are identical</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> otherObject<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

        <span class="token comment">// must return false if the explicit parameter is null</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>otherObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token comment">// if the classes don't match, they can't be equal</span>
        <span class="token comment">// getClass() 方法将会返回这个对象所属的类</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> otherObject<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token comment">// now we know otherObject is a non-null Employee</span>
        <span class="token keyword">var</span> other <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span><span class="token punctuation">)</span> otherObject<span class="token punctuation">;</span>

        <span class="token comment">// test whether the fields have identical values</span>
        <span class="token comment">// 这里为了防止 对象属性 name 和 hireDay 为null导致错误，所有推荐使用 Objects.equals()方法来进行比较，而不是使用 name.equals(other.name)</span>
        <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> other<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
                <span class="token operator">&amp;&amp;</span> salary <span class="token operator">==</span> other<span class="token punctuation">.</span>salary <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>hireDay<span class="token punctuation">,</span> other<span class="token punctuation">.</span>hireDay<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="相等测试与继承"><a href="#相等测试与继承" class="headerlink" title="相等测试与继承"></a>相等测试与继承</h4><p><code>equals</code>方法要具有下面的特性：</p>
<ol>
<li><strong>自反性</strong></li>
<li><strong>对称性</strong></li>
<li><strong>传递性</strong></li>
<li><strong>一致性</strong></li>
<li>对于任意非空引用<code>x</code>，<code>x.equals(null)</code></li>
</ol>
<p>以下时任何编写一个相对完美的<code>equals</code>方法的建议：</p>
<ol>
<li><p>显式参数命名为<code>otherObject</code>，稍后需要将它强制转换成另一个名为other的变量。</p>
</li>
<li><p>检测<code>this</code>与<code>otherObject</code>是否相等：<code>if (this == otherObject) return true;</code>这属于一种优化。</p>
</li>
<li><p>检查<code>otherObject</code>是否为<code>null</code>，如果<code>null</code>，返回<code>false</code>。</p>
</li>
<li><p>比较<code>this</code>与<code>otherObject</code>的类。</p>
<ul>
<li><p>如果<code>equals</code>的语句可以在子类中改变，就使用<code>getClass</code>检测：</p>
<p><code>if (getClass() != otherObject.getClass()) return false;</code></p>
</li>
<li><p>如果<strong>所有的子类</strong>都由相等的相等性语义，就可以使用<code>instanceof</code>检测：</p>
<p><code>if (!(otherObject instanceof ClassName)) return false;</code></p>
</li>
</ul>
</li>
<li><p>将<code>otherObject</code>强制转换为相应类类型的变量：</p>
<p><code>ClassName other = (ClassName) otherObject;</code></p>
</li>
<li><p>根据相等性概念的要求来比较具体的属性字段。</p>
<ul>
<li>使用<code>==</code>比较基本类型字段</li>
<li>使用<code>Objects.equals</code>比较对象字段</li>
<li>对于数组类型的字段，可以使用静态的<code>Arrays.equals</code>方法来检测</li>
</ul>
<p>所有字段都匹配，返回<code>true</code>，否则返回<code>false</code></p>
</li>
</ol>
<blockquote>
<p>如下的实现<code>equals</code>方法的一种常见的错误，</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Employee</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个方法声明的显示参数类型是<code>Employee</code>。因此，它没有覆盖<code>Object</code>类的<code>equals</code>方法，而是定义了一个完全无关的方法。</p>
<p>为了避免这种错误，可以使用<code>@Override</code>标记要覆盖超类方法的那些子类方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> otherObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<h4 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a><code>hashCode</code>方法</h4><p>散列码（<code>hash code</code>）是由对象导出的一个整形值，是没有规律的。</p>
<blockquote>
<p>相同的字符串由相同的散列码，这是因为字符串的散列码是由<strong>内容</strong>导出的。</p>
<p><code>equals</code>与<code>hashCode</code>的定义必须相容</p>
</blockquote>
<h4 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a><code>toString</code>方法</h4><p>返回表示对象值的一个字符串。例如：<code>Point</code>类的<code>toString</code>方法将返回下面的字符串<code>java.awt.Point[x=10,y=20]</code>。</p>
<p><code>Object</code>类定义了<code>toString</code>方法，会打印对象的类名和散列码。例如，<code>System.out.println(System.out)</code>将生成<code>java.io.PrintStream@23f434</code>。原因在于<code>System.out</code>没有覆盖超类<code>Object</code>中的<code>toString</code>方法。</p>
<blockquote>
<ol>
<li><p>建议为自定义的每一个类都添加重写<code>toString</code>方法，方便与在日志中对数据的输出。</p>
</li>
<li><p>对于数组类型的数组，可以调用<code>Arrays.toString(new int[]{1, 2, 3, 4})</code>来生成字符串。</p>
</li>
</ol>
</blockquote>
<h3 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h3><p>所有的基本类型都有一个与之对应的类，这些类称为<strong>包装器（<code>wrapper</code>）</strong>。</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>Integer</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>Long</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>Float</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>Double</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>Short</code></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>Byte</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>Character</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>Boolean</code></td>
</tr>
</tbody></table>
<p>方便在一些必须使用类的地方来使用，例如：<code>ArrayList&lt;Integer&gt;</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在添加 int 类型时，下面的调用</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将自动变换为</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面所述的这个过程称为<strong>自动装箱（<code>autoboxing</code>）</strong>。</p>
<p>相反的将一个<code>Integer</code>对象赋给一个<code>int</code>值时，也会自动的拆箱，编译器将<code>int n = list.get(3)</code>自动的转换成<code>int n = list.get(3).intValue();</code>。</p>
<blockquote>
<ol>
<li>自动装箱规范要求<code>boolean</code>、<code>byte</code>、<code>char&lt;=127</code>、介于<code>-128和127</code>之间的<code>short</code>和<code>int</code>被包装到固定的对象中。</li>
<li><strong>装箱和拆箱时编译器做的工作，而不是虚拟机</strong>。</li>
</ol>
</blockquote>
<p>介于<code>-128和127</code>之间的<code>short</code>和<code>int</code>被包装到固定的对象中。所以两个<code>Integer</code>对象会有时候会相等。如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">prinln</span><span class="token punctuation">(</span> a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出为true</span>

<span class="token comment">/* 
* 因为介于`-128 ~ 127`之间的`short`和`int`被包装到固定的对象中， 所以这时候比较的时同一块地址中保存的数据
* 所以在超过`-128 ~ 127`范围之内的两个 Integer 对象则不相等
*/</span>


<span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> d <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">prinln</span><span class="token punctuation">(</span> a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出为false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="/2022/06/28/cs-languages/core-java-volume-0/integer.png" class="" title="integer">

<h3 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h3><p>可以提供参数数量可变的方法，又被称为<strong>变参（<code>varargs</code>）方法</strong>。例如下面的方法</p>
<p><code>System.out.printf("%d", n);  System.out.printf("%d %s", n, "widghts");  </code></p>
<p>上面的两个语句都是调用同一个方法，不过是一个为两个参数，一个为三个参数。<code>printf</code>方法是如下这样定义的</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintStream</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">PrintStream</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token class-name">String</span> fmt<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">format</span><span class="token punctuation">(</span>fmt<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的省略号<code>...</code>是<code>Java</code>代码的一部分，它表明这个方法可以接收任意数量的对象（除fmt参数之外）。这里<code>printf</code>方法接收了两个参数，一个是格式字符串，<strong>另一个数量可变的参数实际上是一个<code>Object[]</code>数组</strong>。</p>
<p><code>Object... </code>参数类型与<code>Object[]</code>完全一样。</p>
<blockquote>
<p>所以上面的示例调用也可以写作：</p>
<p><code>System.out.printf("%d %s", new Object[] { new Integer(1), "widghts");</code></p>
</blockquote>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>所有的枚举类型都是<code>Enum</code>类的子类。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">enum</span> <span class="token class-name">Size</span> <span class="token punctuation">{</span>
    <span class="token function">SMALL</span><span class="token punctuation">(</span><span class="token string">"S"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">MEDIUM</span><span class="token punctuation">(</span><span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">LARGE</span><span class="token punctuation">(</span><span class="token string">"L"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EXTRA_LARGE</span><span class="token punctuation">(</span><span class="token string">"XL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 枚举的构造器总是私有的</span>
    <span class="token keyword">private</span> <span class="token class-name">Size</span><span class="token punctuation">(</span><span class="token class-name">String</span> abbreviation<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>abbreviation <span class="token operator">=</span> abbreviation<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getAbbreviation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> abbreviation<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> abbreviation<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><strong>反射库（<code>reflection library</code>）</strong>提供了一个丰富且精巧的工具集，可以用来编写能够动态操纵<code>Java</code>代码的程序。</p>
<p>能够分析类能力的程序称为<strong>反射（<code>reflective</code>）</strong>，用于</p>
<ul>
<li>在运行时分析类的能力</li>
<li>在运行时检查对象，例如，编写一个适用与所有类的<code>toString</code>方法</li>
<li>实现泛型数组造作代码</li>
<li>利用<code>Method</code>对象， 这个对象很像C++中的函数指针</li>
</ul>
<h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a><code>Class</code>类</h4><p> <code>Java</code>运行时系统始终为所有对象维护的一个<strong>运行时类型标识</strong>。</p>
<ul>
<li><p><code>Object</code>类中的<code>getClass()</code>方法将会返回一个<code>Class</code>类型的实例。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Employee</span> e<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span> cl <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>静态方法<code>forName</code>获得类名对应的<code>Class</code>对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> className <span class="token operator">=</span> <span class="token string">"java.util.Random"</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span> cl <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<blockquote>
<p><strong>注意</strong>：一个<code>Class</code>对象实际上表示的是一个<strong>类型</strong>，可能是类，也可能不是类，例如，<code>int</code>不是类，但是int.class是一个<code>Class</code>类型的对象。</p>
</blockquote>
<p><strong>虚拟机为每个类型管理一个唯一的Class对象</strong>。因此可以使用==运算符实现两个类对象的比较。</p>
<p>在有一个Class对象的时候，可以用它构造类的实例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> className <span class="token operator">=</span> <span class="token string">"java.util.Random"</span><span class="token punctuation">;</span> <span class="token comment">// or any other name of a class with a no-arg constructor</span>
<span class="token class-name">Class</span> cl <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span> obj <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="声明异常入门"><a href="#声明异常入门" class="headerlink" title="声明异常入门"></a>声明异常入门</h4><ul>
<li><p>非检查型异常 （unchecked）</p>
</li>
<li><p>检查型异常 （checked）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">api</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> classParam<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">NoSuchMethodException</span> <span class="token punctuation">{</span>
  
    <span class="token comment">// 返回一个Class对象， 表示名为className的类。 throws ClassNotFoundException</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> aClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"book.api.ClassApi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 生成一个对象，描述有指定参数类型的构造器。 throws NoSuchMethodException</span>
    <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> classParam<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token class-name">ClassApi</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>在<code>Java</code>中，关联的文件被称为资源（<code>resource</code>）</p>
<p><code>Class</code>类提供了一个很有用的服务可以查找资源文件：</p>
<ol>
<li>获取拥有资源的类的<code>Class</code>对象，例如，ResourceTest.class</li>
<li>接受描述资源位置的<code>URL</code>， <code>URL url = cl.getResource("about.gif");</code></li>
<li>使用<code>getResourceAsStream</code>方法获得一个输入流来读取文件中中的数据。</li>
</ol>
<h4 id="利用反射分析类的能力"><a href="#利用反射分析类的能力" class="headerlink" title="利用反射分析类的能力"></a>利用反射分析类的能力</h4><p>主要是通过 <code>java.lang.reflect</code>包中三个类<code>Field</code>、<code>Method</code>、<code>Constructor</code>分别来描述类的字段、方法和构造器，进而来分析类的能力。</p>
<p><strong><code>Class</code>类的<code>getDeclareFields</code>、<code>getDeclareMethods</code>、<code>getDeclaredConstructors</code>方法将分别而返回类中声明的全部字段、方法和构造器的数组，其中包括私有成员、包成员和受保护成员，但不包括超类的成员。</strong></p>
<h4 id="使用反射在运行时分析对象"><a href="#使用反射在运行时分析对象" class="headerlink" title="使用反射在运行时分析对象"></a>使用反射在运行时分析对象</h4><ul>
<li>反射机制的默认行为受限于<code>Java</code>的访问限制，但是，可以调用<code>Field</code>、<code>Method</code>和<code>Constructor</code>对象的<code>setAccessible</code>方法覆盖Java的访问控制。<ul>
<li>·该方法是<code>AccessibleObject</code>类中的一个方法，是上述三个类的公共超类。这个特性是为调试、持久存储和类似机制提供的。</li>
<li>如果类中存在循环引用，在用反射获取其中属性时可能存在无限递归的问题，因此，可以使用<code>ObjectAnalyzer</code>来跟踪已访问过的对象避免无限递归。</li>
</ul>
</li>
</ul>
<h3 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h3><ol>
<li><strong>将公共操作和字段放在超类中</strong></li>
<li><strong>不要使用受保护的字段</strong></li>
<li><strong>使用继承实现“is-a”关系</strong></li>
<li><strong>除非所有继承的方法都有意义，否则不要使用继承</strong></li>
<li><strong>再覆盖方法时，不要改变预期的行为</strong></li>
<li><strong>使用多态，而不要使用类型信息</strong></li>
<li><strong>不要滥用反射</strong><ul>
<li>反射机制使人们可以在运行时查看字段和方法，从而能编写出更具有通用性的程序。这种功能对于编写系统程序及其有用，但是通常不适于编写应用程序。</li>
<li>反射是很脆弱的，如果使用反射，编译器将无法帮助你查找编程错误，因此只有在运行时才会发现错误并导致异常</li>
</ul>
</li>
</ol>
<h2 id="接口、lambda表达式和内部类"><a href="#接口、lambda表达式和内部类" class="headerlink" title="接口、lambda表达式和内部类"></a>接口、<code>lambda</code>表达式和内部类</h2><h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（<code>interface</code>）</h3><p>用来描述类应该做什么，而不指定它们具体应该怎么做。一个类可以实现（<code>implement</code>）一个或多个接口。</p>
<h4 id="接口概念"><a href="#接口概念" class="headerlink" title="接口概念"></a>接口概念</h4><p>接口不是类，而是对希望符合这个接口的类的一组需求。使用关键字 <code>interface</code> 定义方式如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparable</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>在接口声明中，没有将 <code>compareTo</code> 方法声明为 <code>public</code> ，这是因为在接口中的所有方法都自动时 <code>public</code>。不过，在实现接口是，必须将方法声明为 <code>public</code>；否则，编译器将认为这个方法的访问属性时包可见性，这个类的默认访问属性。</p>
</blockquote>
<p>为了让类实现一个接口，通过如下步骤定义：</p>
<ol>
<li>将类声明为实现给定的接口。</li>
<li>对接口中的所有方法提供定义。</li>
</ol>
<p>使用关键字 <code>implments</code> ：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="接口的属性"><a href="#接口的属性" class="headerlink" title="接口的属性"></a>接口的属性</h4><p>接口不是类。具体来说，<strong>不能使用<code>new</code>运算符实例化一个接口</strong>：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ERROR</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>不过<strong>可以声明接口的变量</strong>：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Comparable</span> x<span class="token punctuation">;</span> <span class="token comment">// ok</span>
x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Exployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可以引用一个实现了这个接口的类对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>使用  <code>instanceof</code> 检查一个对象是否实现了某个特定的接口：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span> anObject <span class="token keyword">instanceof</span> <span class="token class-name">Comparable</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以建立与类的继承层次一样的扩展接口，即 接口继承接口：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Moveable</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Powered</span> <span class="token keyword">extends</span> <span class="token class-name">Moveable</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> <span class="token function">milesPerGallon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接口中不能包含实例字段，但是可以包含常量，接口中的字段总是 <code>public static final</code>：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Powered</span> <span class="token keyword">extends</span> <span class="token class-name">Moveable</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> <span class="token function">milesPerGallon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> SPEED_LIMIT <span class="token operator">=</span> <span class="token number">95</span><span class="token punctuation">;</span> <span class="token comment">// a public static finla constant</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h4><p>一个类可以实现多个接口，但是只能继承一个类，Java不支持多重继承。所以在抽象类之外有引入了接口的概念。</p>
<h4 id="静态和私有方法"><a href="#静态和私有方法" class="headerlink" title="静态和私有方法"></a>静态和私有方法</h4><p>在<code>Java8</code>中，允许在接口中增加静态方法。目前为止，通常的做法都是将静态方法放在伴随类中。在标准库中，你会看到成对出现的接口和实用工具类，如<code>Collection/Collections</code>或<code>Path/Paths</code>.</p>
<p>在Java9中，接口中的方法可以是private。private方法可以是静态方法或实例方法。由于私有方法只能在接口本身的方法中使用，所以用法很有限，只能作为接口中其他方法的辅助方法。</p>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>可以为接口方法提供一个<strong>默认实现</strong>，必须用<code>default</code>修饰符标记这样一个方法。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CompareTo</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">default</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">T</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// by default, all elements are the same</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 同时默认方法可以调用其他方法</span>
    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// an abstract method</span>
    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>默认方法的一个重要用法就是“<strong>接口演化</strong>”（interface evolution）。即对老接口增加新方法，那么历史的已经实现的类要怎么处理呢，这时候通过对新加的方法提供默认实现，即可保证历史的实现也可以正常编译和使用。</p>
<h4 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h4><ol>
<li><p>超类优先。</p>
<p>如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法都会被忽略。</p>
</li>
<li><p>接口冲突。</p>
<p>如果一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突，</p>
</li>
</ol>
<h4 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h4><img src="/2022/06/28/cs-languages/core-java-volume-0/copy_clone.png" class="" title="image-copy_clone">

<img src="/2022/06/28/cs-languages/core-java-volume-0/light_copy.png" class="" title="image-light_copy">

<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a><code>lambda</code>表达式</h3><p> 用于处理代码块</p>
<h4 id="lambda表达式的语法"><a href="#lambda表达式的语法" class="headerlink" title="lambda表达式的语法"></a><code>lambda</code>表达式的语法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如上就是一个简单的**<code>lambda</code>表达式**，<code>lambda</code>表达式就是一个代码块，以及必须传入代码的变量规范。</p>
<p>这是一种表达方式：<strong>参数，箭头（-&gt;）以及一个表达式</strong>。示例：</p>
<ol>
<li><p>如果代码要完成多个计算，可以将代码卸载<code>{}</code>中</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>即使lambda表达式没有参数，仍然需要提供空括号，就像无参数方法一样：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> comp <span class="token operator">=</span> 
    <span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span>  <span class="token comment">// same as (String first, String second)</span>
    <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>如果方法只有一个参数，而且这个参数的类型可以推导出来，那么甚至可以省略小括号</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span> 
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The time is "</span> 
                      <span class="token operator">+</span> <span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">ofEpochMilli</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getWhen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ol>
<p>无须指定<code>lambda</code>表达式的返回类型。<code>lambda</code>表达式的返回类型总是会由上下文推导得出。</p>
<blockquote>
<p>如果一个lambda表达式只在某些分支返回一个值，而另外一个分支不返回值，这是不合法的。例如，(int x) -&gt; { if (x &gt;= 0) return 1;} 就不合法。</p>
</blockquote>
<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为<strong>函数式接口</strong>（<code>functional interface</code>）。</p>
<p>最好把<code>lambda</code>表达式看作是一个函数，而不是一个对象，另外要接受<code>lambda</code>表达式可以传递到函数式接口。</p>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> event <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 也可以改为</span>
<span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TImer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>表达式<strong>System.out::println</strong>是一个<strong>方法引用</strong>（<code>method reference</code>），它指示编译器生成一<strong>个函数式接口</strong>的实例，覆盖这个接口的抽象方法来调用给定的方法。</p>
<p>要用::运算符分割方法名与对象或类名，主要由下面三种情况：</p>
<ol>
<li><p><strong><code>object::instanceMethod</code></strong></p>
<p>方法引用等价于向方法传递参数的<code>lambda</code>表达式。</p>
<p>对于<code>System.out::println</code>，对象是 <code>System.out</code>， 所以方法表达式等价于<code> x -&gt; System.out,println(x)</code></p>
</li>
<li><p><strong><code>Class::instanceMethod</code></strong></p>
<p>第一个参数会成为方法的隐式参数</p>
<p><code>String::compareToIgnoreCase</code> 等同于<code> (x, y) -&gt; x.compareToIgnoreCase(y)</code></p>
</li>
<li><p><strong><code>Class::staticMethod</code></strong></p>
<p>所有的参数都传递到静态方法：<code>Math::pow</code> 等价于<code> (x, y) -&gt; Math.pow(x, y)</code>。</p>
</li>
</ol>
<p><strong>方法引用示例</strong></p>
<table>
<thead>
<tr>
<th>方法引用</th>
<th>等价的lambda表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>separator::equals</code></td>
<td><code>x -&gt; separator.equals(x)</code></td>
<td>这是包含一个对象和一个实例方法的方法表达式。<code>lambda</code>参数作为这个方法的显示参数传入</td>
</tr>
<tr>
<td><code>String::trim</code></td>
<td><code>x -&gt; x.trim()</code></td>
<td>这是一个包含一个类和一个实例方法的方法表达式。<code>lambda</code>表达式会成为隐式参数</td>
</tr>
<tr>
<td><code>String::concat</code></td>
<td><code>(x, y) -&gt; x.concat(y)</code></td>
<td>同样，这里有一个实例方法，不过这次由一个显示参数。与前面一样，第一个<code>lambda</code>参数会称为隐式参数，其余的参数会传递到方法</td>
</tr>
<tr>
<td><code>Integer::valueOf</code></td>
<td><code>x -&gt; Integer::valueOf(x)</code></td>
<td>这是包含一个静态方法的方法表达式。<code>lambda</code>参数会传递到这个静态方法</td>
</tr>
<tr>
<td><code>Integer::sum</code></td>
<td><code>(x, y) -&gt; Integer::sum(x, y)</code></td>
<td>这是另一个静态方法，不过这一次有两个参数。两个<code>lambda</code>参数都传递到这个静态方法。<code>Integer.sum</code>方法专门创建为作为一个方法引用。对于lambda表达式，可以只写作<code>(x, y) -&gt; x+y</code></td>
</tr>
<tr>
<td><code>Integer::new</code></td>
<td><code>x -&gt; new Integer(x)</code></td>
<td>这是一个构造器引用，<code>lambda</code>参数传递到这个构造器，详见<a href="####%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8">构造器引用</a></td>
</tr>
<tr>
<td><code>Integer[]::new</code></td>
<td><code>n -&gt; new Integer[n]</code></td>
<td>这是一个数组构造器引用，<code>lambda</code>参数是数组长度</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：只有当<code>lambda</code>表达式的体只调用一个方法而不做其他操作时，才能把lambda表达式重写为方法引用。例如：<code>s -&gt; s.length() == 0</code>，这里有一个方法调用。但是还有一个比较，所以这里不能使用方法引用。</p>
</blockquote>
<blockquote>
<p>包含对象的方法引用与等价的<code>lambda</code>表达式还有一个细微的差别。考虑一个方法引用，如<code>separator::equals</code>。如果<code>separator</code>为<code>null</code>，构造<code>separator::equals</code>时就会立即抛出一个<code>NullPointerException</code>异常。<code>lambda</code>表达式<code> x-&gt; sparator.equals(x)</code>只在调用时才会抛出<code>NullPointerException</code>异常。</p>
</blockquote>
<p>同样也可以使用：<code>this::instanceMethod</code>和 <code>super::instanceMethod</code></p>
<h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span> people <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>toArray</code>方法调用这个构造器来得到一个有正确类型的数组，这里的<code>Person[]::new</code>就是一个构造器引用。</p>
<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">repeatMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">,</span> <span class="token keyword">int</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultToolkit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的例子中，里面的<code>lambda</code>表达式有一个自由变量<code>text</code>，表示<code>lambda</code>表达式的数据接口必须存储自由变量的值。</p>
<blockquote>
<p>关于代码块以及自由变量值有一个术语：闭包（<code>closure</code>）</p>
</blockquote>
<p>可以看到lambda表达式可以捕获外围作用域中变量的值，<strong>但是这里有一个重要的限制，在lambda表达之中，只能引用值不会改变的变量</strong>，主要原因在于：如果lambda表达式中更改变量，<strong>并发执行多个动作时就会不安全</strong>。例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">countDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        start<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// ERROR: Can't mutate captured variable</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同时，如果lambda表达式中引用一个变量，而这个变量可能在外面改变，这个也是不合法的。例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ERROR: Cannot refer to changing i</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里有一条规则：<font color="blue"><code>lambda</code>表达式中捕获的变量必须实际上是事实最终变量（<code>effectively final</code>）。事实最终变量是指，这个变量初始化之后就不会再为它赋新值</font>。</p>
<p><code>lambda</code>表达式的体与嵌套快有相同的作用域。在一个<code>lambda</code>表达式中使用<code>this</code>关键字时，是指创建这个lambda表达式的方法的<code>this</code>参数。</p>
<h4 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理<code>lambda</code>表达式</h4><p>使用<code>lambda</code>表达式的重点是延迟执行（<code>deferred execution</code>）。毕竟，如果想要立即执行代码，完全可以直接执行，而无需把他包装在一个<code>lambda</code>表达式中。</p>
<p><strong>常用函数式接口</strong></p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>抽象方法</th>
<th>描述</th>
<th>其他方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>Runnable</code></td>
<td><code>无</code></td>
<td><code>void</code></td>
<td><code>run</code></td>
<td><code>作为无参数或返回值的动作执行</code></td>
<td></td>
</tr>
<tr>
<td><code>Supplier&lt;T&gt;</code></td>
<td><code>无</code></td>
<td><code>T</code></td>
<td><code>get</code></td>
<td><code>提供一个T类型的值</code></td>
<td></td>
</tr>
<tr>
<td><code>Consumer&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>void</code></td>
<td><code>accept</code></td>
<td><code>提供一个T类型的值</code></td>
<td><code>andThen</code></td>
</tr>
<tr>
<td><code>BiConsumer&lt;T, U&gt;</code></td>
<td><code>T, U</code></td>
<td><code>void</code></td>
<td><code>accept</code></td>
<td><code>处理T和U类型的值</code></td>
<td><code>andThen</code></td>
</tr>
<tr>
<td><code>Function&lt;T, R&gt;</code></td>
<td><code>T</code></td>
<td><code>R</code></td>
<td><code>apply</code></td>
<td><code>有一个T类型参数的函数</code></td>
<td><code>compose, andThen, identity</code></td>
</tr>
<tr>
<td><code>BiFunction&lt;T, U, R&gt;</code></td>
<td><code>T, U</code></td>
<td><code>R</code></td>
<td><code>apply</code></td>
<td><code>有T和U类型参数的函数</code></td>
<td><code>andThen</code></td>
</tr>
<tr>
<td><code>UnaryOperator&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>T</code></td>
<td><code>apply</code></td>
<td><code>类型T上的一元操作符</code></td>
<td><code>compose, andThen, identity</code></td>
</tr>
<tr>
<td><code>BinaryOperator&lt;T&gt;</code></td>
<td><code>T, T</code></td>
<td><code>T</code></td>
<td><code>apply</code></td>
<td><code>类型T上的二元操作符</code></td>
<td><code>andThen, maxBy, minBy</code></td>
</tr>
<tr>
<td><code>Predicate&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>boolean</code></td>
<td><code>test</code></td>
<td><code>布尔值函数</code></td>
<td><code>and, or, negate, isEqual</code></td>
</tr>
<tr>
<td><code>Bipredicate&lt;T, U&gt;</code></td>
<td><code>T, U</code></td>
<td><code>boolean</code></td>
<td><code>test</code></td>
<td><code>有两个参数的布尔值函数</code></td>
<td><code>and, or, negate</code></td>
</tr>
</tbody></table>
<p>基本类型的函数式接口</p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>抽象方法名</th>
</tr>
</thead>
<tbody><tr>
<td><code>BooleanSupplier</code></td>
<td>无</td>
<td><code>boolean</code></td>
<td><code>getAsBoolean</code></td>
</tr>
<tr>
<td><em><code>P</code></em><code>Supplier</code></td>
<td>无</td>
<td><em><code>p</code></em></td>
<td><code>getAs</code><em><code>P</code></em></td>
</tr>
<tr>
<td><em><code>P</code></em><code>ConSumer</code></td>
<td><em><code>p</code></em></td>
<td><code>void</code></td>
<td><code>accept</code></td>
</tr>
<tr>
<td><em><code>ObjP</code></em><code>Consumer&lt;T&gt;</code></td>
<td><em><code>T</code><em>、</em><code>p</code></em></td>
<td><code>void</code></td>
<td><code>accept</code></td>
</tr>
<tr>
<td><em><code>P</code></em><code>Function&lt;T&gt;</code></td>
<td><em><code>p</code></em></td>
<td><em><code>T</code></em></td>
<td><code>apply</code></td>
</tr>
<tr>
<td><em><code>P</code></em><code>To</code><em><code>Q</code></em><code>Function</code></td>
<td><em><code>p</code></em></td>
<td><em><code>q</code></em></td>
<td><code>applyAs</code><em><code>Q</code></em></td>
</tr>
<tr>
<td><code>To</code><em><code>P</code></em><code>Function&lt;T&gt;</code></td>
<td><em><code>T</code></em></td>
<td><em><code>p</code></em></td>
<td><code>applyAs</code><em><code>P</code></em></td>
</tr>
<tr>
<td><code>To</code><em><code>P</code></em><code>Bifunction&lt;T, U&gt;</code></td>
<td><em><code>T</code><em>、</em><code>U</code></em></td>
<td><em><code>p</code></em></td>
<td><code>applyAs</code><em><code>P</code></em></td>
</tr>
<tr>
<td><em><code>P</code></em><code>UnaryOperator</code></td>
<td><em><code>p</code></em></td>
<td><em><code>p</code></em></td>
<td><code>applyAs</code><em><code>P</code></em></td>
</tr>
<tr>
<td><em><code>P</code></em><code>BinaryOperator</code></td>
<td><em><code>p</code><em>、</em><code>p</code></em></td>
<td><em><code>p</code></em></td>
<td><code>applyAs</code><em><code>P</code></em></td>
</tr>
<tr>
<td><em><code>P</code></em><code>Predicate</code></td>
<td><em><code>p</code></em></td>
<td><code>boolean</code></td>
<td><code>test</code></td>
</tr>
</tbody></table>
<p><strong>注 <em><code>p</code><em>、</em><code>q</code></em> 是<code>int</code>、<code>long</code>、<code>double</code>；*<code>P</code><em>、</em><code>Q</code>*是<code>Int</code>、<code>Long</code>、<code>Double</code></strong></p>
<blockquote>
<p>如果设计你自己的接口，其中只有一个抽象方法，可以用<code>@FunctionalInterface</code>注解来标记这个接口。</p>
</blockquote>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><strong>内部类</strong>（<code>inner class</code>）是定义在另一个类中的类。</p>
<ul>
<li>内部类可以对同一个包中的其他类隐藏。</li>
<li>内部类方法可以访问定义这个类的作用域中的数据，包括原本私有的数据。</li>
</ul>
<h4 id="使用内部类访问对象状态"><a href="#使用内部类访问对象状态" class="headerlink" title="使用内部类访问对象状态"></a>使用内部类访问对象状态</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TalkingClock</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> interval<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> beep<span class="token punctuation">;</span> <span class="token comment">// 注意这个变量，在内部类中被访问了</span>
    
    <span class="token keyword">public</span> <span class="token class-name">TalkingClock</span><span class="token punctuation">(</span><span class="token keyword">int</span> interval<span class="token punctuation">,</span> <span class="token keyword">boolean</span> beep<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimePrinter</span> impements <span class="token class-name">ActinListener</span> <span class="token punctuation">{</span> <span class="token comment">// 这是一个内部类</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 注意这里的 if(beep)中 beep 是外部类的变量</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>beep<span class="token punctuation">)</span> <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultTooklit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>一个内部类方法可以访问自己的数据字段，以可以访问创建它的外围类对象的数据字段。为此，内部类的对象总有一个隐式引用，指向创建它的外部类对象。</p>
<img src="/2022/06/28/cs-languages/core-java-volume-0/inner_class_0.png" class="" title="inner_class_0">

<p>这个引用在内部类的定义中是不可见的。外围类的引用在构造器中设置。编译器会修改所有的内部类构造器，添加一个对应外围类引用的参数。</p>
<h4 id="内部类的特殊语法规则"><a href="#内部类的特殊语法规则" class="headerlink" title="内部类的特殊语法规则"></a>内部类的特殊语法规则</h4><p>当然使用外部类的引用，有一个更专业的语法：<code>OuterClass.this</code>，表示对外围类的引用</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimePrinter</span> impements <span class="token class-name">ActinListener</span> <span class="token punctuation">{</span> <span class="token comment">// 这是一个内部类</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 注意这里的 if(beep)中 beep 是外部类的变量</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">TalkingClock</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>beep<span class="token punctuation">)</span> <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultTooklit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="内部类的编译文件"><a href="#内部类的编译文件" class="headerlink" title="内部类的编译文件"></a>内部类的编译文件</h4><p><strong>内部类</strong>是一个<strong>编译器现象</strong>，与虚拟机无关。编译器将会把内部类转换为常规的类文件，用<code>$</code>分割外部类名与内部类名，而虚拟机则对此一无所知。</p>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>可以在一个方法中局部地定义一个类，这样就可以只限定于在方法块中使用这个类，这样局部类有一个很大的优势，即对外部世界完全隐藏。</p>
<p>声明局部类时不能有访问说明符。</p>
<p>局部类还有一个优点，它们不仅能够访问外部类的字段，还可以访问局部变量！不过，那些局部变量必须是<strong>事实最终变量</strong>（<code>effectively final</code>）。和<code>lambda</code>表达式中的相同限定。</p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>如果只想创建这个类的一个对象，甚至不需要为类指定名字，这样的一个类被称为<strong>匿名内部类</strong>（<code>anonymous inner class</code>）</p>
<p>大致的结构如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span>construction parameters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// inner class methods and data</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ol>
<li>其中SuperType可以时接口，如ActionListener，这样就是实现了这个接口；</li>
<li>也可以时一个类，这样就是扩展这个类，相当于内部类继承这个类。</li>
</ol>
<p><strong>匿名内部类不能有构造器</strong>，实际上，构造参数要传递给超类构造器。</p>
<blockquote>
<p>尽管匿名类不能有构造器，但可以提供一个对象初始化块：</p>
<p>var count = new Person(“Dracula”) {</p>
<p>​		{initialization}</p>
<p>}</p>
</blockquote>
<blockquote>
<p>下面有个技巧为“双括号初始化”（double brace initialization），利用内部类的语法创建并初始化一个数组列表并传递给一个方法：</p>
<p><code>invite(new ArrayList&lt;String&gt;() {{ add("Harry"); add("Tony"); }})</code></p>
<p>这里外层括号建立了<code>ArrayList</code>的一个匿名子类。内层括号则是一个对象初始化块。</p>
</blockquote>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>有时候使用内部类只是为了把一个类隐藏在另一个类的内部，并不需要内部类有外围类对象的一个引用。为此，可以将内部类声明为<code>static</code>，这样就不会生成那个引用了，如果将访问权限设置为public，同时也可以提供给其他类访问。静态内部类类似于其他内部类，只是没有对外部类的引用。</p>
<blockquote>
<p>与常规内部类不同，静态内部类可以有静态字段和方法。</p>
<p>在接口中声明的内部类自动是<code>static</code>和<code>public</code></p>
</blockquote>
<h2 id="异常、断言和日志"><a href="#异常、断言和日志" class="headerlink" title="异常、断言和日志"></a>异常、断言和日志</h2><h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p>异常对象都是派生于<code>Throwable</code>类的一个类实例。</p>
<p>Java语言规范将派生于Error类或RuntimeException类的所有异常称为非检查型（<code>unchecked</code>）异常，所有其他的异常称为检查型（<code>checked</code>）异常。</p>
<img src="/2022/06/28/cs-languages/core-java-volume-0/throwable.png" class="" title="throwable">

<h4 id="声明检查型异常"><a href="#声明检查型异常" class="headerlink" title="声明检查型异常"></a>声明检查型异常</h4><blockquote>
<p>如果在子类中覆盖了超累的一个方法，子类方法中声明的检查型异常不能比超类方法中声明的异常更通用（子类方法可以抛出更特定的异常，或者根本不抛出任何异常）。</p>
<p>如果超类方法没有抛出任何检查型异常，子类已不能抛出任何检查型异常。</p>
</blockquote>
<h4 id="如何抛出异常"><a href="#如何抛出异常" class="headerlink" title="如何抛出异常"></a>如何抛出异常</h4><p>下面是抛出这个异常的语句：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EOFException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h4><p>只需要定义一个派生于<code>Exception</code>的类，或者派生于<code>Exception</code>的某个子类。</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><h4 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>捕获异常需要使用到，<code>try/catch</code>语句块：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// code</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExceptionType</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// handler for this type</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果<code>try</code>语句块中的任何代码抛出了<code>catch</code>子句中指定的一个异常类，那么：</p>
<ol>
<li>程序将跳过<code>try</code>语句块的其他代码</li>
<li>程序将执行catch子句中的处理器代码</li>
</ol>
<h4 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// code that might throw exceptions</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundExcption</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// code</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnknownHostExcption</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// code</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IoExcption</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// code</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在java7之后，同一个catch子句中可以捕获多个异常类型。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// code that might throw exceptions</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundExcption</span> <span class="token operator">|</span> <span class="token class-name">UnknownHostExcptione</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// code</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IoExcption</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// code</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>捕获多个异常时，异常变量隐含为final变量，例如，在以下子句体中不能为 e 赋予不同的值：</p>
<p><code>catch (FileNotFoundExcption | UnknownHostExcptione e) { ... }</code></p>
</blockquote>
<h4 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// access the database</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> original<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServletException</span><span class="token punctuation">(</span><span class="token string">"database error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    e<span class="token punctuation">.</span><span class="token function">initCause</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a><code>finally</code>子句</h4><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">var in = new FileInputStream(...);
try {
    // code that might throw exceptions
} catch (IOException e) {
    // show error message
} finally {
    in.close()
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的例子中，不管是否有异常被捕获，<code>finally</code>子句中的代码都会执行。<code>finally</code>在块（<code>try</code> 或者 <code>catch </code>部分）的“<strong>跳出</strong>”之前执行其中的代码。</p>
<p>同时，<code>try</code>语句可以只有<code>finally</code>子句，而没有<code>catch</code>子句：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// code that might throw exceptions</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>当<code>finally</code>子句包含<code>return</code>语句时，可能会产生意想不到的结果：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// ERROR</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如上所示，在方法返回前，会执行<code>finally</code>子句块，如果<code>finally</code>块也有一个<code>return</code>语句，这个返回值将会遮蔽原来的返回值。如果执行 <code>parseInt("42")</code> ，真正返回前会执行<code>finally</code>子句，使得方法最后返回一个0，而忽略原来的返回值。</p>
<p>更糟糕的是，如果 <code>parseInt("zero")</code> ，会抛出异常，return甚至会“吞掉”这个异常。</p>
<p><code>finally</code>子句的主要用于清理资源。不要把改变控制流的语句（<code>return，throw，break，continue</code>）放在<code>finally</code>子句中。</p>
</blockquote>
<h4 id="try-with-Resources语句"><a href="#try-with-Resources语句" class="headerlink" title="try-with-Resources语句"></a><code>try-with-Resources</code>语句</h4><p>最简格式为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span> <span class="token class-name">Resource</span> res <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// work with res</span>
<span class="token punctuation">}</span>

<span class="token comment">// 同时这里还可以定义多个资源</span>
<span class="token keyword">try</span> <span class="token punctuation">(</span> <span class="token class-name">Resource</span> in <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token class-name">Resource</span> out <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// work with res</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这里，<code>try</code>块退出时，会自动调用<code>res.close()</code>。不论这个块如何退出，异常或者正常退出，都会执行<code>res.close()</code>。</p>
<p>在<code>Java9</code>中，可以在try首部中提供之前声明的事实最终变量。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printAll</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lines<span class="token punctuation">,</span> <span class="token class-name">PrintWriter</span> out<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">(</span>out<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// effectively final variable</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> line <span class="token operator">:</span> lines<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token comment">// out.close() called here</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果try块抛出一个异常，而且<code>close</code>方法也抛出一个异常，这样就会带来一个难题。<code>try-with-resources</code>语句可以很好地处理这种情况。<strong>原来的异常会重新抛出，而<code>close</code>方法抛出的异常会“被抑制”。这些异常将自动捕获，并由<code>addSuppressed</code>方法增加到原来的异常</strong>。如果对这些异常感兴趣，可以调用<code>getSuppressed</code>方法，它会生成从<code>close</code>方法抛出并被抑制的异常数组。</p>
<blockquote>
<p><code>try -with-resources</code>语句自身也可以有catch子句，甚至还可以有一个finally子句。这些子句会在关闭资源后执行。<strong>注意是在关闭资源后执行</strong>。</p>
</blockquote>
<h4 id="分析堆栈轨迹元素"><a href="#分析堆栈轨迹元素" class="headerlink" title="分析堆栈轨迹元素"></a>分析堆栈轨迹元素</h4><p><strong>堆栈轨迹</strong>（<code>stack trace</code>）是程序执行过程中某个特定点上所欲哦挂起的方法调用的一个列表。可以调用<code>Throwable</code>类的<code>printStackTrace</code>方法访问堆栈轨迹。</p>
<h3 id="使用异常的技巧"><a href="#使用异常的技巧" class="headerlink" title="使用异常的技巧"></a>使用异常的技巧</h3><ol>
<li><p><strong>异常处理不能代替简单的测试</strong></p>
</li>
<li><p><strong>不要过分地细化异常</strong></p>
<p>将正常处理与错误处理分开</p>
</li>
<li><p><strong>充分利用异常层次结构</strong></p>
<p>不要只抛出RuntimeException异常，应该寻找一个合适的子类或创建自己的异常类。</p>
<p>不要只捕获Throwable异常，否则，这会使你的代码更难读、更难维护。</p>
</li>
<li><p><strong>不要压制异常</strong></p>
</li>
<li><p><strong>在检测错误时，“苛刻”要比放任更好</strong></p>
</li>
<li><p><strong>不要羞于传递异常</strong></p>
</li>
</ol>
<h3 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h3><h4 id="断言的概念"><a href="#断言的概念" class="headerlink" title="断言的概念"></a>断言的概念</h4><p>断言机制允许在测试期间向代码中插入一些检查，而在产生代码中会自动删除这些检查。</p>
<p>Java语言引入了关键字 assert。这个关键字有两种形式：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">assert</span> condition<span class="token punctuation">;</span>

<span class="token keyword">assert</span> condition <span class="token operator">:</span> expression<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="启用和禁用断言"><a href="#启用和禁用断言" class="headerlink" title="启用和禁用断言"></a>启用和禁用断言</h4><p>在默认情况下，断言时禁用的。可以在运行时用-enableassertions或-ea选项启用断言：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ java -enableassertions MyApp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>需要注意的是，不必重新编译程序来启用或禁用断言。启用或禁用断言是<strong>类加载器</strong>（<code>class loader</code>）的功能。禁用断言时，类加载器会去除断言代码。</p>
<p>也可以在某个类或整个包中启用断言，例如：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ java -ea:MyClass -ea:com.mycompany.mylib MyApp
<span class="token comment"># 在MyClass类以及com.mycompany.mylib包和它的子包</span>

<span class="token comment"># 使用 -disableassertions 或 -da</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>不过，启用和禁用所有断言的<code>-ea</code>和<code>-da</code>开关不能应用到那些没有类加载器的“系统类”上。对于这些系统类，需要使用<code>-enablesystemassertions/-esa</code>开关启用断言。</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>暂略</p>
<h2 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h2><h3 id="为什么要使用泛型程序设计"><a href="#为什么要使用泛型程序设计" class="headerlink" title="为什么要使用泛型程序设计"></a>为什么要使用泛型程序设计</h3><p><strong>反省程序设计</strong>（<code>generic programming</code>）意味着编写的代码可以对多种不同类型的对象重用。</p>
<p>这种设计可以让程序更易读，也更安全。</p>
<h3 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h3><p><strong>泛型类</strong>（<code>generic class</code>）就是有一个或多个类型变量的类。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> first<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> second<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> first <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> second <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token class-name">T</span> first<span class="token punctuation">,</span> <span class="token class-name">T</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> first<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirst</span><span class="token punctuation">(</span><span class="token class-name">T</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecond</span><span class="token punctuation">(</span><span class="token class-name">T</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>Pair</code> 类引入了一个类型变量T，用尖括号（<code>&lt;&gt;</code>）括起来，放在类名的后面。当然也可以定义多个类型变量：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p><code>Java</code>库使用变量<code>E</code>表示集合的元素类型，<code>K</code>和<code>V</code>分别表示表的键和值的类型。<code>T</code>（必要时还可以用相邻的字母<code>U</code>和<code>S</code>）表示“任意类型”</p>
</blockquote>
<p>可以使用具体的类型替换类型变量来实例化（<code>instantiate</code>）泛型类型，例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>除了可以定义泛型类之外，还可以定义一个带有类型参数的方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ArrayAlg</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">getMiddle</span><span class="token punctuation">(</span><span class="token class-name">T</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a<span class="token punctuation">[</span>a<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个方法实在普通类中定于的，而不是在泛型类中。注意，类型变量放在修饰符（这里的修饰符就是public static）的后面，并在返回类型的前面。</p>
<p>泛型方法可以再普通类中定义，也可以在泛型类中定义。</p>
<p>当调用一个泛型方法时，可以把具体类型包围在尖括号中：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> middle <span class="token operator">=</span> <span class="token class-name">ArrayAlg</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token function">getMiddle</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token string">"Q."</span><span class="token punctuation">,</span> <span class="token string">"Public"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>同样，在方法调用中可以省略<code>&lt;String&gt;</code>类型参数。编译器可以将参数的类型和泛型类型<code>T</code>进行匹配，推断出T一定是<code>String</code>。</p>
<h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><p>有时候类或方法需要对类型变量加以约束，这时候就可以通过对类型变量<code>T</code>设置一个限定（<code>bound</code>）来实现这一点：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里表示T应该时限定类型（<code>bounding type</code>）的子类型（<code>subtype</code>）。<code>T</code>和限定类型可以是类，也可以时接口。选择关键词<code>extends</code>的原因是它更接近于子类型的概念。同样一个类型变量或通配符可以有多个限定，例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Compatable</span> <span class="token operator">&amp;</span> <span class="token class-name">Serializable</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>限定类型用“<code>&amp;</code>”分割，而逗号用来分隔类型变量。</p>
<p><strong>在<code>Java</code>的继承中，可以根据需要拥有多个接口超类型，但最多有一个限定可以是类。如果有一个类作为限定，它必须是限定列表中的第一个限定。</strong></p>
<h3 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h3><p>虚拟机没有泛型类型对象——所有对象都属于普通类。在泛型实现的早期版本中，甚至能够将使用泛型的程序编译为1.0虚拟机上运行的类文件！在下面的小结中可以看到编译器如何“擦除”类型参数。</p>
<h4 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h4><p>无论何时定义一个泛型类型，都会自动提供一个相应的<strong>原始类型</strong>（<code>raw type</code>）。这个原始类型的名字就是去掉类型参数后的泛型类型名。类型变量会被<strong>擦除</strong>（<code>erased</code>），并替换为其限定类型（或者，对于无限定的变量则替换为<code>Object</code>）。</p>
<p>例如，<code>Pair&lt;T&gt;</code>的原始类型如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span> first<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span> second<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> first <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> second <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token class-name">Object</span> first<span class="token punctuation">,</span> <span class="token class-name">Object</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> first<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirst</span><span class="token punctuation">(</span><span class="token class-name">Object</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecond</span><span class="token punctuation">(</span><span class="token class-name">Object</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为<code>T</code>是一个无限定的变量，所以直接用<code>Object</code>替代。</p>
<p><strong>原始类型用第一个限定来替换类型变量，或者，如果没有给定限定，就替换为<code>Object</code>。</strong>例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Interval</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span> <span class="token operator">&amp;</span> <span class="token class-name">Serializable</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> first<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> second<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token class-name">T</span> first<span class="token punctuation">,</span> <span class="token class-name">T</span> second<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>类型擦除后，原始类型<code>Interval</code>如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Interval</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Comparable</span> first<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Comparable</span> second<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span> first<span class="token punctuation">,</span> <span class="token class-name">Comparable</span> second<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>如果将限定切换为<code>Class Interval&lt;T extends Serializable &amp; Comparable&gt;</code>会发生什么。如果这样操作，原始类型会用<code>Serializable</code>替换<code>T</code>，而编译器在必要时要向<code>Comparable</code>插入强制类型转换。<strong>为了提高效率，应该将标签（<code>tagging</code>）接口（即没有方法的接口）放在限定列表的末尾。</strong></p>
</blockquote>
<h4 id="转换泛型表达式"><a href="#转换泛型表达式" class="headerlink" title="转换泛型表达式"></a>转换泛型表达式</h4><p>编写一个泛型方法调用时，如果擦除了返回类型，编译器会插入强制类型转换。例如，对于下面的语序：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> buddies <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">Employee</span> buddy <span class="token operator">=</span> buddies<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>getFirst</code>擦除类型后的返回类型时<code>Object</code>。编译器自动插入转换到<code>Employee</code>的强制类型转换。</p>
<h4 id="转换泛型方法"><a href="#转换泛型方法" class="headerlink" title="转换泛型方法"></a>转换泛型方法</h4><p>对于<code>Java</code>泛型转换，需要记住以下几个事实：</p>
<ul>
<li>虚拟机中没有泛型，只有普通的类和方法。</li>
<li>所有的类型参数都会替换它们的限定类型。</li>
<li>会合成<strong>桥方法</strong>来保持多态。</li>
<li>为保持类型安全性，必要时会插入强制类型转换。</li>
</ul>
<h3 id="限制和局限性"><a href="#限制和局限性" class="headerlink" title="限制和局限性"></a>限制和局限性</h3><p><strong>这些限定和局限性的主要造成原因就是<font color="blue">类型擦除</font></strong></p>
<h4 id="不能用基本类型实例化类型参数"><a href="#不能用基本类型实例化类型参数" class="headerlink" title="不能用基本类型实例化类型参数"></a>不能用基本类型实例化类型参数</h4><p>不能用基本类型代替类型参数。因此没有<code>Pair&lt;double&gt;</code>，只有<code>Pair&lt;Double&gt;</code>。其原因就在于类型擦除。擦除之后，<code>Pair</code>类含有<code>Object</code>类型的字段，而<code>Object</code>不能存储<code>double</code>值。</p>
<h4 id="运行时类型查询值适用于原始类型"><a href="#运行时类型查询值适用于原始类型" class="headerlink" title="运行时类型查询值适用于原始类型"></a>运行时类型查询值适用于原始类型</h4><p>虚拟机中的对象总有一个特定的非泛型类型。因此，所有的类型查询只产生原始类型。例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// ERROR</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// ERROR</span>

<span class="token comment">// 或者强制类型转换</span>
<span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> a<span class="token punctuation">;</span> <span class="token comment">// warning can only test that a is a Pair</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同样的道理，getClass方法总是<strong>返回原始类型并不是泛型</strong>，例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stringPair <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> employeePair <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>stringPair<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> employeePair<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// they are equal</span>
<span class="token comment">// getClass() 返回 Pair.class    </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h4><p>不能实例化参数化类型的数据，例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// ERROR</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>因为，擦除之后，<code>table</code>的类型时Pair[]. 可以把它转换为<code>Object[]</code>：<code>Object[] objarray = table;</code></p>
<p>如果试图存储其他类型的元素，就会抛出一个<code>ArrayStoreException</code>异常：<code>objarray[0] = "Hello";</code></p>
<p>不过对于泛型类型，擦除会使这种机制无效。赋值语句：<code>objarray[0] = new Pair&lt;Employee&gt;();</code>，尽管能够通过数组存储的检查，仍然会导致一个类型错误。由于这个原因，不允许创建参数化类型的数组。</p>
<p>需要说明的是，指示不允许创建这个数组，而声明类型为<code>Pair&lt;String&gt;[]</code>的变量仍是合法的。不过不能用<code>new Pair&lt;String&gt;[10]</code>初始化这个变量。</p>
<blockquote>
<p>可以声明通配类型的数组，然后进行强制类型转换：（不过是不安全的初始化）</p>
<p><code>var table = (Pair&lt;String&gt;[]) new Pair&lt;?&gt;[10];</code></p>
</blockquote>
<h4 id="Varargs警告"><a href="#Varargs警告" class="headerlink" title="Varargs警告"></a><code>Varargs</code>警告</h4><p>向参数个数可变的方法传递一个泛型类型的实例。</p>
<p>下面的简单方法，它的参数个数是可变的：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> coll<span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ts<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 存在警告但是还可以使用</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">T</span> t <span class="token operator">:</span> ts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>考虑下面的调用：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pair</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> table <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> pair1 <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> pair2 <span class="token operator">-</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token function">addAll</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> pair1<span class="token punctuation">,</span> pair2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>为了调用这个方法，Java虚拟机必须建立一个Pair<strintg>数组，这违反了<a href="####%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E7%BB%84">上面的规则</a>。</strintg></p>
<blockquote>
<p>这里可以使用两个注解来抑制这个警告：<code>@SuppressWarnings("unchecked")</code> 和 <code>@SafeVarargs</code></p>
</blockquote>
<h4 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h4><p>不能在类似 new T(…) 的表达式中使用类型变量。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> first <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> second <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// ERROR</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>类型擦除将T变成Object，这样就变成调用 new Object()，不是所期望的。</p>
<p>在Java 8 之后，最好的解决办法是让调用者提供一个构造器表达式。例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token class-name">Pair</span><span class="token punctuation">.</span><span class="token function">makePair</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">makePair</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> constr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>constr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> constr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="不能构造泛型数组"><a href="#不能构造泛型数组" class="headerlink" title="不能构造泛型数组"></a>不能构造泛型数组</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">minmax</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//Error</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>因为<strong>类型擦除</strong>的原因，这里会使得这个方法总是构造<code>Comparable[2]</code>数组。</p>
<p>所以这种情况下最好是让用户提供一个数组构造器表达式：</p>
<pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">String[] names = ArrayAlg.minmax(String[]::new, "Tom", "Dick", "Harry");


public static &lt;T extends Comparable&gt; T[] minman(IntFunction&lt;T[]&gt; constr, T... a) {
    T[] result = constr.apply(2);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="泛型类的静态上下文中类型变量无效"><a href="#泛型类的静态上下文中类型变量无效" class="headerlink" title="泛型类的静态上下文中类型变量无效"></a>泛型类的静态上下文中类型变量无效</h4><p>不能在静态字段或方法中引用类型变量。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singletion</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">T</span> singleInstance<span class="token punctuation">;</span> <span class="token comment">// ERROR</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">T</span> <span class="token function">getSingleInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ERROR</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> singleInstance<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如上所示，类型擦除之后，只剩下Singleton类，它只包含一个singleInstance字段。因此，禁止使用带有类型变量的静态字段和方法。</p>
<h4 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h4><p>既不能抛出也不能捕获泛型类的对象。实际上，泛型类扩展<code>Throwable</code>甚至都是不合法的。例如，以下定义就不合法 <code>public class Problem&lt;T&gt; extends Exception {}</code>，不过，在异常规范中使用类型变量是允许的：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// do work </span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> realCause<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">initCause</span><span class="token punctuation">(</span>realCause<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="可以取消对检查型异常的检查"><a href="#可以取消对检查型异常的检查" class="headerlink" title="可以取消对检查型异常的检查"></a>可以取消对检查型异常的检查</h4><p>Java异常处理的一个基本原则是，必须为所有检查型异常提供一个处理器。不过可以利用泛型取消这个机制。关键方法在于：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
<span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">throwAs</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="注意擦除后的冲突"><a href="#注意擦除后的冲突" class="headerlink" title="注意擦除后的冲突"></a>注意擦除后的冲突</h4><p>为了支持擦除转换，倘若两个接口类型是同一个接口的不同参数化，一个类或类型变量就不能同时作为这个两个接口类型的子类。例如，下面的代码时非法的：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Manager</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span class="token comment">// ERROR</span>

<span class="token comment">// Manager 会实现Comparable&lt;Employee&gt; 和 Comparable&lt;Manager&gt; ， 这是同一个接口的不同参数化.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3><img src="/2022/06/28/cs-languages/core-java-volume-0/pair.png" class="" title="pair">

<h3 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h3><h4 id="通配符概念"><a href="#通配符概念" class="headerlink" title="通配符概念"></a>通配符概念</h4><p>在通配符类型中，允许类型参数发生变化。例如，通配符类型：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>表示任何泛型<code>Pair</code>类型，它的类型参数时<code>Employee</code>的子类，如<code>Pair&lt;Manager&gt;</code>，但不是<code>Pair&lt;String&gt;</code>。</p>
<h4 id="通配符的超类型限定"><a href="#通配符的超类型限定" class="headerlink" title="通配符的超类型限定"></a>通配符的超类型限定</h4><p>除了继承限定外，还可以指定<strong>超类型限定</strong>：<code>? super Manager</code>。这个通配符限制为<code>Manager</code>的所有超类型。</p>
<p>直白的来说，带有超类型限定的通配符（<code>&lt;? super Manager&gt;</code>）允许你写入一个泛型对象，而带有子类型限定的通配符（<code>? extends Employee</code>）允许你读取一个泛型对象。</p>
<blockquote>
<p>超类型限定（<code>&lt;? super Manager&gt;</code>）： 可以明确的通过Manager知道其继承的超类，所以方便于写入一个泛型对象。</p>
<p>子类型限定（<code>? extends Employee</code>）：可以明确的知道返回的类型都是Employee的子类，所以方便于读取一个泛型对象。</p>
</blockquote>
<p>超类限定和子类限定同时使用：<code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; T min(T[] a)</code></p>
<h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><p>还可以使用根本无限定的通配符，例如，<code>Pair&lt;?&gt;</code>。初看起来，这好像与原始的Pair类型一样。实际上，这两种类型有很大的不同。类型Pair&lt;?&gt;有以下方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">?</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">setFirst</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>getFirst</code>的返回值只能赋给一个<code>Object</code>。<code>setFirst</code>方法不能被调用，甚至不能用<code>Object</code>调用（可以调用<code>setFirst&lt;null&gt;</code>）。<code>Pair&lt;?&gt;</code>和<code>Pair</code>本质的不同在于：可以用任意<code>Object</code>对象调用原始<code>Pair</code>类的<code>setFirst</code>方法。</p>
<p>为什么要使用这样一个脆弱的类型？它对于很多简单操作非常有用。例如，下面这个方法可用来测试一个对组是否包含一个<code>null</code>引用，它不需要实际的类型。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">hasNulls</span><span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> p<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> p<span class="token punctuation">.</span><span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>通过将<code>hasNulls</code>转换成泛型方法，可以避免使用通配符类型：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">boolean</span> <span class="token function">hasNulls</span><span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>但是 ，带有通配符的版本可读性更好。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a><code>Java</code>集合框架</h3><h4 id="集合接口与实现分类"><a href="#集合接口与实现分类" class="headerlink" title="集合接口与实现分类"></a>集合接口与实现分类</h4><p><code>Java</code>集合类库也将接口（<code>interface</code>）与实现（<code>implementation</code>）分离。</p>
<h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a><code>Collection</code>接口</h4><p>在<code>Java</code>类库中，集合类的基本接口时<code>Collection</code>接口。这个接口有两个基本方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 向集合中添加元素</span>
    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 迭代器</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p><code>Iterator</code>接口包含4个方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">forEachRemaining</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过反复调用<code>next</code>方法，可以逐个访问及各种的每个元素。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> iter <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> element <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// do something with element</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这样的循环可以用“ for each ”， 编译器简单的将其转换为带有迭代器的循环。</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> element <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do something with element</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>“<code>for each</code>”循环可以处理任何实现了Iterable接口的对象，这个接口只包含一个抽象方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>也可以不写循环，而是调用<code>forEachRemaining</code>方法并提供一个<code>lambda</code>表达式：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">iterator<span class="token punctuation">.</span><span class="token function">forEachRemaining</span><span class="token punctuation">(</span>element <span class="token operator">-&gt;</span> <span class="token keyword">do</span> something <span class="token keyword">with</span> <span class="token namespace">element</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>Java</code>的迭代器，查找操作和位置变更十分紧密耦合。查找一个元素的唯一方法时调用<code>next</code>，而在执行查找操作的同时，迭代器的位置就会随之向前移动。因此，<strong>可以认为<code>Java</code>迭代器位于两个元素之间，当调用<code>next</code>时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用</strong>。如下图：</p>
<img src="/2022/06/28/cs-languages/core-java-volume-0/iterator_0.png" class="" title="iterator_0">

<p><code>Iterator</code>接口的<code>remove</code>方法将会<strong>删除上次调用</strong><code>next</code>方法时返回的对象。如果想要删除指定位置上的元素，仍然需要越过这个元素。例如，可以如下删除一个字符串集合中的第一个元素：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// skip over the first element</span>
it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// now remove it</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>跟重要的时，<code>next</code>方法调用之间存在依赖性。如果调用<code>remove</code>之前没有调用<code>next</code>，将时不合法的。如果这样做，将会抛出一个<code>IllegalStateException</code>异常</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ERROR</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>实际上，必须先调用<code>next</code>越过将要删除的元素</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h3><img src="/2022/06/28/cs-languages/core-java-volume-0/collection_0.png" class="" title="collection_0">

<p><code>List</code>是一个有序集合（<code>ordered collection</code>）。元素会增加到容器中的特定位置。可以采用两种方式访问元素</p>
<ul>
<li>使用迭代器访问</li>
<li>使用一个整数索引来访问<ul>
<li>又称为<strong>随机访问</strong>（<code>random access</code>）</li>
</ul>
</li>
</ul>
<h3 id="具体集合"><a href="#具体集合" class="headerlink" title="具体集合"></a>具体集合</h3><blockquote>
<p><strong>线程安全</strong>的集合在后续介绍</p>
</blockquote>
<table>
<thead>
<tr>
<th>集合类型</th>
<th>描述</th>
<th>参见</th>
</tr>
</thead>
<tbody><tr>
<td><code>ArrayList</code></td>
<td>可以动态增长和缩减的一个索引序列</td>
<td></td>
</tr>
<tr>
<td><code>LinkedList</code></td>
<td>可以在任何位置高效插入和删除的一个有序序列</td>
<td><a href="####%E9%93%BE%E8%A1%A8">链表</a></td>
</tr>
<tr>
<td><code>ArrayDeque</code></td>
<td>实现为循环数组的一个双端队列</td>
<td></td>
</tr>
<tr>
<td><code>HashSet</code></td>
<td>没有重复元素的一个无序集合</td>
<td></td>
</tr>
<tr>
<td><code>TreeSet</code></td>
<td>一个有序集</td>
<td></td>
</tr>
<tr>
<td><code>LinkedHashSet</code></td>
<td>一个包含枚举值的集</td>
<td></td>
</tr>
<tr>
<td><code>PriorityQueue</code></td>
<td>允许高效删除最小元素的一个集合</td>
<td></td>
</tr>
<tr>
<td><code>HashMap</code></td>
<td>存储键/值关联的一个数据结构</td>
<td></td>
</tr>
<tr>
<td><code>TreeMap</code></td>
<td>键有序的一个映射</td>
<td></td>
</tr>
<tr>
<td><code>EnumMap</code></td>
<td>键属于枚举类型的一个映射</td>
<td></td>
</tr>
<tr>
<td><code>LinkedHashMap</code></td>
<td>可以记住键/值项添加次序的一个映射</td>
<td></td>
</tr>
<tr>
<td><code>WeakHashMap</code></td>
<td>值不会在别处使用时就可以被垃圾回收的一个映射</td>
<td></td>
</tr>
<tr>
<td><code>IdentityHashMap</code></td>
<td>用<code>==</code>而不是用<code>equals</code>比较键的一个映射</td>
<td></td>
</tr>
</tbody></table>
<img src="/2022/06/28/cs-languages/core-java-volume-0/collection_1.png" class="" title="collection_0">

<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表是一个有序集合，每个对象的位置十分重要。</p>
<p>在<code>Java</code>程序设计语言中，所有链表实际上都是<strong>双向链表</strong>（<code>doubly linked</code>）</p>
<p>如果需要对集合进行随机访问，就是用数组或<code>ArrayList</code>。</p>
<img src="/2022/06/28/cs-languages/core-java-volume-0/linkedlist.png" class="" title="linkedlist">

<h4 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h4><p><code>List</code>是一个有序集合（<code>ordered collection</code>）。元素会增加到容器中的特定位置。可以采用两种方式访问元素</p>
<ul>
<li>使用迭代器访问</li>
<li>使用一个整数索引来访问<ul>
<li>又称为随机访问（<code>random access</code>），这种访问方式不适用于链表，更适用于数组。</li>
</ul>
</li>
</ul>
<blockquote>
<p>这里的动态数组，还涉及到<code>Vector</code>类，为什么要用<code>ArrayList</code>而不是<code>Vector</code>呢？原因在于：<code>Vector</code>类的所有方法都是同步的，可以安全地从两个线程访问一个<code>Vector</code>对象。但是，如果只从一个线程访问<code>Vector</code>，代码就会在同步操作上白白浪费大量时间。而与之不同，<code>ArrayList</code>方法不是同步的，因此，建议在不需要同步时使用<code>ArrayList</code>，而不要使用<code>Vector</code>。</p>
</blockquote>
<h4 id="散列集"><a href="#散列集" class="headerlink" title="散列集"></a>散列集</h4><p><strong>散列表</strong>（<code>hash table</code>），可以用于快速地查找对象。</p>
<p>散列表为每个对象计算一个整数，称为<strong>散列码</strong>（<code>hash code</code>）。散列码是由对象的实例字段得出的一个整数，有不同数据的对象将产生一个不同的散列码。</p>
<p>在<code>Java</code>中，散列表用链表数组实现。每个列表被称为<strong>桶</strong>（<code>bucket</code>）。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。在桶中没有其他元素，此时将元素直接插入到桶中就可以了。当然，有时候会遇到桶已经被填充的情况。这种现象被称为<strong>散列冲突</strong>（<code>hash collision</code>）。这时，需要将新对象与桶中的所有对象比较，查看这个对象是否存在。</p>
<blockquote>
<p>在Java8中，桶满时会从链表变为平衡二叉树</p>
</blockquote>
<p>散列集迭代器将依次访问所有的桶，由于散列将元素分散在表中，所以会以一种看起来随机的顺序访问元素。这就是<strong>散列集无序</strong>的原因。</p>
<p>如果散列表太满，就需要<strong>再散列</strong>（<code>rehashed</code>）。创建一个桶数更多的表，插入数据后丢弃掉原来的表。<strong>装填因子</strong>（<code>load factor</code>）可以确定何时对散列表进行再散列。</p>
<img src="/2022/06/28/cs-languages/core-java-volume-0/hash_table.png" class="" title="hash_table">

<h4 id="树集"><a href="#树集" class="headerlink" title="树集"></a>树集</h4><p><code>TreeSet</code>类与散列集十分类型，不过，相对于散列集有所改进。树集是一个<strong>有序集合</strong>（<code>sorted collection</code>）。树集的排序是用一个<strong>树</strong>数据结构完成的（目前实现使用的是<strong>红黑树</strong>（<code>red-black tree</code>））</p>
<blockquote>
<p>要使用树集，必须能够比较元素，这些元素必须实现<code>Comparable</code>接口，或者构造集必须提供一个<code>Comparator</code>。</p>
</blockquote>
<h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p><strong>优先队列</strong>（<code>priority queue</code>）中的元素可以按照任意的顺序插入，但会按照有序的顺序进行检索。也就是说，无论何时调用<code>remove</code>方法，总会获得优先队列中最小的元素。这里优先队列并没有对所有元素进行排序，是因为优先队列使用了一个精巧且高效的数据结构，称为堆（<code>heap</code>）。堆是一个 可以自组织的二叉树，其添加（<code>add</code>）和删除（<code>remove</code>）操作可以让最小的元素移动到根，而不必花费时间对元素进行排序。</p>
<p>优先队列的典型用法是<strong>任务调度</strong>。</p>
<blockquote>
<p>和树集一样，要使用优先队列，必须能够比较元素，这些元素必须实现<code>Comparable</code>接口，或者构造集必须提供一个<code>Comparator</code>。</p>
</blockquote>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>映射用来存放键/值对，如果提供了键，就能够查找到值。</p>
<h4 id="基本映射操作"><a href="#基本映射操作" class="headerlink" title="基本映射操作"></a>基本映射操作</h4><p><code>Java</code>类库为映射提供了两个通用的实现：<code>HashMap</code>和<code>TreeMap</code>。这两个类都实现了<code>Map</code>接口。</p>
<p>散列映射对键进行散列，树映射根据键的顺序将元素组织为一个搜索树。散列或比较函数只应用于键，与键关联的值不进行散列或比较。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// HashMap implements Map</span>
<span class="token keyword">var</span> harry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

staff<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"23"</span><span class="token punctuation">,</span> harry<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// put() 保存值，只保存最近存储的值</span>

<span class="token class-name">Employee</span> e <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"23"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// gets harry</span>

<span class="token comment">// 迭代处理映射的键和值， 使用方法 forEach</span>
staff<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"key"</span> <span class="token operator">+</span> k <span class="token operator">+</span> <span class="token string">", value="</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="映射试图"><a href="#映射试图" class="headerlink" title="映射试图"></a>映射试图</h4><p>集合框架不认为映射本身是一个集合。（其他数据结构框架认为映射是一个键/值对集合，或者是按键索引的值集合）不过，可以得到映射的<strong>视图</strong>（<code>view</code>）——这是实现了Collection接口或某个子接口的对象。</p>
<p>有3种视图：键集、值集合（不是一个集）以及键/值对集。键和键/值对可以构成一个集，应为映射中一个键值能有一个副本：</p>
<ul>
<li><code>Set&lt;K&gt; keySet()</code> <strong>键集</strong></li>
<li><code>Collection&lt;V&gt; values()</code> <strong>值集</strong></li>
<li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> <strong>键/值对集</strong></li>
</ul>
<p>会分别返回这3个视图。（映射条目集的元素是实现了<code>Map.Entry</code>接口的类的对象）</p>
<h4 id="链接散列集与映射"><a href="#链接散列集与映射" class="headerlink" title="链接散列集与映射"></a>链接散列集与映射</h4><p><code>LinkedHashSet</code>和<code>LinkedHashMap</code>类会记住插入元素项的顺序。这样就可以避免散列表中的项看起来顺序是随机的。在表中插入元素项时，就会并入到双向列表中，如下图：</p>
<img src="/2022/06/28/cs-languages/core-java-volume-0/linked_set_map.png" class="" title="linked_set_map">

<p>链表散列映射可以使用<strong>访问顺序</strong>而不是插入顺序来迭代处理映射条目。每次调用<code>get</code>或<code>put</code>时，收到影响的项将从当前的位置删除，并放到项链表的尾部（只影响项在链表中的位置，而散列表的桶不会受影响。映射条目总是在键散列码对应的桶中）。要构造这样一个散列映射，需要调用：</p>
<p><code>LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, true)</code></p>
<p>访问顺序对于实现缓存的“<strong>最近最少使用</strong>”原则十分重要。</p>
<h4 id="枚举集与映射"><a href="#枚举集与映射" class="headerlink" title="枚举集与映射"></a>枚举集与映射</h4><p><code>EnumSet</code>是一个枚举类型元素集的高效实现。由于枚举类型只有有限个实例，所以<code>EnumSet</code>内部用位序列实现。如果对应的值在集中，则相应的位被置为<code>1</code>。</p>
<p><code>EnumSet</code>类没有公共的构造器。要使用静态工厂方法构造这个集：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">enum</span> <span class="token class-name">Weekday</span> <span class="token punctuation">{</span> MONDAY<span class="token punctuation">,</span> TUESDAY<span class="token punctuation">,</span> WEDNESDAY<span class="token punctuation">,</span> THUSDAY<span class="token punctuation">,</span> FRIDAY<span class="token punctuation">,</span> SATURDAY<span class="token punctuation">,</span> SUNDAY<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Weekday</span><span class="token punctuation">&gt;</span></span> always <span class="token operator">=</span> <span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span><span class="token class-name">Weekday</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Weekday</span><span class="token punctuation">&gt;</span></span> never <span class="token operator">=</span> <span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">noneOf</span><span class="token punctuation">(</span><span class="token class-name">Weekday</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Weekday</span><span class="token punctuation">&gt;</span></span> workday <span class="token operator">=</span> <span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token class-name">Weekday</span><span class="token punctuation">.</span>MONDAY<span class="token punctuation">,</span> <span class="token class-name">Weekday</span><span class="token punctuation">.</span>FRIDAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Weekday</span><span class="token punctuation">&gt;</span></span> mwf <span class="token operator">=</span> <span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token class-name">Weekday</span><span class="token punctuation">.</span>MONDAY<span class="token punctuation">,</span> <span class="token class-name">Weekday</span><span class="token punctuation">.</span>WEDNESDAY<span class="token punctuation">,</span> <span class="token class-name">Weekday</span><span class="token punctuation">.</span>FRIDAY<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以使用<code>Set</code>接口的常用方法来修饰<code>EnumSet</code>。</p>
<p><code>EnumMap</code>是一个<strong>键类型</strong>为枚举类型的映射。可以高效地实现为一个值数组。</p>
<h4 id="标识散列映射"><a href="#标识散列映射" class="headerlink" title="标识散列映射"></a>标识散列映射</h4><p>类<code>IdentityHashMap</code>，键的散列值不是用<code>hashCode</code>函数计算的，而是用<code>System.identityHashCode</code>方法计算的。这是<code>Object.hashCode</code>根据对象的内存地址计算散列码时所使用的方法。而且，**在对两个对象进行比较时，<code>IdentityHashMap</code>类使用<code>==</code>**，而不使用<code>equals</code>。</p>
<blockquote>
<p>即，保存的键值即使内容相同，但是不是同一个对象（即内存地址相同）会被视为两个不同的键值。两个值相同但是不是同一个对象的键再添加时，不会相互产生值的覆盖。</p>
</blockquote>
<p>也就是说，<strong>不同的键对象即使内容相同，也被视为不同的对象</strong>。在实现对象遍历算法（如对象串行化）时，这个类非常有用，可以用来跟踪哪些对象已经遍历过。</p>
<h4 id="属性映射"><a href="#属性映射" class="headerlink" title="属性映射"></a>属性映射</h4><p> 属性映射（property map）是一个特殊类型的映射结构，有2个特性：</p>
<ul>
<li>键与值都是字符串。</li>
<li>这个映射可以很容地保存到文件以及从文件加载。</li>
<li>有一个二级表存放默认值。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> settings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
settings<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"width"</span><span class="token punctuation">,</span> <span class="token string">"600.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
settings<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"filename"</span><span class="token punctuation">,</span> <span class="token string">"/home/qing/books/core_java/code/raven.html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>可以使用store方法将属性映射列表保存到一个文件中：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"program.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 第二个参数是包含在这个文件中的注释</span>
<span class="token class-name">Settings</span><span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"Program Properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>示例如下：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#Program Properties</span>
<span class="token comment">#Sun Mar 12 17:47:54 CST 2023</span>
<span class="token attr-name">top</span><span class="token punctuation">=</span><span class="token attr-value">227.0</span>
<span class="token attr-name">left</span><span class="token punctuation">=</span><span class="token attr-value">1286.0</span>
<span class="token attr-name">width</span><span class="token punctuation">=</span><span class="token attr-value">423.0</span>
<span class="token attr-name">height</span><span class="token punctuation">=</span><span class="token attr-value">547.0</span>
<span class="token attr-name">filename</span><span class="token punctuation">=</span><span class="token attr-value">/home/qing/books/core_java/code/raven.html</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>要从文件加载属性，可以使用以下调用：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"program.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
settings<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>Properties类有两种提供默认值的机制：</p>
<ol>
<li><p>查找一个字符串的值，可以指定一个默认值，这样当键不存在时就会自动使用这个默认值。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> filename <span class="token operator">=</span> settings<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"filename"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>可以把所有默认值都放在一个二级属性映射中，并在主属性映射的构造器中提供这个二级映射。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> defaultSettings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
defaultSettings<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"width"</span><span class="token punctuation">,</span> <span class="token string">"600"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
defaultSettings<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"height"</span><span class="token punctuation">,</span> <span class="token string">"400"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
defaultSettings<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span>filename<span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用默认值初始化主属性映射</span>
<span class="token keyword">var</span> settings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span>defaultSettings<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="视图和包装器"><a href="#视图和包装器" class="headerlink" title="视图和包装器"></a>视图和包装器</h3><p><strong>视图</strong>（<code>view</code>）获得其他实现了<code>Collection</code>接口或<code>Map</code>接口的对象。<code>keySet</code>方法就是这样的一个应用例子。<code>keySet</code>方法返回一个实现了Set接口的类对象，由这个类的方法操纵原映射。这种集合称为<strong>视图</strong>。</p>
<h4 id="小集合"><a href="#小集合" class="headerlink" title="小集合"></a>小集合</h4><p><code>Java9</code>引入了一些静态方法，可以生成给定元素的集和列表，已经给定键/值对的映射：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> names <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Peter"</span><span class="token punctuation">,</span> <span class="token string">"Pual"</span><span class="token punctuation">,</span> <span class="token string">"Mary"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numbers <span class="token operator">=</span> <span class="token class-name">Set</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> scores <span class="token operator">=</span> <span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Peter"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Pual"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Mary"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这些集合对象时<strong>不可修改</strong>的。如果试图修改，会导致一个<code>UnsupportedOperationException</code>异常。</p>
<blockquote>
<p><code>Java9</code>之前由一个静态方法<code>Arrays.asList</code>，返回一个可更改但是大小不可变的列表。</p>
<p>另外还有遗留的方法<code>Collections.emptySet</code>和<code>Collections.singleton</code>。</p>
<p><code>Collections</code>类包含很多实用方法，这些方法的参数和返回值都是集合。注意与<code>Collection</code>接口区分。</p>
</blockquote>
<h4 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h4><p>可以为很多集合建立子范围（<code>subrange</code>）视图。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> group2 <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中第一个索引包含在子列表中，第二个索引不包含在内（<strong>左闭右开</strong>截取）。可以对子范围应用任何操作，而且操作会自动反映到整个列表。</p>
<h4 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h4><p><code>Collections</code>类可以生成集合的不可修改视图（<code>unmodifiable view</code>）。这些视图对现有集合增加一个运行时检查，如果发现试图对集合进行修改，就会抛出一个异常，集合仍保持不变。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 主要是这8个方法</span>
<span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableCollection<span class="token punctuation">;</span>
<span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableList<span class="token punctuation">;</span>
<span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableSet<span class="token punctuation">;</span>
<span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableSortedSet<span class="token punctuation">;</span>
<span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableNavigableSet<span class="token punctuation">;</span>
<span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableMap<span class="token punctuation">;</span>
<span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableSortedMap<span class="token punctuation">;</span>
<span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableNavigableMap<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例如，假设想要让某些代码查看但不能修改一个集合的内容，就可以进行以下操作：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">lookAt</span><span class="token punctuation">(</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableList</span><span class="token punctuation">(</span>staff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 之后，在lookAt中对于传递的集合不能进行修改操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h4><p>如果从多个线程访问集合，就必须确保集合不会被意外地破坏。此时，就可以使用试图机制来确保常规集合时线程安全的，对于没有实现线程安全的集合类，就饿可以使用<code>Collections.synchronizedMap</code>方法来将任何一个映射转换成由同步访问方法的Map。</p>
<h4 id="检查型视图"><a href="#检查型视图" class="headerlink" title="检查型视图"></a>检查型视图</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> safeStrings <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">checkedList</span><span class="token punctuation">(</span>strings<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个视图的<code>add</code>方法将检查插入的对象是否属于给定的类，如果不属于给定的类，就立即抛出一个<code>ClassCastException</code>。</p>
<blockquote>
<p>检查型视图受限于虚拟机可以完成的运行时检查。例如，对于<code>ArrayList&lt;Pair&lt;String&gt;&gt;</code>，由于虚拟机有一个“原始”<code>Pair</code>类，所以无法阻止插入<code>Pair&lt;Date&gt;</code>。</p>
</blockquote>
<h2 id="图形用户界面程序设计"><a href="#图形用户界面程序设计" class="headerlink" title="图形用户界面程序设计"></a>图形用户界面程序设计</h2><p>暂略</p>
<h2 id="Swing用户界面组件"><a href="#Swing用户界面组件" class="headerlink" title="Swing用户界面组件"></a><code>Swing</code>用户界面组件</h2><p>暂略</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>每个任务在一个线程（thread）中执行，线程是控制线程的简称。如果一个程序可以同时运行多个线程，则称这个程序是多线程的（multithreaded）。</p>
<p>多进程与多线程的本质区别在于每个进程都拥有自己的一套变量，而线程则共享数据。共享变量使线程之间的通信比进程之间的通信更有效、更容易。此外，在有些操作系统中，与进程相比较，线程更“轻量级”，创建、撤销一个线程比启动新进程的开销要小得多。</p>
<h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><ol>
<li><p>将执行这个任务的代码放在一个类的<code>run</code>方法中，这个类要实现<code>Runnable</code>接口。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// task code;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>从这个<code>Runnable</code>构造一个<code>Thread</code>对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>启动线程</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<p>这里的<code>Thread</code>就是创建了一个单独的线程去处理任务。线程之间是可以并发运行的。</p>
<blockquote>
<p>还可以通过建立<code>Thread</code>类的一个子类来定义线程，如下所示：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// task code</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后可以构造这个子类的一个对象，并调用它的<code>start</code>方法。不过，现在不在推荐这种方法。</p>
</blockquote>
<blockquote>
<p><strong>警告</strong>：不要调用<code>Thread</code>类或<code>Runnable</code>对象的run方法。直接调用<code>run</code>方法只会在同一个线程中执行这个任务——而没有启动新的线程。实际上，应当调用<code>Thread.start</code>方法，这会创建一个执行<code>run</code>方法的新线程。</p>
</blockquote>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>线程有如下6个状态：</p>
<ul>
<li><code>New</code>（新建）</li>
<li><code>Runnable</code>（可运行）</li>
<li><code>Blocked</code>（阻塞）</li>
<li><code>Waiting</code>（等待）</li>
<li><code>Timed waiting</code>（计时等待）</li>
<li><code>Terminated</code>（终止）</li>
</ul>
<p>如果要确定一个线程的当前状态，只需要调用<code>getState</code>方法。</p>
<h4 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h4><p>当用new操作符创建一个新线程时，如<code>new Thread(r)</code>，这个线程还没有开始运行。这意味着它的状态是新建（<code>new</code>）。当一个线程处于新建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。</p>
<h4 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h4><p>一旦调用<code>start</code>方法，线程就处于<strong>可运行</strong>（<code>runnable</code>）状态。一个可运行的线程可能长在运行也可能没有运行。要由操作系统为线程提供具体的运行时间。</p>
<p>一旦<strong>一个线程开始运行，它不一定始终保持运行。事实上，运行中的线程有时需要暂停，让其他线程有机会运行</strong>。线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每个可运行线程一个时间片来执行任务。当时间片用完时，操作系统<strong>剥夺</strong>该线程的运行权，并给另一个线程一个机会来运行。当选择下一个线程时，操作系统会考虑线程的优先级。</p>
<p>现在所有的桌面以及服务器操作系统都是用<strong>抢占式调度</strong>。但是，想手机这样的小型设备可能使用<strong>协作式调度</strong>。在这样的设备中，一个线程只能在调用<code>yield</code>方法或者被阻塞或等待时才是去控制权。</p>
<p>在有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当然，如果线程的数目多于处理的数目，调度器还是需要分配时间片的。</p>
<p><strong>在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行（正是因为这样，这个状态称为“可运行”而不是“运行”）</strong></p>
<h4 id="阻塞和等待状态"><a href="#阻塞和等待状态" class="headerlink" title="阻塞和等待状态"></a>阻塞和等待状态</h4><p>当线程处于阻塞或等待状态时，它暂时是不活动的。阻塞的造成原因可能如下</p>
<ul>
<li>当一个线程试图获取一个内部的对象锁（这里的锁并不是指 <code>java.util.concurrent</code> 库中的<code>Lock</code>），而这个锁目前被其他线程占有，该线程就会被阻塞。当所有其他线程都释放了这个锁，并且线程调度器允许该线程持有这个锁时，它将变成非阻塞状态。</li>
<li>当线程等待另一个线程通知调度器出现一个条件时，这个线程会进入等待状态。阻塞状态与等待状态并没有太大的区别</li>
<li>有几个方法有超时参数，调用这些方法会让线程进入计时等待（<code>time waiting</code>）状态。</li>
</ul>
<p>线程在获得可运行的“状态”后，根据优先级来判断是否可以抢占正在运行的线程的运行权。</p>
<img src="/2022/06/28/cs-languages/core-java-volume-0/thread_state.png" class="" title="thread_state">

<h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><p>线程会由于以下两个原因之一而终止：</p>
<ul>
<li><code>run</code> 方法正常退出，线程自然终止</li>
<li>因为一个没有捕获的异常终止了<code>run</code>方法，使线程意外终止。</li>
</ul>
<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><h4 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h4><p>当线程的<code>run</code>方法执行方法体中最后一条语句后在执行<code>return</code>语句<strong>返回时</strong>，或者出现了方法中<strong>没有捕获的异常时</strong>，线程将终止。</p>
<p>还可以通过<code>interrupt</code>方法来<strong>请求终止</strong>一个线程，这时候会设置线程的<strong>中断状态</strong>。这是每个线程都有的<code>boolean</code>标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断。</p>
<p>如何检查这个中断状态呢？首先调用静态的<code>Thread.currentThread</code>方法获得当前线程，然后调用<code>isInterrupted</code>方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> more work <span class="token keyword">to</span> <span class="token keyword">do</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do more work</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>但是，如果线程被阻塞，就无法检查中断状态。这里就需要使用<code>InterruptedException</code>异常。当在一个被<code>sleep</code>或<code>wait</code>调用阻塞的线程上调用<code>interrupt</code>方法时，那个阻塞调用（即<code>sleep</code>或<code>wait</code>调用）将被一个<code>InterruptedException</code>异常中断。（有一些阻塞<code>I/O</code>调用不能被中断，对此应该考虑选择可中断的调用）</p>
<p><strong>常用的模板思路如下</strong>：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1. 检查中断标志位</span>
             <span class="token comment">// &amp;&amp; more work to do  </span>
             <span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 2. 检查中断异常</span>
        <span class="token comment">// thread was interrupted during sleep or wait</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// cleanup, if required</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// exiting the run method terminates the thread</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果在每次工作迭代之后都调用<code>sleep</code>方法（或者其他可中断方法），<code>isInterrupted</code>检查既没有必要也没有用处。如果设置了中断状态，此时倘若调用<code>sleep</code>方法，它不会休眠。实际上，它会清除中断状态并抛出<code>InterruptedException</code>。因此，使用循环调用了<code>sleep</code>，就不要检测中断状态，而应当捕获<code>InterruptedException</code>异常。如下所示：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>
             <span class="token comment">// &amp;&amp; more work to do  </span>
             <span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 检查中断异常</span>
        <span class="token comment">// thread was interrupted during sleep or wait</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// cleanup, if required</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// exiting the run method terminates the thread</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>在这里有两个非常类似的方法，<code>interrupted</code>和<code>isInterrupted</code>。</p>
<p><code>interrupted</code>方法时一个静态方法，它检查<strong>当前线程是否被中断</strong>。而且，调用<code>interrupted</code>方法<strong>会清除该线程中的中断状态</strong>。</p>
<p>另一方面，<code>isInterrupted</code>方法时一个实例方法，可以用来<strong>检查是否有线程被中断</strong>。调用这个方法<strong>不会改变中断状态</strong>。</p>
</blockquote>
<p>如果，在处理中想不出在catch子句中可以做什么有意义的工作，可以将其抛出：</p>
<ul>
<li>```java<br>void mySubTask() {<br>// …<br>try {<br>    sleep(delay);<br>} catch (InterruptedException e) {<br>    Thread.currentThread().interrupt(); // 设置中断状态，这样一来调用者就可以检测中断状态<br>}<br>// …<br>}<pre class="line-numbers language-none"><code class="language-none">
+ ```java
  void mySubtask() throws InterruptedException { // 标记抛出异常，提供给调用者去处理
      // ...
      sleep(delay) 
      // ...
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将这个线程转换为守护线程（daemon thread）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>守护线程为其他线程提供服务。</p>
<h4 id="线程名"><a href="#线程名" class="headerlink" title="线程名"></a>线程名</h4><p>默认情况下，线程有容易记的名字，如 Thread-2。同时也可以使用setName方法为线程设置任何名字：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"Web crawler"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在线程转储时可能很有用。</p>
<h4 id="未捕获异常的处理器"><a href="#未捕获异常的处理器" class="headerlink" title="未捕获异常的处理器"></a>未捕获异常的处理器</h4><p>线程的<code>run</code>方法不能抛出任何检查型异常，但是，非检查型异常可能会导致线程终止。这种情况下，线程会死亡。</p>
<p>不过，对于可以传播的异常，并没有任何<code>catch</code>子句。实际上，在线程死亡之前，异常会传递到一个用于处理未捕获异常的处理器。</p>
<p>这个处理器必须属于一个实现了<code>Thread.UncaughtExceptionaHandler</code>接口的类。这个接口只有一个方法 </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">uncaughtExctption</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> e<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>单一：可以用<code>setUncaughtExctptionHandler</code>方法为<strong>任何线程安装一个处理器</strong>。</p>
<p>全局：也可以用<code>Thread</code>类的静态方法<code>setDefaultUncaughtExctptionHandler</code>为<strong>所有线程安装一个默认的处理器</strong>。</p>
<p>如果没有安装默认处理器，默认处理器则是<code>null</code>。但是，如果没有为单个线程安装处理器，那么处理器就是该线程的<code>ThreadGroup</code>对象。</p>
<p><code>ThreadGroup</code>类实现了<code>Thread.UncaughtExceptionHandler</code>接口。它的<code>uncaughtException</code>方法执行以下操作：</p>
<ol>
<li>如果该线程组有父线程组，那么调用父线程组的<code>uncaughtException</code>方法。</li>
<li>否则，如果<code>Thread.UncaughtExceptionaHandler</code>方法返回一个非<code>null</code>的处理器，则调用该处理器。</li>
<li>否则，如果<code>Throwble</code>是<code>ThreadDeath</code>的一个实例，什么都不做。</li>
<li>否则，将线程的名字以及<code>Throwable</code>的栈轨迹输出到<code>System.err</code>。</li>
</ol>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>在<code>Java</code>中，每一个线程都有一个优先级。默认一个线程会继承构造它的那个线程的优先级。可以用<code>setPriority</code>方法提高或降低任何一个线程的优先级。可以将优先级设置为<code>MIN_PRIORITY</code>（在<code>Thread</code>类中定义为1）与<code>MAX_PRIORITY</code>（定义为10）之间的任何值。<code>NORM_PRIORITY</code>定义为5、</p>
<p>线程调度器有机会选择新线程时，首先选择具有较高优先级的线程。但是，<strong>线程优先级高度依赖于系统</strong>。</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>竟态条件（<code>race condition</code>）。主要就是数据同步问题。</p>
<h4 id="竟态条件的一个例子"><a href="#竟态条件的一个例子" class="headerlink" title="竟态条件的一个例子"></a>竟态条件的一个例子</h4><p>为了避免多线程破坏共享数据，必须学习如何同步存取。使用一个模拟银行交易的例子来说明。</p>
<p>这里要随机地选择从哪个源账户转账到哪个目标账户：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// CAUTION: unsafe when called from multiple threads</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    accounts<span class="token punctuation">[</span>from<span class="token punctuation">]</span> <span class="token operator">-=</span> amount<span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" %10.2f from %d to %d"</span><span class="token punctuation">,</span> amount<span class="token punctuation">,</span> from<span class="token punctuation">,</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    accounts<span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" Total Blance: %10.2f%n"</span><span class="token punctuation">,</span> <span class="token function">getTotalBlance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面时<code>Runnable</code>实例的代码。<code>run</code>方法不断地从一个给定银行账户取钱。在每次迭代中，<code>run</code>方法选择一个随机的目标账户和一个随机金额，调用<code>bank</code>对象的<code>tranfer</code>方法，然后休眠。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> toAccount <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>bank<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">double</span> amount <span class="token operator">=</span> MAX_AMOUNT <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            bank<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>fromAccount<span class="token punctuation">,</span> toAccount<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>DELAY <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个模拟程序运行是，不清楚在某一时刻某个银行账户中有多少钱，但是我们知道所有账户的总金额应该保持不变，因为我们所做的只是把钱从一个账户转移到另一个账号。</p>
<p>每一次交易结束时，<code>transfer</code>方法会重新计算总金额并打印出来。</p>
<p>这个程序永远不会结束。只能按<code>CTRL+C</code>来终止程序。</p>
<p>下面时典型的输出：</p>
<pre class="line-numbers language-log" data-language="log"><code class="language-log">Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>	<span class="token number">588.23</span> from <span class="token number">11</span> to <span class="token number">44</span> Total Balance<span class="token operator">:</span>		<span class="token number">100000.00</span>
Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>	<span class="token number">684.24</span> from <span class="token number">15</span> to <span class="token number">34</span> Total Balance<span class="token operator">:</span>		<span class="token number">100000.00</span>
Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>	<span class="token number">578.73</span> from <span class="token number">21</span> to <span class="token number">51</span> Total Balance<span class="token operator">:</span>		<span class="token number">100000.00</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>	<span class="token number">288.23</span> from <span class="token number">13</span> to <span class="token number">14</span> Total Balance<span class="token operator">:</span>		<span class="token number">90200.03</span>
Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>	<span class="token number">583.23</span> from <span class="token number">31</span> to <span class="token number">24</span> Total Balance<span class="token operator">:</span>		<span class="token number">90200.03</span>
Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>	<span class="token number">988.23</span> from <span class="token number">51</span> to <span class="token number">45</span> Total Balance<span class="token operator">:</span>		<span class="token number">90200.03</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，这里出现了错误。对于最初的几次交易，银行余额保持在100000，这是正确的，因为共1000个账户，每个账户1000。不过，经过一段时间后，余额有轻微的变化。运行这个程序的时候，可能很快就能发现出错了，有时可能需要很长的时间才能发现余额不对。</p>
<p>完整的示例代码如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * A bank with a number of bank accounts.
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bank</span>
<span class="token punctuation">{</span>
   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> accounts<span class="token punctuation">;</span>

   <span class="token comment">/**
    * Constructs the bank.
    * @param n the number of accounts
    * @param initialBalance the initial balance for each account
    */</span>
   <span class="token keyword">public</span> <span class="token class-name">Bank</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> initialBalance<span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
      accounts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>accounts<span class="token punctuation">,</span> initialBalance<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token comment">/**
    * Transfers money from one account to another.
    * @param from the account to transfer from
    * @param to the account to transfer to
    * @param amount the amount to transfer
    */</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>accounts<span class="token punctuation">[</span>from<span class="token punctuation">]</span> <span class="token operator">&lt;</span> amount<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      accounts<span class="token punctuation">[</span>from<span class="token punctuation">]</span> <span class="token operator">-=</span> amount<span class="token punctuation">;</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %10.2f from %d to %d"</span><span class="token punctuation">,</span> amount<span class="token punctuation">,</span> from<span class="token punctuation">,</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      accounts<span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" Total Balance: %10.2f%n"</span><span class="token punctuation">,</span> <span class="token function">getTotalBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token comment">/**
    * Gets the sum of all account balances.
    * @return the total balance
    */</span>
   <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getTotalBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
      <span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">double</span> a <span class="token operator">:</span> accounts<span class="token punctuation">)</span>
         sum <span class="token operator">+=</span> a<span class="token punctuation">;</span>

      <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token comment">/**
    * Gets the number of accounts in the bank.
    * @return the number of accounts
    */</span>
   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
      <span class="token keyword">return</span> accounts<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * This program shows data corruption when multiple threads access a data structure.
 * @version 1.32 2018-04-10
 * @author Cay Horstmann
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnsynchBankTest</span>
<span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NACCOUNTS <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">double</span> INITIAL_BALANCE <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">double</span> MAX_AMOUNT <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DELAY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
   
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
      <span class="token keyword">var</span> bank <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bank</span><span class="token punctuation">(</span>NACCOUNTS<span class="token punctuation">,</span> INITIAL_BALANCE<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NACCOUNTS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
         <span class="token keyword">int</span> fromAccount <span class="token operator">=</span> i<span class="token punctuation">;</span>
         <span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span>
            <span class="token punctuation">{</span>
               <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
               <span class="token punctuation">{</span>
                  <span class="token keyword">int</span> toAccount <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>bank<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token keyword">double</span> amount <span class="token operator">=</span> MAX_AMOUNT <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  bank<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>fromAccount<span class="token punctuation">,</span> toAccount<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>DELAY <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
            <span class="token punctuation">}</span>            
         <span class="token punctuation">}</span><span class="token punctuation">;</span>
         <span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
         t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="竟态条件详解"><a href="#竟态条件详解" class="headerlink" title="竟态条件详解"></a>竟态条件详解</h4><p>上一节运行了一个程序，其中有几个线程会更新银行银行余额。一段时间之后，不知不觉地出现了错误，可能有些钱会丢失，也可能几个账户同时有钱进账。当两个线程试图同时更新同一个账户时，就会出现这个问题。假设两个线程同时执行指令</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">accounts<span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>问题在于这不是原子操作哦。这个指令可能如下处理：</p>
<ol>
<li>将<code>accounts[to]</code>加载到寄存器。</li>
<li>增加<code>amount</code>。</li>
<li>将结果写回<code>accounts[to]</code>。</li>
</ol>
<p>现在，假定第1个线程执行步骤1和步骤2，然后，它的运行权被抢占。在假设第2个线程被唤醒，更新<code>account</code>数组中的同一个元素。然后，第1个线程被唤醒并完成其第3步。</p>
<p>这个动作会抹除第2个线程所作的更新。这样一来，总金额就不再正确了。如下图</p>
<img src="/2022/06/28/cs-languages/core-java-volume-0/transfer_thread_00.png" class="" title="transfer_thread_00">

<blockquote>
<p>实际上可以查看执行这个类中每一个语句的虚拟机字节码。运行以下命令</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">javap <span class="token operator">-</span>c <span class="token operator">-</span>v <span class="token class-name">Bank</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>对Bank.class文件进行反编译。例如，代码行</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">accounts<span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>会转换为下面的字节码：</p>
<pre class="line-numbers language-ABAP" data-language="ABAP"><code class="language-ABAP">aload_0
getfield	#2 // Field accounts:[D
iload_2
dup2
daload
dload_3
dadd
dastore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这些代码的含义无关紧要。重要的是这个增加命令是由多条指令组成的，执行这些指令的线程可以在任何一条指令上被中断。</p>
</blockquote>
<p>在一个有多个核心的现代处理器上，出问题的风险相当高。</p>
<p>如果能够确保线程失去控制之前方法已经运行完成，那么银行账户对象的状态就不会被破坏。</p>
<h4 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h4><p>有两种机制可以防止并发访问代码块。<code>Java</code>语言提供了一个<code>synchronized</code>关键词来达到这一目的，另外<code>Java 5</code>引入了<code>ReentrantLock</code>类。 <code>synchronized</code>关键字会自动提供一个锁以及相关的“条件”，对于大多数需要显示锁的情况，这种机制功能很强大，也很便利。</p>
<p>用<code>ReentrantLock</code>保护代码块的基本结构如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">myLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// a ReentrantLock object</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// critical section</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    myLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// make sure the lock is unlocked even if an exception is thrown</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个结构确保<strong>任何时刻只有一个线程进入临界区。一旦一个线程锁定了锁对象，其他任何线程都无法通过<code>lock</code>语句</strong>。当其他线程调用<code>lock</code>时，它们会暂停，知道第一个线程释放这个锁对象。</p>
<blockquote>
<p><strong>警告</strong>：<strong>要把unlock操作包括在finally子句中，这一点至关重要</strong>。如果在临界区的代码抛出一个异常，锁必须释放。否则，其他线程将永远阻塞。</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：<strong>使用锁时，就不能使用<code>try-with-resources</code>语句</strong>。首先，解锁方法名不是<code>close</code>。不过，即使将它重命名，<code>try-with-resources</code>语句也无法正常工作。它的首部希望声明一个新变量。但是如果使用一个锁，你可能想使用多个线程共享那个变量（而不是新变量）。</p>
</blockquote>
<p>非同步线程与同步线程的比较</p>
<img src="/2022/06/28/cs-languages/core-java-volume-0/transfer_thread_01.png" class="" title="transfer_thread_01">

<p>注意每个<code>Bank</code>对象都有自己的<code>ReentrantLock</code>对象。如果两个线程试图访问同一个<code>Bank</code>对象，那么锁可以用来保证串行化访问。不过，如果两个线程访问不同的<code>Bank</code>对象，每个线程会得到不同的锁对象，两个线程都不会阻塞。本应该如此，因为线程在操纵不同的<code>Bank</code>实例时，线程之间不会相互影响。</p>
<p>这个锁称为<strong>重入（<code>reentrant</code>）锁</strong>，因为线程可以反复获得已拥有的锁。锁有一个<strong>持有计数</strong>（<code>hold count</code>）来跟踪对<code>lock</code>方法的嵌套调用。线程每一次调用lock后都要调用<code>unlock</code>来释放锁。由于这个特性，被一个锁保护的代码可以调用另一个使用相同锁的方法。</p>
<blockquote>
<p><strong>警告</strong>：要注意确保临界区中的代码不要因为抛出异常而跳出临界区。如果在临界区代码结束之前抛出了异常，<code>finally</code>子句将释放锁，但是对象可能处于被破坏的状态。</p>
</blockquote>
<h4 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h4><p>通常，线程进入临界区后却发现只有满足了某个条件之后它才能执行。可以使用一个<strong>条件对象</strong>来管理那些已经获得了一个锁却不能做有用工作的线程。在这一节里，将会介绍Java库中条件对象的实现（由于历史原因，条件对象经常被称为条件变量（<code>confitional variable</code>））。</p>
<p>如下所示，假定只有当账户中的金额大于要转出的金额时才可以转账。如果某个线程刚刚获得对<code>bankLock</code>的<strong>排他性访问权</strong>，如果此时账户中资金不足，则无法完成转账操作，但是又因为锁的存在，别的线程没有存款的机会，这里就会产生死锁问题，这种情况下就可以引入条件对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Bank</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Confition</span> sufficientFunds<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">public</span> <span class="token class-name">Bank</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
        sufficientFunds <span class="token operator">=</span> bankLock<span class="token punctuation">.</span><span class="token function">newConfition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建条件对象来表示“资金充足”条件。</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果transfer方法发现资金不足，就会调用</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">sufficientFuns<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>当前线程现在暂停，并放弃锁。这就允许另一个线程执行</strong>，来增加账户余额。</p>
<p>一旦一个线程调用了await方法，它就会进入这个条件的等待集（wait set）。当锁可用时，该线程并不会变为可运行状态。实际上，它仍保持非活动那个状态，直到另一个线程在同一条件上调用signalAll方法。当另外一个线程完成转账时，它应该调用</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">sufficientFunds<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 启动所有的等待线程</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个调用会重新激活等待这个条件的所有线程。当这些线程从等待集中移出时，它们再次成为可运行的线程，调度器最终将再次将它们激活。同时，它们会尝试重新进入该对象。一旦锁可用，它们中的某个线程将从<code>await</code>调用返回，得到这个锁，<strong>并从之前暂停的地方继续执行</strong>。</p>
<p><code>signalAll</code>方法仅仅时通知等待的线程：现在<strong>有可能</strong>满足条件，值得再次检查条件。</p>
<blockquote>
<p><strong>注释</strong>：t通常，await调用应该放在如下形式的循环中</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>OK <span class="token keyword">to</span> <span class="token namespace">proceed</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>当一个线程调用<code>await</code>时，它没有办法重新自行激活。它寄希望于其他线程。如果没有其他线程来重新激活等待的线程，它就永远不再运行了。这将导致<strong>死锁</strong>（<code>deadlock</code>）现象。如果所有其他线程都被阻塞，最后一个活动线程调用了<code>await</code>方法但没有先解除另外某个线程的阻塞，现在这个线程也会阻塞。此时没有线程可以解除其他线程的阻塞状态，程序会永远挂起<strong>。所以至关重要的一点，最终必须要有某个其他线程调用<code>signalAll</code>方法激活线程</strong>。</p>
<p>注意<code>signalAll</code>调用<strong>不会立即激活一个等待的线程</strong>。它姿势解除等待线程的阻塞，使这些线程可以在当前线程释放锁之后竞争访问对象。</p>
<p>当然也可以调用<code>signal</code>只是随机选择等待集中的一个线程解锁，但是如果被解锁的线程仍旧不能运行，它就会被再次阻塞。如果此时没有其他线程再次调用<code>signal</code>，系统就会进入死锁。</p>
<blockquote>
<p><strong>警告</strong>：只有当线程拥有一个条件的锁时，它才能在这个条件上调用<code>await</code>、<code>signalAll</code>或<code>signal</code>方法。</p>
</blockquote>
<p>当然加入了以上的控制手段之后，整个程序运行起来要慢一些，这是为了实现同步机制所涉及的额外工作付出的代价。</p>
<h4 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a><code>synchronized</code>关键字</h4><p>在上一个小节，了解了<code>Lock</code>和<code>Condition</code>对象，先对锁和条件的要点做个总结：</p>
<ul>
<li>锁用来保护代码片段，一次只能由一个线程执行被保护的代码。</li>
<li>锁可以管理试图进入被保护代码段的线程。</li>
<li>一个锁可以有一个或多个相关联的条件对象。</li>
<li>每个条件对象管理那些已经进入被保护代码段但还不能运行的线程。</li>
</ul>
<p><code>Java</code>中的<strong>每个对象都有一个内部锁</strong>。如果一个方法声明时有<code>synchronized</code>关键字，那么对象的锁将保护整个方法，也就是要调用这个方法，线程必须获得内部对象锁。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// method body</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>等价于</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>intrinsicLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// method body</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>intrinsicLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><strong>注释</strong>：<code>wait</code>、<code>notifyAll</code>以及<code>notify</code>方法是<code>Object</code>类的<code>final</code>方法。<code>Condition</code>方法必须命名为<code>await</code>、<code>signalAll</code>和<code>signal</code>，从而不会与那些方法发生冲突。</p>
</blockquote>
<p>经静态方法声明为同步也是合法的。如果调用这样的一个方法，它会获得相关类对象的内部锁。</p>
<p>内部锁和条件存在一些限制。包括：</p>
<ul>
<li>不能中断一个正在尝试获得锁的线程。</li>
<li>不能指定尝试获得锁时的超时时间。</li>
<li>每个锁仅有一个条件可能时不够的。</li>
</ul>
<p>对<code>Lock</code>和<code>Condition</code>对象的使用建议：</p>
<ul>
<li>最好既不使用<code>Lock/Condition</code>也不使用<code>synchronized</code>关键字。使用<code>java.util.concurrent</code>包中的某种机制，它会为你处理所有的锁定。例如，使用阻塞队列来同步完成一个共同任务的线程。</li>
<li>如果<code>synchronized</code>关键字适合你的程序，那么尽量使用这种做法，这样可以减少编写的代码量，还能减少出错的概率。</li>
<li>如果特别需要<code>Lock/Condition</code>结构提供的额外能力，则使用<code>Lock/Condition</code></li>
</ul>
<h4 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h4><p>每一个<code>Java</code>对象都有一个锁，线程可以通过调用同步方法获得锁。还有另一种机制可以获得锁：即进入一个同步块。当线程进入如下形式的块时：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// this is the syntax for a synchronized block</span>
    <span class="token comment">// critical section</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>它会获得<code>obj</code>的锁。</p>
<p>有时我们会发现一些“专用”锁，例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bank</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> accounts<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// an ad-hoc lock</span>
            accounts<span class="token punctuation">[</span>from<span class="token punctuation">]</span> <span class="token operator">-=</span> amount<span class="token punctuation">;</span>
            accounts<span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这里，创建<code>lock</code>对象只是为了使用每个<code>Java</code>对象拥有的锁。</p>
<p>使用一个对象的锁来实现额外的原子操作，这种做法称为<strong>客户端锁定</strong>（<code>client-side locking</code>）</p>
<p>但是完全依赖于<code>Bank</code>类对自己的所有更改方法使用内部锁，但是如果开发者没有在文档中标注这些限定，那就需要自己去越多源代码，从这个角度看，<strong>客户端锁定是非常脆弱的，通常不推荐使用</strong>。</p>
<h4 id="监控器"><a href="#监控器" class="headerlink" title="监控器"></a>监控器</h4><p>监控器具有如下特性：</p>
<ul>
<li>监视器是只包含私有字段的类。</li>
<li>监视器类的每个对象有一个关联的锁。</li>
<li>所有方法由这个锁锁定。换句话说，如果客户端调用<code>obj.method()</code>，那么<code>obj</code>对象的锁在方法调用开始时自动获得，并且当方法返回时自动释放该锁。因此所有的字段是私有的，这样的安排可以确保一个线程处理字段时，没有其他线程能够访问这些字段。</li>
<li>锁可以由任意多个相关联的条件。</li>
</ul>
<h4 id="volatile字段"><a href="#volatile字段" class="headerlink" title="volatile字段"></a><code>volatile</code>字段</h4><p><code>volatile</code>关键字为实例字段的同步访问提供了一种免锁机制。如果声明一个字段为<code>volatile</code>，那么编译器和虚拟机就知道该字段可能被另一个线程并发更新。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> done<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> done<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>编译器会插入适当的代码，以确保如果一个线程对done变量做了修改，这个修改对读取这个变量的所有其他线程都可见。</p>
<blockquote>
<p>volatile 变量不能提供原子性。例如，方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">flipDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> done <span class="token operator">=</span> <span class="token operator">!</span>done<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// not atomic</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>不能确保翻转字段中的值。不能保证读取、翻转和写入不被中断。</p>
</blockquote>
<h4 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a><code>final</code>变量</h4><p>还可以考虑使用final声明：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">var</span> accounts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其他线程会在构造器完成构造之后才看到这个<code>accounts</code>变量。</p>
<p>如果不使用<code>final</code>，就不能保证其他线程看到的是<code>accounts</code>更新后的值，它们可能都只是看到<code>null</code>，而不是新构造的<code>HashMap</code>。</p>
<p>当然，<strong>对这个映射的操作并不是线程安全的</strong>。如果有多个线程更改和读取这个映射，仍然需要进行同步。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>假设对共享变量除了赋值之外并不做其他操作，那么可以将这些共享变量声明为<code>volatile</code>。</p>
<p><code>java.util.concurrent.atomic</code>包中很多类使用了很高效的机器级指令（而没有使用锁）来保证其他操作的原子性。例如，<code>AtomicInteger</code>类提供了方法<code>incrementAndGet</code>和<code>decrementAndGet</code>，它们分别以原子方式将一个整数进行自增或自减。</p>
<p>如果有大量线程要访问相同的原子值，性能会大幅下降，因此乐观更新需要太多次重试。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>锁和条件不能解决多线程中可能出现的所有问题，例如：</p>
<ol>
<li>账户1：200</li>
<li>账户2：300</li>
<li>线程1：从账户1转300到账户2</li>
<li>线程2：从账户2转400到账户1</li>
</ol>
<p>如果在线程转账时有条件限定，需要大于转账金额才能转账，则两个线程都会因为要等待更多的钱款存入而导致所有的线程进入<strong>阻塞状态</strong>。这样的状态称为<strong>死锁</strong>（<code>deadlock</code>）</p>
<blockquote>
<p>当程序挂起时，按下 <code>Ctrl + \</code>，将得到一个线程转储，这会累出所有线程。</p>
</blockquote>
<p><strong>遗憾的是，<code>Java</code>编程语言中没有任何东西可以避免或打破这种死锁。必须仔细设计程序，确保不会出现死锁</strong>。</p>
<h4 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h4><p>线程间共享变量存在风险，有时可能要避免共享变量，使用<code>ThreadLocal</code>辅助类为各个线程提供各自的实例。例如，<code>SimpleDateFormat</code>类不是线程安全的。假设有一个静态变量：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">SimpleDateFormat</span> dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果两个线程都执行以下操作：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> dateStamp <span class="token operator">=</span> dateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>结果可能很混乱，因为<code>dateFormat</code>使用的内部数据结构可能会被并发的访问所破坏。当然可以使用同步，但开销很大；或者也可以在需要时构造一个局部<code>SimpleDateFormat</code>对象，不过这样很浪费。</p>
<p>可以考虑为每个线程构造一个实例的方式来避免错误产生：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SimpleDateFormat</span><span class="token punctuation">&gt;</span></span> dateFormat <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用时，使用如下格式：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> dateStamp <span class="token operator">=</span> dateFormat<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这样在给定线程中首次调用<code>get</code>时，会调用构造器中的<code>lambda</code>表达式。在此之后，<code>get</code>方法会返回属于当前线程的那个实例。</p>
<h3 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h3><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，<strong>阻塞队列</strong>（<code>blocking queue</code>）将导致线程阻塞。在协调多个线程之间的合作时，阻塞队列是一个有用的工具。</p>
<p>阻塞队列方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>正常动作</th>
<th>特殊情况下的动作</th>
</tr>
</thead>
<tbody><tr>
<td><code>add</code></td>
<td>添加一个元素</td>
<td>如果队列满，则抛出<code>IllegalStateException</code>异常</td>
</tr>
<tr>
<td><code>element</code></td>
<td>返回队头元素</td>
<td>如果队列空，则抛出<code>NoSuchElementException</code>异常</td>
</tr>
<tr>
<td><code>offer</code></td>
<td>添加一个元素并返回true</td>
<td>如果队列满，则返回<code>false</code></td>
</tr>
<tr>
<td><code>peek</code></td>
<td>返回队头元素</td>
<td>如果队列空，则返回 <code>null</code></td>
</tr>
<tr>
<td><code>poll</code></td>
<td>移除并返回队头元素</td>
<td>如果队列空，则返回<code>null</code></td>
</tr>
<tr>
<td><code>put</code></td>
<td>添加一个元素</td>
<td>如果队列满，则阻塞</td>
</tr>
<tr>
<td><code>remove</code></td>
<td>移除并返回队头元素</td>
<td>如果队列空，则抛出<code>NoSuchElementException</code>异常</td>
</tr>
<tr>
<td><code>take</code></td>
<td>移除并返回队头元素</td>
<td>如果队列空，则阻塞</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注释</strong>：<code>poll</code>和<code>peek</code>方法返回<code>null</code>来指示失败。因此，向这些队列中插入<code>null</code>值时非法的。</p>
</blockquote>
<p><code>java.util.concurrent</code>包提供了阻塞队列的几个变体。默认情况下</p>
<ul>
<li><code>LinkedBlockingQueue</code>的容量没有上界，但是也可以选择指定一个最大容量。</li>
<li><code>LinkedBlockingDeque</code>是一个双端队列。</li>
<li><code>ArrayBlockingQueue</code>在构造时需要指定容量，并且有一个可选的参数来指定是否需要公平性。若设置了公平参数，那么等待了最长时间的线程会优先得到处理。通常，公平性会降低性能，只有在确实非常需要时才使用公平参数。</li>
<li><code>PriorityBlockingQueue</code>时一个优先队列，而不是先进先出队列。元素按照它们的优先级顺序移除。这个队列没有容量上限，但是，如果队列时空的，获取元素的操作会阻塞。</li>
<li><code>TransferQueue</code>接口，允许生产者线程等待，直到消费者准备就绪可以接受元素。如果生产者调用<code>q.transfer(item);</code>这个调用会阻塞，直到另一个线程将元素（<code>item</code>）删除。</li>
</ul>
<h4 id="高效的映射、集和队列"><a href="#高效的映射、集和队列" class="headerlink" title="高效的映射、集和队列"></a>高效的映射、集和队列</h4><p><code>java.util.concurrent</code>包提供了映射、有序集和队列的高效实现：<code>ConcurrentHashMap</code>、<code>ConcurrentSkipListMap</code>、<code>ConcurrentSkipListSet</code>和<code>ConcurrentLinkedQueue</code>。</p>
<p><strong>这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分尽可能减少竞争</strong>。</p>
<p>与大多数集合不同，这些类的<code>size</code>方法不一定在常量时间内完成操作。确定这些集合的当前大小通常需要遍历。</p>
<p>并发散列映射可以高效地支持大量阅读器和一定数量的书写器。默认情况下认为可以有至多16个同时运行的书写器线程。当然可以有更多的书写器线程，但是，同一时间如果多于16个，其他线程将暂时阻塞。可以在构造器中指定更大数目，不过，通常都没有这种必要。</p>
<blockquote>
<p>散列映射将相同散列码的所有条目放在同一个“桶”中。不过，在较新的<code>Java</code>版本中<strong>，并发散列映射将桶组织为树</strong>，而不是列表，键类型实现<code>Comparable</code>，从而可以保证性能为<code>O(log(n))</code>。</p>
</blockquote>
<h4 id="对并发散列映射的批操作"><a href="#对并发散列映射的批操作" class="headerlink" title="对并发散列映射的批操作"></a>对并发散列映射的批操作</h4><p><code>Java API</code>为并发散列映射提供了批操作，即使有其他线程在处理映射，这些操作也能安全地执行。批操作会遍历映射，处理遍历过程中找到的元素。这里不会冻结映射的当前快照。除非恰好直到批操作运行时映射不会被修改，否则就要把结果看作是映射的一个近似。</p>
<p>有3种不同的操作：</p>
<ul>
<li><code>search</code>（搜索）为每个键或值应用一个函数，直到函数生成一个非null的结果。然后搜索终止，返回这个函的结果。</li>
<li><code>reduce</code>（归约）组合所有键或值，这里要使用所提供的一个累加函数。</li>
<li><code>forEach</code>为所有键或值应用一个函数。</li>
</ul>
<p>每个操作都有4个版本：</p>
<ul>
<li><code>operationKeys</code>：处理键</li>
<li><code>operationValues</code>：处理值</li>
<li><code>operation</code>：处理键和值</li>
<li><code>operationEntries</code>：处理<code>Map.Entry</code>对象</li>
</ul>
<h4 id="并发集视图"><a href="#并发集视图" class="headerlink" title="并发集视图"></a>并发集视图</h4><p>如果需要一个很大的线程安全的集而不是映射，并没有<code>ConcurrentHashSet</code>类，可以使用<code>ConcurrentHashMap.newKeySet()</code>方法生成一个<code>Set&lt;K&gt;</code>，这实际上是<code>ConcurrentHashMap&lt;K, Boolean&gt;</code>的一个包装器。（所有映射值都为<code>Boolean.TRUE</code>，不过因为只是要把它用作一个集，所以并不关系映射值。）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> words <span class="token operator">=</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token function">newKeySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当然，如果原先有一个映射，<code>keySet</code>方法可以生成这个映射的键值。这个集是可更改的。</p>
<h4 id="写数组的拷贝"><a href="#写数组的拷贝" class="headerlink" title="写数组的拷贝"></a>写数组的拷贝</h4><p><code>CopyOnWriteArrayList</code>和<code>CopyOnWeiteArraySet</code>是线程安全的集合，其中所有更改器会建立底层数组的一个副本。如果迭代访问集合的线程数超过更改集合的线程数，这样的安排是很有用的。当构造一个迭代器的时候，它包含当前数组的一个引用。如果这个数组后来被更改了，迭代器仍然引用旧数组，但是，集合的数组已经替换。因而，<strong>原来的迭代器可以访问一致的（但可能过时的）视图</strong>，而且不存在任何同步开销。</p>
<h4 id="并行数组算法"><a href="#并行数组算法" class="headerlink" title="并行数组算法"></a>并行数组算法</h4><p><code>Arrays</code>类提供了大量并行化操作。静态<code>Arrays.parallelSort</code>方法可以对一个基本类型值或对象数组排序。</p>
<h4 id="较早的线程安全集合"><a href="#较早的线程安全集合" class="headerlink" title="较早的线程安全集合"></a>较早的线程安全集合</h4><p>从<code>Java</code>的初始版本开始，<code>Vector</code>和<code>Hashtable</code>类就提供了动态数组和散列表的线程安全的实现。现在这些类被认为已经过时，而被<code>ArrayList</code>和<code>HashMap</code>类所取代。不过，那些类不是线程安全的，实际上，集合库中提供了一种不同的机制。任何集合类都可以通过使用<strong>同步包装器</strong>（synchronization wrapper）变成线程安全的：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> synchArrayList <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> synchHashMap <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>结果集合的方法使用锁加以保护，可以提供线程安全的访问。</p>
<h3 id="任务和线程池"><a href="#任务和线程池" class="headerlink" title="任务和线程池"></a>任务和线程池</h3><p>构造一个新的线程开销有些大，因为这涉及与操作系统的交互。如果你的程序中创建了大量的生命期很短的线程，那么不应该把每个任务映射到一个单独的线程，而应该使用<strong>线程池</strong>（<code>thread pool</code>）。线程池中包含需要准备运行的线程。为线程池提供一个<code>Runnable</code>，就会有一个线程调用<code>run</code>方法。当<code>run</code>方法退出时，这个线程不会死亡，而是留在池中准备给下一个请求提供服务。</p>
<h4 id="Callable与Future"><a href="#Callable与Future" class="headerlink" title="Callable与Future"></a><code>Callable</code>与<code>Future</code></h4><p><code>Runnable</code>封装一个异步运行的任务，可以把它想象成一个没有参数和返回值的异步任务。<code>Callable</code>与<code>Runnable</code>类似，但是又返回值。<code>Callable</code>接口时一个参数化的类型，只有一个方法<code>call</code>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">V</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>Future</code>保存异步计算的<strong>结果</strong>。可以启动一个计算，将<code>Future</code>对象交给某个线程，然后忘掉它。这个<code>Future</code>对象的所有者在结果计算好之后就可以获得结果。</p>
<p><code>Future&lt;V&gt;</code>接口又下面的方法。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterrupt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第一个<code>get</code>方法的调用会阻塞，直到计算完成。</p>
<p>第二个<code>get</code>方法也会阻塞，不过如果在计算完成之前调用超时，会抛出一个<code>TimeoutException</code>。如果计算已经完成，那么<code>get</code>方法立即返回。</p>
<p>如果计算还在进行，<code>isDone</code>方法返回<code>false</code>；如果已经完成，则返回<code>true</code>。</p>
<p>可以用<code>cancel</code>方法取消计算。如果计算还没有开始，它会被取消而且不再开始。如果计算正在进行，那么如果<code>mayInterrupt</code>参数为<code>true</code>，它就会被中断。</p>
<blockquote>
<p><strong>警告</strong>：取消一个任务涉及两个步骤。必须找到并中断底层线程。另外任务实现（在<code>call</code>方法中）必须感知到中断，并放弃它的工作。如果一个<code>Future</code>对象不知道任务在哪个线程中执行，或者如果任务没有监视执行任务的线程的中断状态，那么取消任务没有任何效果。</p>
</blockquote>
<p>执行<code>Callable</code>的一种方法时使用<code>FutureTask</code>，它实现了<code>Future</code>和<code>Runnable</code>接口，所以可以构造一个线程来运行这个任务：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span>integer<span class="token punctuation">&gt;</span></span> task <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// is's a Runnable</span>
t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//...</span>
<span class="token class-name">Integer</span> result <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// it's a Future</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p><strong>执行器</strong>（<code>Executors</code>）类又许多静态工厂方法，用来构造线程池。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>newCachedThreadPool</code></td>
<td>必要时创建新线程；空闲线程会保留60秒</td>
</tr>
<tr>
<td><code>newFixedThreadPool</code></td>
<td>池中包含固定数目的线程；空闲线程会一直保留</td>
</tr>
<tr>
<td><code>newWorkStealingPool</code></td>
<td>一种适合“fork-join”任务的线程池，其中复杂的任务会分解为更简单的任务，空闲线程会“密取”较简单的任务</td>
</tr>
<tr>
<td><code>newSingleThreadExecutor</code></td>
<td>只有一个线程的“池”，会顺序地执行所提交的任务，适合于性能分析，做对照组</td>
</tr>
<tr>
<td><code>newScheduledThreadPool</code></td>
<td>用于调度执行的固定线程池</td>
</tr>
<tr>
<td><code>newSingleThreadScheduledExecutor</code></td>
<td>用于调度执行的单线程“池”，适合于性能分析，做对照组</td>
</tr>
</tbody></table>
<p><code>newCachedThreadPool</code>方法构造一个线程池，会立即执行各个任务，如果又空闲线程可用，就使用现有空闲线程执行任务；如果没有可用的空闲线程，则创建一个新线程。</p>
<p><code>newFixedThreadPool</code>方法构造一个具有固定大小的线程池。如果提交的任务数多于空闲线程数，就把未得到服务的任务放到队列中。当其他任务完成以后再运行这些排队的任务。</p>
<p><code>newSingleThreadExecutor</code>是一个退化了的大小为1的线程池：由一个线程顺序地执行所提交的任务。</p>
<p>以上三个方法返回实现了<code>ExecutorService</code>接口的<code>ThreadPoolExecutor</code>类的对象。</p>
<p>可以下面的方法之一将<code>Runnable</code>或<code>Callable</code>对象提交给<code>ExecutorService</code>：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">T</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 完成时返回指定的result对象。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>线程池会再方便的时候今早执行提交的任务。</p>
<p>使用完一个线程池时，调用<code>shutdown</code>。这个方法启动线程池的关闭序列。被关闭的执行器不再接受新的任务。当所有任务都完成时，线程池中的线程死亡。另一种方法是调用<code>shutdownNow</code>。线程池会取消所有尚未开始的任务。</p>
<ol>
<li>调用Executors类的静态方法<code>NewCachedThreadPool</code>或<code>newFixedThreadPool</code>。</li>
<li>调用<code>submit</code>提交<code>Runnable</code>或Callable对象。</li>
<li>保存好返回的<code>Future</code>对象，以便得到结果或者取消任务。</li>
<li>当不想再提交任何任务时，调用<code>shutdown</code></li>
</ol>
<p><code>ScheduledExecutorService</code>接口为调度执行或重复执行任务提交了一些方法。</p>
<h4 id="fork-join框架"><a href="#fork-join框架" class="headerlink" title="fork-join框架"></a><code>fork-join</code>框架</h4><p><code>fore-join</code>框架使用了一种有效的只能方法来平衡可用线程的工作负载，这种方法称为<strong>工作密取</strong>（<code>work stealing</code>）。</p>
<h3 id="异步计算"><a href="#异步计算" class="headerlink" title="异步计算"></a>异步计算</h3><p>无等待或<strong>异步</strong>计算</p>
<h4 id="可完成Future"><a href="#可完成Future" class="headerlink" title="可完成Future"></a>可完成<code>Future</code></h4><p>当有一个<code>Future</code>对象时，需要调用<code>get</code>来获得值，这个方法会阻塞，直到值可用。<code>CompletableFuture</code>类实现了<code>Future</code>接口，它提供了获得结果的另一种机制。<strong>通过注册一个回调，一旦结果而可用，就会（再某个线程中）利用该结果调用这个回调。</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
f<span class="token punctuation">.</span><span class="token function">thenAccept</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> <span class="token comment">// Process the result string s</span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>通过这种方式，无需阻塞就可以再结果可用时对结果进行处理。</p>
<p>大多数情况下，都需要建立自己的<code>CompletableFuture</code>。要想异步运行任务并得到<code>CompletableFuture</code>，不要把它直接调用给执行器服务，而应该调用静态方法<code>CompletableFuture.supplyAsync</code>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">readPage</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">openStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UncheckedIOException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> executor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果省略执行器，任务会在一个默认执行器上运行（具体就是<code>ForkJoinPool.commonPoll()</code>返回的执行器）。</p>
<blockquote>
<p><strong>警告</strong>：注意<code>supplyAsync</code>方法的第一个参数是一个<code>Supplier&lt;T&gt;</code>，而不是<code>Callable&lt;T&gt;</code>。这两个接口都描述了无参数而且返回值类型为<code>T</code>的函数，不过<code>Supplier</code>函数不能抛出检查型异常。送上面的代码可以看到，这不是一个令人鼓舞的选择。</p>
</blockquote>
<p><code>CompletableFuture</code>可以采用两种方式完成：得到一个结果，或者由一个未捕获的异常。要处理这两种情况，可以使用<code>whenComplete</code>方法。要对结果（或者如果没有就为<code>null</code>）和异常（或者如果没有就为<code>null</code>）调用所提供的函数。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">f<span class="token punctuation">.</span><span class="token function">whenComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Process the result s;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// Process the Throwable t;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>CompletableFuture</code>之所以被称为时可完成的，是因为可以手动地设置一个完成值。（在其他并发库中，这样的对象称为承诺（<code>promise</code>）。）当然，用<code>supplyAsync</code>创建一个<code>CompetableFuture</code>时，任务完成时就会隐式地设置完成值。不过，显示地设置结果可以提供更大的灵活性。例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
exector<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">workHard</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    f<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">workSmart</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    f<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 要对一个异常完成future，需要调用</span>
<span class="token class-name">Throwable</span> t <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
f<span class="token punctuation">.</span><span class="token function">completeExceptionally</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>可以在多个线程中在同一个<code>future</code>上安全地调用complete或<code>completeExceptionally</code>。如果这个<code>future</code>已经完成，这些调用没有任何作用。</p>
</blockquote>
<blockquote>
<p>与普通的<code>Future</code>不同，调用<code>cancel</code>方法时，<code>CompletableFuture</code>的计算不会中断。取消只会把这个<code>Future</code>对象设置为以异常方式完成（有一个<code>CancellationException</code>异常）。</p>
</blockquote>
<h4 id="组合可完成Future"><a href="#组合可完成Future" class="headerlink" title="组合可完成Future"></a>组合可完成<code>Future</code></h4><p>为<code>CompletableFuture&lt;T&gt;</code>对象增加一个动作</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>thenApply</code></td>
<td><code>T -&gt; U</code></td>
<td>对结果应用一个函数</td>
</tr>
<tr>
<td><code>thenAccept</code></td>
<td><code>T -&gt; void</code></td>
<td>类似于<code>thenApply</code>，不过结果为<code>void</code></td>
</tr>
<tr>
<td><code>thenCompose</code></td>
<td><code>T -&gt; CompletableFuture&lt;U&gt;</code></td>
<td>对结果调用函数并执行返回的<code>future</code></td>
</tr>
<tr>
<td><code>handle</code></td>
<td><code>(T, Throwable) -&gt; U</code></td>
<td>处理结果或错误，生成一个新结果</td>
</tr>
<tr>
<td><code>whenComplete</code></td>
<td><code>(T, Throwable) -&gt; void</code></td>
<td>类似于<code>handle</code>，不过结果为<code>void</code></td>
</tr>
<tr>
<td><code>exceptionally</code></td>
<td><code>Throwable -&gt; T</code></td>
<td>从错误计算一个结果</td>
</tr>
<tr>
<td><code>completeOnTimeout</code></td>
<td><code>T, long, TimeUnit</code></td>
<td>如果超时，生成给定值作为结果</td>
</tr>
<tr>
<td><code>orTimeout</code></td>
<td><code>long, TimeUnit</code></td>
<td>如果超时，生成一个<code>TimeoutException</code>异常</td>
</tr>
<tr>
<td><code>thenRun</code></td>
<td><code>Runnable</code></td>
<td>执行<code>Runnable</code>，结果为<code>void</code></td>
</tr>
</tbody></table>
<p>组合多个组合对象</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>thenCombine</code></td>
<td><code>CompletableFuture&lt;U&gt;, (T, U) -&gt; V</code></td>
<td>执行两个动作并用给定函数组合结果</td>
</tr>
<tr>
<td><code>thenAcceptBoth</code></td>
<td><code>CompletableFuture&lt;U&gt;, (T, U) -&gt; void</code></td>
<td>与<code>thenCombine</code>类似，不过结果为<code>void</code></td>
</tr>
<tr>
<td><code>runAfterBoth</code></td>
<td><code>CompletableFuture&lt;?&gt;, Runnable</code></td>
<td>两个都完成后执行<code>runnable</code></td>
</tr>
<tr>
<td><code>applyToEither</code></td>
<td><code>CompletableFuture&lt;T&gt;, T -&gt; V</code></td>
<td>得到其中一个的结果时，传入给定的函数</td>
</tr>
<tr>
<td><code>acceptEither</code></td>
<td><code>CompletableFuture&lt;T&gt;, T -&gt; void</code></td>
<td>与<code>applyToEither</code>类似，不过结果为<code>void</code></td>
</tr>
<tr>
<td><code>runAfterEither</code></td>
<td><code>CompletableFuture&lt;?&gt;, Runnable</code></td>
<td>其中一个完成后执行 <code>runnable</code></td>
</tr>
<tr>
<td><code>static allOf</code></td>
<td><code>CompletableFuture&lt;?&gt; ...</code></td>
<td>所有给定的<code>future</code>都完成后完成，结果为<code>void</code></td>
</tr>
<tr>
<td><code>static anyOf</code></td>
<td><code>CompletableFuture&lt;?&gt; ...</code></td>
<td>任意给定的<code>future</code>完成后则玩抽，结果为<code>void</code></td>
</tr>
</tbody></table>
<ul>
<li>前三个方法并发运行一个<code>CompletableFuture&lt;T&gt;</code>和一个<code>CompletableFuture&lt;U&gt;</code>动作，并组合结果。</li>
<li>接下来三个方法并发运行两个<code>CompletableFuture&lt;T&gt;</code>动作。一旦其中一个动作完成，就传递它的结果，并忽略另一个结果。</li>
<li>最后的静态<code>allOf</code>和<code>allOr</code>方法取一组可完成<code>future</code>（数目可变），并生成一个<code>CompletableFuture&lt;Void&gt;</code>，它会在所有这些future都完成时或者其中任意一个<code>future</code>完成时结束。<code>allOf</code>方法不会生成任何结果。**<code>anyOf</code>方法不会终止其余任务**。</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>到目前为止，已经了解了如何在同一个程序的不同线程中执行<code>Java</code>代码。有时候还需要执行另一个程序。为此，可以使用<code>ProcessBuilder</code>和<code>Process</code>类。<code>Process</code>类在一个单独的操作系统进程中执行一个命令，允许我们与标准输入、输出和错误流交互。<code>ProcessBuilder</code>类则允许我们配置<code>Process</code>对象。</p>
<blockquote>
<p><code>ProcessBuilder</code>类可以取代<code>Runtime.exec</code>调用，而且更为灵活。</p>
</blockquote>
<h4 id="建立一个进程"><a href="#建立一个进程" class="headerlink" title="建立一个进程"></a>建立一个进程</h4><p>首先指定想要执行的命令。可以提供一个<code>List&lt;String&gt;</code>，或者直接提供命令字符串。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"gcc"</span><span class="token punctuation">,</span> <span class="token string">"myapp.c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p><strong>警告</strong>：第一个字符串必须是一个可执行的命令，而不是一个<code>shell</code>内置命令。例如，要在<code>Windows</code>中运行<code>dir</code>命令，就需要提供字符串 <code>"cmd.exe" "/C"</code> 和 <code>"dir"</code> 来建立进程。</p>
</blockquote>
<p>每个进程都有一个工作目录，用来解析相对目录名。默认情况下，进程的工作目录与虚拟机相同，通常是启动<code>java</code>程序的哪个目录。可以用<code>directory</code>方法改变工作目录：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">builder <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">directory</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">toFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>配置<code>ProcessBuilder</code>的各个方法都返回其自身，所以可以把命令串起来。最终会调用：</p>
<p><code>Process p = new ProcessBuilder(command).directory(file)......start();</code></p>
</blockquote>
<p>接下来，要指定如何处理进程的标准输入、输出和错误流。默认情况下，它们分别是一个管道，可以用以下方法访问：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">OutputStream</span> processIn <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">InputStream</span> processOut <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">InputStream</span> processErr <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getErrorStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>注意，进程的输入流是<code>JVM</code>的一个输出流！我们会写入这个流，而我们写的内容会成为进程的输入。与之相反，我们会读取进程写入输出和错误流的内容。对我们来说，它们都是输入流。</p>
<p>可以指定新进程的输入、输出和错误流与<code>JVM</code>相同。如果用户在一个控制台运行<code>JVM</code>，所有用户输入都会转发到进程，而进程的输出将显示在控制台上。可以调用：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">builder<span class="token punctuation">.</span><span class="token function">redirectIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>为这三个流建立这个设置。如果只想继承某些流，可以把值：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ProcessBuilder<span class="token punctuation">.</span>Redirect</span><span class="token punctuation">.</span>INHERIT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>传入<code>redirectInput</code>、<code>redirectOutput</code>或<code>redirectError</code>方法。例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">builder<span class="token punctuation">.</span><span class="token function">redirectOutput</span><span class="token punctuation">(</span><span class="token class-name">ProcessBuilder<span class="token punctuation">.</span>Redirect</span><span class="token punctuation">.</span>INHERIT<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>通过提供<code>File</code>对象，可以将进程流重定向到文件：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">builder<span class="token punctuation">.</span><span class="token function">redirectInput</span><span class="token punctuation">(</span>inputFile<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">redirectOutput</span><span class="token punctuation">(</span>outputFile<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">redirectError</span><span class="token punctuation">(</span>errorFile<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>进程启动时，会创建或删除输出和错误文件。要追加到现有的文件，可以使用：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">builder<span class="token punctuation">.</span><span class="token function">redirectOutput</span><span class="token punctuation">(</span><span class="token class-name">ProcessBuilder<span class="token punctuation">.</span>Redirect</span><span class="token punctuation">.</span><span class="token function">appendTo</span><span class="token punctuation">(</span>outputFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>合并输出和错误流通常很有用，这样就能按进程生成这些消息的顺序显示输出和错误消息。可以调用</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">builder<span class="token punctuation">.</span><span class="token function">redirectErrorStream</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>启用合并。如果这样做，就不能再在<code>ProcessBuilder</code>上调用<code>redirectError</code>，也不能在<code>Process</code>上调用<code>getErrorStream</code>。</p>
<p>有时可能还需要修改进程的环境变量。在这里，构建器的串联语法就不能用了。需要得到构造器的环境（由运行<code>JVM</code>的那个进程的环境变量初始化），然后加入或删除环境变量条目。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> env <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">environment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
env<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"LANG"</span><span class="token punctuation">,</span> <span class="token string">"fr_ER"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
env<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"JAVA_HOME"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Process</span> p <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果希望利用管道将一个进程的输出作为另一个进程的输入（类似于<code>shell</code>中的 <code>|</code> 操作符），<code>Java 9</code>提供了一个<code>startPipeline</code>方法。可以传入一个进程构建器列表，并从最后一个进程读取结果。这里给出了一个枚举一个目录树中的各个扩展的例子：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Process</span><span class="token punctuation">&gt;</span></span> processes <span class="token operator">=</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">.</span><span class="token function">startPipeline</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>
	<span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"find"</span><span class="token punctuation">,</span> <span class="token string">"/opt/jdk-9"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"grep"</span><span class="token punctuation">,</span> <span class="token string">"-o"</span><span class="token punctuation">,</span> <span class="token string">"\\.[^./]*$"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"sort"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"uniq"</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Process</span> last <span class="token operator">=</span> processes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>processes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>last<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="运行一个进程"><a href="#运行一个进程" class="headerlink" title="运行一个进程"></a>运行一个进程</h4><p>配置了构建器之后，要调用它的<code>start</code>方法启用进程。如果把输入、输出和错误流配置为管道，现在可以写输入流，并读取输出和错误流。例如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Process</span> process <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span> <span class="token string">"-l"</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">directory</span><span class="token punctuation">(</span><span class="token class-name">Path</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"/tmp"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token keyword">var</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">hasNextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><strong>警告</strong>：ji进程流的缓冲空间是有限的。不能写入太多输入，而且要及时读取输出。如果由大量输入和输出，可能需要在单独的线程中生产和消费这些输入输出。否则可能会造成阻塞问题。</p>
</blockquote>
<p>要等待进程完成，可以调用</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> result <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">waitFor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者，如果不想无限期地等待，可以这样做：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> delay <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">waitFor</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">exitValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    process<span class="token punctuation">.</span><span class="token function">destroyForcibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第一个<code>waitFor</code>调用返回过程的退出值（<code>0</code>表示成功，或者返回一个非0的错误码）。如果进程没有超时，第二个调用返回<code>true</code>。然后需要调用<code>exitValue</code>方法获取退出值。</p>
<p>如果不会等待进程结束，而只是让它继续运行，不时调用<code>isAlive</code>来查看进程是否仍存活。要杀死这个进程，可以调用<code>destroy</code>或<code>destroyForcibly</code>。这两个调用之间的区别取决于平台。在<code>UNIX</code>上，前者会以<code>SIGTERM</code>终止进程，后者会以<code>SIGKILL</code>终止进程。（如果<code>destory</code>方法可以正常终止进程，<code>supportsNormalTermination</code>方法返回<code>true</code>。）</p>
<p>最后会在进程完成时接收到一个异步通知。调用<code>process.onExit()</code>会得到一个<code>CompletableFuture&lt;Process&gt;</code>，可以用来调度任何动作。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">process<span class="token punctuation">.</span><span class="token function">onExit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenAccept</span><span class="token punctuation">(</span>
	p <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Exit value: "</span> <span class="token operator">+</span> p<span class="token punctuation">.</span><span class="token function">exitValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="进程句柄"><a href="#进程句柄" class="headerlink" title="进程句柄"></a>进程句柄</h4><p>要获得进程启动的一个进程的更多信息，或者想更多地了解你的计算机上正在运行的任何其他进程，可以使用<code>ProcessHandle</code>接口。可以用4种方式得到一个<code>ProcessHandle</code>：</p>
<ol>
<li>给定一个<code>Process</code>对象p，<code>p.toHandle()</code>会生成它的<code>ProcessHandle</code></li>
<li>给定一个<code>long</code>类型的操作进程<code>ID</code>，<code>ProcessHandle.of(id)</code>可以生成这个进程的句柄。</li>
<li><code>Process.current()</code>时运行这个<code>Java</code>虚拟机的进程的句柄</li>
<li><code>ProcessHandle.allProcesses()</code> 可以生成对当前进程可见的所有操作系统进程的<code>Stream&lt;ProcessHandle&gt;</code></li>
</ol>
<p>给定一个进程句柄，可以得到它的进程<code>ID</code>、父进程、子进程和后代进程。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> pid <span class="token operator">=</span> handle<span class="token punctuation">.</span><span class="token function">pid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProcessHandle</span><span class="token punctuation">&gt;</span></span> parent <span class="token operator">=</span> handle<span class="token punctuation">.</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProcessHandle</span><span class="token punctuation">&gt;</span></span> children <span class="token operator">=</span> handle<span class="token punctuation">.</span><span class="token function">children</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProcessHandle</span><span class="token punctuation">&gt;</span></span> descendants <span class="token operator">=</span> handle<span class="token punctuation">.</span><span class="token function">descendants</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><code>allProcesses</code>、<code>children</code>和<code>descendants</code>方法返回<code>Stream&lt;ProcessHandle&gt;</code>实例只是当时的快照。流中的任何进程在你看到它们的时候可能已经终止了，而且可能已经启动了其他进程，而那些新启动的进程不在流中。</p>
</blockquote>
<p>info方法可以生成一个<code>ProcessHandle.Info</code>对象，它提供了一些方法来获得进程的有关信息。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token function">arguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">command</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">commandLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">startInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">totalCpuDuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>所有这些方法都返回<code>Optional</code>值，因为可能某个特定的操作系统不能报告这个信息。</p>
<p>要监视或强制进程终止，于Process类一样，<code>Processhandle</code>接口也有<code>isAlive</code>、<code>supportsNormalTermination</code>、<code>destroy</code>、<code>destroyForcibly</code>和<code>onExit</code>方法。不过，没有对应<code>waitFor</code>的方法。</p>
<h2 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a><code>Java</code>关键字</h2><p>本附录列出了Java语言的所有关键字。有些关键字是“受限的”，它们只在某些特定场合（例如。在模块声明中）有特殊含义。在其他情况下，它们可以是标识符。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>abstract</code></td>
<td>抽象类或方法</td>
</tr>
<tr>
<td><code>assert</code></td>
<td>用来查找内部程序错误</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>布尔类型</td>
</tr>
<tr>
<td><code>break</code></td>
<td>跳出一个选择语句或循环</td>
</tr>
<tr>
<td><code>byte</code></td>
<td>8位整数类型</td>
</tr>
<tr>
<td><code>case</code></td>
<td><code>switch</code>的一个分支</td>
</tr>
<tr>
<td><code>catch</code></td>
<td>捕获异常的<code>try</code>块子句</td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>Unicode</code>字符类型</td>
</tr>
<tr>
<td><code>class</code></td>
<td>定义一个类类型</td>
</tr>
<tr>
<td><code>const</code></td>
<td>未使用</td>
</tr>
<tr>
<td><code>continue</code></td>
<td>在循环末尾继续</td>
</tr>
<tr>
<td><code>default</code></td>
<td><code>switch</code>的默认子句，或者接口的默认方法</td>
</tr>
<tr>
<td><code>do</code></td>
<td><code>do/while</code> 循环最前面的语句</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双精度浮点数类型</td>
</tr>
<tr>
<td><code>else</code></td>
<td><code>if</code> 语句的 <code>else</code> 子句</td>
</tr>
<tr>
<td><code>enum</code></td>
<td>枚举类型</td>
</tr>
<tr>
<td><code>exports</code></td>
<td>导出一个模块的包（受限）</td>
</tr>
<tr>
<td><code>extends</code></td>
<td>定义一个类的父类，或者一个通配符的上届</td>
</tr>
<tr>
<td><code>final</code></td>
<td>一个常量，或一个不能被覆盖的类或方法</td>
</tr>
<tr>
<td><code>finally</code></td>
<td><code>try</code>块中总会执行的部分</td>
</tr>
<tr>
<td><code>float</code></td>
<td>单精度浮点数类型</td>
</tr>
<tr>
<td><code>for</code></td>
<td>一种循环类型</td>
</tr>
<tr>
<td><code>goto</code></td>
<td>未使用</td>
</tr>
<tr>
<td><code>if</code></td>
<td>一个条件语句</td>
</tr>
<tr>
<td><code>implements</code></td>
<td>定义一个类实现的接口</td>
</tr>
<tr>
<td><code>import</code></td>
<td>导入一个包</td>
</tr>
<tr>
<td><code>instanceof</code></td>
<td>测试一个对象是否为一个类的实例</td>
</tr>
<tr>
<td><code>int</code></td>
<td>32位整数类型</td>
</tr>
<tr>
<td><code>interface</code></td>
<td>一种抽象类型，其中包含可以由类实现的方法</td>
</tr>
<tr>
<td><code>long</code></td>
<td>64位长整数类型</td>
</tr>
<tr>
<td><code>native</code></td>
<td>由宿主系统实现的一个方法</td>
</tr>
<tr>
<td><code>new</code></td>
<td>分配一个新对象或数据</td>
</tr>
<tr>
<td><code>null</code></td>
<td>一个空引用（需要说明的是，<code>null</code>从技术上讲是一个字面量，而不是关键字）</td>
</tr>
<tr>
<td><code>module</code></td>
<td>声明一个模块（受限）</td>
</tr>
<tr>
<td><code>open</code></td>
<td>修改一个<code>module</code>声明（受限）</td>
</tr>
<tr>
<td><code>opens</code></td>
<td>打开一个模块的包（受限）</td>
</tr>
<tr>
<td><code>package</code></td>
<td>包含类的一个包</td>
</tr>
<tr>
<td><code>private</code></td>
<td>这个特性只能由该类的方法访问</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>这个特性只能由该类、其子类以及同一个包中的其他类的方法访问</td>
</tr>
<tr>
<td><code>provides</code></td>
<td>只是一个模块使用一个服务（受限）</td>
</tr>
<tr>
<td><code>public</code></td>
<td>这个特性可以由所有类的方法访问</td>
</tr>
<tr>
<td><code>return</code></td>
<td>从一个方法返回</td>
</tr>
<tr>
<td><code>short</code></td>
<td>16位整数类型</td>
</tr>
<tr>
<td><code>static</code></td>
<td>这个特性是类或接口特有的，而不属于类的实例</td>
</tr>
<tr>
<td><code>strictfp</code></td>
<td>对浮点数计算使用严格的规则</td>
</tr>
<tr>
<td><code>super</code></td>
<td>超类对象或构造器，或一个通配符的下界</td>
</tr>
<tr>
<td><code>switch</code></td>
<td>一个选择语句</td>
</tr>
<tr>
<td><code>synchronized</code></td>
<td>对线程而言是原子的方法或代码块</td>
</tr>
<tr>
<td><code>this</code></td>
<td>当前类的一个方法或构造器的隐含参数</td>
</tr>
<tr>
<td><code>throw</code></td>
<td>抛出一个异常</td>
</tr>
<tr>
<td><code>to</code></td>
<td><code>exports</code> 或 <code>opens</code> 声明的一部分（受限）</td>
</tr>
<tr>
<td><code>throws</code></td>
<td>一个方法可能抛出的异常</td>
</tr>
<tr>
<td><code>transient</code></td>
<td>标记非永久的数据</td>
</tr>
<tr>
<td><code>transitive</code></td>
<td>修饰一个<code>require</code>声明（受限）</td>
</tr>
<tr>
<td><code>try</code></td>
<td>捕获异常的代码块</td>
</tr>
<tr>
<td><code>uses</code></td>
<td>指示一个模块使用一个服务（受限）</td>
</tr>
<tr>
<td><code>var</code></td>
<td>声明一个变量的类型是推导得出的（受限）</td>
</tr>
<tr>
<td><code>void</code></td>
<td>指示一个方法不返回任何值</td>
</tr>
<tr>
<td><code>volatile</code></td>
<td>确保一个字段可以由多个线程访问</td>
</tr>
<tr>
<td><code>with</code></td>
<td>在一个<code>provides</code>语句中定义服务类（受限）</td>
</tr>
<tr>
<td><code>while</code></td>
<td>一种循环</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul>
<li><code>-Xlint:unchecked</code>：编译时使用，可以看到警告的文本信息。</li>
<li><code>@SuppressWarnings("unchecked")</code>：标识编译器忽略<code>unchecked</code>警告信息，例如：使用<code>List</code>，<code>ArrayList</code>等未进行参数化产生的警告信息。</li>
</ul>
<hr>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://robertsunq.github.io" rel="external nofollow noreferrer">Robert Sunq</a>
                    </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://robertsunq.github.io/2022/06/28/cs-languages/core-java-volume-0/">https://robertsunq.github.io/2022/06/28/cs-languages/core-java-volume-0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-SA 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://robertsunq.github.io" target="_blank">Robert Sunq</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%8E%9F%E5%88%9B/">
                                    <span class="chip bg-color">原创</span>
                                </a>
                            
                                <a href="/tags/java/">
                                    <span class="chip bg-color">java</span>
                                </a>
                            
                                <a href="/tags/book/">
                                    <span class="chip bg-color">book</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,wechat" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/03/25/notes/keep-alive-e5/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="Microsoft 365 E5订阅 office 与自动续订">
                        
                        <span class="card-title">Microsoft 365 E5订阅 office 与自动续订</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            使用Microsoft 365 E5免费订阅 office 以及通过 github 的 KeepAliveE5 项目定时续期
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-03-25
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/notes/" class="post-category">
                                    notes
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%8E%9F%E5%88%9B/">
                        <span class="chip bg-color">原创</span>
                    </a>
                    
                    <a href="/tags/note/">
                        <span class="chip bg-color">note</span>
                    </a>
                    
                    <a href="/tags/office/">
                        <span class="chip bg-color">office</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/05/22/hello-world/happy-day/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="开心最重要">
                        
                        <span class="card-title">开心最重要</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            遵循本心
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-05-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/hello-world/" class="post-category">
                                    hello-world
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%8E%9F%E5%88%9B/">
                        <span class="chip bg-color">原创</span>
                    </a>
                    
                    <a href="/tags/%E5%BF%83%E6%83%85/">
                        <span class="chip bg-color">心情</span>
                    </a>
                    
                    <a href="/tags/%E5%BC%80%E5%BF%83%E5%B0%B1%E5%A5%BD/">
                        <span class="chip bg-color">开心就好</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: Qing<br />'
            + '文章作者: Robert Sunq<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '<原创文章> 著作权归Robert Sunq所有，<转载文章> 著作权归原作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2023</span>
            
            <a href="/about" target="_blank">Robert Sunq</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">127.5k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/RobertSunq" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:loading@xx.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=loading..." class="tooltipped" target="_blank" data-tooltip="QQ联系我: loading..." data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"left","width":150,"height":350},"mobile":{"show":true},"log":false});</script></body>

</html>
