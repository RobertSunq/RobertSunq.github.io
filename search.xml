<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>UltralSO制作U盘启动盘</title>
      <link href="/2023/03/26/tools/ultralso-make-startup-disk/"/>
      <url>/2023/03/26/tools/ultralso-make-startup-disk/</url>
      
        <content type="html"><![CDATA[<h1 id="UltralSO制作U盘启动盘"><a href="#UltralSO制作U盘启动盘" class="headerlink" title="UltralSO制作U盘启动盘"></a>UltralSO制作U盘启动盘</h1><blockquote><p>说明：使用<code>UltralSO</code>（软碟通）制作<code>U</code>盘启动盘</p><p>软件<a href="https://cn.ultraiso.net/">下载链接</a>：<a href="https://cn.ultraiso.net/%EF%BC%8C">https://cn.ultraiso.net/，</a>  <a href="https://www.ultraiso.com/">https://www.ultraiso.com/</a></p></blockquote><ol><li><p>格式化需要使用的<code>U</code>盘。</p></li><li><p>打开<code>UltralSO</code>，然后点击  文件 -&gt; 打开，选择需要刻录到<code>U</code>盘的<code>ISO</code>镜像文件。</p><img src="/2023/03/26/tools/ultralso-make-startup-disk/images_00.png" class="" title="images_00"><p>如果右上角显示的镜像容量，大于预设的磁盘大小，可以点击大小设置部分，修改为合适的容量</p><img src="/2023/03/26/tools/ultralso-make-startup-disk/images_04.png" class="" title="images_04"></li><li><p>再左下角区域选择需要刻录的<code>U</code>盘</p><img src="/2023/03/26/tools/ultralso-make-startup-disk/images_01.png" class="" title="images_01"></li><li><p>点击 启动 -&gt; 写入硬盘映像。</p><img src="/2023/03/26/tools/ultralso-make-startup-disk/images_02.png" class="" title="images_02"></li><li><p>在弹出框中进行配置</p><ol><li><p>写入方式选择“<code>USB-HDD+</code>”</p><img src="/2023/03/26/tools/ultralso-make-startup-disk/images_03.png" class="" title="images_03"></li><li><p>点击“写入”按钮</p><img src="/2023/03/26/tools/ultralso-make-startup-disk/images_05.png" class="" title="images_05"><p>如果写入过程中提示 “磁盘/映像空间太小！” 可以尝试去官网下载最新版的<code>UltralSO</code>，这个是老版软件的问题。（在确定自己的U盘容量足够且大于要写入的系统文件大小时）</p></li></ol></li><li><p>最后等待刻录成功</p><img src="/2023/03/26/tools/ultralso-make-startup-disk/images_06.png" class="" title="images_06"></li></ol><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Microsoft 365 E5订阅 office 与自动续订</title>
      <link href="/2023/03/25/tools/keep-alive-e5/"/>
      <url>/2023/03/25/tools/keep-alive-e5/</url>
      
        <content type="html"><![CDATA[<h1 id="Microsoft-365-E5-订阅-office-与自动续订"><a href="#Microsoft-365-E5-订阅-office-与自动续订" class="headerlink" title="Microsoft 365 E5 订阅 office 与自动续订"></a><code>Microsoft 365 E5</code> 订阅 <code>office</code> 与自动续订</h1><blockquote><p>说明：使用<code>Microsoft 365 E5</code>免费订阅<code>office</code>以及通过<code>github</code>的<code>KeepAliveE5</code>项目定时续期</p></blockquote><h2 id="注册与激活E5账号"><a href="#注册与激活E5账号" class="headerlink" title="注册与激活E5账号"></a>注册与激活<code>E5</code>账号</h2><blockquote><p>注意：下述操作涉及到登录微软官方地址，中途需要使用到谷歌的人机验证，请自行准备好网络环境来访问这些官网。同时需要准备一个微软账号，且安装的时候确保电脑当中没有 <code>office</code>产品，以免安装 <code>microsoft 365</code>失败</p></blockquote><ol><li><p>首先来到<code>microsoft 365</code> 开发人员中心的<a href="https://developer.microsoft.com/en-us/microsoft-365/dev-program">官网</a>：<a href="https://developer.microsoft.com/en-us/microsoft-365/dev-program%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%8C%E9%80%89%E6%8B%A9%E7%AB%8B%E5%8D%B3%E5%8A%A0%E5%85%A5">https://developer.microsoft.com/en-us/microsoft-365/dev-program，如下图，选择立即加入</a></p><img src="/2023/03/25/tools/keep-alive-e5/join_e5.png" class="" title="join_e5"></li><li><p>之后会跳转到需要登陆<code>microsoft</code>账号页面，选择登录账号.</p><img src="/2023/03/25/tools/keep-alive-e5/sign_in_microsoft_account.png" class="" title="sign_in_microsoft_account"></li><li><p>再登录账号之后，会出现页面填写加入计划的详细信息，这里根据自己的实际情况填写即可。（公司部分可以虚拟，此处不会验证公司配置）。</p><img src="/2023/03/25/tools/keep-alive-e5/setting_01.png" class="" title="setting_01"></li><li><p>之后作为开发人员最关注的是什么，根据实际情况随意选择一个</p><img src="/2023/03/25/tools/keep-alive-e5/setting_02.png" class="" title="setting_02"></li><li><p>感兴趣的开发领域也随意选择即可</p><img src="/2023/03/25/tools/keep-alive-e5/setting_03.png" class="" title="setting_03"></li><li><p>之后就会跳转到设置<code>E5</code>订阅</p><img src="/2023/03/25/tools/keep-alive-e5/setting_04.png" class="" title="setting_04"></li><li><p>之后开始填写表单中的信息，<strong>注意这里设置的用户名和创建域会影响到图片中红色圈圈部分的注册的E5账户号名和二级域名</strong>。</p><img src="/2023/03/25/tools/keep-alive-e5/setting_00.png" class="" title="setting_00"></li><li><p>之后，就是设置电话号码。可选择填写国内手机号（<code>China(+86)</code>，<strong>此处就需要谷歌认证了请自行准备好网络环境</strong>）。</p><img src="/2023/03/25/tools/keep-alive-e5/setting_05.png" class="" title="setting_05"></li><li><p>之后就正常登录到开发人员页面了，随后来到<code>admin.microsoft.com</code>来到管理面板。这个时候需要登录刚刚注册的<code>microsoft</code>账号（也就是刚刚配置的<code>E5</code>开发者账号，也就是第八步中红框设定好的域名账号）。</p></li><li><p>登录完成后，选择左边菜单栏中的用户下的活跃用户选项</p><img src="/2023/03/25/tools/keep-alive-e5/setting_06.png" class="" title="setting_06"></li><li><p>勾选自己的账号，然后选择上方的“管理产品许可证”，在弹出的右侧菜单栏中出现的所有许可证都选上然后保存更改</p><img src="/2023/03/25/tools/keep-alive-e5/setting_07.png" class="" title="setting_07"></li></ol><h2 id="下载与激活office"><a href="#下载与激活office" class="headerlink" title="下载与激活office"></a>下载与激活<code>office</code></h2><ol><li><p>来到微软的<a href="https://www.office.com/">官网</a> <a href="https://www.office.com/">https://www.office.com/</a></p><p>登录刚刚注册的E5账号（注意是刚刚注册的E5账号，而不是最开始的微软账号）。</p><img src="/2023/03/25/tools/keep-alive-e5/setting_08.png" class="" title="setting_08"></li><li><p>之后选择右上角的选择，安装<code>office</code>，然后选择 <code>office 365</code> 应用</p><img src="/2023/03/25/tools/keep-alive-e5/setting_09.png" class="" title="setting_09"></li><li><p>之后就下载一个安装软件，下载完成后点击安装运行，会自动安装office 365，再等待安装完成之后，登录之前注册的E5账号即可完成自动激活。</p><img src="/2023/03/25/tools/keep-alive-e5/setting_10.png" class="" title="setting_10"></li></ol><h2 id="使用github-action来自动续订E5"><a href="#使用github-action来自动续订E5" class="headerlink" title="使用github action来自动续订E5"></a>使用<code>github action</code>来自动续订<code>E5</code></h2><ol><li><p>登录<code>github</code>官网，选择账号下面的<code>settings</code>选项。</p><img src="/2023/03/25/tools/keep-alive-e5/active_setting_00.png" class="" title="active_setting_00"></li><li><p>然后点击最下面的<code>Developer settings</code>选项。</p><img src="/2023/03/25/tools/keep-alive-e5/active_setting_01.png" class="" title="active_setting_01"></li><li><p>然后选择 <code>personal accsee tokens</code>，点击 <code>Generate new token</code> 新建 <code>token</code>。保存好新生成的<code>token</code>。</p><img src="/2023/03/25/tools/keep-alive-e5/active_setting_02.png" class="" title="active_setting_02"><img src="/2023/03/25/tools/keep-alive-e5/active_setting_03.png" class="" title="active_setting_03"><img src="/2023/03/25/tools/keep-alive-e5/active_setting_04.png" class="" title="active_setting_04"></li><li><p>搜索<a href="https://github.com/vcheckzen/KeepAliveE5"><code>KeepAliveE5</code></a>项目，并导入到自己的存储库。导入完成后跳转到自己的仓库。</p><img src="/2023/03/25/tools/keep-alive-e5/active_setting_05.png" class="" title="active_setting_05"><p>复制项目的 <code>code</code> ，选择头像旁边的+号导入自己的仓库。</p><img src="/2023/03/25/tools/keep-alive-e5/active_setting_06.png" class="" title="active_setting_06"><img src="/2023/03/25/tools/keep-alive-e5/active_setting_07.png" class="" title="active_setting_07"><img src="/2023/03/25/tools/keep-alive-e5/active_setting_08.png" class="" title="active_setting_08"><p>导入完成后，可以点击跳转到自己项目</p><img src="/2023/03/25/tools/keep-alive-e5/active_setting_09.png" class="" title="active_setting_09"></li><li><p>开启<code>Action</code>功能。进入到项目的<code>settings</code>选项，选择<code>Actions</code>选项中的 <code>General</code>，将Actions permissions 选项设置为第一个 <code>Allow all actions and reusable workflows</code>选项，然后点击<strong>保存</strong>。</p><img src="/2023/03/25/tools/keep-alive-e5/active_setting_10.png" class="" title="active_setting_10"></li><li><p>之后继续在<code>Settings</code>里选择 <code>Secrets and variables</code>选项，点击 <code>Actions</code>，点击 <code>new repository secret</code> 选项。之后配置三个密钥，<code>PAT</code>就是上一步第三步生成的<code>token</code>，<code>USER</code>就是你的<code>E5</code>账号，<code>PASSWD</code>就是你的<code>E5</code>账号的密码，然后<code>Add secret</code>分别设置添加这三个密钥。</p><img src="/2023/03/25/tools/keep-alive-e5/active_setting_11.png" class="" title="active_setting_11"><img src="/2023/03/25/tools/keep-alive-e5/active_setting_13.png" class="" title="active_setting_13"><p>上述三个配置在项目的<code>README</code>中也可以看到</p><img src="/2023/03/25/tools/keep-alive-e5/active_setting_12.png" class="" title="active_setting_12"></li><li><p>之后根据<a href="https://learn.microsoft.com/zh-cn/azure/active-directory/fundamentals/concept-fundamentals-security-defaults#disabling-security-defaults">微软禁用安全默认值教程</a>禁用安全默认值</p><ol><li><p>以安全管理员、条件访问管理员或全局管理员身份登录到 <a href="https://azure.microsoft.com/zh-cn/">Azure</a></p><img src="/2023/03/25/tools/keep-alive-e5/active_setting_14.png" class="" title="active_setting_14"></li><li><p>点击 <code>Azure active directoty</code> 选择 <strong>属性</strong></p></li><li><p>选择 <strong>管理安全默认值</strong></p></li><li><p>将 <strong>启用安全默认值</strong> 切换为 <strong>否</strong></p></li><li><p>选择 保存</p><img src="/2023/03/25/tools/keep-alive-e5/active_setting_15.png" class="" title="active_setting_15"></li></ol></li><li><p>启用<code>Action</code>的注册<code>APP</code>工作流，进入到<code>Action</code>点击 <code>Register APP</code>，点击右侧的<code>Run workflow</code>，分支就选择当前项目的主分支，然后点击 <code>Run workflow</code> 运行注册流程。</p><img src="/2023/03/25/tools/keep-alive-e5/active_setting_16.png" class="" title="active_setting_16"></li><li><p>然后等待一会，等待期间可以点击进去看运行的日志，运行到什么步骤了，完成后点击日志中的 <code>Register app</code> 那一步。 如果最后显示是注册成功就可以了。</p><img src="/2023/03/25/tools/keep-alive-e5/active_setting_17.png" class="" title="active_setting_17"><img src="/2023/03/25/tools/keep-alive-e5/active_setting_18.png" class="" title="active_setting_18"><img src="/2023/03/25/tools/keep-alive-e5/active_setting_20.png" class="" title="active_setting_20"></li><li><p>启用 <code>Action</code> 的调用 <code>API</code> 工作流。进入到 <code>Action</code> 点击 <code>invoke API</code>，点击右侧 <code>Run workflow</code>， 分支就选择当前项目的主分支，点击 <code>Run workflow</code> 运行调用流程。</p><img src="/2023/03/25/tools/keep-alive-e5/active_setting_19.png" class="" title="active_setting_19"></li><li><p>然后等待一会，等待期间可以点击进去看运行的日志，运行到什么步骤了，完成后点击日志中的 <code>Test Api</code> 那一步。可以看到最后已经成功了。</p><img src="/2023/03/25/tools/keep-alive-e5/active_setting_21.png" class="" title="active_setting_21"><img src="/2023/03/25/tools/keep-alive-e5/active_setting_22.png" class="" title="active_setting_22"></li><li><p>后面之歌工作流就会每天自动调用<code>API</code>，保证账号是使用的，从而得到微软的自动续期。</p></li></ol><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java核心技术——卷1</title>
      <link href="/2022/06/28/java/core-java-volume-0/"/>
      <url>/2022/06/28/java/core-java-volume-0/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA核心技术——卷1"><a href="#JAVA核心技术——卷1" class="headerlink" title="JAVA核心技术——卷1"></a>JAVA核心技术——卷1</h1><blockquote><p>说明：java核心技术 —— 卷Ⅰ</p><p>当然这本书很厚，讲解的也很详细。所有呢，我没有准备将所有的知识点在我的这份文章中书写记录，在这里只记录部分我觉得需要备忘的知识。</p><p><a href="https://github.com/RobertSunq/data/tree/master/qing/blog/hexo/corejava/book/api">书中涉及到的java基础类和接口的解析链接</a></p><p><a href="https://github.com/RobertSunq/data/tree/master/qing/blog/hexo/corejava/book/code">书中涉及到的示例代码链接</a> 拷贝自 <a href="http://horstmann.com/corejava">http://horstmann.com/corejava</a></p></blockquote><h2 id="Java程序设置环境"><a href="#Java程序设置环境" class="headerlink" title="Java程序设置环境"></a>Java程序设置环境</h2><h3 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h3><blockquote><p><a href="https://www.oracle.com/java/technologies/downloads/">download-link</a></p><p>以下以 <code>jdk_path</code> 代表 <code>java</code> 安装目录</p></blockquote><table><thead><tr><th>术语</th><th>缩写</th><th>解释</th></tr></thead><tbody><tr><td>Java Development Kit (Java开发工具包)</td><td>JDK</td><td>编写Java程序的程序员使用的软件</td></tr><tr><td>Java Runtime Enviroment (Java运行时环境)</td><td>JRE</td><td>运行Java程序的用户使用的软件</td></tr><tr><td>Server JRE (服务器JRE)</td><td>——</td><td>在服务器上运行Java程序的软件</td></tr><tr><td>Standard Edition (标准版)</td><td>SE</td><td>用于桌面或简单服务器应用的Java平台</td></tr><tr><td>Enterprise Edition (企业版)</td><td>EE</td><td>用于复杂服务器应用的Java平台</td></tr><tr><td>Micro Edition (微型版)</td><td>ME</td><td>用于小型设备的Java平台</td></tr><tr><td>Java FX</td><td>——</td><td>用于图形化用户界面的一个备选工具包，在Java 11之前的某些Java SE发布版本中提供</td></tr><tr><td>OpenJDK</td><td>——</td><td>Java SE的一个免费开源实现</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="设置JDK"><a href="#设置JDK" class="headerlink" title="设置JDK"></a>设置JDK</h3><h4 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a>安装目录</h4><ul><li><p>在Windows中，设置自定义的安装目录，配置好环境变量即可。(最好路径中不要存在空格和中文)</p><ul><li>环境变量的配置略</li></ul></li><li><p>在Mac中，运行安装程序。会把软件安装到 <code>/Library/Java/JavaVirtualMachines/jdk-11.0.x.jdk/Contents/Home</code>。 通过 <code>which java</code> 查找</p></li><li><p>在Linux中</p><ul><li>使用 <code>.tar.gz</code>文件解压到选择的目录即可。 eg. <code>/opt</code></li><li>使用 <code>RPM</code> 文件安装， 需要检查是否安装在  <code>/usr/java/jdk-11.0.x</code> 目录</li><li>环境变量的配置：在 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code> 文件的最后一行添加 export <code>PATH=/usr/java/jdk-11.0.x/bin:$PATH</code></li></ul></li></ul><h4 id="安装库源文件和文档"><a href="#安装库源文件和文档" class="headerlink" title="安装库源文件和文档"></a>安装库源文件和文档</h4><p><strong>库源文件</strong></p><ol><li><p>确保JDK已经安装，而且<code>jdk_path/bin</code> 目录在可执行路径中</p></li><li><p>在主目录(<code>jdk_path</code>)中建立一个目录 <code>javasrc</code> 。 </p></li><li><p>将 <code>jdk_path/lib/zip</code> 解压到 <code>javasrc</code> 目录中 </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ cd jdk_path[root@qing centos]$ mkdir javasrc[root@qing centos]$ cd javasrc[root@qing centos]$ jar xvf jdk_path/lib/zip[root@qing centos]$ cd ..<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p>src.zip 文件中包含了所有公共类库的源代码。获取更多的源代码（编译器、虚拟机、原生方法、私有辅助类）, 访问 <a href="https://openjdk.org/">https://openjdk.org/</a></p></blockquote><p> <strong>文档</strong> </p><ol><li>文档包含在一个压缩文件中，独立于JDK，可以直接从 <a href="https://www.oracle.com/java/technologies/downloads">https://www.oracle.com/java/technologies/downloads</a> 中下载对应版本的文档</li><li>解压压缩包并重命名</li><li>在浏览器中导航到 jdk_path/javadoc/index.html</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ cd jdk_path[root@qing centos]$ jar xvf jdk-11.0.15.1_doc-all.zip[root@qing centos]$ mv docs javadoc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="运行一个程序"><a href="#运行一个程序" class="headerlink" title="运行一个程序"></a>运行一个程序</h3><ol><li>编写如下 Welcome.java 文件</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">book<span class="token punctuation">.</span>v1ch02</span><span class="token punctuation">;</span><span class="token comment">/** * @author: Robert Sunq * @date: 2022-06-29 0:03 * @since: JDK-11 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Welcome</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> greeting <span class="token operator">=</span> <span class="token string">"Welcome to Core Java!"</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> greeting<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>shell 中键入 <code>javac .\book\v1ch02\Welcome.java</code> <ol><li>如果你的代码中没有添加 <code>package</code> 则去掉命令中的路径，并在文件所在的目录下运行该命令</li><li>注意需要包含文件类型<code>.java</code></li></ol></li><li>键入  <code> java book.v1ch02.Welcome</code>  <ol><li>如果你的代码中没有添加 <code>package</code> 则不需要键入全路径来运行程序</li><li>出现错误<code>java.lang.ClassNotFoundException: ImageViewer</code> 则有可能是时引入<code>package</code>的原因，导致找不到 <code>.class</code> 文件来运行</li><li>注意 不要包含编译后的文件名 <code>.class</code></li></ol></li></ol><h3 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h3><p>Java 9引入了另一种使用Java的方法。<strong>JShell</strong>程序提供一个“读取-计算-打印循环”（Read-Evaluate-Print Loop, REPL）。键入一个Java表达式；JShell会自动评估输入，打印结果，等待下一个输入。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 键入在配置后java的全局环境后，键入 jshell 进入，之后会显示问候符[root@qing centos]$ jshell|  欢迎使用 JShell -- 版本 11.0.15.1|  要大致了解该版本, 请键入: /help intro# 键入表达式，将还会输入结果，即使没有键入 System.out.printlnjshell&gt; "core java".length()$1 ==&gt; 9# 之后可使用输出的变量名 $1 来使用于之后的计算jshell&gt; 5 * $1 - 3$2 ==&gt; 42# 当然也可以自定义变量jshell&gt; int a = 4a ==&gt; 4jshell&gt; aa ==&gt; 4# 键入部分名称后，可与使用  `tab` 来进行补全jshell&gt; MathMath          MathContext签名:java.lang.Math&lt;再次按 Tab 可查看文档&gt;jshell&gt; Math.E                 IEEEremainder(    PI                abs(              acos(             addExact(         asin(             atan(             atan2(            cbrt(             ceil(             classcopySign(         cos(              cosh(             decrementExact(   exp(              expm1(            floor(            floorDiv(         floorMod(         fma(              getExponent(      hypot(incrementExact(   log(              log10(            log1p(            max(              min(              multiplyExact(    multiplyFull(     multiplyHigh(     negateExact(      nextAfter(        nextDown(nextUp(           pow(              random()          rint(             round(            scalb(            signum(           sin(              sinh(             sqrt(             subtractExact(    tan(tanh(             toDegrees(        toIntExact(       toRadians(        ulp(jshell&gt; Math.llog(     log10(   log1p(# 当然和常用的 shell 窗口一样 可与使用方向键来调整光标和查看历史命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Java的基本程序设计结构"><a href="#Java的基本程序设计结构" class="headerlink" title="Java的基本程序设计结构"></a>Java的基本程序设计结构</h2><h3 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h3><ul><li><strong>Java中区分大小写</strong></li><li>类的命名请遵循 <strong>驼峰法</strong></li><li>java虚拟机总是从 <strong>main</strong> 方法的代码作为类的执行入口</li><li>java中的注释有两种形式 <code>\\</code> 和 <code>\*  *\</code></li><li>Java 时一种 <strong>强类型语言</strong>，所以必须为每个变量声明一种类型</li></ul><h4 id="类型说明"><a href="#类型说明" class="headerlink" title="类型说明"></a>类型说明</h4><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th><th>包装类型</th></tr></thead><tbody><tr><td><code>int</code></td><td>4(字节)</td><td>-2147483648 — 2147483647</td><td><code>Integer</code></td></tr><tr><td><code>short</code></td><td>2</td><td>-32768 — 32767</td><td><code>Short</code></td></tr><tr><td><code>long</code></td><td>8</td><td>-9223372036854775808 — 9223372036854775807</td><td><code>Long</code></td></tr><tr><td><code>byte</code></td><td>1</td><td>-128 — 127</td><td><code>Byte</code></td></tr><tr><td><code>float</code></td><td>4</td><td>+- 3.40282347E+23F(有效位数 6~7 位)</td><td><code>Float</code></td></tr><tr><td><code>double</code></td><td>8</td><td>+- 1.79769313486231570E+308(有效位数 15位)</td><td><code>Double</code></td></tr><tr><td><code>char</code></td><td>1</td><td></td><td><code>Char</code></td></tr><tr><td><code>boolean</code></td><td>1</td><td><code>false</code>  <code>true</code></td><td><code>Boolean</code></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li><p><strong><code>String</code></strong></p><ul><li>字符串，使用<code> ""</code> 包含起来的字符。 </li><li><strong>不可变</strong>，表示该对象中的值时不能修改的。<code>String greeting = "hello"; greeting = greeting.substring(0,3) + "p!";</code>注意这里字符串 <code>"hello"</code>是永远包含这几个代码单元序列的，并不能修改。第二步中只是使 <code>greeting </code> 引用向了另一个字符串而已。如同原本存放<code>3</code>数值变量的地方存放上了<code>4</code>.</li><li>不可变字符串的优点：<strong>编译器可以让字符串共享</strong>，字符串存放在公共的存储池中。</li><li>注意检测相等时用 :  <code>s.equals(t)</code> 比较字符串字面量上的相等； 如果使用 <code>==</code> 运算符则会检测两个字符串是否存放再同一个位置上，即是否引用向同一个内存地址，如果两个字符串再同一个位置必然相等，但是也有可能将内容相等的多个字符串副本放置到不同的位置上，所以<strong>千万不要</strong>使用 <code>== </code>来测试字符串的相等。</li></ul></li><li><p><code>Long</code></p><ul><li>长整型数值有一个后缀<code>L</code>或<code>l</code>（<code>40000000L</code>）。</li><li>十六进制数值有一个前缀<code>0x</code>或<code>0X</code>（<code>0xFFE</code>）。</li><li>八进制数值有一个前缀<code>0</code>（<code>010</code>）。</li><li>二进制数值有一个前缀<code>0b</code>或<code>0B</code>（<code>0b1001</code>）。Java7之后</li><li>还可以在数字字面量加下划线，<code>1_000_000</code>(或 `0b1111_0100_0010_0100_0000)表示100万。当然Java编译器在编译后会去除这些下划线。</li><li>注意：Java 没有任何无符号（<code>unsigned</code>）形式的<code>int long short byte</code>类型。</li></ul></li><li><p><code>Double</code>和<code>Float</code></p><ul><li><code>float</code>类型的数值只有一个后缀<code>F</code>或<code>f</code>（<code>3.14</code>）。通常都是使用<strong>双精度数值</strong><code>double</code>类型。只有少数情况会使用<code>float</code>，比如：需要<strong>单精度</strong>的库或者大量存储数据。</li><li>没有后缀的浮点数值（3.14）默认为<code>double</code>类型。当然也可以添加后缀<code>D</code>或<code>d</code>（<code>3.14D</code>）</li><li>也可以使用十六进制表示浮点数。<code>0.125 = 0x1.0p-3</code>，在十六进制表示中 <code>p</code>表示指数，而不是<code>e</code>。注意，尾数采用十六进制，指数采用十进制。指数的基数是<code>2</code>，而不是<code>10</code>。</li></ul></li><li><p><code>Unicode</code>和<code>Char</code></p><ul><li><code>... ...</code></li></ul></li></ul><h4 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h4><ol><li><p>变量</p><ul><li><p>声明与定义</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">double</span> salary<span class="token punctuation">;</span><span class="token keyword">int</span> vacationDays<span class="token punctuation">;</span>vacationDays <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>从 <code>Java 10 </code>开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不需要在声明类型了，只需要使用关键字 <code>var</code> 而无需指定类型</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> vacationDays <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span><span class="token keyword">var</span> greeting <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li><p>常量</p><ul><li>使用关键字 <code>final</code>来指示常量。</li><li>关键字 <code>final</code>表示这个变量只能被赋值一次。</li><li>使用关键字 <code>static final</code>设置一个<strong>类常量</strong>，可以在一个类的多个方法中使用。如果被声明为 <code>public</code> 那么其他类也可以使用这个常量。</li></ul></li><li><p>枚举</p><ul><li><p>自定义<strong>枚举类型</strong>。<strong>枚举类型</strong>包括<strong>有限</strong>个命名的值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">enum</span> <span class="token class-name">Size</span> <span class="token punctuation">{</span>SMALL<span class="token punctuation">,</span> MEDIUM<span class="token punctuation">,</span> LARGE<span class="token punctuation">,</span> EXTRA_LARGE<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Size</span> s <span class="token operator">=</span> <span class="token class-name">Size</span><span class="token punctuation">.</span>MEDIUM<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><code>+</code> 加 、<code>-</code> 减、 <code>*</code> 乘、 <code>%</code>  取余</li><li><code>/</code> 除<ul><li>使用关键字 <code>strictfp</code> 修饰类或者方法，表示类或者方法中将采用<strong>严格的浮点运算</strong>，即所有中的中间计算都进行截断为64位计算。<code>double x * y / z;</code> <code>x*y</code>将计算结果截取保存在64位寄存器中， 之后在除以<code>z</code> 将计算结果截取保存到64位寄存器中</li></ul></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><code>int n = 123456; long m = n;</code></p><img src="/2022/06/28/java/core-java-volume-0/convert.png" class="" title="类型转换"><p><strong>强制类型转换</strong></p><p>符合上图的类型转换会走到那个进行转换，如果进行反方向的就需要进行<strong>强制类型转换</strong>（cast）来完成，当然会有可能损失信息。</p><p><code>double x = 9.997; int nx = (int) x; // nx = 9</code></p><h4 id="关系比较符"><a href="#关系比较符" class="headerlink" title="关系比较符"></a>关系比较符</h4><p><code>&lt;</code> 、<code>&gt;</code>、<code>=</code>、<code>&lt;=</code>、<code>&gt;=</code></p><h4 id="逻辑比较符"><a href="#逻辑比较符" class="headerlink" title="逻辑比较符"></a>逻辑比较符</h4><p><code>&amp;&amp;</code>、<code>||</code>、<code>!</code></p><p>三元表达试： <code>condition ? expression1 : expression2</code></p><p>注意：在逻辑运算中，是按照<strong>短路</strong>方式来求值的。</p><ul><li><code>2 != 1 &amp;&amp; 3 != 2</code> 第一个表达式已经是<code> false</code>时 不会再计算第二个表达式</li><li><code>1 == 1 || 3 != 2</code> 第一个表达式已经是<code> true</code>时 不会再计算第二个表达式</li></ul><p><strong>位运算符</strong></p><p>处理整型类型时，可以直接对成组整数的各个位完成操作。可以使用掩码技术得到整数中的各个位。</p><p><code>&amp;</code> 与、<code>|</code> 或、<code>^</code> 同或 、<code>~</code> 按位取反、</p><p><code>&gt;&gt;</code> 右移，包含移动符号位，使用符号位填充高位</p><p><code>&lt;&lt;</code>左移，低位补 0</p><p><code>&gt;&gt;&gt;</code>无符号右移，高位填充 0</p><h4 id="联机文档"><a href="#联机文档" class="headerlink" title="联机文档"></a>联机文档</h4><blockquote><p>link : <a href="https://docs.oracle.com/en/java/javase/11/docs/api/index.html">https://docs.oracle.com/en/java/javase/11/docs/api/index.html</a></p></blockquote><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>读取“标准输入流” <code>System.in</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InputTest</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * @see book.api.ScannerApi     * @see book.api.SystemApi     * @see book.api.ConsoleApi     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 读取下一行，以回车作为分隔符，中断读入 (输入行中包括空格，也不会中断读入)</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你的名字是: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> name <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 读取一个单词， 空白符作为分隔符，中断读入</span>        <span class="token comment">//  String next = scanner.next();</span>        <span class="token comment">// 读取一个整数</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你多大了: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> age <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你好， "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">". 明年，你将 "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>age <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Java6 之后引入 console 从控制台读取隐形的密码输入。 IDEA 运行 System.console() 返回null时 用命令 javac 编译后  命令java 运行</span><span class="token comment">//        Console console = System.console();</span><span class="token comment">//        String username = console.readLine("用户名： ");</span><span class="token comment">//        char[] passwd = console.readPassword("密码: ");</span><span class="token comment">//        System.out.println("username : " + username + "密码 : "+ String.valueOf(passwd));</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><ul><li><code>System.out.println(x)</code><ul><li>将数值 <code>x</code>输出到控制台</li></ul></li><li><code>System.out.println(“Hello, %s. Next year, you'll be %d", name, age)</code><ul><li>以 <code>%</code> 字符开始的 **格式说明符 **都用后面相应的参数替换</li></ul></li></ul><p><strong>用于<code>printf</code>转换符</strong></p><table><thead><tr><th>转换符</th><th>类型</th><th>示例</th></tr></thead><tbody><tr><td><code>d</code></td><td>十进制整数</td><td>100</td></tr><tr><td><code>x</code></td><td>十六进制整数</td><td>9f</td></tr><tr><td><code>o</code></td><td>八进制整数</td><td>200</td></tr><tr><td><code>f</code></td><td>定点浮点数</td><td>10.9</td></tr><tr><td><code>e</code></td><td>指数浮点数</td><td>1.59e+01</td></tr><tr><td><code>g</code></td><td>通用浮点数(<code>e </code>和<code>f</code>中较短的一个)</td><td>—–</td></tr><tr><td><code>a</code></td><td>十六进制浮点数</td><td>0x1.fccdp3</td></tr><tr><td><code>s</code></td><td>字符串</td><td>Hello</td></tr><tr><td><code>c</code></td><td>字符</td><td>H</td></tr><tr><td><code>b</code></td><td>布尔</td><td><code>true</code></td></tr><tr><td><code>h</code></td><td>散列码</td><td>43423</td></tr><tr><td><code>%</code></td><td>百分号</td><td>%</td></tr><tr><td><code>n</code></td><td>行分隔符</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><strong>用于<code>printf</code>的标志</strong></p><table><thead><tr><th>转换符</th><th>类型</th><th>示例</th></tr></thead><tbody><tr><td><code>+</code></td><td>打印正数和负数的符号</td><td>+2333.333</td></tr><tr><td><code>空格</code></td><td>在正数之前添加空格</td><td>|  2333.33|</td></tr><tr><td><code>0</code></td><td>数字前面补 0</td><td>002333.33</td></tr><tr><td><code>-</code></td><td>左对齐</td><td>|233.33  |</td></tr><tr><td><code>(</code></td><td>将负号括在括号内</td><td>(2333.33)</td></tr><tr><td><code>,</code></td><td>添加分组分隔符</td><td>2,333,33</td></tr><tr><td><code>#</code>(对于 <code>f</code> 格式)</td><td>包含小数点</td><td>3,333.</td></tr><tr><td><code>#</code>(对于 <code>x</code> 或 <code>0</code> 格式)</td><td>添加前缀 <code>0x</code> 或 <code>0</code></td><td>0xcafc</td></tr><tr><td><code>$</code></td><td>指定要格式化的参数索引。<br>eg. <code>%1$d %1$x</code>将以十进制和十六进制格式打印第一个参数<br><strong>注意 参数索引从 <code>1</code> 开始而不是 <code>0</code></strong></td><td>159 9F</td></tr><tr><td><code>&lt;</code></td><td>格式化前面加说明的数值。<br>eg. <code>%d%&lt;x</code>将以十进制和十六进制格式打印同一个数值</td><td>159 9F</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><blockquote><p>可以使用 <code>s</code> 转换符格式化任意的对象。对于实现了 <code>formattable</code> 接口的任意对象，将调用这个对象的 <code>formatTo</code> 方法；否则将对这个对象转换位字符串。即调用 <code>toString</code>方法。</p></blockquote><ul><li>对于上述的格式化字符串，也可以使用静态的 <code>String.format</code> 方法创建一个格式化的字符串</li></ul><p><strong>日期和时间的转换符</strong></p><p><code>printf</code>中的日期和时间格式化选项，已经过时，所以暂时不总结。替换方案 <code>java.time</code></p><table><thead><tr><th>转换符</th><th>类型</th><th>示例</th></tr></thead><tbody><tr><td><code>tx</code> 或 <code>tx</code></td><td>时间日期(<code>T</code>强制大写)</td><td>—-</td></tr><tr><td><code>tc</code></td><td>完整的日期和时间</td><td>周五 7月 15 00:15:46 CST 2022</td></tr><tr><td>—-</td><td>—-</td><td>—-</td></tr></tbody></table><img src="/2022/06/28/java/core-java-volume-0/printf_format.png" class="" title="格式化输出"><h4 id="文件输入和输出"><a href="#文件输入和输出" class="headerlink" title="文件输入和输出"></a>文件输入和输出</h4><p>读取文件，也是构造一个<code>Scanner</code>对象，如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Scanner</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">Path</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"myfile.txt"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 如果文件名中包含反斜杠符号，需要使用双反斜杠："c:\\mydirectory\\myfile.txt"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出文件，需要构造一个<code>PrintWriter</code>对象，在构造器中需要提供文件名和字符编码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token string">"myfile.txt"</span><span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>当指定一个相对文件名时，eg. “dir/myfile.txt” or “../myfile.txt”，文件位置时相对于<strong>Java</strong></p><p><strong>虚拟机</strong>启动目录的位置。</p><p>如果在命令行方式下执行 <code>java MyProg</code> 启动目录就是命令解释器的房前目录。</p><p>如果是集成开发环境，那么启动目录由IDE控制，使用 <code>String dir = System.getProperty("user.dir");</code>获取到调用的目录。</p><p>当然也可以使用据对路径。</p></blockquote><h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><h4 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/* 块作用域 */</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> k<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment">// k 的作用域只在 块作用域内</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/* 条件语句 */</span>    <span class="token comment">// if (confition) statement</span>    <span class="token comment">// if (confition) statement_1 else statement_2</span>    <span class="token comment">// if (confition_1) statement_1 else if (confition_2) statement_2 else confition_3</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>yourSales <span class="token operator">&gt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1</span>    <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>yourSales <span class="token operator">&gt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// 2</span>    <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>yourSales <span class="token operator">&gt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>yourSales1 <span class="token operator">&gt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 2</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// 3</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/* 循环 */</span>    <span class="token comment">// while (condition) statement</span>    <span class="token comment">// do statement while (confition)</span><span class="token keyword">while</span> <span class="token punctuation">(</span>balance <span class="token operator">&lt;</span> goal<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1</span>    <span class="token punctuation">}</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token comment">// 2</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>balance <span class="token operator">&lt;</span> goal<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="确定循环"><a href="#确定循环" class="headerlink" title="确定循环"></a>确定循环</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">/* 确定循环 */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// i</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/* 多重循环：switch 语句 */</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>choice<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> case 的标签可以是： </p><ul><li>char、byte、short、int的常量表达式；</li><li>枚举常量 <ul><li>可以不必再每个标签中指明枚举名，可以由switch表达式推导出来</li></ul></li><li>字符串字面量</li></ul><blockquote><p>警告：在<code>switch</code>结构中，如果条件可能触发多个<code>case</code>分支，如果在<code>case</code>分支语句的末尾没有<code>break</code>语句，那么就会接着执行下一个<code>case</code>分支语句。这种方式会引发错误。</p><p>如果使用了 <code>switch</code> 语句，在编译代码时可以考虑加上 <code>-Xlint:fallthrough</code> 选项，eg. <code>javac -Xlint:fallthrough Test.java</code>，这样如果某个分支最后缺少一个 <code>break</code> 语句，编译器就会给出一个警告信息。</p><p>如果正好想要使用这种 “直通式” 行为，可以在外围方法上加上一个注解 <code>@SuppressWarnings("fallthrough") </code>，这样就不会针对这个方法产生告警了。</p></blockquote><h4 id="中断控制流程的语句"><a href="#中断控制流程的语句" class="headerlink" title="中断控制流程的语句"></a>中断控制流程的语句</h4><ul><li><code>break</code>：用于退出循环和判断</li><li><code>continue</code>： 将控制转移到最内存循环的首部，即跳出当前循环体的剩余部分，立刻跳转到循环的首部。</li></ul><p>同时，Java 也提供了一种带**标签的<code>break</code>**，用于跳出多重嵌套的循环语句。有时候，在嵌套很深的循环语句中会发生一些不可预料的事情。此时可能更加希望完全跳出所有的嵌套循环之外。</p><p>下面有个示例说明<code>break</code>语句的工作状态。注意：标签必须放在希望跳出的最外层循环之前，并且必须紧跟着一个冒号。</p><blockquote><p>执行带标签的<code>break</code> 会跳转到带标签的语句块的末尾。</p><p>同样在<code>if</code>语句中也可以使用该方式跳出语句块。</p><p>同样也可以用带标签的<code>continue</code>，将跳到与标签匹配的循环首部。</p><p>注意：这里只能跳出语句块，不能跳入语句块。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Scanner</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token comment">// 注意该标签</span>read_data<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 这个循环代码块中由标签标记</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 这个内循环中没有被标记</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" 输入数字 &gt;= 0:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        n <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> n <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span> read_data<span class="token punctuation">;</span>            <span class="token comment">// 中断该标签的循环</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 此语句在标记的break之后立即执行</span><span class="token keyword">if</span> <span class="token punctuation">(</span> n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 检查错误情况</span>    <span class="token comment">// 处理错误情况</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment">// 进行正常处理</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h3><p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用<code>java.math</code>包中的两个类：<code>BigInteger</code> 和 <code>BigDecimal</code>。这两个类可以处理包含任意长度数字序列的数值。</p><p>在使用大数类之后，就不能使用常用的算数运算符(eg. <code>+</code> 和 <code>*</code>)处理大数，而需要使用大数类中的 <code>add</code> 和 <code>multiply</code> 方法</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>存储相同类型值的序列</p></blockquote><h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h4><p>一种数据结构，用来存储同一类型值的集合，通过一个整数下标(<code>index</code>，或称索引)可以访问数组中的每一个值。</p><p>在声明数组变量时，需要指出数组类型（数组元素类型紧跟 <code>[]</code>）和数组变量的名字。</p><blockquote><p>注意：一旦创建了数组，就不能再改变它的长度。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 声明整型数组 a  并未创建</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span><span class="token comment">// or int a[];</span><span class="token comment">// 声明整型数组 a 并创建数组</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 声明并初始化，这个语法中不需要使用 new。 最后一个值后面允许使用逗号</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> small <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 也可以使用 使用 new 初始化</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> anonymous <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// java 中 允许创建有长度为 0 的数组</span><span class="token keyword">new</span> elementType<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h4><p>使用数组下标访问数组 <code>a[n]</code></p><p>在创建：</p><ul><li>数字数组，所有元素都初始化为 <code>0 </code></li><li><code>boolean</code> 数组， 所有元素都初始化 <code>false</code></li><li>对象数组，所有元素都初始化为 <code>null</code></li></ul><h4 id="for-each-循环"><a href="#for-each-循环" class="headerlink" title="for each 循环"></a><code>for each</code> 循环</h4><p><code>java</code> 中也可以使用语法糖来遍历数组中的每个元素</p><p><code>for (variable : collection) statement</code></p><p>当然<code>collection</code> 这以及和表达式必须是一个数组或者是一个实现了 <code>Iterable</code> 接口的类对象(eg. <code>ArrayList</code>)</p><blockquote><p><code>for each</code>循环语句的驯化变量将会遍历数组中的每个元素，而不是下标值。</p></blockquote><h4 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 允许将一个数组变量拷贝到另一个数组变量中，这时，</span><span class="token comment">// 两个变量将引用同一个数组， 因为这里是指向同一块内存空间。</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> smallPrimes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> luckyNumers <span class="token operator">=</span> smallPrimes<span class="token punctuation">;</span><span class="token comment">// 如果希望将一个数组的所有值拷贝到一个新的的胡祖中，要使用 Arrays 类的 copyOf 方法</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> copiedLuckyNumbers <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>luckyNumbers<span class="token punctuation">,</span> luckyNumbers<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 也可以使用这种方法来增大数组的大小</span>luckyNumbers <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>luckyNumbers<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> luckyNumbers<span class="token punctuation">.</span>length<span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><blockquote><p>每一个 <code>Java</code> 应用程序都有一个带 <code>String arg[]</code> 参数的 <code>main</code> 方法。 这个参数表明 <code>mian</code> 方法将接收一个字符串数组，也就是命令行上指定的参数。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Message</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"-h"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello,"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"-g"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Goodbye,"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" "</span> <span class="token operator">+</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果使用下面的形式调用这个程序</p><p><code>java Message -g cruel world</code></p><p><code>args</code> 数组将包含以下内容 ：<code>args[0] = "-g", args[0] = "cruel", args[0] = "world"</code></p><p>这个程序会显示下面的消息：</p><p><code>Goodbye, cruel world!</code></p><blockquote><p>再 <code>Java</code> 应用程序的<code>main</code>方法中，程序名并没有存储再 <code>args</code> 数组中。例如，当从命令行使用下面的命令运行程序时 ： <code>java Message -h world</code>  <code>args[0]</code> 是 <code>"-h"</code>, 而不是 <code>Message</code> 或 <code>java</code></p></blockquote><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><p>相对数值类型数组进行排序，可以使用 <code>Arrays</code> 类中的 <code>sort</code> 方法： <code>Arrays.sort(new int[1000]{...})</code> 这个方法使用了<strong>优化的快速排序</strong>(QuickSort)算法</p><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> magicSquare <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>for each</code> 循环语句不能自动处理二维数组的每一个元素。它会循环处理行，而这些行本身是一个一维数组。访问所有元素，需要使用两个嵌套的循环：</p><p>for (double[] row : a)</p><p>​for (double value : row)</p><p>​do something with value</p></blockquote><blockquote><p>想要快速打印一个二维数组的数据元素列表，可以调用 <code>System.out.println(Arrays.deepToString(a));</code></p></blockquote><h4 id="不规则数组"><a href="#不规则数组" class="headerlink" title="不规则数组"></a>不规则数组</h4><p><strong><code>Java</code>实际上没有多维数组</strong>，只有一维数组，多维数组又被解释为”数组的数组“</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> odds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>N_MAX <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;=</span> N_MAX<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    odds<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 生成一个三角形数据结构</span><span class="token comment">// 0</span><span class="token comment">// 0 0</span><span class="token comment">// 0 0 0</span><span class="token comment">// 0 0 0 0</span><span class="token comment">// 0 0 0 0 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h2><img src="/2022/06/28/java/core-java-volume-0/opp.png" class="" title="面向对象"><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><strong>类</strong><ul><li>构造对象的模板或蓝图</li><li>由类<strong>构造</strong>对象的过程称之为创建类的<strong>实例</strong></li></ul></li><li><strong>封装</strong><ul><li>处理对象的一个重要改变，将数据和行为组合在一个包中。</li><li>对象中的数据称为<strong>实例字段</strong>，操作数据的过程称为<strong>方法</strong>。</li></ul></li></ul><h3 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h3><ul><li><p><strong>结构示意</strong></p><blockquote><p>在一个源文件中，只能由一个公共类，但可以由任意数目的非公共类。 </p></blockquote><ul><li>构造器与类名相同</li><li>每个类可以由一个及以上的构造器</li><li>构造器可以由0个，1个或多个参数</li><li>构造器没有返回值</li><li>构造器总是伴随着<code>new</code>操作符调用</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ClassName</span> <span class="token punctuation">{</span>    field1<span class="token punctuation">;</span>    field2<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>        constructor1<span class="token punctuation">;</span>    contructor2<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>        method1<span class="token punctuation">;</span>    method2<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="var关键词"><a href="#var关键词" class="headerlink" title="var关键词"></a><code>var</code>关键词</h4><p>Java 10 之后，如果可以从变量的初始值推导出它们的类型，那么可以用 <code>var</code> 关键字声明<strong>局部变量</strong>，而无须指定类型。注意：<code>var</code> 关键字只能用于方法中的<strong>局部变量</strong>。参数和字段的类型必须声明。</p><h4 id="null引用"><a href="#null引用" class="headerlink" title="null引用"></a><code>null</code>引用</h4><p>如果对<code>null</code>值应用一个方法，会产生一个 <code>NullPointerException</code>异常。</p><p>在 <code>Java 9</code>中，Object类提供了一个判断<code>null</code>的方法：</p><ul><li><p>“宽容型”处理<code>null</code>参数，将其转为一个默认值</p><p><code>String name = Objects.requireNonNullElse(n, "defuale");</code></p></li><li><p>“严格型”直接拒绝<code>null</code>参数</p><p><code>Objects.requireNonNull(n, "The name cannot be null");</code></p><p>会产生一个 <code>NullPointerException</code>异常</p></li></ul><h4 id="基于类的访问权限"><a href="#基于类的访问权限" class="headerlink" title="基于类的访问权限"></a>基于类的访问权限</h4><p>一个方法可以访问<strong>所属类的所有对象</strong>的私有数据。</p><h4 id="final实例字段"><a href="#final实例字段" class="headerlink" title="final实例字段"></a>final实例字段</h4><ul><li>修饰实例字段<ul><li>这样的字段必须在构造对象时初始化，在设置之后，就不能再进行修改。但是如果修饰是一个对象变量，对对象的引用不可以修改，不过这个对象的属性可以更改。</li></ul></li></ul><h3 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h3><ul><li><p>静态变量</p><ul><li>使用<code>static</code>修饰实例字段，这个类所有的实例将共享这个字段，如果被一个实例修改，其他所有实例获取到的也是修改的值。</li></ul></li><li><p>静态常量</p><ul><li>使用<code>static final</code>，类的所有实例共享且不允许被修改。</li></ul></li><li><p>静态方法</p><ul><li>使用<code>static</code>修改方法，只能访问类的静态字段，不能访问类的其他非静态属性</li><li>所需要的参数都需要显式的提供</li></ul></li><li><p>工厂方法</p><ul><li><p>使用静态<strong>工厂方法</strong>来构造对象，代理使用构造方法。例如 ： <code>LocalDate.now</code> 、<code>LocalDate.of</code> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">NumberFormat</span> currencyFormatter <span class="token operator">=</span> <span class="token class-name">NumberFormat</span><span class="token punctuation">.</span><span class="token function">getCurrencyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">NumberFormat</span> percentFormatter <span class="token operator">=</span> <span class="token class-name">NumberFormat</span><span class="token punctuation">.</span><span class="token function">getPercentInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 为什么不使用 NumberFormat 的构造器方法去创建实例呢？这样使用的原因如下：</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>无法命名构造器</p><ul><li>构造器的名字必须与类名相同。但是，这里希望由两个不同的名字，分别得到货币实例和百分比实例。</li></ul></li><li><p>使用构造器时，无法改变所构造对象的类型。</p><ul><li>工厂方法是实际上返回的<code>DecimalFormat</code>类的对象，这是<code>NumberFormat</code>的一个子类（继承内容后续说明）。</li></ul></li></ul></li></ul><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><blockquote><p>Java对对象采用的不是按照引用调用，实际上，<strong>对象引用是按照值传递的</strong></p><p>在传递对象类型的数据时，<strong>方法内获取的是对传递的对象引用的一个副本</strong>，而不是传递的原始对象引用。所以在方法内对这个对象引用改变为新的引用的时候，并不会影响到调用处的对象引用；方法结束后，方法内的引用副本就会被丢弃。</p></blockquote><ul><li>方法不能修改基本数据类型的参数（即数值型或布尔型）</li><li>方法可以改变对象参数的状态</li><li>方法不能让一个对象参数参数引用一个新的对象</li></ul><h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><h4 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h4><p>java中由三种初始化数据字段的方法：</p><ul><li><p>在构造器中设置值</p></li><li><p>在声明中赋值</p></li><li><p>初始化块</p><ul><li><p>在一个类的声明中，可以包含任意多个代码块。只要构造这个类的对象，这些块就会被执行。如下示例中：首先运行初始化块，然后才运行构造器的主体部分</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Employee</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> nextId<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> salary<span class="token punctuation">;</span>        <span class="token comment">// 初始化块</span>    <span class="token punctuation">{</span>        id <span class="token operator">=</span> nextId<span class="token punctuation">;</span>        nextId<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        name <span class="token operator">=</span> n<span class="token punctuation">;</span>        salary <span class="token operator">=</span> s<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        name <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        salary <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h4 id="构造器的执行步骤"><a href="#构造器的执行步骤" class="headerlink" title="构造器的执行步骤"></a>构造器的执行步骤</h4><ol><li>如果构造器的第一行调用了另一个构造器，则基于所提供得参数执行第二个构造器。</li><li>否则<ol><li>所有数据字段初始为其默认值（0，false或null）。</li><li>按照在类声明中出现的顺序，执行所有字段初始化方法和初始化块。</li></ol></li><li>执行构造器主体代码。</li></ol><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><h4 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h4><p>使用<strong>包</strong>将类组织在一个集合中，借助包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。</p><p>只用包的主要原因是确保<strong>类名的唯一性</strong>。</p><blockquote><p>在对据有包名且按照包路径放置的类进行编译或运行时，需要加上包路径（完全限定名），例如：</p><p>javac cn/qing/PayrollApp.java</p><p>java cn.qing.PayrollApp</p></blockquote><h4 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h4><p>为了使类能够被多个程序共享，需要做到以下几点：</p><ol><li><p>把类文件放到一个目录中，例如 <code>/home/user/classdir</code>。 需要注意，这个目录是包树状结构的<strong>基目录</strong>。如果希望增加 <code>com.qing.corejava.Employee</code>类，那么<code>Employee.class</code>类文件就必须位于子目录 <code>/home/user/classir/com/qing/corejava</code>中。</p></li><li><p>将<code>JAR</code>文件放在一个目录中，例如：<code>/home/user/archives</code>。</p></li><li><p>设置**类路径(class path)**。类路径是所有包含类文件的路径的集合。</p><p>在UNIX环境中，类路径中的各项之间用（:）分割：</p><p><code>/home/user/classdir:.:/home/user/archives/archive.jar</code></p><p>而在Windows环境中，则以分号（;）分割：</p><p><code>c:\classdir;.;c:\archives\archive.jar</code></p><p>不论是UNIX还是Windows，都用句点（.）表示当前目录。</p><p>类路径包括：</p><ul><li>基目录 <code>/home/user/classdir</code>或<code>c:\clases</code>；</li><li>当前目录（<code>.</code>）；</li><li><code>JAR</code>文件<code>/home/user/archives/archive.jar</code>或<code>c:\archives\archive.jar</code></li></ul><p>从Java 6 开始，可以在JAR文件目录中指定通配符，如下：</p><p><code>/home/user/classdir:.:/home/user/archives/'*'</code> 或者 <code>c:\classdir;.;c:\archives\*</code></p><p>在UNIX中，<code>*</code> 必须转义以放置<code>shell</code>扩展 。</p><p>archives目录中所有JAR文件（但不包括<code>.class</code>文件）都包含在这个类路径中。</p><p>类路径所列出的目录和归档文件是搜索类的<strong>起始点</strong>。</p><h4 id="设置类路径"><a href="#设置类路径" class="headerlink" title="设置类路径"></a>设置类路径</h4><p>最好使用 <code>-classpath</code>（或 <code>-cp</code>，或者Java 9中的 <code>--class-path</code>）选择指定类路径：</p><p><code>java -classpath /home/user/classdir:.:/home/user/archives/archive.jar MyProg</code>或</p><p><code>java -classpath c:\classdir;.;c:\archives\archive.jar MyProy</code></p><p>整个指令必须写在一行中。可以将这样一个长的命令行放在一个shell脚本或一个批处理文件中。</p><p>利用<code>-classpath</code>选项设置类路径是首选的方法，也可以通过设置<code>CLASSPATH</code>环境变量来指定。具体细节依赖于所使用的shell。在Bourne Again shell(bash)中，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">CLASSPATH</span><span class="token operator">=</span>/home/user/classdir:.:/home/user/archives/archive.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在Windows中，命令如下:</p><pre class="line-numbers language-bat" data-language="bat"><code class="language-bat">set CLASSPATH=c:\classdir;.;c:\archives\archive.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>知道退出shell为止，类路径设置均有效。</p></li></ol><h3 id="JAR文件"><a href="#JAR文件" class="headerlink" title="JAR文件"></a><code>JAR</code>文件</h3><p><code>Java</code>归档(<code>JAR</code>)文件是一个压缩文件，使用了<code>ZIP</code>压缩格式，可以包含类文件，也可以包含图像和声音等其他类型文件。</p><h4 id="创建JAR文件"><a href="#创建JAR文件" class="headerlink" title="创建JAR文件"></a>创建<code>JAR</code>文件</h4><p>使用<code>jar</code>工具制作<code>JAR</code>文件（在默认的<code>JDK</code>安装中，这个工具位于<code>jdk/bin</code>目录下）。创建一个新的<code>JAR</code>文件常用命令如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">jar cvf jarFileName file1 file2 *.class <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用格式为 <code>jar options file1 file2 ...</code>   </p><p><code>options</code>具体参数说明如下</p><table><thead><tr><th>option</th><th>说明</th></tr></thead><tbody><tr><td><code>c</code></td><td>创建一个新的或者空的归档文件并加入文件。<br>如果指定的文件名是目录，<code>jar</code>程序将会对他们进行递归处理。</td></tr><tr><td><code>C</code></td><td>临时改变目录，例如：<br>    <code>jar cvf jarFileName.jar -C classes *.class</code><br>切换到<code>classes</code>子目录以便于增加类文件</td></tr><tr><td><code>e</code></td><td>在清单文件中创建一个入口点（请参看<a href="#%E5%8F%AF%E6%89%A7%E8%A1%8Cjar%E6%96%87%E4%BB%B6">可执行JAR文件</a>）</td></tr><tr><td><code>f</code></td><td>指定<code>JAR</code>文件名作为第二个命令行参数。如果没有这个参数，<code>jar</code>命令会将结果写至标准输出（在创建JAR文件时）或者从标准输出读取（在解压或者列出<code>JAR</code>文件内容时）</td></tr><tr><td><code>i</code></td><td>建立索引文件（用于加快大型归档中的查找）</td></tr><tr><td><code>m</code></td><td>将一个<font color="blue">清单文件</font>添加到一个<code>JAR</code>文件中。清单是对归档内容和来源的一个说明。每个归档有一个默认的清单文件。但是，如果想验证归档文件的内容，可以提供自己的清单文件。</td></tr><tr><td><code>M</code></td><td>不为条目创建清单文件</td></tr><tr><td><code>t</code></td><td>显示内容表</td></tr><tr><td><code>u</code></td><td>更新一个已有的<code>JAR</code>文件</td></tr><tr><td><code>v</code></td><td>生成详细的输出结果</td></tr><tr><td><code>x</code></td><td>解压文件。如果提供一个或多个文件名，之解压这些文件；否则，解压所有文件</td></tr><tr><td><code>0</code></td><td>存储，但不进行<code>ZIP</code>压缩</td></tr></tbody></table><h4 id="清单文件"><a href="#清单文件" class="headerlink" title="清单文件"></a>清单文件</h4><p>除了类文件、图像和其他资源外，每个<code>JAR</code>文件还包含一个<strong>清单文件</strong>（<code>manifest</code>），用于描述归档文件的特殊特性。</p><p>清单文件被命名为<code>MANIFEST.MF</code>，位于<code>JAR</code>的一个特殊的<code>MATE_INFO</code>子目录中，最小清单文件示例如下</p><img src="/2022/06/28/java/core-java-volume-0/MANIFEST.png" class="" title="MANIFEST"><pre class="line-numbers language-none"><code class="language-none">Manifest-Version: 1.0lines describing this archiveName: Woozle.classlines describing this fileName: com/qing/mypkg/lines describing this package<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>详细格式和信息参看： <a href="https://docs.oracle.com/javase/10/docs/specs/jar/jar.html">https://docs.oracle.com/javase/10/docs/specs/jar/jar.html</a></p></blockquote><h4 id="可执行JAR文件"><a href="#可执行JAR文件" class="headerlink" title="可执行JAR文件"></a>可执行<code>JAR</code>文件</h4><p>使用<code>jar</code>命令中的<code>e</code>选项来指定程序的<strong>入口点</strong>，即通常需要在调用<code>java</code>程序启动器时指定的类：</p><p><code>jar cvfe MyProgram.jar cn.qing.mypkg.MainApplication files to add</code></p><p>或者，可以在清单文件中指定程序的主类，例如：</p><p><code>Main-Class: cn.qing.mypkg.MainApplication</code></p><p><strong>注意，不要为主类名增加扩展名。 即 .class</strong></p><blockquote><p>清单文件的最后一行必须以换行符结束。否则，清单文件将无法被正确地读取。</p><p>常见的一个错误是创建了一个只包含Main-Class行而没有行结束符的文本文件</p></blockquote><p>之后就可以使用已下命令来快速的启动程序：</p><p><code>java -jar MyProgam.jar</code></p><h4 id="多版本JAR文件"><a href="#多版本JAR文件" class="headerlink" title="多版本JAR文件"></a>多版本<code>JAR</code>文件</h4><p>在<code>Java 9</code>之后引入**多版本<code>JAR</code>**，其中可以包含面对不同<code>Java</code>版本的类文件，用来解决一个强封装的包在不同版本的<code>Java</code>环境上的运行。</p><p>为了保证向后兼容，额外的类文件放在<code>META-INF/versions</code>目录中：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">Application.classBuidingBlocks.classUtil.classMETA-INF |- MANIFEST.MF (with line Multi-Release: true) |- versions |- 9 |  |- Application.class |  |- BuildingBlocks.class |- 10    |- BuildingBlocks.class<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Java 9</code>之后的版本就可以根据所需，从<code>version</code>中加载自己版本对应的类文件，而<code>Java 8</code>完全不知道<code>META_INF/versions</code>目录的存在，只会去加载最外层遗留的类</p><p>要增加不同版本的类文件，可以使用<code>--release</code>标志：</p><p><code>jar uf MyProgram.jar --release 9 Application.class</code></p><p>要从头构建一个多版本的<code>JAR</code>文件，就可以使用<code>-C</code>选项，对应每个版本要切换到一个不同的类文件目录：</p><p><code>jar cf MyProgram.jar -C bin/8 . --release 9 -C bin/9 Application.class</code></p><p>面向不同版本编译时，使用<code>--release</code>和<code>-d</code>来指定输出目录：</p><p><code>javac -d bin/8 --release 8 .....</code></p><p>在<code>Java 9</code> 中，<code>-d</code>选项会创建这个目录。</p><blockquote><p><code>--release</code>标志是<code>Java 9</code>之后新增的。在之前的版本中，许哟啊使用 <code>-source</code>、<code>-target</code>和<code>-boot-classpath</code>标志。</p></blockquote><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p><code>javadoc</code>工具，可以由源文件中的注释生成一个<code>HTML</code>文件。</p><p><code>java</code>中的注释分两种 <code>\\</code>和<code>\*  *\</code> 两种方式。</p><p>第二种注释中可以添加<strong>自由格式文本</strong>，自由格式文本的<strong>第一句应该是一个概要性的句子</strong>。<code>javadoc</code>工具自动会将这些句子抽取出来形成文档。同时在自由文本中，可以使用<code>HTML</code>修饰符。</p><h4 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h4><p>类注释必须放在<code>import</code>语句之后，类定义之前。</p><h4 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h4><p>每一个方法注释必须放在所描述的方法之前。除了通用标记之外，还可以使用下面的标记，还可以使用下面的标记：</p><ul><li><code>@param variable description</code></li><li><code>@return description</code></li><li><code>@throws class description</code></li></ul><h4 id="字段注释"><a href="#字段注释" class="headerlink" title="字段注释"></a>字段注释</h4><p>只需要对公共字段（通常指的是静态常量）建立稳定。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * The "Hearts" card suit */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> HEARTS <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="通用注释"><a href="#通用注释" class="headerlink" title="通用注释"></a>通用注释</h4><ul><li><p><code>@since text</code></p></li><li><p><code>@author name</code></p></li><li><p><code>@version text</code></p></li><li><p><code>@see</code>  <code>@link</code></p><p>这两个注释可以使用超链接，连接到<code>javadoc</code>文档中插入一个超链接，示例如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">\<span class="token operator">*</span><span class="token operator">*</span>    <span class="token annotation punctuation">@see</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>qing<span class="token punctuation">.</span>corejava<span class="token punctuation">.</span></span>Employee</span>#<span class="token function">raiseSalary</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> 连接到一个具体的方法上    <span class="token annotation punctuation">@see</span> <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"www.qing.cn/corejava.html"</span><span class="token class-name">The</span> <span class="token class-name">Core</span> <span class="token class-name">Java</span> home page<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">&gt;</span>     <span class="token annotation punctuation">@see</span> <span class="token string">"Core Java 2 volume 2"</span><span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> <span class="token keyword">package</span><span class="token punctuation">.</span><span class="token keyword">class</span>#feature label<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token annotation punctuation">@index</span> enrty<span class="token punctuation">}</span> java9 之后添加，标记为搜索框增加一个条目 <span class="token operator">*</span>\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="包注释"><a href="#包注释" class="headerlink" title="包注释"></a>包注释</h4><p>包注释需要在每一个包目录中添加一个单独的文件。有如下两种选择</p><ol><li>提供一个名为<code>package-info.java</code>的文件，这个文件必须包含一个初始的以<code>/**</code>和<code>*/</code>界定的注释，后面是一个<code>package</code>语句。它不能包含更多的代码和注释。</li><li>提供一个名为<code>package.html</code>的<code>HTML</code>文件。会抽取标记<code>&lt;body&gt; ... &lt;/body</code>之间的所有文本。</li></ol><h4 id="注释抽取"><a href="#注释抽取" class="headerlink" title="注释抽取"></a>注释抽取</h4><p>假设希望<code>HTML</code>文件将放在名为<code>docDir</code>的目录下，执行以下步骤</p><ol><li><p>切换到包含想要生成文档的源文件的目录。如果有<strong>嵌套的包</strong>要生成文档，例如<code>com.qing.corejava</code>，就必须切换到包含子目录<code>com</code>的目录（如果提供了<code>overview.html</code>文件的话，就是这个文件所在的目录）</p></li><li><p>运行如下命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 如果是一个包</span>$ javadoc -d docDir nameOfPackage<span class="token comment"># 如果要为多个包生成文档</span>$ javadoc -d docDir nameOfPackage1 nameOfPackage2<span class="token comment"># 如果文件在无名的包中</span>$ javadoc -d docDir *.java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p>更多参考见 <a href="https://docs.oracle.com/javase/9/javadoc/javadoc.htm">https://docs.oracle.com/javase/9/javadoc/javadoc.htm</a></p></blockquote><h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><ol><li><p><strong>一定要保证数据私有</strong></p></li><li><p><strong>一定要对数据进行初始化</strong></p><p><code>java</code>不会初始化局部变量，但是会对对象的实例字段进行初始化。</p></li><li><p><strong>不要在类中使用过多的基本类型</strong></p></li><li><p><strong>不是所有的字段都需要单独的字段访问器和字段更改器</strong></p></li><li><p><strong>分解有过多职责的类</strong></p></li><li><p><strong>类名和方法名要能够体现它们的职责</strong></p></li><li><p><strong>优先使用不可变的类</strong></p></li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>基于已有的类创建新的类。继承已存在的类就是复用（继承）这些类的方法。而且可以增加一些新的方法和字段，使新类能够适应新的情况。</p><h3 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h3><h4 id="定义子类"><a href="#定义子类" class="headerlink" title="定义子类"></a>定义子类</h4><p><code>Java</code>中使用关键字<code>extends</code>来表示继承关系。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>    <span class="token comment">// ....</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>关键词 <code>extends</code>表明正在构造一个新类，它派生于一个已存在的类。这个已存在的类称为<strong>超类（<code>superclass</code>）</strong>、<strong>基类（<code>base class</code>）</strong>、或<strong>父类（<code>parent class</code>）</strong>；新的类称为<strong>子类（<code>subclass</code>）</strong>、<strong>派生类（<code>derived class</code>)<strong>或</strong>孩子类（<code>child class</code>）</strong></p><h4 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h4><p>超类中的有些方法对于子类并不一定适用。为此，需要提供一个新的方法来<strong>覆盖（<code>override</code>）</strong>超类中的这个方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> getSalary <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>    <span class="token comment">// 覆盖 超类 中的方法</span>     <span class="token keyword">public</span> <span class="token keyword">int</span> getSalary <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而如果想在子类中访问父类中的某个方法或者变量时，可以使用特殊的关键字<code>super</code>:。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>    <span class="token comment">// 覆盖 超类 中的方法</span>     <span class="token keyword">public</span> <span class="token keyword">int</span> getSalary <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，这里的<code>super</code>不是一个对象的引用，例如，不能将值<code>super</code>赋给另一个对象变量。</p></blockquote><h4 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h4><p>由于子类的构造器不能访问超类中的私有字段，所以必须通过调用超类的构造器来初始化这些私有字段，同样这里利用的是<code>super</code>的特殊语法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Manager</span> <span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> salary<span class="token punctuation">,</span> <span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> salary<span class="token punctuation">,</span> year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> year<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>bonus <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以简单对比下<code>this</code>和<code>super</code>的含义：</p><ul><li><code>this</code><ul><li>指示隐式参数的引用。</li><li>调用该类的其他构造器。</li></ul></li><li><code>super</code><ul><li>调用超类的方法。</li><li>调用超类的其他构造器。</li></ul></li></ul><p>这里简单引入下<strong>多态</strong>和<strong>动态绑定</strong>:</p><p>如下面的代码块中所示，变量 e 可以指示多种实际类型的，这种现象就是<strong>多态</strong>。在运行时能自动地选择适当的方法，就被称为<strong>动态绑定（<code>dynamic binding</code>）</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>staff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>staff<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span> e <span class="token operator">:</span> staff<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="继承层次"><a href="#继承层次" class="headerlink" title="继承层次"></a>继承层次</h4><p>由一个公共的超类派生出来的所有类的集合称为<strong>继承层次（<code>inheritance hierarchy</code>）</strong>，如下图所示，从某个特定的类到其祖先的路径称为类的<strong>继承链（<code>inheritance chain</code>）</strong>。</p><img src="/2022/06/28/java/core-java-volume-0/inheritance_hierarchy.png" class="" title="继承层次"><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p><code>"is - a"</code>规则的另一种表达是**替换原则（<code>substitution principle</code>）。它指出程序中出现超类对象的任何地方都可以使用子类对象替换。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Employee</span> e<span class="token punctuation">;</span>e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Employ object expected</span>e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK, Manager can be used as wll</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在<code>Java</code>程序语言中，对象变量是多态的（**<code>polymorphic</code>**）。</p><h4 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h4><p>简单概述下方法调用的过程， 下面以调用<code>x.f(args)</code>，隐式参数<code>x</code>声明为类<code>C</code>的一个对象。</p><ol><li><p>编译器查看对象的声明类型和方法名。</p><ul><li>编译器将会一一列举<code>C</code>类中所有名为f的方法和其超类中所有名为f而且可以访问的方法（超类的私有方法不可访问）。</li><li>此时，编译器已经知道所有可能被调用的候选方法。</li></ul></li><li><p>编译器确定方法调用中提供的参数类型。</p><ul><li><p>编译器根据方法名和具体的参数类型，选择一个与所提供参数类型完全匹配的方法。这个过程称为<strong>重载解析（<code>overloading resolution</code>）</strong>。</p><blockquote><p>方法的名字和参数列表称为方法的<strong>签名</strong>。</p></blockquote></li></ul></li><li><p>如果是<code>private</code>方法、<code>static</code>方法、<code>final</code>方法或者构造器，那么编译器将可以准确地直到应该调用哪个方法。这个称为<strong>静态绑定（<code>static binding</code>）</strong>。</p></li><li><p>程序运行并且采用<strong>动态绑定</strong>调用方法时，虚拟机必须调用与x所引用对象的实际类型对应的那个方法。</p><ul><li><p>由于每次调用方法都需要完成搜索去找到对应的方法，这样开销比较大。因此，虚拟机预先为每个类计算了一个<strong>方法表（<code>method table</code>）</strong>，其中列出了所有方法的签名和要调用的实际方法。这样在真正调用的时候只需要查找这张表就可以了。</p><blockquote><p>在覆盖一个方法的时候，子类方法<strong>不能低于</strong>超类方法的<strong>可见性</strong>。特别是超类方法是<code>public</code>，子类方法也必须声明为<code>public</code>。</p></blockquote></li></ul></li></ol><h4 id="阻止继承：final类和方法"><a href="#阻止继承：final类和方法" class="headerlink" title="阻止继承：final类和方法"></a>阻止继承：<code>final</code>类和方法</h4><p>不允许扩展的类被称为<code>final</code>类。</p><blockquote><p>对于<code>final</code>字段来说，构造对象之后就不允许改变其值了，但是如果将一个类声明为<code>final</code>，只有其中的方法自动的称为<code>final</code>，而不包括字段。</p></blockquote><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>在继承链上进行向下的强制类型转换，并且”谎报”对象宝航的内容，就有可能产生错误。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>staff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>staff<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Manager</span> boss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span> staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Java</code>运行到第七行的时候，将会注意到所给的实例与转换类型不匹配，就会产生一个<code>ClassCastException</code>异常。如果没有进程捕获处理这个异常，程序就会退出。所以可以通过下述方式，使用<code>instanceof</code>在转换之前检查能否转换。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Manager</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    boss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span> staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是如果使用一个超出<strong>继承链</strong>的强制转换就会编译错误。例如：<code>String c = (String) staff[1]</code></p><p>故，强制类型转换：</p><ul><li><p>只能在继承层次内进行强制类型转换。</p></li><li><p>在将超类强制转换成子类之前，应该使用<code>instanceof</code>进行检查</p><blockquote><p>如果 <code>x</code> 为 <code>null</code>， 测试 <code>x instanceof C</code> 。 不会产生异常，只是会返回 <code>false</code>。 这样是因为 <code>null</code>没有引用任何对象，当然也不会引用<code>C</code>类型的对象。</p></blockquote></li></ul><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>主要用于在超类中定义，但是将实现交给子类去实现；同时，抽象方法在子类中必须被重写。由关键字**<code>abstract</code>**修饰。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// no implementation required</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须声明为抽象类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"student"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时即使不含抽象方法的类，也可以定义为抽象类。</p><p>注意：<strong>抽象类不能实例化</strong>，即不能创建这个类的对象，但是可以定义一个抽象类的<strong>对象变量</strong>，就是定义成变量去引用菲抽象子类的对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">Preson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span><span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// success</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="受保护访问"><a href="#受保护访问" class="headerlink" title="受保护访问"></a>受保护访问</h4><p>使用关键字<code>protected</code>修饰，被其修饰的字段和方法只能由同一个包中的类访问，不能通过派生子类来访问受保护的字段。</p><blockquote><p>事实上，<code>Java</code>中的受保护部分对所有子类及同一个包中的所有其他类都可见。与<code>C++</code>中的保护机制不同，<code>Java</code>中的<code>protected</code>概念要比<code>C++</code>中的安全性差。</p></blockquote><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><ol><li><code>private</code>：仅对本类可见。</li><li><code>public</code>：仅对外部完全可见。</li><li><code>protected</code>：仅对本包和所有子类可见。</li><li>默认：不需要修饰符，对本包可见。</li></ol><h3 id="Object：所有类的超类"><a href="#Object：所有类的超类" class="headerlink" title="Object：所有类的超类"></a><code>Object</code>：所有类的超类</h3><p><code>Object</code>类是<code>Java</code>中所有类的始祖，在<code>Java</code>中每个类都扩展了<code>Object</code>，但是并不需要在类的定义中显式的去继承它。</p><h4 id="Object类型的变量"><a href="#Object类型的变量" class="headerlink" title="Object类型的变量"></a><code>Object</code>类型的变量</h4><ol><li>可以使用<code>Object</code>类去引用任何类型的对象，<code>Object obj = new Employee();</code>。</li><li>在<code>Java</code>中只有<strong>基本类型（<code>primitive type</code>）</strong>不是对象。</li><li>所有的数组类型，不管是对象数组还是基本类型的数组都扩展了<code>Object</code>类。</li></ol><h4 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a><code>equals</code>方法</h4><p><code>Object</code>类中实现的<code>equals</code>方法将确定两个对象引用是否相等。</p><p>但是对于一些状态检测的对象的相等性，更多的是去比较其包含的属性之间的相等状态，而不能只是简单的比较两个引用必须是一个对象。这里就需要对<code>equals</code>的方法进行重写。</p><p>同时子类中定义<code>equals</code>方法时，首先要调用超类的<code>euqals</code>方法。</p><p>如下示例来展示对<code>equals</code>方法的重写：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> salary<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">LocalDate</span> hireDay<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">double</span> salary<span class="token punctuation">,</span> <span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> salary<span class="token punctuation">;</span>        hireDay <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> otherObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// a quick test to see if the objects are identical</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> otherObject<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// must return false if the explicit parameter is null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>otherObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">// if the classes don't match, they can't be equal</span>        <span class="token comment">// getClass() 方法将会返回这个对象所属的类</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> otherObject<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">// now we know otherObject is a non-null Employee</span>        <span class="token keyword">var</span> other <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span><span class="token punctuation">)</span> otherObject<span class="token punctuation">;</span>        <span class="token comment">// test whether the fields have identical values</span>        <span class="token comment">// 这里为了防止 对象属性 name 和 hireDay 为null导致错误，所有推荐使用 Objects.equals()方法来进行比较，而不是使用 name.equals(other.name)</span>        <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> other<span class="token punctuation">.</span>name<span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span> salary <span class="token operator">==</span> other<span class="token punctuation">.</span>salary <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>hireDay<span class="token punctuation">,</span> other<span class="token punctuation">.</span>hireDay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="相等测试与继承"><a href="#相等测试与继承" class="headerlink" title="相等测试与继承"></a>相等测试与继承</h4><p><code>equals</code>方法要具有下面的特性：</p><ol><li><strong>自反性</strong></li><li><strong>对称性</strong></li><li><strong>传递性</strong></li><li><strong>一致性</strong></li><li>对于任意非空引用<code>x</code>，<code>x.equals(null)</code></li></ol><p>以下时任何编写一个相对完美的<code>equals</code>方法的建议：</p><ol><li><p>显式参数命名为<code>otherObject</code>，稍后需要将它强制转换成另一个名为other的变量。</p></li><li><p>检测<code>this</code>与<code>otherObject</code>是否相等：<code>if (this == otherObject) return true;</code>这属于一种优化。</p></li><li><p>检查<code>otherObject</code>是否为<code>null</code>，如果<code>null</code>，返回<code>false</code>。</p></li><li><p>比较<code>this</code>与<code>otherObject</code>的类。</p><ul><li><p>如果<code>equals</code>的语句可以在子类中改变，就使用<code>getClass</code>检测：</p><p><code>if (getClass() != otherObject.getClass()) return false;</code></p></li><li><p>如果<strong>所有的子类</strong>都由相等的相等性语义，就可以使用<code>instanceof</code>检测：</p><p><code>if (!(otherObject instanceof ClassName)) return false;</code></p></li></ul></li><li><p>将<code>otherObject</code>强制转换为相应类类型的变量：</p><p><code>ClassName other = (ClassName) otherObject;</code></p></li><li><p>根据相等性概念的要求来比较具体的属性字段。</p><ul><li>使用<code>==</code>比较基本类型字段</li><li>使用<code>Objects.equals</code>比较对象字段</li><li>对于数组类型的字段，可以使用静态的<code>Arrays.equals</code>方法来检测</li></ul><p>所有字段都匹配，返回<code>true</code>，否则返回<code>false</code></p></li></ol><blockquote><p>如下的实现<code>equals</code>方法的一种常见的错误，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Employee</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法声明的显示参数类型是<code>Employee</code>。因此，它没有覆盖<code>Object</code>类的<code>equals</code>方法，而是定义了一个完全无关的方法。</p><p>为了避免这种错误，可以使用<code>@Override</code>标记要覆盖超类方法的那些子类方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> otherObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a><code>hashCode</code>方法</h4><p>散列码（<code>hash code</code>）是由对象导出的一个整形值，是没有规律的。</p><blockquote><p>相同的字符串由相同的散列码，这是因为字符串的散列码是由<strong>内容</strong>导出的。</p><p><code>equals</code>与<code>hashCode</code>的定义必须相容</p></blockquote><h4 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a><code>toString</code>方法</h4><p>返回表示对象值的一个字符串。例如：<code>Point</code>类的<code>toString</code>方法将返回下面的字符串<code>java.awt.Point[x=10,y=20]</code>。</p><p><code>Object</code>类定义了<code>toString</code>方法，会打印对象的类名和散列码。例如，<code>System.out.println(System.out)</code>将生成<code>java.io.PrintStream@23f434</code>。原因在于<code>System.out</code>没有覆盖超类<code>Object</code>中的<code>toString</code>方法。</p><blockquote><ol><li><p>建议为自定义的每一个类都添加重写<code>toString</code>方法，方便与在日志中对数据的输出。</p></li><li><p>对于数组类型的数组，可以调用<code>Arrays.toString(new int[]{1, 2, 3, 4})</code>来生成字符串。</p></li></ol></blockquote><h3 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h3><p>所有的基本类型都有一个与之对应的类，这些类称为<strong>包装器（<code>wrapper</code>）</strong>。</p><table><thead><tr><th>基本类型</th><th>包装类型</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>Integer</code></td></tr><tr><td><code>long</code></td><td><code>Long</code></td></tr><tr><td><code>float</code></td><td><code>Float</code></td></tr><tr><td><code>double</code></td><td><code>Double</code></td></tr><tr><td><code>short</code></td><td><code>Short</code></td></tr><tr><td><code>byte</code></td><td><code>Byte</code></td></tr><tr><td><code>char</code></td><td><code>Character</code></td></tr><tr><td><code>bool</code></td><td><code>Boolean</code></td></tr></tbody></table><p>方便在一些必须使用类的地方来使用，例如：<code>ArrayList&lt;Integer&gt;</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 在添加 int 类型时，下面的调用</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将自动变换为</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面所述的这个过程称为<strong>自动装箱（<code>autoboxing</code>）</strong>。</p><p>相反的将一个<code>Integer</code>对象赋给一个<code>int</code>值时，也会自动的拆箱，编译器将<code>int n = list.get(3)</code>自动的转换成<code>int n = list.get(3).intValue();</code>。</p><blockquote><ol><li>自动装箱规范要求<code>boolean</code>、<code>byte</code>、<code>char&lt;=127</code>、介于<code>-128和127</code>之间的<code>short</code>和<code>int</code>被包装到固定的对象中。</li><li><strong>装箱和拆箱时编译器做的工作，而不是虚拟机</strong>。</li></ol></blockquote><p>介于<code>-128和127</code>之间的<code>short</code>和<code>int</code>被包装到固定的对象中。所以两个<code>Integer</code>对象会有时候会相等。如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">prinln</span><span class="token punctuation">(</span> a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出为true</span><span class="token comment">/* * 因为介于`-128 ~ 127`之间的`short`和`int`被包装到固定的对象中， 所以这时候比较的时同一块地址中保存的数据* 所以在超过`-128 ~ 127`范围之内的两个 Integer 对象则不相等*/</span><span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> d <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">prinln</span><span class="token punctuation">(</span> a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出为false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2022/06/28/java/core-java-volume-0/integer.png" class="" title="integer"><h3 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h3><p>可以提供参数数量可变的方法，又被称为<strong>变参（<code>varargs</code>）方法</strong>。例如下面的方法</p><p><code>System.out.printf("%d", n);  System.out.printf("%d %s", n, "widghts");  </code></p><p>上面的两个语句都是调用同一个方法，不过是一个为两个参数，一个为三个参数。<code>printf</code>方法是如下这样定义的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintStream</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">PrintStream</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token class-name">String</span> fmt<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">format</span><span class="token punctuation">(</span>fmt<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的省略号<code>...</code>是<code>Java</code>代码的一部分，它表明这个方法可以接收任意数量的对象（除fmt参数之外）。这里<code>printf</code>方法接收了两个参数，一个是格式字符串，<strong>另一个数量可变的参数实际上是一个<code>Object[]</code>数组</strong>。</p><p><code>Object... </code>参数类型与<code>Object[]</code>完全一样。</p><blockquote><p>所以上面的示例调用也可以写作：</p><p><code>System.out.printf("%d %s", new Object[] { new Integer(1), "widghts");</code></p></blockquote><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>所有的枚举类型都是<code>Enum</code>类的子类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">enum</span> <span class="token class-name">Size</span> <span class="token punctuation">{</span>    <span class="token function">SMALL</span><span class="token punctuation">(</span><span class="token string">"S"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">MEDIUM</span><span class="token punctuation">(</span><span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">LARGE</span><span class="token punctuation">(</span><span class="token string">"L"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EXTRA_LARGE</span><span class="token punctuation">(</span><span class="token string">"XL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 枚举的构造器总是私有的</span>    <span class="token keyword">private</span> <span class="token class-name">Size</span><span class="token punctuation">(</span><span class="token class-name">String</span> abbreviation<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>abbreviation <span class="token operator">=</span> abbreviation<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getAbbreviation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> abbreviation<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> abbreviation<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><strong>反射库（<code>reflection library</code>）</strong>提供了一个丰富且精巧的工具集，可以用来编写能够动态操纵<code>Java</code>代码的程序。</p><p>能够分析类能力的程序称为<strong>反射（<code>reflective</code>）</strong>，用于</p><ul><li>在运行时分析类的能力</li><li>在运行时检查对象，例如，编写一个适用与所有类的<code>toString</code>方法</li><li>实现泛型数组造作代码</li><li>利用<code>Method</code>对象， 这个对象很像C++中的函数指针</li></ul><h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a><code>Class</code>类</h4><p> <code>Java</code>运行时系统始终为所有对象维护的一个<strong>运行时类型标识</strong>。</p><ul><li><p><code>Object</code>类中的<code>getClass()</code>方法将会返回一个<code>Class</code>类型的实例。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Employee</span> e<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token class-name">Class</span> cl <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>静态方法<code>forName</code>获得类名对应的<code>Class</code>对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> className <span class="token operator">=</span> <span class="token string">"java.util.Random"</span><span class="token punctuation">;</span><span class="token class-name">Class</span> cl <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><blockquote><p><strong>注意</strong>：一个<code>Class</code>对象实际上表示的是一个<strong>类型</strong>，可能是类，也可能不是类，例如，<code>int</code>不是类，但是int.class是一个<code>Class</code>类型的对象。</p></blockquote><p><strong>虚拟机为每个类型管理一个唯一的Class对象</strong>。因此可以使用==运算符实现两个类对象的比较。</p><p>在有一个Class对象的时候，可以用它构造类的实例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> className <span class="token operator">=</span> <span class="token string">"java.util.Random"</span><span class="token punctuation">;</span> <span class="token comment">// or any other name of a class with a no-arg constructor</span><span class="token class-name">Class</span> cl <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Object</span> obj <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="声明异常入门"><a href="#声明异常入门" class="headerlink" title="声明异常入门"></a>声明异常入门</h4><ul><li><p>非检查型异常 （unchecked）</p></li><li><p>检查型异常 （checked）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">api</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> classParam<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">NoSuchMethodException</span> <span class="token punctuation">{</span>      <span class="token comment">// 返回一个Class对象， 表示名为className的类。 throws ClassNotFoundException</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> aClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"book.api.ClassApi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 生成一个对象，描述有指定参数类型的构造器。 throws NoSuchMethodException</span>    <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> classParam<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token class-name">ClassApi</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>在<code>Java</code>中，关联的文件被称为资源（<code>resource</code>）</p><p><code>Class</code>类提供了一个很有用的服务可以查找资源文件：</p><ol><li>获取拥有资源的类的<code>Class</code>对象，例如，ResourceTest.class</li><li>接受描述资源位置的<code>URL</code>， <code>URL url = cl.getResource("about.gif");</code></li><li>使用<code>getResourceAsStream</code>方法获得一个输入流来读取文件中中的数据。</li></ol><h4 id="利用反射分析类的能力"><a href="#利用反射分析类的能力" class="headerlink" title="利用反射分析类的能力"></a>利用反射分析类的能力</h4><p>主要是通过 <code>java.lang.reflect</code>包中三个类<code>Field</code>、<code>Method</code>、<code>Constructor</code>分别来描述类的字段、方法和构造器，进而来分析类的能力。</p><p><strong><code>Class</code>类的<code>getDeclareFields</code>、<code>getDeclareMethods</code>、<code>getDeclaredConstructors</code>方法将分别而返回类中声明的全部字段、方法和构造器的数组，其中包括私有成员、包成员和受保护成员，但不包括超类的成员。</strong></p><h4 id="使用反射在运行时分析对象"><a href="#使用反射在运行时分析对象" class="headerlink" title="使用反射在运行时分析对象"></a>使用反射在运行时分析对象</h4><ul><li>反射机制的默认行为受限于<code>Java</code>的访问限制，但是，可以调用<code>Field</code>、<code>Method</code>和<code>Constructor</code>对象的<code>setAccessible</code>方法覆盖Java的访问控制。<ul><li>·该方法是<code>AccessibleObject</code>类中的一个方法，是上述三个类的公共超类。这个特性是为调试、持久存储和类似机制提供的。</li><li>如果类中存在循环引用，在用反射获取其中属性时可能存在无限递归的问题，因此，可以使用<code>ObjectAnalyzer</code>来跟踪已访问过的对象避免无限递归。</li></ul></li></ul><h3 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h3><ol><li><strong>将公共操作和字段放在超类中</strong></li><li><strong>不要使用受保护的字段</strong></li><li><strong>使用继承实现“is-a”关系</strong></li><li><strong>除非所有继承的方法都有意义，否则不要使用继承</strong></li><li><strong>再覆盖方法时，不要改变预期的行为</strong></li><li><strong>使用多态，而不要使用类型信息</strong></li><li><strong>不要滥用反射</strong><ul><li>反射机制使人们可以在运行时查看字段和方法，从而能编写出更具有通用性的程序。这种功能对于编写系统程序及其有用，但是通常不适于编写应用程序。</li><li>反射是很脆弱的，如果使用反射，编译器将无法帮助你查找编程错误，因此只有在运行时才会发现错误并导致异常</li></ul></li></ol><h2 id="接口、lambda表达式和内部类"><a href="#接口、lambda表达式和内部类" class="headerlink" title="接口、lambda表达式和内部类"></a>接口、<code>lambda</code>表达式和内部类</h2><h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（<code>interface</code>）</h3><p>用来描述类应该做什么，而不指定它们具体应该怎么做。一个类可以实现（<code>implement</code>）一个或多个接口。</p><h4 id="接口概念"><a href="#接口概念" class="headerlink" title="接口概念"></a>接口概念</h4><p>接口不是类，而是对希望符合这个接口的类的一组需求。使用关键字 <code>interface</code> 定义方式如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparable</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>在接口声明中，没有将 <code>compareTo</code> 方法声明为 <code>public</code> ，这是因为在接口中的所有方法都自动时 <code>public</code>。不过，在实现接口是，必须将方法声明为 <code>public</code>；否则，编译器将认为这个方法的访问属性时包可见性，这个类的默认访问属性。</p></blockquote><p>为了让类实现一个接口，通过如下步骤定义：</p><ol><li>将类声明为实现给定的接口。</li><li>对接口中的所有方法提供定义。</li></ol><p>使用关键字 <code>implments</code> ：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="接口的属性"><a href="#接口的属性" class="headerlink" title="接口的属性"></a>接口的属性</h4><p>接口不是类。具体来说，<strong>不能使用<code>new</code>运算符实例化一个接口</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ERROR</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过<strong>可以声明接口的变量</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Comparable</span> x<span class="token punctuation">;</span> <span class="token comment">// ok</span>x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Exployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可以引用一个实现了这个接口的类对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用  <code>instanceof</code> 检查一个对象是否实现了某个特定的接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span> anObject <span class="token keyword">instanceof</span> <span class="token class-name">Comparable</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以建立与类的继承层次一样的扩展接口，即 接口继承接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Moveable</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Powered</span> <span class="token keyword">extends</span> <span class="token class-name">Moveable</span> <span class="token punctuation">{</span>    <span class="token keyword">double</span> <span class="token function">milesPerGallon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接口中不能包含实例字段，但是可以包含常量，接口中的字段总是 <code>public static final</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Powered</span> <span class="token keyword">extends</span> <span class="token class-name">Moveable</span> <span class="token punctuation">{</span>    <span class="token keyword">double</span> <span class="token function">milesPerGallon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> SPEED_LIMIT <span class="token operator">=</span> <span class="token number">95</span><span class="token punctuation">;</span> <span class="token comment">// a public static finla constant</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h4><p>一个类可以实现多个接口，但是只能继承一个类，Java不支持多重继承。所以在抽象类之外有引入了接口的概念。</p><h4 id="静态和私有方法"><a href="#静态和私有方法" class="headerlink" title="静态和私有方法"></a>静态和私有方法</h4><p>在<code>Java8</code>中，允许在接口中增加静态方法。目前为止，通常的做法都是将静态方法放在伴随类中。在标准库中，你会看到成对出现的接口和实用工具类，如<code>Collection/Collections</code>或<code>Path/Paths</code>.</p><p>在Java9中，接口中的方法可以是private。private方法可以是静态方法或实例方法。由于私有方法只能在接口本身的方法中使用，所以用法很有限，只能作为接口中其他方法的辅助方法。</p><h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>可以为接口方法提供一个<strong>默认实现</strong>，必须用<code>default</code>修饰符标记这样一个方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CompareTo</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">default</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">T</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// by default, all elements are the same</span>    <span class="token punctuation">}</span>        <span class="token comment">// 同时默认方法可以调用其他方法</span>    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// an abstract method</span>    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认方法的一个重要用法就是“<strong>接口演化</strong>”（interface evolution）。即对老接口增加新方法，那么历史的已经实现的类要怎么处理呢，这时候通过对新加的方法提供默认实现，即可保证历史的实现也可以正常编译和使用。</p><h4 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h4><ol><li><p>超类优先。</p><p>如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法都会被忽略。</p></li><li><p>接口冲突。</p><p>如果一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突，</p></li></ol><h4 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h4><img src="/2022/06/28/java/core-java-volume-0/copy_clone.png" class="" title="image-copy_clone"><img src="/2022/06/28/java/core-java-volume-0/light_copy.png" class="" title="image-light_copy"><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a><code>lambda</code>表达式</h3><p> 用于处理代码块</p><h4 id="lambda表达式的语法"><a href="#lambda表达式的语法" class="headerlink" title="lambda表达式的语法"></a><code>lambda</code>表达式的语法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如上就是一个简单的**<code>lambda</code>表达式**，<code>lambda</code>表达式就是一个代码块，以及必须传入代码的变量规范。</p><p>这是一种表达方式：<strong>参数，箭头（-&gt;）以及一个表达式</strong>。示例：</p><ol><li><p>如果代码要完成多个计算，可以将代码卸载<code>{}</code>中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>即使lambda表达式没有参数，仍然需要提供空括号，就像无参数方法一样：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> comp <span class="token operator">=</span>     <span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span>  <span class="token comment">// same as (String first, String second)</span>    <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>如果方法只有一个参数，而且这个参数的类型可以推导出来，那么甚至可以省略小括号</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The time is "</span>                       <span class="token operator">+</span> <span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">ofEpochMilli</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getWhen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p>无须指定<code>lambda</code>表达式的返回类型。<code>lambda</code>表达式的返回类型总是会由上下文推导得出。</p><blockquote><p>如果一个lambda表达式只在某些分支返回一个值，而另外一个分支不返回值，这是不合法的。例如，(int x) -&gt; { if (x &gt;= 0) return 1;} 就不合法。</p></blockquote><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为<strong>函数式接口</strong>（<code>functional interface</code>）。</p><p>最好把<code>lambda</code>表达式看作是一个函数，而不是一个对象，另外要接受<code>lambda</code>表达式可以传递到函数式接口。</p><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> event <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 也可以改为</span><span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TImer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>表达式<strong>System.out::println</strong>是一个<strong>方法引用</strong>（<code>method reference</code>），它指示编译器生成一<strong>个函数式接口</strong>的实例，覆盖这个接口的抽象方法来调用给定的方法。</p><p>要用::运算符分割方法名与对象或类名，主要由下面三种情况：</p><ol><li><p><strong><code>object::instanceMethod</code></strong></p><p>方法引用等价于向方法传递参数的<code>lambda</code>表达式。</p><p>对于<code>System.out::println</code>，对象是 <code>System.out</code>， 所以方法表达式等价于<code> x -&gt; System.out,println(x)</code></p></li><li><p><strong><code>Class::instanceMethod</code></strong></p><p>第一个参数会成为方法的隐式参数</p><p><code>String::compareToIgnoreCase</code> 等同于<code> (x, y) -&gt; x.compareToIgnoreCase(y)</code></p></li><li><p><strong><code>Class::staticMethod</code></strong></p><p>所有的参数都传递到静态方法：<code>Math::pow</code> 等价于<code> (x, y) -&gt; Math.pow(x, y)</code>。</p></li></ol><p><strong>方法引用示例</strong></p><table><thead><tr><th>方法引用</th><th>等价的lambda表达式</th><th>说明</th></tr></thead><tbody><tr><td><code>separator::equals</code></td><td><code>x -&gt; separator.equals(x)</code></td><td>这是包含一个对象和一个实例方法的方法表达式。<code>lambda</code>参数作为这个方法的显示参数传入</td></tr><tr><td><code>String::trim</code></td><td><code>x -&gt; x.trim()</code></td><td>这是一个包含一个类和一个实例方法的方法表达式。<code>lambda</code>表达式会成为隐式参数</td></tr><tr><td><code>String::concat</code></td><td><code>(x, y) -&gt; x.concat(y)</code></td><td>同样，这里有一个实例方法，不过这次由一个显示参数。与前面一样，第一个<code>lambda</code>参数会称为隐式参数，其余的参数会传递到方法</td></tr><tr><td><code>Integer::valueOf</code></td><td><code>x -&gt; Integer::valueOf(x)</code></td><td>这是包含一个静态方法的方法表达式。<code>lambda</code>参数会传递到这个静态方法</td></tr><tr><td><code>Integer::sum</code></td><td><code>(x, y) -&gt; Integer::sum(x, y)</code></td><td>这是另一个静态方法，不过这一次有两个参数。两个<code>lambda</code>参数都传递到这个静态方法。<code>Integer.sum</code>方法专门创建为作为一个方法引用。对于lambda表达式，可以只写作<code>(x, y) -&gt; x+y</code></td></tr><tr><td><code>Integer::new</code></td><td><code>x -&gt; new Integer(x)</code></td><td>这是一个构造器引用，<code>lambda</code>参数传递到这个构造器，详见<a href="####%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8">构造器引用</a></td></tr><tr><td><code>Integer[]::new</code></td><td><code>n -&gt; new Integer[n]</code></td><td>这是一个数组构造器引用，<code>lambda</code>参数是数组长度</td></tr></tbody></table><blockquote><p>注意：只有当<code>lambda</code>表达式的体只调用一个方法而不做其他操作时，才能把lambda表达式重写为方法引用。例如：<code>s -&gt; s.length() == 0</code>，这里有一个方法调用。但是还有一个比较，所以这里不能使用方法引用。</p></blockquote><blockquote><p>包含对象的方法引用与等价的<code>lambda</code>表达式还有一个细微的差别。考虑一个方法引用，如<code>separator::equals</code>。如果<code>separator</code>为<code>null</code>，构造<code>separator::equals</code>时就会立即抛出一个<code>NullPointerException</code>异常。<code>lambda</code>表达式<code> x-&gt; sparator.equals(x)</code>只在调用时才会抛出<code>NullPointerException</code>异常。</p></blockquote><p>同样也可以使用：<code>this::instanceMethod</code>和 <code>super::instanceMethod</code></p><h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span> people <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>toArray</code>方法调用这个构造器来得到一个有正确类型的数组，这里的<code>Person[]::new</code>就是一个构造器引用。</p><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">repeatMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">,</span> <span class="token keyword">int</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultToolkit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，里面的<code>lambda</code>表达式有一个自由变量<code>text</code>，表示<code>lambda</code>表达式的数据接口必须存储自由变量的值。</p><blockquote><p>关于代码块以及自由变量值有一个术语：闭包（<code>closure</code>）</p></blockquote><p>可以看到lambda表达式可以捕获外围作用域中变量的值，<strong>但是这里有一个重要的限制，在lambda表达之中，只能引用值不会改变的变量</strong>，主要原因在于：如果lambda表达式中更改变量，<strong>并发执行多个动作时就会不安全</strong>。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">countDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        start<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// ERROR: Can't mutate captured variable</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，如果lambda表达式中引用一个变量，而这个变量可能在外面改变，这个也是不合法的。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ERROR: Cannot refer to changing i</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有一条规则：<font color="blue"><code>lambda</code>表达式中捕获的变量必须实际上是事实最终变量（<code>effectively final</code>）。事实最终变量是指，这个变量初始化之后就不会再为它赋新值</font>。</p><p><code>lambda</code>表达式的体与嵌套快有相同的作用域。在一个<code>lambda</code>表达式中使用<code>this</code>关键字时，是指创建这个lambda表达式的方法的<code>this</code>参数。</p><h4 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理<code>lambda</code>表达式</h4><p>使用<code>lambda</code>表达式的重点是延迟执行（<code>deferred execution</code>）。毕竟，如果想要立即执行代码，完全可以直接执行，而无需把他包装在一个<code>lambda</code>表达式中。</p><p><strong>常用函数式接口</strong></p><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>抽象方法</th><th>描述</th><th>其他方法</th></tr></thead><tbody><tr><td><code>Runnable</code></td><td><code>无</code></td><td><code>void</code></td><td><code>run</code></td><td><code>作为无参数或返回值的动作执行</code></td><td></td></tr><tr><td><code>Supplier&lt;T&gt;</code></td><td><code>无</code></td><td><code>T</code></td><td><code>get</code></td><td><code>提供一个T类型的值</code></td><td></td></tr><tr><td><code>Consumer&lt;T&gt;</code></td><td><code>T</code></td><td><code>void</code></td><td><code>accept</code></td><td><code>提供一个T类型的值</code></td><td><code>andThen</code></td></tr><tr><td><code>BiConsumer&lt;T, U&gt;</code></td><td><code>T, U</code></td><td><code>void</code></td><td><code>accept</code></td><td><code>处理T和U类型的值</code></td><td><code>andThen</code></td></tr><tr><td><code>Function&lt;T, R&gt;</code></td><td><code>T</code></td><td><code>R</code></td><td><code>apply</code></td><td><code>有一个T类型参数的函数</code></td><td><code>compose, andThen, identity</code></td></tr><tr><td><code>BiFunction&lt;T, U, R&gt;</code></td><td><code>T, U</code></td><td><code>R</code></td><td><code>apply</code></td><td><code>有T和U类型参数的函数</code></td><td><code>andThen</code></td></tr><tr><td><code>UnaryOperator&lt;T&gt;</code></td><td><code>T</code></td><td><code>T</code></td><td><code>apply</code></td><td><code>类型T上的一元操作符</code></td><td><code>compose, andThen, identity</code></td></tr><tr><td><code>BinaryOperator&lt;T&gt;</code></td><td><code>T, T</code></td><td><code>T</code></td><td><code>apply</code></td><td><code>类型T上的二元操作符</code></td><td><code>andThen, maxBy, minBy</code></td></tr><tr><td><code>Predicate&lt;T&gt;</code></td><td><code>T</code></td><td><code>boolean</code></td><td><code>test</code></td><td><code>布尔值函数</code></td><td><code>and, or, negate, isEqual</code></td></tr><tr><td><code>Bipredicate&lt;T, U&gt;</code></td><td><code>T, U</code></td><td><code>boolean</code></td><td><code>test</code></td><td><code>有两个参数的布尔值函数</code></td><td><code>and, or, negate</code></td></tr></tbody></table><p>基本类型的函数式接口</p><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>抽象方法名</th></tr></thead><tbody><tr><td><code>BooleanSupplier</code></td><td>无</td><td><code>boolean</code></td><td><code>getAsBoolean</code></td></tr><tr><td><em><code>P</code></em><code>Supplier</code></td><td>无</td><td><em><code>p</code></em></td><td><code>getAs</code><em><code>P</code></em></td></tr><tr><td><em><code>P</code></em><code>ConSumer</code></td><td><em><code>p</code></em></td><td><code>void</code></td><td><code>accept</code></td></tr><tr><td><em><code>ObjP</code></em><code>Consumer&lt;T&gt;</code></td><td><em><code>T</code><em>、</em><code>p</code></em></td><td><code>void</code></td><td><code>accept</code></td></tr><tr><td><em><code>P</code></em><code>Function&lt;T&gt;</code></td><td><em><code>p</code></em></td><td><em><code>T</code></em></td><td><code>apply</code></td></tr><tr><td><em><code>P</code></em><code>To</code><em><code>Q</code></em><code>Function</code></td><td><em><code>p</code></em></td><td><em><code>q</code></em></td><td><code>applyAs</code><em><code>Q</code></em></td></tr><tr><td><code>To</code><em><code>P</code></em><code>Function&lt;T&gt;</code></td><td><em><code>T</code></em></td><td><em><code>p</code></em></td><td><code>applyAs</code><em><code>P</code></em></td></tr><tr><td><code>To</code><em><code>P</code></em><code>Bifunction&lt;T, U&gt;</code></td><td><em><code>T</code><em>、</em><code>U</code></em></td><td><em><code>p</code></em></td><td><code>applyAs</code><em><code>P</code></em></td></tr><tr><td><em><code>P</code></em><code>UnaryOperator</code></td><td><em><code>p</code></em></td><td><em><code>p</code></em></td><td><code>applyAs</code><em><code>P</code></em></td></tr><tr><td><em><code>P</code></em><code>BinaryOperator</code></td><td><em><code>p</code><em>、</em><code>p</code></em></td><td><em><code>p</code></em></td><td><code>applyAs</code><em><code>P</code></em></td></tr><tr><td><em><code>P</code></em><code>Predicate</code></td><td><em><code>p</code></em></td><td><code>boolean</code></td><td><code>test</code></td></tr></tbody></table><p><strong>注 <em><code>p</code><em>、</em><code>q</code></em> 是<code>int</code>、<code>long</code>、<code>double</code>；*<code>P</code><em>、</em><code>Q</code>*是<code>Int</code>、<code>Long</code>、<code>Double</code></strong></p><blockquote><p>如果设计你自己的接口，其中只有一个抽象方法，可以用<code>@FunctionalInterface</code>注解来标记这个接口。</p></blockquote><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><strong>内部类</strong>（<code>inner class</code>）是定义在另一个类中的类。</p><ul><li>内部类可以对同一个包中的其他类隐藏。</li><li>内部类方法可以访问定义这个类的作用域中的数据，包括原本私有的数据。</li></ul><h4 id="使用内部类访问对象状态"><a href="#使用内部类访问对象状态" class="headerlink" title="使用内部类访问对象状态"></a>使用内部类访问对象状态</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TalkingClock</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> interval<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> beep<span class="token punctuation">;</span> <span class="token comment">// 注意这个变量，在内部类中被访问了</span>        <span class="token keyword">public</span> <span class="token class-name">TalkingClock</span><span class="token punctuation">(</span><span class="token keyword">int</span> interval<span class="token punctuation">,</span> <span class="token keyword">boolean</span> beep<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimePrinter</span> impements <span class="token class-name">ActinListener</span> <span class="token punctuation">{</span> <span class="token comment">// 这是一个内部类</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 注意这里的 if(beep)中 beep 是外部类的变量</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>beep<span class="token punctuation">)</span> <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultTooklit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个内部类方法可以访问自己的数据字段，以可以访问创建它的外围类对象的数据字段。为此，内部类的对象总有一个隐式引用，指向创建它的外部类对象。</p><img src="/2022/06/28/java/core-java-volume-0/inner_class_0.png" class="" title="inner_class_0"><p>这个引用在内部类的定义中是不可见的。外围类的引用在构造器中设置。编译器会修改所有的内部类构造器，添加一个对应外围类引用的参数。</p><h4 id="内部类的特殊语法规则"><a href="#内部类的特殊语法规则" class="headerlink" title="内部类的特殊语法规则"></a>内部类的特殊语法规则</h4><p>当然使用外部类的引用，有一个更专业的语法：<code>OuterClass.this</code>，表示对外围类的引用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimePrinter</span> impements <span class="token class-name">ActinListener</span> <span class="token punctuation">{</span> <span class="token comment">// 这是一个内部类</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 注意这里的 if(beep)中 beep 是外部类的变量</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">TalkingClock</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>beep<span class="token punctuation">)</span> <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultTooklit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="内部类的编译文件"><a href="#内部类的编译文件" class="headerlink" title="内部类的编译文件"></a>内部类的编译文件</h4><p><strong>内部类</strong>是一个<strong>编译器现象</strong>，与虚拟机无关。编译器将会把内部类转换为常规的类文件，用<code>$</code>分割外部类名与内部类名，而虚拟机则对此一无所知。</p><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>可以在一个方法中局部地定义一个类，这样就可以只限定于在方法块中使用这个类，这样局部类有一个很大的优势，即对外部世界完全隐藏。</p><p>声明局部类时不能有访问说明符。</p><p>局部类还有一个优点，它们不仅能够访问外部类的字段，还可以访问局部变量！不过，那些局部变量必须是<strong>事实最终变量</strong>（<code>effectively final</code>）。和<code>lambda</code>表达式中的相同限定。</p><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>如果只想创建这个类的一个对象，甚至不需要为类指定名字，这样的一个类被称为<strong>匿名内部类</strong>（<code>anonymous inner class</code>）</p><p>大致的结构如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span>construction parameters<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// inner class methods and data</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>其中SuperType可以时接口，如ActionListener，这样就是实现了这个接口；</li><li>也可以时一个类，这样就是扩展这个类，相当于内部类继承这个类。</li></ol><p><strong>匿名内部类不能有构造器</strong>，实际上，构造参数要传递给超类构造器。</p><blockquote><p>尽管匿名类不能有构造器，但可以提供一个对象初始化块：</p><p>var count = new Person(“Dracula”) {</p><p>​{initialization}</p><p>}</p></blockquote><blockquote><p>下面有个技巧为“双括号初始化”（double brace initialization），利用内部类的语法创建并初始化一个数组列表并传递给一个方法：</p><p><code>invite(new ArrayList&lt;String&gt;() {{ add("Harry"); add("Tony"); }})</code></p><p>这里外层括号建立了<code>ArrayList</code>的一个匿名子类。内层括号则是一个对象初始化块。</p></blockquote><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>有时候使用内部类只是为了把一个类隐藏在另一个类的内部，并不需要内部类有外围类对象的一个引用。为此，可以将内部类声明为<code>static</code>，这样就不会生成那个引用了，如果将访问权限设置为public，同时也可以提供给其他类访问。静态内部类类似于其他内部类，只是没有对外部类的引用。</p><blockquote><p>与常规内部类不同，静态内部类可以有静态字段和方法。</p><p>在接口中声明的内部类自动是<code>static</code>和<code>public</code></p></blockquote><h2 id="异常、断言和日志"><a href="#异常、断言和日志" class="headerlink" title="异常、断言和日志"></a>异常、断言和日志</h2><h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p>异常对象都是派生于<code>Throwable</code>类的一个类实例。</p><p>Java语言规范将派生于Error类或RuntimeException类的所有异常称为非检查型（<code>unchecked</code>）异常，所有其他的异常称为检查型（<code>checked</code>）异常。</p><img src="/2022/06/28/java/core-java-volume-0/throwable.png" class="" title="throwable"><h4 id="声明检查型异常"><a href="#声明检查型异常" class="headerlink" title="声明检查型异常"></a>声明检查型异常</h4><blockquote><p>如果在子类中覆盖了超累的一个方法，子类方法中声明的检查型异常不能比超类方法中声明的异常更通用（子类方法可以抛出更特定的异常，或者根本不抛出任何异常）。</p><p>如果超类方法没有抛出任何检查型异常，子类已不能抛出任何检查型异常。</p></blockquote><h4 id="如何抛出异常"><a href="#如何抛出异常" class="headerlink" title="如何抛出异常"></a>如何抛出异常</h4><p>下面是抛出这个异常的语句：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EOFException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h4><p>只需要定义一个派生于<code>Exception</code>的类，或者派生于<code>Exception</code>的某个子类。</p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><h4 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>捕获异常需要使用到，<code>try/catch</code>语句块：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// code</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExceptionType</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// handler for this type</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果<code>try</code>语句块中的任何代码抛出了<code>catch</code>子句中指定的一个异常类，那么：</p><ol><li>程序将跳过<code>try</code>语句块的其他代码</li><li>程序将执行catch子句中的处理器代码</li></ol><h4 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// code that might throw exceptions</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundExcption</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// code</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnknownHostExcption</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// code</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IoExcption</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// code</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在java7之后，同一个catch子句中可以捕获多个异常类型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// code that might throw exceptions</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundExcption</span> <span class="token operator">|</span> <span class="token class-name">UnknownHostExcptione</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// code</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IoExcption</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// code</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>捕获多个异常时，异常变量隐含为final变量，例如，在以下子句体中不能为 e 赋予不同的值：</p><p><code>catch (FileNotFoundExcption | UnknownHostExcptione e) { ... }</code></p></blockquote><h4 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// access the database</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> original<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServletException</span><span class="token punctuation">(</span><span class="token string">"database error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span><span class="token function">initCause</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a><code>finally</code>子句</h4><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">var in = new FileInputStream(...);try {    // code that might throw exceptions} catch (IOException e) {    // show error message} finally {    in.close()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，不管是否有异常被捕获，<code>finally</code>子句中的代码都会执行。<code>finally</code>在块（<code>try</code> 或者 <code>catch </code>部分）的“<strong>跳出</strong>”之前执行其中的代码。</p><p>同时，<code>try</code>语句可以只有<code>finally</code>子句，而没有<code>catch</code>子句：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// code that might throw exceptions</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当<code>finally</code>子句包含<code>return</code>语句时，可能会产生意想不到的结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// ERROR</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上所示，在方法返回前，会执行<code>finally</code>子句块，如果<code>finally</code>块也有一个<code>return</code>语句，这个返回值将会遮蔽原来的返回值。如果执行 <code>parseInt("42")</code> ，真正返回前会执行<code>finally</code>子句，使得方法最后返回一个0，而忽略原来的返回值。</p><p>更糟糕的是，如果 <code>parseInt("zero")</code> ，会抛出异常，return甚至会“吞掉”这个异常。</p><p><code>finally</code>子句的主要用于清理资源。不要把改变控制流的语句（<code>return，throw，break，continue</code>）放在<code>finally</code>子句中。</p></blockquote><h4 id="try-with-Resources语句"><a href="#try-with-Resources语句" class="headerlink" title="try-with-Resources语句"></a><code>try-with-Resources</code>语句</h4><p>最简格式为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span> <span class="token class-name">Resource</span> res <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// work with res</span><span class="token punctuation">}</span><span class="token comment">// 同时这里还可以定义多个资源</span><span class="token keyword">try</span> <span class="token punctuation">(</span> <span class="token class-name">Resource</span> in <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token class-name">Resource</span> out <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// work with res</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，<code>try</code>块退出时，会自动调用<code>res.close()</code>。不论这个块如何退出，异常或者正常退出，都会执行<code>res.close()</code>。</p><p>在<code>Java9</code>中，可以在try首部中提供之前声明的事实最终变量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printAll</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lines<span class="token punctuation">,</span> <span class="token class-name">PrintWriter</span> out<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>out<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// effectively final variable</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> line <span class="token operator">:</span> lines<span class="token punctuation">)</span> <span class="token punctuation">{</span>            out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token comment">// out.close() called here</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果try块抛出一个异常，而且<code>close</code>方法也抛出一个异常，这样就会带来一个难题。<code>try-with-resources</code>语句可以很好地处理这种情况。<strong>原来的异常会重新抛出，而<code>close</code>方法抛出的异常会“被抑制”。这些异常将自动捕获，并由<code>addSuppressed</code>方法增加到原来的异常</strong>。如果对这些异常感兴趣，可以调用<code>getSuppressed</code>方法，它会生成从<code>close</code>方法抛出并被抑制的异常数组。</p><blockquote><p><code>try -with-resources</code>语句自身也可以有catch子句，甚至还可以有一个finally子句。这些子句会在关闭资源后执行。<strong>注意是在关闭资源后执行</strong>。</p></blockquote><h4 id="分析堆栈轨迹元素"><a href="#分析堆栈轨迹元素" class="headerlink" title="分析堆栈轨迹元素"></a>分析堆栈轨迹元素</h4><p><strong>堆栈轨迹</strong>（<code>stack trace</code>）是程序执行过程中某个特定点上所欲哦挂起的方法调用的一个列表。可以调用<code>Throwable</code>类的<code>printStackTrace</code>方法访问堆栈轨迹。</p><h3 id="使用异常的技巧"><a href="#使用异常的技巧" class="headerlink" title="使用异常的技巧"></a>使用异常的技巧</h3><ol><li><p><strong>异常处理不能代替简单的测试</strong></p></li><li><p><strong>不要过分地细化异常</strong></p><p>将正常处理与错误处理分开</p></li><li><p><strong>充分利用异常层次结构</strong></p><p>不要只抛出RuntimeException异常，应该寻找一个合适的子类或创建自己的异常类。</p><p>不要只捕获Throwable异常，否则，这会使你的代码更难读、更难维护。</p></li><li><p><strong>不要压制异常</strong></p></li><li><p><strong>在检测错误时，“苛刻”要比放任更好</strong></p></li><li><p><strong>不要羞于传递异常</strong></p></li></ol><h3 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h3><h4 id="断言的概念"><a href="#断言的概念" class="headerlink" title="断言的概念"></a>断言的概念</h4><p>断言机制允许在测试期间向代码中插入一些检查，而在产生代码中会自动删除这些检查。</p><p>Java语言引入了关键字 assert。这个关键字有两种形式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">assert</span> condition<span class="token punctuation">;</span><span class="token keyword">assert</span> condition <span class="token operator">:</span> expression<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="启用和禁用断言"><a href="#启用和禁用断言" class="headerlink" title="启用和禁用断言"></a>启用和禁用断言</h4><p>在默认情况下，断言时禁用的。可以在运行时用-enableassertions或-ea选项启用断言：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ java -enableassertions MyApp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要注意的是，不必重新编译程序来启用或禁用断言。启用或禁用断言是<strong>类加载器</strong>（<code>class loader</code>）的功能。禁用断言时，类加载器会去除断言代码。</p><p>也可以在某个类或整个包中启用断言，例如：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ java -ea:MyClass -ea:com.mycompany.mylib MyApp<span class="token comment"># 在MyClass类以及com.mycompany.mylib包和它的子包</span><span class="token comment"># 使用 -disableassertions 或 -da</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不过，启用和禁用所有断言的<code>-ea</code>和<code>-da</code>开关不能应用到那些没有类加载器的“系统类”上。对于这些系统类，需要使用<code>-enablesystemassertions/-esa</code>开关启用断言。</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>暂略</p><h2 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h2><h3 id="为什么要使用泛型程序设计"><a href="#为什么要使用泛型程序设计" class="headerlink" title="为什么要使用泛型程序设计"></a>为什么要使用泛型程序设计</h3><p><strong>反省程序设计</strong>（<code>generic programming</code>）意味着编写的代码可以对多种不同类型的对象重用。</p><p>这种设计可以让程序更易读，也更安全。</p><h3 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h3><p><strong>泛型类</strong>（<code>generic class</code>）就是有一个或多个类型变量的类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">T</span> first<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">T</span> second<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> first <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> second <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token class-name">T</span> first<span class="token punctuation">,</span> <span class="token class-name">T</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> first<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirst</span><span class="token punctuation">(</span><span class="token class-name">T</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecond</span><span class="token punctuation">(</span><span class="token class-name">T</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Pair</code> 类引入了一个类型变量T，用尖括号（<code>&lt;&gt;</code>）括起来，放在类名的后面。当然也可以定义多个类型变量：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>Java</code>库使用变量<code>E</code>表示集合的元素类型，<code>K</code>和<code>V</code>分别表示表的键和值的类型。<code>T</code>（必要时还可以用相邻的字母<code>U</code>和<code>S</code>）表示“任意类型”</p></blockquote><p>可以使用具体的类型替换类型变量来实例化（<code>instantiate</code>）泛型类型，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>除了可以定义泛型类之外，还可以定义一个带有类型参数的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ArrayAlg</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">getMiddle</span><span class="token punctuation">(</span><span class="token class-name">T</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token punctuation">[</span>a<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法实在普通类中定于的，而不是在泛型类中。注意，类型变量放在修饰符（这里的修饰符就是public static）的后面，并在返回类型的前面。</p><p>泛型方法可以再普通类中定义，也可以在泛型类中定义。</p><p>当调用一个泛型方法时，可以把具体类型包围在尖括号中：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> middle <span class="token operator">=</span> <span class="token class-name">ArrayAlg</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token function">getMiddle</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token string">"Q."</span><span class="token punctuation">,</span> <span class="token string">"Public"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样，在方法调用中可以省略<code>&lt;String&gt;</code>类型参数。编译器可以将参数的类型和泛型类型<code>T</code>进行匹配，推断出T一定是<code>String</code>。</p><h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><p>有时候类或方法需要对类型变量加以约束，这时候就可以通过对类型变量<code>T</code>设置一个限定（<code>bound</code>）来实现这一点：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里表示T应该时限定类型（<code>bounding type</code>）的子类型（<code>subtype</code>）。<code>T</code>和限定类型可以是类，也可以时接口。选择关键词<code>extends</code>的原因是它更接近于子类型的概念。同样一个类型变量或通配符可以有多个限定，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Compatable</span> <span class="token operator">&amp;</span> <span class="token class-name">Serializable</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>限定类型用“<code>&amp;</code>”分割，而逗号用来分隔类型变量。</p><p><strong>在<code>Java</code>的继承中，可以根据需要拥有多个接口超类型，但最多有一个限定可以是类。如果有一个类作为限定，它必须是限定列表中的第一个限定。</strong></p><h3 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h3><p>虚拟机没有泛型类型对象——所有对象都属于普通类。在泛型实现的早期版本中，甚至能够将使用泛型的程序编译为1.0虚拟机上运行的类文件！在下面的小结中可以看到编译器如何“擦除”类型参数。</p><h4 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h4><p>无论何时定义一个泛型类型，都会自动提供一个相应的<strong>原始类型</strong>（<code>raw type</code>）。这个原始类型的名字就是去掉类型参数后的泛型类型名。类型变量会被<strong>擦除</strong>（<code>erased</code>），并替换为其限定类型（或者，对于无限定的变量则替换为<code>Object</code>）。</p><p>例如，<code>Pair&lt;T&gt;</code>的原始类型如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> first<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> second<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> first <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> second <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token class-name">Object</span> first<span class="token punctuation">,</span> <span class="token class-name">Object</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> first<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirst</span><span class="token punctuation">(</span><span class="token class-name">Object</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecond</span><span class="token punctuation">(</span><span class="token class-name">Object</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为<code>T</code>是一个无限定的变量，所以直接用<code>Object</code>替代。</p><p><strong>原始类型用第一个限定来替换类型变量，或者，如果没有给定限定，就替换为<code>Object</code>。</strong>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Interval</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span> <span class="token operator">&amp;</span> <span class="token class-name">Serializable</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">T</span> first<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">T</span> second<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token class-name">T</span> first<span class="token punctuation">,</span> <span class="token class-name">T</span> second<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类型擦除后，原始类型<code>Interval</code>如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Interval</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Comparable</span> first<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Comparable</span> second<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span> first<span class="token punctuation">,</span> <span class="token class-name">Comparable</span> second<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果将限定切换为<code>Class Interval&lt;T extends Serializable &amp; Comparable&gt;</code>会发生什么。如果这样操作，原始类型会用<code>Serializable</code>替换<code>T</code>，而编译器在必要时要向<code>Comparable</code>插入强制类型转换。<strong>为了提高效率，应该将标签（<code>tagging</code>）接口（即没有方法的接口）放在限定列表的末尾。</strong></p></blockquote><h4 id="转换泛型表达式"><a href="#转换泛型表达式" class="headerlink" title="转换泛型表达式"></a>转换泛型表达式</h4><p>编写一个泛型方法调用时，如果擦除了返回类型，编译器会插入强制类型转换。例如，对于下面的语序：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> buddies <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token class-name">Employee</span> buddy <span class="token operator">=</span> buddies<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>getFirst</code>擦除类型后的返回类型时<code>Object</code>。编译器自动插入转换到<code>Employee</code>的强制类型转换。</p><h4 id="转换泛型方法"><a href="#转换泛型方法" class="headerlink" title="转换泛型方法"></a>转换泛型方法</h4><p>对于<code>Java</code>泛型转换，需要记住以下几个事实：</p><ul><li>虚拟机中没有泛型，只有普通的类和方法。</li><li>所有的类型参数都会替换它们的限定类型。</li><li>会合成<strong>桥方法</strong>来保持多态。</li><li>为保持类型安全性，必要时会插入强制类型转换。</li></ul><h3 id="限制和局限性"><a href="#限制和局限性" class="headerlink" title="限制和局限性"></a>限制和局限性</h3><p><strong>这些限定和局限性的主要造成原因就是<font color="blue">类型擦除</font></strong></p><h4 id="不能用基本类型实例化类型参数"><a href="#不能用基本类型实例化类型参数" class="headerlink" title="不能用基本类型实例化类型参数"></a>不能用基本类型实例化类型参数</h4><p>不能用基本类型代替类型参数。因此没有<code>Pair&lt;double&gt;</code>，只有<code>Pair&lt;Double&gt;</code>。其原因就在于类型擦除。擦除之后，<code>Pair</code>类含有<code>Object</code>类型的字段，而<code>Object</code>不能存储<code>double</code>值。</p><h4 id="运行时类型查询值适用于原始类型"><a href="#运行时类型查询值适用于原始类型" class="headerlink" title="运行时类型查询值适用于原始类型"></a>运行时类型查询值适用于原始类型</h4><p>虚拟机中的对象总有一个特定的非泛型类型。因此，所有的类型查询只产生原始类型。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// ERROR</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// ERROR</span><span class="token comment">// 或者强制类型转换</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> a<span class="token punctuation">;</span> <span class="token comment">// warning can only test that a is a Pair</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的道理，getClass方法总是<strong>返回原始类型并不是泛型</strong>，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stringPair <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> employeePair <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>stringPair<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> employeePair<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// they are equal</span><span class="token comment">// getClass() 返回 Pair.class    </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h4><p>不能实例化参数化类型的数据，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// ERROR</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为，擦除之后，<code>table</code>的类型时Pair[]. 可以把它转换为<code>Object[]</code>：<code>Object[] objarray = table;</code></p><p>如果试图存储其他类型的元素，就会抛出一个<code>ArrayStoreException</code>异常：<code>objarray[0] = "Hello";</code></p><p>不过对于泛型类型，擦除会使这种机制无效。赋值语句：<code>objarray[0] = new Pair&lt;Employee&gt;();</code>，尽管能够通过数组存储的检查，仍然会导致一个类型错误。由于这个原因，不允许创建参数化类型的数组。</p><p>需要说明的是，指示不允许创建这个数组，而声明类型为<code>Pair&lt;String&gt;[]</code>的变量仍是合法的。不过不能用<code>new Pair&lt;String&gt;[10]</code>初始化这个变量。</p><blockquote><p>可以声明通配类型的数组，然后进行强制类型转换：（不过是不安全的初始化）</p><p><code>var table = (Pair&lt;String&gt;[]) new Pair&lt;?&gt;[10];</code></p></blockquote><h4 id="Varargs警告"><a href="#Varargs警告" class="headerlink" title="Varargs警告"></a><code>Varargs</code>警告</h4><p>向参数个数可变的方法传递一个泛型类型的实例。</p><p>下面的简单方法，它的参数个数是可变的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> coll<span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ts<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 存在警告但是还可以使用</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">T</span> t <span class="token operator">:</span> ts<span class="token punctuation">)</span> <span class="token punctuation">{</span>        coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>考虑下面的调用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pair</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> table <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> pair1 <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> pair2 <span class="token operator">-</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token function">addAll</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> pair1<span class="token punctuation">,</span> pair2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为了调用这个方法，Java虚拟机必须建立一个Pair<strintg>数组，这违反了<a href="####%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E7%BB%84">上面的规则</a>。</strintg></p><blockquote><p>这里可以使用两个注解来抑制这个警告：<code>@SuppressWarnings("unchecked")</code> 和 <code>@SafeVarargs</code></p></blockquote><h4 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h4><p>不能在类似 new T(…) 的表达式中使用类型变量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> first <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> second <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// ERROR</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型擦除将T变成Object，这样就变成调用 new Object()，不是所期望的。</p><p>在Java 8 之后，最好的解决办法是让调用者提供一个构造器表达式。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token class-name">Pair</span><span class="token punctuation">.</span><span class="token function">makePair</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">makePair</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> constr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>constr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> constr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="不能构造泛型数组"><a href="#不能构造泛型数组" class="headerlink" title="不能构造泛型数组"></a>不能构造泛型数组</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">minmax</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//Error</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>因为<strong>类型擦除</strong>的原因，这里会使得这个方法总是构造<code>Comparable[2]</code>数组。</p><p>所以这种情况下最好是让用户提供一个数组构造器表达式：</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">String[] names = ArrayAlg.minmax(String[]::new, "Tom", "Dick", "Harry");public static &lt;T extends Comparable&gt; T[] minman(IntFunction&lt;T[]&gt; constr, T... a) {    T[] result = constr.apply(2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型类的静态上下文中类型变量无效"><a href="#泛型类的静态上下文中类型变量无效" class="headerlink" title="泛型类的静态上下文中类型变量无效"></a>泛型类的静态上下文中类型变量无效</h4><p>不能在静态字段或方法中引用类型变量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singletion</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">T</span> singleInstance<span class="token punctuation">;</span> <span class="token comment">// ERROR</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">T</span> <span class="token function">getSingleInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ERROR</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> singleInstance<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上所示，类型擦除之后，只剩下Singleton类，它只包含一个singleInstance字段。因此，禁止使用带有类型变量的静态字段和方法。</p><h4 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h4><p>既不能抛出也不能捕获泛型类的对象。实际上，泛型类扩展<code>Throwable</code>甚至都是不合法的。例如，以下定义就不合法 <code>public class Problem&lt;T&gt; extends Exception {}</code>，不过，在异常规范中使用类型变量是允许的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// do work </span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> realCause<span class="token punctuation">)</span> <span class="token punctuation">{</span>        t<span class="token punctuation">.</span><span class="token function">initCause</span><span class="token punctuation">(</span>realCause<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="可以取消对检查型异常的检查"><a href="#可以取消对检查型异常的检查" class="headerlink" title="可以取消对检查型异常的检查"></a>可以取消对检查型异常的检查</h4><p>Java异常处理的一个基本原则是，必须为所有检查型异常提供一个处理器。不过可以利用泛型取消这个机制。关键方法在于：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">throwAs</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意擦除后的冲突"><a href="#注意擦除后的冲突" class="headerlink" title="注意擦除后的冲突"></a>注意擦除后的冲突</h4><p>为了支持擦除转换，倘若两个接口类型是同一个接口的不同参数化，一个类或类型变量就不能同时作为这个两个接口类型的子类。例如，下面的代码时非法的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Manager</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span class="token comment">// ERROR</span><span class="token comment">// Manager 会实现Comparable&lt;Employee&gt; 和 Comparable&lt;Manager&gt; ， 这是同一个接口的不同参数化.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3><img src="/2022/06/28/java/core-java-volume-0/pair.png" class="" title="pair"><h3 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h3><h4 id="通配符概念"><a href="#通配符概念" class="headerlink" title="通配符概念"></a>通配符概念</h4><p>在通配符类型中，允许类型参数发生变化。例如，通配符类型：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示任何泛型<code>Pair</code>类型，它的类型参数时<code>Employee</code>的子类，如<code>Pair&lt;Manager&gt;</code>，但不是<code>Pair&lt;String&gt;</code>。</p><h4 id="通配符的超类型限定"><a href="#通配符的超类型限定" class="headerlink" title="通配符的超类型限定"></a>通配符的超类型限定</h4><p>除了继承限定外，还可以指定<strong>超类型限定</strong>：<code>? super Manager</code>。这个通配符限制为<code>Manager</code>的所有超类型。</p><p>直白的来说，带有超类型限定的通配符（<code>&lt;? super Manager&gt;</code>）允许你写入一个泛型对象，而带有子类型限定的通配符（<code>? extends Employee</code>）允许你读取一个泛型对象。</p><blockquote><p>超类型限定（<code>&lt;? super Manager&gt;</code>）： 可以明确的通过Manager知道其继承的超类，所以方便于写入一个泛型对象。</p><p>子类型限定（<code>? extends Employee</code>）：可以明确的知道返回的类型都是Employee的子类，所以方便于读取一个泛型对象。</p></blockquote><p>超类限定和子类限定同时使用：<code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; T min(T[] a)</code></p><h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><p>还可以使用根本无限定的通配符，例如，<code>Pair&lt;?&gt;</code>。初看起来，这好像与原始的Pair类型一样。实际上，这两种类型有很大的不同。类型Pair&lt;?&gt;有以下方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">?</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">setFirst</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>getFirst</code>的返回值只能赋给一个<code>Object</code>。<code>setFirst</code>方法不能被调用，甚至不能用<code>Object</code>调用（可以调用<code>setFirst&lt;null&gt;</code>）。<code>Pair&lt;?&gt;</code>和<code>Pair</code>本质的不同在于：可以用任意<code>Object</code>对象调用原始<code>Pair</code>类的<code>setFirst</code>方法。</p><p>为什么要使用这样一个脆弱的类型？它对于很多简单操作非常有用。例如，下面这个方法可用来测试一个对组是否包含一个<code>null</code>引用，它不需要实际的类型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">hasNulls</span><span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> p<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> p<span class="token punctuation">.</span><span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过将<code>hasNulls</code>转换成泛型方法，可以避免使用通配符类型：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">boolean</span> <span class="token function">hasNulls</span><span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是 ，带有通配符的版本可读性更好。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a><code>Java</code>集合框架</h3><h4 id="集合接口与实现分类"><a href="#集合接口与实现分类" class="headerlink" title="集合接口与实现分类"></a>集合接口与实现分类</h4><p><code>Java</code>集合类库也将接口（<code>interface</code>）与实现（<code>implementation</code>）分离。</p><h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a><code>Collection</code>接口</h4><p>在<code>Java</code>类库中，集合类的基本接口时<code>Collection</code>接口。这个接口有两个基本方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 向集合中添加元素</span>    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 迭代器</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p><code>Iterator</code>接口包含4个方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">forEachRemaining</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过反复调用<code>next</code>方法，可以逐个访问及各种的每个元素。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> iter <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> element <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// do something with element</span><span class="token punctuation">}</span><span class="token comment">// 这样的循环可以用“ for each ”， 编译器简单的将其转换为带有迭代器的循环。</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> element <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// do something with element</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>“<code>for each</code>”循环可以处理任何实现了Iterable接口的对象，这个接口只包含一个抽象方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也可以不写循环，而是调用<code>forEachRemaining</code>方法并提供一个<code>lambda</code>表达式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">iterator<span class="token punctuation">.</span><span class="token function">forEachRemaining</span><span class="token punctuation">(</span>element <span class="token operator">-&gt;</span> <span class="token keyword">do</span> something <span class="token keyword">with</span> <span class="token namespace">element</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>Java</code>的迭代器，查找操作和位置变更十分紧密耦合。查找一个元素的唯一方法时调用<code>next</code>，而在执行查找操作的同时，迭代器的位置就会随之向前移动。因此，<strong>可以认为<code>Java</code>迭代器位于两个元素之间，当调用<code>next</code>时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用</strong>。如下图：</p><img src="/2022/06/28/java/core-java-volume-0/iterator_0.png" class="" title="iterator_0"><p><code>Iterator</code>接口的<code>remove</code>方法将会<strong>删除上次调用</strong><code>next</code>方法时返回的对象。如果想要删除指定位置上的元素，仍然需要越过这个元素。例如，可以如下删除一个字符串集合中的第一个元素：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// skip over the first element</span>it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// now remove it</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>跟重要的时，<code>next</code>方法调用之间存在依赖性。如果调用<code>remove</code>之前没有调用<code>next</code>，将时不合法的。如果这样做，将会抛出一个<code>IllegalStateException</code>异常</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ERROR</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上，必须先调用<code>next</code>越过将要删除的元素</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h3><img src="/2022/06/28/java/core-java-volume-0/collection_0.png" class="" title="collection_0"><p><code>List</code>是一个有序集合（<code>ordered collection</code>）。元素会增加到容器中的特定位置。可以采用两种方式访问元素</p><ul><li>使用迭代器访问</li><li>使用一个整数索引来访问<ul><li>又称为<strong>随机访问</strong>（<code>random access</code>）</li></ul></li></ul><h3 id="具体集合"><a href="#具体集合" class="headerlink" title="具体集合"></a>具体集合</h3><blockquote><p><strong>线程安全</strong>的集合在后续介绍</p></blockquote><table><thead><tr><th>集合类型</th><th>描述</th><th>参见</th></tr></thead><tbody><tr><td><code>ArrayList</code></td><td>可以动态增长和缩减的一个索引序列</td><td></td></tr><tr><td><code>LinkedList</code></td><td>可以在任何位置高效插入和删除的一个有序序列</td><td><a href="####%E9%93%BE%E8%A1%A8">链表</a></td></tr><tr><td><code>ArrayDeque</code></td><td>实现为循环数组的一个双端队列</td><td></td></tr><tr><td><code>HashSet</code></td><td>没有重复元素的一个无序集合</td><td></td></tr><tr><td><code>TreeSet</code></td><td>一个有序集</td><td></td></tr><tr><td><code>LinkedHashSet</code></td><td>一个包含枚举值的集</td><td></td></tr><tr><td><code>PriorityQueue</code></td><td>允许高效删除最小元素的一个集合</td><td></td></tr><tr><td><code>HashMap</code></td><td>存储键/值关联的一个数据结构</td><td></td></tr><tr><td><code>TreeMap</code></td><td>键有序的一个映射</td><td></td></tr><tr><td><code>EnumMap</code></td><td>键属于枚举类型的一个映射</td><td></td></tr><tr><td><code>LinkedHashMap</code></td><td>可以记住键/值项添加次序的一个映射</td><td></td></tr><tr><td><code>WeakHashMap</code></td><td>值不会在别处使用时就可以被垃圾回收的一个映射</td><td></td></tr><tr><td><code>IdentityHashMap</code></td><td>用<code>==</code>而不是用<code>equals</code>比较键的一个映射</td><td></td></tr></tbody></table><img src="/2022/06/28/java/core-java-volume-0/collection_1.png" class="" title="collection_0"><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表是一个有序集合，每个对象的位置十分重要。</p><p>在<code>Java</code>程序设计语言中，所有链表实际上都是<strong>双向链表</strong>（<code>doubly linked</code>）</p><p>如果需要对集合进行随机访问，就是用数组或<code>ArrayList</code>。</p><img src="/2022/06/28/java/core-java-volume-0/linkedlist.png" class="" title="linkedlist"><h4 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h4><p><code>List</code>是一个有序集合（<code>ordered collection</code>）。元素会增加到容器中的特定位置。可以采用两种方式访问元素</p><ul><li>使用迭代器访问</li><li>使用一个整数索引来访问<ul><li>又称为随机访问（<code>random access</code>），这种访问方式不适用于链表，更适用于数组。</li></ul></li></ul><blockquote><p>这里的动态数组，还涉及到<code>Vector</code>类，为什么要用<code>ArrayList</code>而不是<code>Vector</code>呢？原因在于：<code>Vector</code>类的所有方法都是同步的，可以安全地从两个线程访问一个<code>Vector</code>对象。但是，如果只从一个线程访问<code>Vector</code>，代码就会在同步操作上白白浪费大量时间。而与之不同，<code>ArrayList</code>方法不是同步的，因此，建议在不需要同步时使用<code>ArrayList</code>，而不要使用<code>Vector</code>。</p></blockquote><h4 id="散列集"><a href="#散列集" class="headerlink" title="散列集"></a>散列集</h4><p><strong>散列表</strong>（<code>hash table</code>），可以用于快速地查找对象。</p><p>散列表为每个对象计算一个整数，称为<strong>散列码</strong>（<code>hash code</code>）。散列码是由对象的实例字段得出的一个整数，有不同数据的对象将产生一个不同的散列码。</p><p>在<code>Java</code>中，散列表用链表数组实现。每个列表被称为<strong>桶</strong>（<code>bucket</code>）。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。在桶中没有其他元素，此时将元素直接插入到桶中就可以了。当然，有时候会遇到桶已经被填充的情况。这种现象被称为<strong>散列冲突</strong>（<code>hash collision</code>）。这时，需要将新对象与桶中的所有对象比较，查看这个对象是否存在。</p><blockquote><p>在Java8中，桶满时会从链表变为平衡二叉树</p></blockquote><p>散列集迭代器将依次访问所有的桶，由于散列将元素分散在表中，所以会以一种看起来随机的顺序访问元素。这就是<strong>散列集无序</strong>的原因。</p><p>如果散列表太满，就需要<strong>再散列</strong>（<code>rehashed</code>）。创建一个桶数更多的表，插入数据后丢弃掉原来的表。<strong>装填因子</strong>（<code>load factor</code>）可以确定何时对散列表进行再散列。</p><img src="/2022/06/28/java/core-java-volume-0/hash_table.png" class="" title="hash_table"><h4 id="树集"><a href="#树集" class="headerlink" title="树集"></a>树集</h4><p><code>TreeSet</code>类与散列集十分类型，不过，相对于散列集有所改进。树集是一个<strong>有序集合</strong>（<code>sorted collection</code>）。树集的排序是用一个<strong>树</strong>数据结构完成的（目前实现使用的是<strong>红黑树</strong>（<code>red-black tree</code>））</p><blockquote><p>要使用树集，必须能够比较元素，这些元素必须实现<code>Comparable</code>接口，或者构造集必须提供一个<code>Comparator</code>。</p></blockquote><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p><strong>优先队列</strong>（<code>priority queue</code>）中的元素可以按照任意的顺序插入，但会按照有序的顺序进行检索。也就是说，无论何时调用<code>remove</code>方法，总会获得优先队列中最小的元素。这里优先队列并没有对所有元素进行排序，是因为优先队列使用了一个精巧且高效的数据结构，称为堆（<code>heap</code>）。堆是一个 可以自组织的二叉树，其添加（<code>add</code>）和删除（<code>remove</code>）操作可以让最小的元素移动到根，而不必花费时间对元素进行排序。</p><p>优先队列的典型用法是<strong>任务调度</strong>。</p><blockquote><p>和树集一样，要使用优先队列，必须能够比较元素，这些元素必须实现<code>Comparable</code>接口，或者构造集必须提供一个<code>Comparator</code>。</p></blockquote><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>映射用来存放键/值对，如果提供了键，就能够查找到值。</p><h4 id="基本映射操作"><a href="#基本映射操作" class="headerlink" title="基本映射操作"></a>基本映射操作</h4><p><code>Java</code>类库为映射提供了两个通用的实现：<code>HashMap</code>和<code>TreeMap</code>。这两个类都实现了<code>Map</code>接口。</p><p>散列映射对键进行散列，树映射根据键的顺序将元素组织为一个搜索树。散列或比较函数只应用于键，与键关联的值不进行散列或比较。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// HashMap implements Map</span><span class="token keyword">var</span> harry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>staff<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"23"</span><span class="token punctuation">,</span> harry<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// put() 保存值，只保存最近存储的值</span><span class="token class-name">Employee</span> e <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"23"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// gets harry</span><span class="token comment">// 迭代处理映射的键和值， 使用方法 forEach</span>staff<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"key"</span> <span class="token operator">+</span> k <span class="token operator">+</span> <span class="token string">", value="</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="映射试图"><a href="#映射试图" class="headerlink" title="映射试图"></a>映射试图</h4><p>集合框架不认为映射本身是一个集合。（其他数据结构框架认为映射是一个键/值对集合，或者是按键索引的值集合）不过，可以得到映射的<strong>视图</strong>（<code>view</code>）——这是实现了Collection接口或某个子接口的对象。</p><p>有3种视图：键集、值集合（不是一个集）以及键/值对集。键和键/值对可以构成一个集，应为映射中一个键值能有一个副本：</p><ul><li><code>Set&lt;K&gt; keySet()</code> <strong>键集</strong></li><li><code>Collection&lt;V&gt; values()</code> <strong>值集</strong></li><li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> <strong>键/值对集</strong></li></ul><p>会分别返回这3个视图。（映射条目集的元素是实现了<code>Map.Entry</code>接口的类的对象）</p><h4 id="链接散列集与映射"><a href="#链接散列集与映射" class="headerlink" title="链接散列集与映射"></a>链接散列集与映射</h4><p><code>LinkedHashSet</code>和<code>LinkedHashMap</code>类会记住插入元素项的顺序。这样就可以避免散列表中的项看起来顺序是随机的。在表中插入元素项时，就会并入到双向列表中，如下图：</p><img src="/2022/06/28/java/core-java-volume-0/linked_set_map.png" class="" title="linked_set_map"><p>链表散列映射可以使用<strong>访问顺序</strong>而不是插入顺序来迭代处理映射条目。每次调用<code>get</code>或<code>put</code>时，收到影响的项将从当前的位置删除，并放到项链表的尾部（只影响项在链表中的位置，而散列表的桶不会受影响。映射条目总是在键散列码对应的桶中）。要构造这样一个散列映射，需要调用：</p><p><code>LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, true)</code></p><p>访问顺序对于实现缓存的“<strong>最近最少使用</strong>”原则十分重要。</p><h4 id="枚举集与映射"><a href="#枚举集与映射" class="headerlink" title="枚举集与映射"></a>枚举集与映射</h4><p><code>EnumSet</code>是一个枚举类型元素集的高效实现。由于枚举类型只有有限个实例，所以<code>EnumSet</code>内部用位序列实现。如果对应的值在集中，则相应的位被置为<code>1</code>。</p><p><code>EnumSet</code>类没有公共的构造器。要使用静态工厂方法构造这个集：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">enum</span> <span class="token class-name">Weekday</span> <span class="token punctuation">{</span> MONDAY<span class="token punctuation">,</span> TUESDAY<span class="token punctuation">,</span> WEDNESDAY<span class="token punctuation">,</span> THUSDAY<span class="token punctuation">,</span> FRIDAY<span class="token punctuation">,</span> SATURDAY<span class="token punctuation">,</span> SUNDAY<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Weekday</span><span class="token punctuation">&gt;</span></span> always <span class="token operator">=</span> <span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span><span class="token class-name">Weekday</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Weekday</span><span class="token punctuation">&gt;</span></span> never <span class="token operator">=</span> <span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">noneOf</span><span class="token punctuation">(</span><span class="token class-name">Weekday</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Weekday</span><span class="token punctuation">&gt;</span></span> workday <span class="token operator">=</span> <span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token class-name">Weekday</span><span class="token punctuation">.</span>MONDAY<span class="token punctuation">,</span> <span class="token class-name">Weekday</span><span class="token punctuation">.</span>FRIDAY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Weekday</span><span class="token punctuation">&gt;</span></span> mwf <span class="token operator">=</span> <span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token class-name">Weekday</span><span class="token punctuation">.</span>MONDAY<span class="token punctuation">,</span> <span class="token class-name">Weekday</span><span class="token punctuation">.</span>WEDNESDAY<span class="token punctuation">,</span> <span class="token class-name">Weekday</span><span class="token punctuation">.</span>FRIDAY<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用<code>Set</code>接口的常用方法来修饰<code>EnumSet</code>。</p><p><code>EnumMap</code>是一个<strong>键类型</strong>为枚举类型的映射。可以高效地实现为一个值数组。</p><h4 id="标识散列映射"><a href="#标识散列映射" class="headerlink" title="标识散列映射"></a>标识散列映射</h4><p>类<code>IdentityHashMap</code>，键的散列值不是用<code>hashCode</code>函数计算的，而是用<code>System.identityHashCode</code>方法计算的。这是<code>Object.hashCode</code>根据对象的内存地址计算散列码时所使用的方法。而且，**在对两个对象进行比较时，<code>IdentityHashMap</code>类使用<code>==</code>**，而不使用<code>equals</code>。</p><blockquote><p>即，保存的键值即使内容相同，但是不是同一个对象（即内存地址相同）会被视为两个不同的键值。两个值相同但是不是同一个对象的键再添加时，不会相互产生值的覆盖。</p></blockquote><p>也就是说，<strong>不同的键对象即使内容相同，也被视为不同的对象</strong>。在实现对象遍历算法（如对象串行化）时，这个类非常有用，可以用来跟踪哪些对象已经遍历过。</p><h4 id="属性映射"><a href="#属性映射" class="headerlink" title="属性映射"></a>属性映射</h4><p> 属性映射（property map）是一个特殊类型的映射结构，有2个特性：</p><ul><li>键与值都是字符串。</li><li>这个映射可以很容地保存到文件以及从文件加载。</li><li>有一个二级表存放默认值。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> settings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>settings<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"width"</span><span class="token punctuation">,</span> <span class="token string">"600.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>settings<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"filename"</span><span class="token punctuation">,</span> <span class="token string">"/home/qing/books/core_java/code/raven.html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以使用store方法将属性映射列表保存到一个文件中：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"program.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 第二个参数是包含在这个文件中的注释</span><span class="token class-name">Settings</span><span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"Program Properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例如下：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#Program Properties</span><span class="token comment">#Sun Mar 12 17:47:54 CST 2023</span><span class="token attr-name">top</span><span class="token punctuation">=</span><span class="token attr-value">227.0</span><span class="token attr-name">left</span><span class="token punctuation">=</span><span class="token attr-value">1286.0</span><span class="token attr-name">width</span><span class="token punctuation">=</span><span class="token attr-value">423.0</span><span class="token attr-name">height</span><span class="token punctuation">=</span><span class="token attr-value">547.0</span><span class="token attr-name">filename</span><span class="token punctuation">=</span><span class="token attr-value">/home/qing/books/core_java/code/raven.html</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要从文件加载属性，可以使用以下调用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"program.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>settings<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Properties类有两种提供默认值的机制：</p><ol><li><p>查找一个字符串的值，可以指定一个默认值，这样当键不存在时就会自动使用这个默认值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> filename <span class="token operator">=</span> settings<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"filename"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>可以把所有默认值都放在一个二级属性映射中，并在主属性映射的构造器中提供这个二级映射。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> defaultSettings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>defaultSettings<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"width"</span><span class="token punctuation">,</span> <span class="token string">"600"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>defaultSettings<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"height"</span><span class="token punctuation">,</span> <span class="token string">"400"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>defaultSettings<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span>filename<span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用默认值初始化主属性映射</span><span class="token keyword">var</span> settings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span>defaultSettings<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="视图和包装器"><a href="#视图和包装器" class="headerlink" title="视图和包装器"></a>视图和包装器</h3><p><strong>视图</strong>（<code>view</code>）获得其他实现了<code>Collection</code>接口或<code>Map</code>接口的对象。<code>keySet</code>方法就是这样的一个应用例子。<code>keySet</code>方法返回一个实现了Set接口的类对象，由这个类的方法操纵原映射。这种集合称为<strong>视图</strong>。</p><h4 id="小集合"><a href="#小集合" class="headerlink" title="小集合"></a>小集合</h4><p><code>Java9</code>引入了一些静态方法，可以生成给定元素的集和列表，已经给定键/值对的映射：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> names <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Peter"</span><span class="token punctuation">,</span> <span class="token string">"Pual"</span><span class="token punctuation">,</span> <span class="token string">"Mary"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numbers <span class="token operator">=</span> <span class="token class-name">Set</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> scores <span class="token operator">=</span> <span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Peter"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Pual"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Mary"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这些集合对象时<strong>不可修改</strong>的。如果试图修改，会导致一个<code>UnsupportedOperationException</code>异常。</p><blockquote><p><code>Java9</code>之前由一个静态方法<code>Arrays.asList</code>，返回一个可更改但是大小不可变的列表。</p><p>另外还有遗留的方法<code>Collections.emptySet</code>和<code>Collections.singleton</code>。</p><p><code>Collections</code>类包含很多实用方法，这些方法的参数和返回值都是集合。注意与<code>Collection</code>接口区分。</p></blockquote><h4 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h4><p>可以为很多集合建立子范围（<code>subrange</code>）视图。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> group2 <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中第一个索引包含在子列表中，第二个索引不包含在内（<strong>左闭右开</strong>截取）。可以对子范围应用任何操作，而且操作会自动反映到整个列表。</p><h4 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h4><p><code>Collections</code>类可以生成集合的不可修改视图（<code>unmodifiable view</code>）。这些视图对现有集合增加一个运行时检查，如果发现试图对集合进行修改，就会抛出一个异常，集合仍保持不变。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 主要是这8个方法</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableCollection<span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableList<span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableSet<span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableSortedSet<span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableNavigableSet<span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableMap<span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableSortedMap<span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableNavigableMap<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如，假设想要让某些代码查看但不能修改一个集合的内容，就可以进行以下操作：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">lookAt</span><span class="token punctuation">(</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableList</span><span class="token punctuation">(</span>staff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 之后，在lookAt中对于传递的集合不能进行修改操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h4><p>如果从多个线程访问集合，就必须确保集合不会被意外地破坏。此时，就可以使用试图机制来确保常规集合时线程安全的，对于没有实现线程安全的集合类，就饿可以使用<code>Collections.synchronizedMap</code>方法来将任何一个映射转换成由同步访问方法的Map。</p><h4 id="检查型视图"><a href="#检查型视图" class="headerlink" title="检查型视图"></a>检查型视图</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> safeStrings <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">checkedList</span><span class="token punctuation">(</span>strings<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个视图的<code>add</code>方法将检查插入的对象是否属于给定的类，如果不属于给定的类，就立即抛出一个<code>ClassCastException</code>。</p><blockquote><p>检查型视图受限于虚拟机可以完成的运行时检查。例如，对于<code>ArrayList&lt;Pair&lt;String&gt;&gt;</code>，由于虚拟机有一个“原始”<code>Pair</code>类，所以无法阻止插入<code>Pair&lt;Date&gt;</code>。</p></blockquote><h2 id="图形用户界面程序设计"><a href="#图形用户界面程序设计" class="headerlink" title="图形用户界面程序设计"></a>图形用户界面程序设计</h2><p>暂略</p><h2 id="Swing用户界面组件"><a href="#Swing用户界面组件" class="headerlink" title="Swing用户界面组件"></a><code>Swing</code>用户界面组件</h2><p>暂略</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>每个任务在一个线程（thread）中执行，线程是控制线程的简称。如果一个程序可以同时运行多个线程，则称这个程序是多线程的（multithreaded）。</p><p>多进程与多线程的本质区别在于每个进程都拥有自己的一套变量，而线程则共享数据。共享变量使线程之间的通信比进程之间的通信更有效、更容易。此外，在有些操作系统中，与进程相比较，线程更“轻量级”，创建、撤销一个线程比启动新进程的开销要小得多。</p><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><ol><li><p>将执行这个任务的代码放在一个类的<code>run</code>方法中，这个类要实现<code>Runnable</code>接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token comment">// task code;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>从这个<code>Runnable</code>构造一个<code>Thread</code>对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>启动线程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>这里的<code>Thread</code>就是创建了一个单独的线程去处理任务。线程之间是可以并发运行的。</p><blockquote><p>还可以通过建立<code>Thread</code>类的一个子类来定义线程，如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// task code</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后可以构造这个子类的一个对象，并调用它的<code>start</code>方法。不过，现在不在推荐这种方法。</p></blockquote><blockquote><p><strong>警告</strong>：不要调用<code>Thread</code>类或<code>Runnable</code>对象的run方法。直接调用<code>run</code>方法只会在同一个线程中执行这个任务——而没有启动新的线程。实际上，应当调用<code>Thread.start</code>方法，这会创建一个执行<code>run</code>方法的新线程。</p></blockquote><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>线程有如下6个状态：</p><ul><li><code>New</code>（新建）</li><li><code>Runnable</code>（可运行）</li><li><code>Blocked</code>（阻塞）</li><li><code>Waiting</code>（等待）</li><li><code>Timed waiting</code>（计时等待）</li><li><code>Terminated</code>（终止）</li></ul><p>如果要确定一个线程的当前状态，只需要调用<code>getState</code>方法。</p><h4 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h4><p>当用new操作符创建一个新线程时，如<code>new Thread(r)</code>，这个线程还没有开始运行。这意味着它的状态是新建（<code>new</code>）。当一个线程处于新建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。</p><h4 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h4><p>一旦调用<code>start</code>方法，线程就处于<strong>可运行</strong>（<code>runnable</code>）状态。一个可运行的线程可能长在运行也可能没有运行。要由操作系统为线程提供具体的运行时间。</p><p>一旦<strong>一个线程开始运行，它不一定始终保持运行。事实上，运行中的线程有时需要暂停，让其他线程有机会运行</strong>。线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每个可运行线程一个时间片来执行任务。当时间片用完时，操作系统<strong>剥夺</strong>该线程的运行权，并给另一个线程一个机会来运行。当选择下一个线程时，操作系统会考虑线程的优先级。</p><p>现在所有的桌面以及服务器操作系统都是用<strong>抢占式调度</strong>。但是，想手机这样的小型设备可能使用<strong>协作式调度</strong>。在这样的设备中，一个线程只能在调用<code>yield</code>方法或者被阻塞或等待时才是去控制权。</p><p>在有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当然，如果线程的数目多于处理的数目，调度器还是需要分配时间片的。</p><p><strong>在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行（正是因为这样，这个状态称为“可运行”而不是“运行”）</strong></p><h4 id="阻塞和等待状态"><a href="#阻塞和等待状态" class="headerlink" title="阻塞和等待状态"></a>阻塞和等待状态</h4><p>当线程处于阻塞或等待状态时，它暂时是不活动的。阻塞的造成原因可能如下</p><ul><li>当一个线程试图获取一个内部的对象锁（这里的锁并不是指 <code>java.util.concurrent</code> 库中的<code>Lock</code>），而这个锁目前被其他线程占有，该线程就会被阻塞。当所有其他线程都释放了这个锁，并且线程调度器允许该线程持有这个锁时，它将变成非阻塞状态。</li><li>当线程等待另一个线程通知调度器出现一个条件时，这个线程会进入等待状态。阻塞状态与等待状态并没有太大的区别</li><li>有几个方法有超时参数，调用这些方法会让线程进入计时等待（<code>time waiting</code>）状态。</li></ul><p>线程在获得可运行的“状态”后，根据优先级来判断是否可以抢占正在运行的线程的运行权。</p><img src="/2022/06/28/java/core-java-volume-0/thread_state.png" class="" title="thread_state"><h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><p>线程会由于以下两个原因之一而终止：</p><ul><li><code>run</code> 方法正常退出，线程自然终止</li><li>因为一个没有捕获的异常终止了<code>run</code>方法，使线程意外终止。</li></ul><h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><h4 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h4><p>当线程的<code>run</code>方法执行方法体中最后一条语句后在执行<code>return</code>语句<strong>返回时</strong>，或者出现了方法中<strong>没有捕获的异常时</strong>，线程将终止。</p><p>还可以通过<code>interrupt</code>方法来<strong>请求终止</strong>一个线程，这时候会设置线程的<strong>中断状态</strong>。这是每个线程都有的<code>boolean</code>标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断。</p><p>如何检查这个中断状态呢？首先调用静态的<code>Thread.currentThread</code>方法获得当前线程，然后调用<code>isInterrupted</code>方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> more work <span class="token keyword">to</span> <span class="token keyword">do</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// do more work</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是，如果线程被阻塞，就无法检查中断状态。这里就需要使用<code>InterruptedException</code>异常。当在一个被<code>sleep</code>或<code>wait</code>调用阻塞的线程上调用<code>interrupt</code>方法时，那个阻塞调用（即<code>sleep</code>或<code>wait</code>调用）将被一个<code>InterruptedException</code>异常中断。（有一些阻塞<code>I/O</code>调用不能被中断，对此应该考虑选择可中断的调用）</p><p><strong>常用的模板思路如下</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// ...</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1. 检查中断标志位</span>             <span class="token comment">// &amp;&amp; more work to do  </span>             <span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 2. 检查中断异常</span>        <span class="token comment">// thread was interrupted during sleep or wait</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment">// cleanup, if required</span>    <span class="token punctuation">}</span>    <span class="token comment">// exiting the run method terminates the thread</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在每次工作迭代之后都调用<code>sleep</code>方法（或者其他可中断方法），<code>isInterrupted</code>检查既没有必要也没有用处。如果设置了中断状态，此时倘若调用<code>sleep</code>方法，它不会休眠。实际上，它会清除中断状态并抛出<code>InterruptedException</code>。因此，使用循环调用了<code>sleep</code>，就不要检测中断状态，而应当捕获<code>InterruptedException</code>异常。如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// ...</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>             <span class="token comment">// &amp;&amp; more work to do  </span>             <span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 检查中断异常</span>        <span class="token comment">// thread was interrupted during sleep or wait</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment">// cleanup, if required</span>    <span class="token punctuation">}</span>    <span class="token comment">// exiting the run method terminates the thread</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在这里有两个非常类似的方法，<code>interrupted</code>和<code>isInterrupted</code>。</p><p><code>interrupted</code>方法时一个静态方法，它检查<strong>当前线程是否被中断</strong>。而且，调用<code>interrupted</code>方法<strong>会清除该线程中的中断状态</strong>。</p><p>另一方面，<code>isInterrupted</code>方法时一个实例方法，可以用来<strong>检查是否有线程被中断</strong>。调用这个方法<strong>不会改变中断状态</strong>。</p></blockquote><p>如果，在处理中想不出在catch子句中可以做什么有意义的工作，可以将其抛出：</p><ul><li>```java<br>void mySubTask() {<br>// …<br>try {<br>    sleep(delay);<br>} catch (InterruptedException e) {<br>    Thread.currentThread().interrupt(); // 设置中断状态，这样一来调用者就可以检测中断状态<br>}<br>// …<br>}<pre class="line-numbers language-none"><code class="language-none">+ ```java  void mySubtask() throws InterruptedException { // 标记抛出异常，提供给调用者去处理      // ...      sleep(delay)       // ...  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将这个线程转换为守护线程（daemon thread）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>守护线程为其他线程提供服务。</p><h4 id="线程名"><a href="#线程名" class="headerlink" title="线程名"></a>线程名</h4><p>默认情况下，线程有容易记的名字，如 Thread-2。同时也可以使用setName方法为线程设置任何名字：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"Web crawler"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在线程转储时可能很有用。</p><h4 id="未捕获异常的处理器"><a href="#未捕获异常的处理器" class="headerlink" title="未捕获异常的处理器"></a>未捕获异常的处理器</h4><p>线程的<code>run</code>方法不能抛出任何检查型异常，但是，非检查型异常可能会导致线程终止。这种情况下，线程会死亡。</p><p>不过，对于可以传播的异常，并没有任何<code>catch</code>子句。实际上，在线程死亡之前，异常会传递到一个用于处理未捕获异常的处理器。</p><p>这个处理器必须属于一个实现了<code>Thread.UncaughtExceptionaHandler</code>接口的类。这个接口只有一个方法 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">uncaughtExctption</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> e<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>单一：可以用<code>setUncaughtExctptionHandler</code>方法为<strong>任何线程安装一个处理器</strong>。</p><p>全局：也可以用<code>Thread</code>类的静态方法<code>setDefaultUncaughtExctptionHandler</code>为<strong>所有线程安装一个默认的处理器</strong>。</p><p>如果没有安装默认处理器，默认处理器则是<code>null</code>。但是，如果没有为单个线程安装处理器，那么处理器就是该线程的<code>ThreadGroup</code>对象。</p><p><code>ThreadGroup</code>类实现了<code>Thread.UncaughtExceptionHandler</code>接口。它的<code>uncaughtException</code>方法执行以下操作：</p><ol><li>如果该线程组有父线程组，那么调用父线程组的<code>uncaughtException</code>方法。</li><li>否则，如果<code>Thread.UncaughtExceptionaHandler</code>方法返回一个非<code>null</code>的处理器，则调用该处理器。</li><li>否则，如果<code>Throwble</code>是<code>ThreadDeath</code>的一个实例，什么都不做。</li><li>否则，将线程的名字以及<code>Throwable</code>的栈轨迹输出到<code>System.err</code>。</li></ol><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>在<code>Java</code>中，每一个线程都有一个优先级。默认一个线程会继承构造它的那个线程的优先级。可以用<code>setPriority</code>方法提高或降低任何一个线程的优先级。可以将优先级设置为<code>MIN_PRIORITY</code>（在<code>Thread</code>类中定义为1）与<code>MAX_PRIORITY</code>（定义为10）之间的任何值。<code>NORM_PRIORITY</code>定义为5、</p><p>线程调度器有机会选择新线程时，首先选择具有较高优先级的线程。但是，<strong>线程优先级高度依赖于系统</strong>。</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>竟态条件（<code>race condition</code>）。主要就是数据同步问题。</p><h4 id="竟态条件的一个例子"><a href="#竟态条件的一个例子" class="headerlink" title="竟态条件的一个例子"></a>竟态条件的一个例子</h4><p>为了避免多线程破坏共享数据，必须学习如何同步存取。使用一个模拟银行交易的例子来说明。</p><p>这里要随机地选择从哪个源账户转账到哪个目标账户：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// CAUTION: unsafe when called from multiple threads</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    accounts<span class="token punctuation">[</span>from<span class="token punctuation">]</span> <span class="token operator">-=</span> amount<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" %10.2f from %d to %d"</span><span class="token punctuation">,</span> amount<span class="token punctuation">,</span> from<span class="token punctuation">,</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    accounts<span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" Total Blance: %10.2f%n"</span><span class="token punctuation">,</span> <span class="token function">getTotalBlance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面时<code>Runnable</code>实例的代码。<code>run</code>方法不断地从一个给定银行账户取钱。在每次迭代中，<code>run</code>方法选择一个随机的目标账户和一个随机金额，调用<code>bank</code>对象的<code>tranfer</code>方法，然后休眠。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> toAccount <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>bank<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">double</span> amount <span class="token operator">=</span> MAX_AMOUNT <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bank<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>fromAccount<span class="token punctuation">,</span> toAccount<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>DELAY <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个模拟程序运行是，不清楚在某一时刻某个银行账户中有多少钱，但是我们知道所有账户的总金额应该保持不变，因为我们所做的只是把钱从一个账户转移到另一个账号。</p><p>每一次交易结束时，<code>transfer</code>方法会重新计算总金额并打印出来。</p><p>这个程序永远不会结束。只能按<code>CTRL+C</code>来终止程序。</p><p>下面时典型的输出：</p><pre class="line-numbers language-log" data-language="log"><code class="language-log">Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span><span class="token number">588.23</span> from <span class="token number">11</span> to <span class="token number">44</span> Total Balance<span class="token operator">:</span><span class="token number">100000.00</span>Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span><span class="token number">684.24</span> from <span class="token number">15</span> to <span class="token number">34</span> Total Balance<span class="token operator">:</span><span class="token number">100000.00</span>Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span><span class="token number">578.73</span> from <span class="token number">21</span> to <span class="token number">51</span> Total Balance<span class="token operator">:</span><span class="token number">100000.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span><span class="token number">288.23</span> from <span class="token number">13</span> to <span class="token number">14</span> Total Balance<span class="token operator">:</span><span class="token number">90200.03</span>Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span><span class="token number">583.23</span> from <span class="token number">31</span> to <span class="token number">24</span> Total Balance<span class="token operator">:</span><span class="token number">90200.03</span>Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span><span class="token number">988.23</span> from <span class="token number">51</span> to <span class="token number">45</span> Total Balance<span class="token operator">:</span><span class="token number">90200.03</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，这里出现了错误。对于最初的几次交易，银行余额保持在100000，这是正确的，因为共1000个账户，每个账户1000。不过，经过一段时间后，余额有轻微的变化。运行这个程序的时候，可能很快就能发现出错了，有时可能需要很长的时间才能发现余额不对。</p><p>完整的示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token comment">/** * A bank with a number of bank accounts. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bank</span><span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> accounts<span class="token punctuation">;</span>   <span class="token comment">/**    * Constructs the bank.    * @param n the number of accounts    * @param initialBalance the initial balance for each account    */</span>   <span class="token keyword">public</span> <span class="token class-name">Bank</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> initialBalance<span class="token punctuation">)</span>   <span class="token punctuation">{</span>      accounts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>accounts<span class="token punctuation">,</span> initialBalance<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment">/**    * Transfers money from one account to another.    * @param from the account to transfer from    * @param to the account to transfer to    * @param amount the amount to transfer    */</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span>   <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>accounts<span class="token punctuation">[</span>from<span class="token punctuation">]</span> <span class="token operator">&lt;</span> amount<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      accounts<span class="token punctuation">[</span>from<span class="token punctuation">]</span> <span class="token operator">-=</span> amount<span class="token punctuation">;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %10.2f from %d to %d"</span><span class="token punctuation">,</span> amount<span class="token punctuation">,</span> from<span class="token punctuation">,</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      accounts<span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" Total Balance: %10.2f%n"</span><span class="token punctuation">,</span> <span class="token function">getTotalBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment">/**    * Gets the sum of all account balances.    * @return the total balance    */</span>   <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getTotalBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>      <span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">double</span> a <span class="token operator">:</span> accounts<span class="token punctuation">)</span>         sum <span class="token operator">+=</span> a<span class="token punctuation">;</span>      <span class="token keyword">return</span> sum<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment">/**    * Gets the number of accounts in the bank.    * @return the number of accounts    */</span>   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>      <span class="token keyword">return</span> accounts<span class="token punctuation">.</span>length<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * This program shows data corruption when multiple threads access a data structure. * @version 1.32 2018-04-10 * @author Cay Horstmann */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnsynchBankTest</span><span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NACCOUNTS <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">double</span> INITIAL_BALANCE <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">double</span> MAX_AMOUNT <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DELAY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>   <span class="token punctuation">{</span>      <span class="token keyword">var</span> bank <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bank</span><span class="token punctuation">(</span>NACCOUNTS<span class="token punctuation">,</span> INITIAL_BALANCE<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NACCOUNTS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>         <span class="token keyword">int</span> fromAccount <span class="token operator">=</span> i<span class="token punctuation">;</span>         <span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span>            <span class="token punctuation">{</span>               <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>               <span class="token punctuation">{</span>                  <span class="token keyword">int</span> toAccount <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>bank<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">double</span> amount <span class="token operator">=</span> MAX_AMOUNT <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  bank<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>fromAccount<span class="token punctuation">,</span> toAccount<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>DELAY <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span>            <span class="token punctuation">{</span>            <span class="token punctuation">}</span>                     <span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>         t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="竟态条件详解"><a href="#竟态条件详解" class="headerlink" title="竟态条件详解"></a>竟态条件详解</h4><p>上一节运行了一个程序，其中有几个线程会更新银行银行余额。一段时间之后，不知不觉地出现了错误，可能有些钱会丢失，也可能几个账户同时有钱进账。当两个线程试图同时更新同一个账户时，就会出现这个问题。假设两个线程同时执行指令</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">accounts<span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>问题在于这不是原子操作哦。这个指令可能如下处理：</p><ol><li>将<code>accounts[to]</code>加载到寄存器。</li><li>增加<code>amount</code>。</li><li>将结果写回<code>accounts[to]</code>。</li></ol><p>现在，假定第1个线程执行步骤1和步骤2，然后，它的运行权被抢占。在假设第2个线程被唤醒，更新<code>account</code>数组中的同一个元素。然后，第1个线程被唤醒并完成其第3步。</p><p>这个动作会抹除第2个线程所作的更新。这样一来，总金额就不再正确了。如下图</p><img src="/2022/06/28/java/core-java-volume-0/transfer_thread_00.png" class="" title="transfer_thread_00"><blockquote><p>实际上可以查看执行这个类中每一个语句的虚拟机字节码。运行以下命令</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">javap <span class="token operator">-</span>c <span class="token operator">-</span>v <span class="token class-name">Bank</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对Bank.class文件进行反编译。例如，代码行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">accounts<span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会转换为下面的字节码：</p><pre class="line-numbers language-ABAP" data-language="ABAP"><code class="language-ABAP">aload_0getfield#2 // Field accounts:[Diload_2dup2daloaddload_3dadddastore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些代码的含义无关紧要。重要的是这个增加命令是由多条指令组成的，执行这些指令的线程可以在任何一条指令上被中断。</p></blockquote><p>在一个有多个核心的现代处理器上，出问题的风险相当高。</p><p>如果能够确保线程失去控制之前方法已经运行完成，那么银行账户对象的状态就不会被破坏。</p><h4 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h4><p>有两种机制可以防止并发访问代码块。<code>Java</code>语言提供了一个<code>synchronized</code>关键词来达到这一目的，另外<code>Java 5</code>引入了<code>ReentrantLock</code>类。 <code>synchronized</code>关键字会自动提供一个锁以及相关的“条件”，对于大多数需要显示锁的情况，这种机制功能很强大，也很便利。</p><p>用<code>ReentrantLock</code>保护代码块的基本结构如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">myLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// a ReentrantLock object</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// critical section</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    myLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// make sure the lock is unlocked even if an exception is thrown</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个结构确保<strong>任何时刻只有一个线程进入临界区。一旦一个线程锁定了锁对象，其他任何线程都无法通过<code>lock</code>语句</strong>。当其他线程调用<code>lock</code>时，它们会暂停，知道第一个线程释放这个锁对象。</p><blockquote><p><strong>警告</strong>：<strong>要把unlock操作包括在finally子句中，这一点至关重要</strong>。如果在临界区的代码抛出一个异常，锁必须释放。否则，其他线程将永远阻塞。</p></blockquote><blockquote><p><strong>注意</strong>：<strong>使用锁时，就不能使用<code>try-with-resources</code>语句</strong>。首先，解锁方法名不是<code>close</code>。不过，即使将它重命名，<code>try-with-resources</code>语句也无法正常工作。它的首部希望声明一个新变量。但是如果使用一个锁，你可能想使用多个线程共享那个变量（而不是新变量）。</p></blockquote><p>非同步线程与同步线程的比较</p><img src="/2022/06/28/java/core-java-volume-0/transfer_thread_01.png" class="" title="transfer_thread_01"><p>注意每个<code>Bank</code>对象都有自己的<code>ReentrantLock</code>对象。如果两个线程试图访问同一个<code>Bank</code>对象，那么锁可以用来保证串行化访问。不过，如果两个线程访问不同的<code>Bank</code>对象，每个线程会得到不同的锁对象，两个线程都不会阻塞。本应该如此，因为线程在操纵不同的<code>Bank</code>实例时，线程之间不会相互影响。</p><p>这个锁称为<strong>重入（<code>reentrant</code>）锁</strong>，因为线程可以反复获得已拥有的锁。锁有一个<strong>持有计数</strong>（<code>hold count</code>）来跟踪对<code>lock</code>方法的嵌套调用。线程每一次调用lock后都要调用<code>unlock</code>来释放锁。由于这个特性，被一个锁保护的代码可以调用另一个使用相同锁的方法。</p><blockquote><p><strong>警告</strong>：要注意确保临界区中的代码不要因为抛出异常而跳出临界区。如果在临界区代码结束之前抛出了异常，<code>finally</code>子句将释放锁，但是对象可能处于被破坏的状态。</p></blockquote><h4 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h4><p>通常，线程进入临界区后却发现只有满足了某个条件之后它才能执行。可以使用一个<strong>条件对象</strong>来管理那些已经获得了一个锁却不能做有用工作的线程。在这一节里，将会介绍Java库中条件对象的实现（由于历史原因，条件对象经常被称为条件变量（<code>confitional variable</code>））。</p><p>如下所示，假定只有当账户中的金额大于要转出的金额时才可以转账。如果某个线程刚刚获得对<code>bankLock</code>的<strong>排他性访问权</strong>，如果此时账户中资金不足，则无法完成转账操作，但是又因为锁的存在，别的线程没有存款的机会，这里就会产生死锁问题，这种情况下就可以引入条件对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Bank</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Confition</span> sufficientFunds<span class="token punctuation">;</span>    <span class="token comment">// ...</span>    <span class="token keyword">public</span> <span class="token class-name">Bank</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// ...</span>        sufficientFunds <span class="token operator">=</span> bankLock<span class="token punctuation">.</span><span class="token function">newConfition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建条件对象来表示“资金充足”条件。</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果transfer方法发现资金不足，就会调用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">sufficientFuns<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>当前线程现在暂停，并放弃锁。这就允许另一个线程执行</strong>，来增加账户余额。</p><p>一旦一个线程调用了await方法，它就会进入这个条件的等待集（wait set）。当锁可用时，该线程并不会变为可运行状态。实际上，它仍保持非活动那个状态，直到另一个线程在同一条件上调用signalAll方法。当另外一个线程完成转账时，它应该调用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">sufficientFunds<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 启动所有的等待线程</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个调用会重新激活等待这个条件的所有线程。当这些线程从等待集中移出时，它们再次成为可运行的线程，调度器最终将再次将它们激活。同时，它们会尝试重新进入该对象。一旦锁可用，它们中的某个线程将从<code>await</code>调用返回，得到这个锁，<strong>并从之前暂停的地方继续执行</strong>。</p><p><code>signalAll</code>方法仅仅时通知等待的线程：现在<strong>有可能</strong>满足条件，值得再次检查条件。</p><blockquote><p><strong>注释</strong>：t通常，await调用应该放在如下形式的循环中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>OK <span class="token keyword">to</span> <span class="token namespace">proceed</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><p>当一个线程调用<code>await</code>时，它没有办法重新自行激活。它寄希望于其他线程。如果没有其他线程来重新激活等待的线程，它就永远不再运行了。这将导致<strong>死锁</strong>（<code>deadlock</code>）现象。如果所有其他线程都被阻塞，最后一个活动线程调用了<code>await</code>方法但没有先解除另外某个线程的阻塞，现在这个线程也会阻塞。此时没有线程可以解除其他线程的阻塞状态，程序会永远挂起<strong>。所以至关重要的一点，最终必须要有某个其他线程调用<code>signalAll</code>方法激活线程</strong>。</p><p>注意<code>signalAll</code>调用<strong>不会立即激活一个等待的线程</strong>。它姿势解除等待线程的阻塞，使这些线程可以在当前线程释放锁之后竞争访问对象。</p><p>当然也可以调用<code>signal</code>只是随机选择等待集中的一个线程解锁，但是如果被解锁的线程仍旧不能运行，它就会被再次阻塞。如果此时没有其他线程再次调用<code>signal</code>，系统就会进入死锁。</p><blockquote><p><strong>警告</strong>：只有当线程拥有一个条件的锁时，它才能在这个条件上调用<code>await</code>、<code>signalAll</code>或<code>signal</code>方法。</p></blockquote><p>当然加入了以上的控制手段之后，整个程序运行起来要慢一些，这是为了实现同步机制所涉及的额外工作付出的代价。</p><h4 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a><code>synchronized</code>关键字</h4><p>在上一个小节，了解了<code>Lock</code>和<code>Condition</code>对象，先对锁和条件的要点做个总结：</p><ul><li>锁用来保护代码片段，一次只能由一个线程执行被保护的代码。</li><li>锁可以管理试图进入被保护代码段的线程。</li><li>一个锁可以有一个或多个相关联的条件对象。</li><li>每个条件对象管理那些已经进入被保护代码段但还不能运行的线程。</li></ul><p><code>Java</code>中的<strong>每个对象都有一个内部锁</strong>。如果一个方法声明时有<code>synchronized</code>关键字，那么对象的锁将保护整个方法，也就是要调用这个方法，线程必须获得内部对象锁。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// method body</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等价于</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>intrinsicLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// method body</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>intrinsicLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注释</strong>：<code>wait</code>、<code>notifyAll</code>以及<code>notify</code>方法是<code>Object</code>类的<code>final</code>方法。<code>Condition</code>方法必须命名为<code>await</code>、<code>signalAll</code>和<code>signal</code>，从而不会与那些方法发生冲突。</p></blockquote><p>经静态方法声明为同步也是合法的。如果调用这样的一个方法，它会获得相关类对象的内部锁。</p><p>内部锁和条件存在一些限制。包括：</p><ul><li>不能中断一个正在尝试获得锁的线程。</li><li>不能指定尝试获得锁时的超时时间。</li><li>每个锁仅有一个条件可能时不够的。</li></ul><p>对<code>Lock</code>和<code>Condition</code>对象的使用建议：</p><ul><li>最好既不使用<code>Lock/Condition</code>也不使用<code>synchronized</code>关键字。使用<code>java.util.concurrent</code>包中的某种机制，它会为你处理所有的锁定。例如，使用阻塞队列来同步完成一个共同任务的线程。</li><li>如果<code>synchronized</code>关键字适合你的程序，那么尽量使用这种做法，这样可以减少编写的代码量，还能减少出错的概率。</li><li>如果特别需要<code>Lock/Condition</code>结构提供的额外能力，则使用<code>Lock/Condition</code></li></ul><h4 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h4><p>每一个<code>Java</code>对象都有一个锁，线程可以通过调用同步方法获得锁。还有另一种机制可以获得锁：即进入一个同步块。当线程进入如下形式的块时：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// this is the syntax for a synchronized block</span>    <span class="token comment">// critical section</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它会获得<code>obj</code>的锁。</p><p>有时我们会发现一些“专用”锁，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bank</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> accounts<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// an ad-hoc lock</span>            accounts<span class="token punctuation">[</span>from<span class="token punctuation">]</span> <span class="token operator">-=</span> amount<span class="token punctuation">;</span>            accounts<span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，创建<code>lock</code>对象只是为了使用每个<code>Java</code>对象拥有的锁。</p><p>使用一个对象的锁来实现额外的原子操作，这种做法称为<strong>客户端锁定</strong>（<code>client-side locking</code>）</p><p>但是完全依赖于<code>Bank</code>类对自己的所有更改方法使用内部锁，但是如果开发者没有在文档中标注这些限定，那就需要自己去越多源代码，从这个角度看，<strong>客户端锁定是非常脆弱的，通常不推荐使用</strong>。</p><h4 id="监控器"><a href="#监控器" class="headerlink" title="监控器"></a>监控器</h4><p>监控器具有如下特性：</p><ul><li>监视器是只包含私有字段的类。</li><li>监视器类的每个对象有一个关联的锁。</li><li>所有方法由这个锁锁定。换句话说，如果客户端调用<code>obj.method()</code>，那么<code>obj</code>对象的锁在方法调用开始时自动获得，并且当方法返回时自动释放该锁。因此所有的字段是私有的，这样的安排可以确保一个线程处理字段时，没有其他线程能够访问这些字段。</li><li>锁可以由任意多个相关联的条件。</li></ul><h4 id="volatile字段"><a href="#volatile字段" class="headerlink" title="volatile字段"></a><code>volatile</code>字段</h4><p><code>volatile</code>关键字为实例字段的同步访问提供了一种免锁机制。如果声明一个字段为<code>volatile</code>，那么编译器和虚拟机就知道该字段可能被另一个线程并发更新。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> done<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> done<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>编译器会插入适当的代码，以确保如果一个线程对done变量做了修改，这个修改对读取这个变量的所有其他线程都可见。</p><blockquote><p>volatile 变量不能提供原子性。例如，方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">flipDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> done <span class="token operator">=</span> <span class="token operator">!</span>done<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// not atomic</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不能确保翻转字段中的值。不能保证读取、翻转和写入不被中断。</p></blockquote><h4 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a><code>final</code>变量</h4><p>还可以考虑使用final声明：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">var</span> accounts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他线程会在构造器完成构造之后才看到这个<code>accounts</code>变量。</p><p>如果不使用<code>final</code>，就不能保证其他线程看到的是<code>accounts</code>更新后的值，它们可能都只是看到<code>null</code>，而不是新构造的<code>HashMap</code>。</p><p>当然，<strong>对这个映射的操作并不是线程安全的</strong>。如果有多个线程更改和读取这个映射，仍然需要进行同步。</p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>假设对共享变量除了赋值之外并不做其他操作，那么可以将这些共享变量声明为<code>volatile</code>。</p><p><code>java.util.concurrent.atomic</code>包中很多类使用了很高效的机器级指令（而没有使用锁）来保证其他操作的原子性。例如，<code>AtomicInteger</code>类提供了方法<code>incrementAndGet</code>和<code>decrementAndGet</code>，它们分别以原子方式将一个整数进行自增或自减。</p><p>如果有大量线程要访问相同的原子值，性能会大幅下降，因此乐观更新需要太多次重试。</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>锁和条件不能解决多线程中可能出现的所有问题，例如：</p><ol><li>账户1：200</li><li>账户2：300</li><li>线程1：从账户1转300到账户2</li><li>线程2：从账户2转400到账户1</li></ol><p>如果在线程转账时有条件限定，需要大于转账金额才能转账，则两个线程都会因为要等待更多的钱款存入而导致所有的线程进入<strong>阻塞状态</strong>。这样的状态称为<strong>死锁</strong>（<code>deadlock</code>）</p><blockquote><p>当程序挂起时，按下 <code>Ctrl + \</code>，将得到一个线程转储，这会累出所有线程。</p></blockquote><p><strong>遗憾的是，<code>Java</code>编程语言中没有任何东西可以避免或打破这种死锁。必须仔细设计程序，确保不会出现死锁</strong>。</p><h4 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h4><p>线程间共享变量存在风险，有时可能要避免共享变量，使用<code>ThreadLocal</code>辅助类为各个线程提供各自的实例。例如，<code>SimpleDateFormat</code>类不是线程安全的。假设有一个静态变量：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">SimpleDateFormat</span> dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果两个线程都执行以下操作：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> dateStamp <span class="token operator">=</span> dateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果可能很混乱，因为<code>dateFormat</code>使用的内部数据结构可能会被并发的访问所破坏。当然可以使用同步，但开销很大；或者也可以在需要时构造一个局部<code>SimpleDateFormat</code>对象，不过这样很浪费。</p><p>可以考虑为每个线程构造一个实例的方式来避免错误产生：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SimpleDateFormat</span><span class="token punctuation">&gt;</span></span> dateFormat <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用时，使用如下格式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> dateStamp <span class="token operator">=</span> dateFormat<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样在给定线程中首次调用<code>get</code>时，会调用构造器中的<code>lambda</code>表达式。在此之后，<code>get</code>方法会返回属于当前线程的那个实例。</p><h3 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h3><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，<strong>阻塞队列</strong>（<code>blocking queue</code>）将导致线程阻塞。在协调多个线程之间的合作时，阻塞队列是一个有用的工具。</p><p>阻塞队列方法：</p><table><thead><tr><th>方法</th><th>正常动作</th><th>特殊情况下的动作</th></tr></thead><tbody><tr><td><code>add</code></td><td>添加一个元素</td><td>如果队列满，则抛出<code>IllegalStateException</code>异常</td></tr><tr><td><code>element</code></td><td>返回队头元素</td><td>如果队列空，则抛出<code>NoSuchElementException</code>异常</td></tr><tr><td><code>offer</code></td><td>添加一个元素并返回true</td><td>如果队列满，则返回<code>false</code></td></tr><tr><td><code>peek</code></td><td>返回队头元素</td><td>如果队列空，则返回 <code>null</code></td></tr><tr><td><code>poll</code></td><td>移除并返回队头元素</td><td>如果队列空，则返回<code>null</code></td></tr><tr><td><code>put</code></td><td>添加一个元素</td><td>如果队列满，则阻塞</td></tr><tr><td><code>remove</code></td><td>移除并返回队头元素</td><td>如果队列空，则抛出<code>NoSuchElementException</code>异常</td></tr><tr><td><code>take</code></td><td>移除并返回队头元素</td><td>如果队列空，则阻塞</td></tr></tbody></table><blockquote><p><strong>注释</strong>：<code>poll</code>和<code>peek</code>方法返回<code>null</code>来指示失败。因此，向这些队列中插入<code>null</code>值时非法的。</p></blockquote><p><code>java.util.concurrent</code>包提供了阻塞队列的几个变体。默认情况下</p><ul><li><code>LinkedBlockingQueue</code>的容量没有上界，但是也可以选择指定一个最大容量。</li><li><code>LinkedBlockingDeque</code>是一个双端队列。</li><li><code>ArrayBlockingQueue</code>在构造时需要指定容量，并且有一个可选的参数来指定是否需要公平性。若设置了公平参数，那么等待了最长时间的线程会优先得到处理。通常，公平性会降低性能，只有在确实非常需要时才使用公平参数。</li><li><code>PriorityBlockingQueue</code>时一个优先队列，而不是先进先出队列。元素按照它们的优先级顺序移除。这个队列没有容量上限，但是，如果队列时空的，获取元素的操作会阻塞。</li><li><code>TransferQueue</code>接口，允许生产者线程等待，直到消费者准备就绪可以接受元素。如果生产者调用<code>q.transfer(item);</code>这个调用会阻塞，直到另一个线程将元素（<code>item</code>）删除。</li></ul><h4 id="高效的映射、集和队列"><a href="#高效的映射、集和队列" class="headerlink" title="高效的映射、集和队列"></a>高效的映射、集和队列</h4><p><code>java.util.concurrent</code>包提供了映射、有序集和队列的高效实现：<code>ConcurrentHashMap</code>、<code>ConcurrentSkipListMap</code>、<code>ConcurrentSkipListSet</code>和<code>ConcurrentLinkedQueue</code>。</p><p><strong>这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分尽可能减少竞争</strong>。</p><p>与大多数集合不同，这些类的<code>size</code>方法不一定在常量时间内完成操作。确定这些集合的当前大小通常需要遍历。</p><p>并发散列映射可以高效地支持大量阅读器和一定数量的书写器。默认情况下认为可以有至多16个同时运行的书写器线程。当然可以有更多的书写器线程，但是，同一时间如果多于16个，其他线程将暂时阻塞。可以在构造器中指定更大数目，不过，通常都没有这种必要。</p><blockquote><p>散列映射将相同散列码的所有条目放在同一个“桶”中。不过，在较新的<code>Java</code>版本中<strong>，并发散列映射将桶组织为树</strong>，而不是列表，键类型实现<code>Comparable</code>，从而可以保证性能为<code>O(log(n))</code>。</p></blockquote><h4 id="对并发散列映射的批操作"><a href="#对并发散列映射的批操作" class="headerlink" title="对并发散列映射的批操作"></a>对并发散列映射的批操作</h4><p><code>Java API</code>为并发散列映射提供了批操作，即使有其他线程在处理映射，这些操作也能安全地执行。批操作会遍历映射，处理遍历过程中找到的元素。这里不会冻结映射的当前快照。除非恰好直到批操作运行时映射不会被修改，否则就要把结果看作是映射的一个近似。</p><p>有3种不同的操作：</p><ul><li><code>search</code>（搜索）为每个键或值应用一个函数，直到函数生成一个非null的结果。然后搜索终止，返回这个函的结果。</li><li><code>reduce</code>（归约）组合所有键或值，这里要使用所提供的一个累加函数。</li><li><code>forEach</code>为所有键或值应用一个函数。</li></ul><p>每个操作都有4个版本：</p><ul><li><code>operationKeys</code>：处理键</li><li><code>operationValues</code>：处理值</li><li><code>operation</code>：处理键和值</li><li><code>operationEntries</code>：处理<code>Map.Entry</code>对象</li></ul><h4 id="并发集视图"><a href="#并发集视图" class="headerlink" title="并发集视图"></a>并发集视图</h4><p>如果需要一个很大的线程安全的集而不是映射，并没有<code>ConcurrentHashSet</code>类，可以使用<code>ConcurrentHashMap.newKeySet()</code>方法生成一个<code>Set&lt;K&gt;</code>，这实际上是<code>ConcurrentHashMap&lt;K, Boolean&gt;</code>的一个包装器。（所有映射值都为<code>Boolean.TRUE</code>，不过因为只是要把它用作一个集，所以并不关系映射值。）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> words <span class="token operator">=</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token function">newKeySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，如果原先有一个映射，<code>keySet</code>方法可以生成这个映射的键值。这个集是可更改的。</p><h4 id="写数组的拷贝"><a href="#写数组的拷贝" class="headerlink" title="写数组的拷贝"></a>写数组的拷贝</h4><p><code>CopyOnWriteArrayList</code>和<code>CopyOnWeiteArraySet</code>是线程安全的集合，其中所有更改器会建立底层数组的一个副本。如果迭代访问集合的线程数超过更改集合的线程数，这样的安排是很有用的。当构造一个迭代器的时候，它包含当前数组的一个引用。如果这个数组后来被更改了，迭代器仍然引用旧数组，但是，集合的数组已经替换。因而，<strong>原来的迭代器可以访问一致的（但可能过时的）视图</strong>，而且不存在任何同步开销。</p><h4 id="并行数组算法"><a href="#并行数组算法" class="headerlink" title="并行数组算法"></a>并行数组算法</h4><p><code>Arrays</code>类提供了大量并行化操作。静态<code>Arrays.parallelSort</code>方法可以对一个基本类型值或对象数组排序。</p><h4 id="较早的线程安全集合"><a href="#较早的线程安全集合" class="headerlink" title="较早的线程安全集合"></a>较早的线程安全集合</h4><p>从<code>Java</code>的初始版本开始，<code>Vector</code>和<code>Hashtable</code>类就提供了动态数组和散列表的线程安全的实现。现在这些类被认为已经过时，而被<code>ArrayList</code>和<code>HashMap</code>类所取代。不过，那些类不是线程安全的，实际上，集合库中提供了一种不同的机制。任何集合类都可以通过使用<strong>同步包装器</strong>（synchronization wrapper）变成线程安全的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> synchArrayList <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> synchHashMap <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果集合的方法使用锁加以保护，可以提供线程安全的访问。</p><h3 id="任务和线程池"><a href="#任务和线程池" class="headerlink" title="任务和线程池"></a>任务和线程池</h3><p>构造一个新的线程开销有些大，因为这涉及与操作系统的交互。如果你的程序中创建了大量的生命期很短的线程，那么不应该把每个任务映射到一个单独的线程，而应该使用<strong>线程池</strong>（<code>thread pool</code>）。线程池中包含需要准备运行的线程。为线程池提供一个<code>Runnable</code>，就会有一个线程调用<code>run</code>方法。当<code>run</code>方法退出时，这个线程不会死亡，而是留在池中准备给下一个请求提供服务。</p><h4 id="Callable与Future"><a href="#Callable与Future" class="headerlink" title="Callable与Future"></a><code>Callable</code>与<code>Future</code></h4><p><code>Runnable</code>封装一个异步运行的任务，可以把它想象成一个没有参数和返回值的异步任务。<code>Callable</code>与<code>Runnable</code>类似，但是又返回值。<code>Callable</code>接口时一个参数化的类型，只有一个方法<code>call</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token class-name">V</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>Future</code>保存异步计算的<strong>结果</strong>。可以启动一个计算，将<code>Future</code>对象交给某个线程，然后忘掉它。这个<code>Future</code>对象的所有者在结果计算好之后就可以获得结果。</p><p><code>Future&lt;V&gt;</code>接口又下面的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterrupt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个<code>get</code>方法的调用会阻塞，直到计算完成。</p><p>第二个<code>get</code>方法也会阻塞，不过如果在计算完成之前调用超时，会抛出一个<code>TimeoutException</code>。如果计算已经完成，那么<code>get</code>方法立即返回。</p><p>如果计算还在进行，<code>isDone</code>方法返回<code>false</code>；如果已经完成，则返回<code>true</code>。</p><p>可以用<code>cancel</code>方法取消计算。如果计算还没有开始，它会被取消而且不再开始。如果计算正在进行，那么如果<code>mayInterrupt</code>参数为<code>true</code>，它就会被中断。</p><blockquote><p><strong>警告</strong>：取消一个任务涉及两个步骤。必须找到并中断底层线程。另外任务实现（在<code>call</code>方法中）必须感知到中断，并放弃它的工作。如果一个<code>Future</code>对象不知道任务在哪个线程中执行，或者如果任务没有监视执行任务的线程的中断状态，那么取消任务没有任何效果。</p></blockquote><p>执行<code>Callable</code>的一种方法时使用<code>FutureTask</code>，它实现了<code>Future</code>和<code>Runnable</code>接口，所以可以构造一个线程来运行这个任务：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span>integer<span class="token punctuation">&gt;</span></span> task <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token keyword">var</span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// is's a Runnable</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//...</span><span class="token class-name">Integer</span> result <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// it's a Future</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p><strong>执行器</strong>（<code>Executors</code>）类又许多静态工厂方法，用来构造线程池。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>newCachedThreadPool</code></td><td>必要时创建新线程；空闲线程会保留60秒</td></tr><tr><td><code>newFixedThreadPool</code></td><td>池中包含固定数目的线程；空闲线程会一直保留</td></tr><tr><td><code>newWorkStealingPool</code></td><td>一种适合“fork-join”任务的线程池，其中复杂的任务会分解为更简单的任务，空闲线程会“密取”较简单的任务</td></tr><tr><td><code>newSingleThreadExecutor</code></td><td>只有一个线程的“池”，会顺序地执行所提交的任务，适合于性能分析，做对照组</td></tr><tr><td><code>newScheduledThreadPool</code></td><td>用于调度执行的固定线程池</td></tr><tr><td><code>newSingleThreadScheduledExecutor</code></td><td>用于调度执行的单线程“池”，适合于性能分析，做对照组</td></tr></tbody></table><p><code>newCachedThreadPool</code>方法构造一个线程池，会立即执行各个任务，如果又空闲线程可用，就使用现有空闲线程执行任务；如果没有可用的空闲线程，则创建一个新线程。</p><p><code>newFixedThreadPool</code>方法构造一个具有固定大小的线程池。如果提交的任务数多于空闲线程数，就把未得到服务的任务放到队列中。当其他任务完成以后再运行这些排队的任务。</p><p><code>newSingleThreadExecutor</code>是一个退化了的大小为1的线程池：由一个线程顺序地执行所提交的任务。</p><p>以上三个方法返回实现了<code>ExecutorService</code>接口的<code>ThreadPoolExecutor</code>类的对象。</p><p>可以下面的方法之一将<code>Runnable</code>或<code>Callable</code>对象提交给<code>ExecutorService</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">T</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 完成时返回指定的result对象。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>线程池会再方便的时候今早执行提交的任务。</p><p>使用完一个线程池时，调用<code>shutdown</code>。这个方法启动线程池的关闭序列。被关闭的执行器不再接受新的任务。当所有任务都完成时，线程池中的线程死亡。另一种方法是调用<code>shutdownNow</code>。线程池会取消所有尚未开始的任务。</p><ol><li>调用Executors类的静态方法<code>NewCachedThreadPool</code>或<code>newFixedThreadPool</code>。</li><li>调用<code>submit</code>提交<code>Runnable</code>或Callable对象。</li><li>保存好返回的<code>Future</code>对象，以便得到结果或者取消任务。</li><li>当不想再提交任何任务时，调用<code>shutdown</code></li></ol><p><code>ScheduledExecutorService</code>接口为调度执行或重复执行任务提交了一些方法。</p><h4 id="fork-join框架"><a href="#fork-join框架" class="headerlink" title="fork-join框架"></a><code>fork-join</code>框架</h4><p><code>fore-join</code>框架使用了一种有效的只能方法来平衡可用线程的工作负载，这种方法称为<strong>工作密取</strong>（<code>work stealing</code>）。</p><h3 id="异步计算"><a href="#异步计算" class="headerlink" title="异步计算"></a>异步计算</h3><p>无等待或<strong>异步</strong>计算</p><h4 id="可完成Future"><a href="#可完成Future" class="headerlink" title="可完成Future"></a>可完成<code>Future</code></h4><p>当有一个<code>Future</code>对象时，需要调用<code>get</code>来获得值，这个方法会阻塞，直到值可用。<code>CompletableFuture</code>类实现了<code>Future</code>接口，它提供了获得结果的另一种机制。<strong>通过注册一个回调，一旦结果而可用，就会（再某个线程中）利用该结果调用这个回调。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>f<span class="token punctuation">.</span><span class="token function">thenAccept</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> <span class="token comment">// Process the result string s</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过这种方式，无需阻塞就可以再结果可用时对结果进行处理。</p><p>大多数情况下，都需要建立自己的<code>CompletableFuture</code>。要想异步运行任务并得到<code>CompletableFuture</code>，不要把它直接调用给执行器服务，而应该调用静态方法<code>CompletableFuture.supplyAsync</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">readPage</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">openStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UncheckedIOException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> executor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果省略执行器，任务会在一个默认执行器上运行（具体就是<code>ForkJoinPool.commonPoll()</code>返回的执行器）。</p><blockquote><p><strong>警告</strong>：注意<code>supplyAsync</code>方法的第一个参数是一个<code>Supplier&lt;T&gt;</code>，而不是<code>Callable&lt;T&gt;</code>。这两个接口都描述了无参数而且返回值类型为<code>T</code>的函数，不过<code>Supplier</code>函数不能抛出检查型异常。送上面的代码可以看到，这不是一个令人鼓舞的选择。</p></blockquote><p><code>CompletableFuture</code>可以采用两种方式完成：得到一个结果，或者由一个未捕获的异常。要处理这两种情况，可以使用<code>whenComplete</code>方法。要对结果（或者如果没有就为<code>null</code>）和异常（或者如果没有就为<code>null</code>）调用所提供的函数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">f<span class="token punctuation">.</span><span class="token function">whenComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// Process the result s;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// Process the Throwable t;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>CompletableFuture</code>之所以被称为时可完成的，是因为可以手动地设置一个完成值。（在其他并发库中，这样的对象称为承诺（<code>promise</code>）。）当然，用<code>supplyAsync</code>创建一个<code>CompetableFuture</code>时，任务完成时就会隐式地设置完成值。不过，显示地设置结果可以提供更大的灵活性。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>exector<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">workHard</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    f<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">workSmart</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    f<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 要对一个异常完成future，需要调用</span><span class="token class-name">Throwable</span> t <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>f<span class="token punctuation">.</span><span class="token function">completeExceptionally</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以在多个线程中在同一个<code>future</code>上安全地调用complete或<code>completeExceptionally</code>。如果这个<code>future</code>已经完成，这些调用没有任何作用。</p></blockquote><blockquote><p>与普通的<code>Future</code>不同，调用<code>cancel</code>方法时，<code>CompletableFuture</code>的计算不会中断。取消只会把这个<code>Future</code>对象设置为以异常方式完成（有一个<code>CancellationException</code>异常）。</p></blockquote><h4 id="组合可完成Future"><a href="#组合可完成Future" class="headerlink" title="组合可完成Future"></a>组合可完成<code>Future</code></h4><p>为<code>CompletableFuture&lt;T&gt;</code>对象增加一个动作</p><table><thead><tr><th>方法</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>thenApply</code></td><td><code>T -&gt; U</code></td><td>对结果应用一个函数</td></tr><tr><td><code>thenAccept</code></td><td><code>T -&gt; void</code></td><td>类似于<code>thenApply</code>，不过结果为<code>void</code></td></tr><tr><td><code>thenCompose</code></td><td><code>T -&gt; CompletableFuture&lt;U&gt;</code></td><td>对结果调用函数并执行返回的<code>future</code></td></tr><tr><td><code>handle</code></td><td><code>(T, Throwable) -&gt; U</code></td><td>处理结果或错误，生成一个新结果</td></tr><tr><td><code>whenComplete</code></td><td><code>(T, Throwable) -&gt; void</code></td><td>类似于<code>handle</code>，不过结果为<code>void</code></td></tr><tr><td><code>exceptionally</code></td><td><code>Throwable -&gt; T</code></td><td>从错误计算一个结果</td></tr><tr><td><code>completeOnTimeout</code></td><td><code>T, long, TimeUnit</code></td><td>如果超时，生成给定值作为结果</td></tr><tr><td><code>orTimeout</code></td><td><code>long, TimeUnit</code></td><td>如果超时，生成一个<code>TimeoutException</code>异常</td></tr><tr><td><code>thenRun</code></td><td><code>Runnable</code></td><td>执行<code>Runnable</code>，结果为<code>void</code></td></tr></tbody></table><p>组合多个组合对象</p><table><thead><tr><th>方法</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>thenCombine</code></td><td><code>CompletableFuture&lt;U&gt;, (T, U) -&gt; V</code></td><td>执行两个动作并用给定函数组合结果</td></tr><tr><td><code>thenAcceptBoth</code></td><td><code>CompletableFuture&lt;U&gt;, (T, U) -&gt; void</code></td><td>与<code>thenCombine</code>类似，不过结果为<code>void</code></td></tr><tr><td><code>runAfterBoth</code></td><td><code>CompletableFuture&lt;?&gt;, Runnable</code></td><td>两个都完成后执行<code>runnable</code></td></tr><tr><td><code>applyToEither</code></td><td><code>CompletableFuture&lt;T&gt;, T -&gt; V</code></td><td>得到其中一个的结果时，传入给定的函数</td></tr><tr><td><code>acceptEither</code></td><td><code>CompletableFuture&lt;T&gt;, T -&gt; void</code></td><td>与<code>applyToEither</code>类似，不过结果为<code>void</code></td></tr><tr><td><code>runAfterEither</code></td><td><code>CompletableFuture&lt;?&gt;, Runnable</code></td><td>其中一个完成后执行 <code>runnable</code></td></tr><tr><td><code>static allOf</code></td><td><code>CompletableFuture&lt;?&gt; ...</code></td><td>所有给定的<code>future</code>都完成后完成，结果为<code>void</code></td></tr><tr><td><code>static anyOf</code></td><td><code>CompletableFuture&lt;?&gt; ...</code></td><td>任意给定的<code>future</code>完成后则玩抽，结果为<code>void</code></td></tr></tbody></table><ul><li>前三个方法并发运行一个<code>CompletableFuture&lt;T&gt;</code>和一个<code>CompletableFuture&lt;U&gt;</code>动作，并组合结果。</li><li>接下来三个方法并发运行两个<code>CompletableFuture&lt;T&gt;</code>动作。一旦其中一个动作完成，就传递它的结果，并忽略另一个结果。</li><li>最后的静态<code>allOf</code>和<code>allOr</code>方法取一组可完成<code>future</code>（数目可变），并生成一个<code>CompletableFuture&lt;Void&gt;</code>，它会在所有这些future都完成时或者其中任意一个<code>future</code>完成时结束。<code>allOf</code>方法不会生成任何结果。**<code>anyOf</code>方法不会终止其余任务**。</li></ul><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>到目前为止，已经了解了如何在同一个程序的不同线程中执行<code>Java</code>代码。有时候还需要执行另一个程序。为此，可以使用<code>ProcessBuilder</code>和<code>Process</code>类。<code>Process</code>类在一个单独的操作系统进程中执行一个命令，允许我们与标准输入、输出和错误流交互。<code>ProcessBuilder</code>类则允许我们配置<code>Process</code>对象。</p><blockquote><p><code>ProcessBuilder</code>类可以取代<code>Runtime.exec</code>调用，而且更为灵活。</p></blockquote><h4 id="建立一个进程"><a href="#建立一个进程" class="headerlink" title="建立一个进程"></a>建立一个进程</h4><p>首先指定想要执行的命令。可以提供一个<code>List&lt;String&gt;</code>，或者直接提供命令字符串。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"gcc"</span><span class="token punctuation">,</span> <span class="token string">"myapp.c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>警告</strong>：第一个字符串必须是一个可执行的命令，而不是一个<code>shell</code>内置命令。例如，要在<code>Windows</code>中运行<code>dir</code>命令，就需要提供字符串 <code>"cmd.exe" "/C"</code> 和 <code>"dir"</code> 来建立进程。</p></blockquote><p>每个进程都有一个工作目录，用来解析相对目录名。默认情况下，进程的工作目录与虚拟机相同，通常是启动<code>java</code>程序的哪个目录。可以用<code>directory</code>方法改变工作目录：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">builder <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">directory</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">toFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>配置<code>ProcessBuilder</code>的各个方法都返回其自身，所以可以把命令串起来。最终会调用：</p><p><code>Process p = new ProcessBuilder(command).directory(file)......start();</code></p></blockquote><p>接下来，要指定如何处理进程的标准输入、输出和错误流。默认情况下，它们分别是一个管道，可以用以下方法访问：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">OutputStream</span> processIn <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">InputStream</span> processOut <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">InputStream</span> processErr <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getErrorStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意，进程的输入流是<code>JVM</code>的一个输出流！我们会写入这个流，而我们写的内容会成为进程的输入。与之相反，我们会读取进程写入输出和错误流的内容。对我们来说，它们都是输入流。</p><p>可以指定新进程的输入、输出和错误流与<code>JVM</code>相同。如果用户在一个控制台运行<code>JVM</code>，所有用户输入都会转发到进程，而进程的输出将显示在控制台上。可以调用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">builder<span class="token punctuation">.</span><span class="token function">redirectIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为这三个流建立这个设置。如果只想继承某些流，可以把值：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ProcessBuilder<span class="token punctuation">.</span>Redirect</span><span class="token punctuation">.</span>INHERIT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>传入<code>redirectInput</code>、<code>redirectOutput</code>或<code>redirectError</code>方法。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">builder<span class="token punctuation">.</span><span class="token function">redirectOutput</span><span class="token punctuation">(</span><span class="token class-name">ProcessBuilder<span class="token punctuation">.</span>Redirect</span><span class="token punctuation">.</span>INHERIT<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过提供<code>File</code>对象，可以将进程流重定向到文件：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">builder<span class="token punctuation">.</span><span class="token function">redirectInput</span><span class="token punctuation">(</span>inputFile<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">redirectOutput</span><span class="token punctuation">(</span>outputFile<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">redirectError</span><span class="token punctuation">(</span>errorFile<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>进程启动时，会创建或删除输出和错误文件。要追加到现有的文件，可以使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">builder<span class="token punctuation">.</span><span class="token function">redirectOutput</span><span class="token punctuation">(</span><span class="token class-name">ProcessBuilder<span class="token punctuation">.</span>Redirect</span><span class="token punctuation">.</span><span class="token function">appendTo</span><span class="token punctuation">(</span>outputFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>合并输出和错误流通常很有用，这样就能按进程生成这些消息的顺序显示输出和错误消息。可以调用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">builder<span class="token punctuation">.</span><span class="token function">redirectErrorStream</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启用合并。如果这样做，就不能再在<code>ProcessBuilder</code>上调用<code>redirectError</code>，也不能在<code>Process</code>上调用<code>getErrorStream</code>。</p><p>有时可能还需要修改进程的环境变量。在这里，构建器的串联语法就不能用了。需要得到构造器的环境（由运行<code>JVM</code>的那个进程的环境变量初始化），然后加入或删除环境变量条目。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> env <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">environment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>env<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"LANG"</span><span class="token punctuation">,</span> <span class="token string">"fr_ER"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>env<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"JAVA_HOME"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Process</span> p <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果希望利用管道将一个进程的输出作为另一个进程的输入（类似于<code>shell</code>中的 <code>|</code> 操作符），<code>Java 9</code>提供了一个<code>startPipeline</code>方法。可以传入一个进程构建器列表，并从最后一个进程读取结果。这里给出了一个枚举一个目录树中的各个扩展的例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Process</span><span class="token punctuation">&gt;</span></span> processes <span class="token operator">=</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">.</span><span class="token function">startPipeline</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"find"</span><span class="token punctuation">,</span> <span class="token string">"/opt/jdk-9"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"grep"</span><span class="token punctuation">,</span> <span class="token string">"-o"</span><span class="token punctuation">,</span> <span class="token string">"\\.[^./]*$"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"sort"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"uniq"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Process</span> last <span class="token operator">=</span> processes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>processes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>last<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行一个进程"><a href="#运行一个进程" class="headerlink" title="运行一个进程"></a>运行一个进程</h4><p>配置了构建器之后，要调用它的<code>start</code>方法启用进程。如果把输入、输出和错误流配置为管道，现在可以写输入流，并读取输出和错误流。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Process</span> process <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span> <span class="token string">"-l"</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">directory</span><span class="token punctuation">(</span><span class="token class-name">Path</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"/tmp"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token keyword">var</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">hasNextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>警告</strong>：ji进程流的缓冲空间是有限的。不能写入太多输入，而且要及时读取输出。如果由大量输入和输出，可能需要在单独的线程中生产和消费这些输入输出。否则可能会造成阻塞问题。</p></blockquote><p>要等待进程完成，可以调用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> result <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">waitFor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者，如果不想无限期地等待，可以这样做：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> delay <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">waitFor</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">exitValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    process<span class="token punctuation">.</span><span class="token function">destroyForcibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个<code>waitFor</code>调用返回过程的退出值（<code>0</code>表示成功，或者返回一个非0的错误码）。如果进程没有超时，第二个调用返回<code>true</code>。然后需要调用<code>exitValue</code>方法获取退出值。</p><p>如果不会等待进程结束，而只是让它继续运行，不时调用<code>isAlive</code>来查看进程是否仍存活。要杀死这个进程，可以调用<code>destroy</code>或<code>destroyForcibly</code>。这两个调用之间的区别取决于平台。在<code>UNIX</code>上，前者会以<code>SIGTERM</code>终止进程，后者会以<code>SIGKILL</code>终止进程。（如果<code>destory</code>方法可以正常终止进程，<code>supportsNormalTermination</code>方法返回<code>true</code>。）</p><p>最后会在进程完成时接收到一个异步通知。调用<code>process.onExit()</code>会得到一个<code>CompletableFuture&lt;Process&gt;</code>，可以用来调度任何动作。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">process<span class="token punctuation">.</span><span class="token function">onExit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenAccept</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Exit value: "</span> <span class="token operator">+</span> p<span class="token punctuation">.</span><span class="token function">exitValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="进程句柄"><a href="#进程句柄" class="headerlink" title="进程句柄"></a>进程句柄</h4><p>要获得进程启动的一个进程的更多信息，或者想更多地了解你的计算机上正在运行的任何其他进程，可以使用<code>ProcessHandle</code>接口。可以用4种方式得到一个<code>ProcessHandle</code>：</p><ol><li>给定一个<code>Process</code>对象p，<code>p.toHandle()</code>会生成它的<code>ProcessHandle</code></li><li>给定一个<code>long</code>类型的操作进程<code>ID</code>，<code>ProcessHandle.of(id)</code>可以生成这个进程的句柄。</li><li><code>Process.current()</code>时运行这个<code>Java</code>虚拟机的进程的句柄</li><li><code>ProcessHandle.allProcesses()</code> 可以生成对当前进程可见的所有操作系统进程的<code>Stream&lt;ProcessHandle&gt;</code></li></ol><p>给定一个进程句柄，可以得到它的进程<code>ID</code>、父进程、子进程和后代进程。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> pid <span class="token operator">=</span> handle<span class="token punctuation">.</span><span class="token function">pid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProcessHandle</span><span class="token punctuation">&gt;</span></span> parent <span class="token operator">=</span> handle<span class="token punctuation">.</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProcessHandle</span><span class="token punctuation">&gt;</span></span> children <span class="token operator">=</span> handle<span class="token punctuation">.</span><span class="token function">children</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProcessHandle</span><span class="token punctuation">&gt;</span></span> descendants <span class="token operator">=</span> handle<span class="token punctuation">.</span><span class="token function">descendants</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>allProcesses</code>、<code>children</code>和<code>descendants</code>方法返回<code>Stream&lt;ProcessHandle&gt;</code>实例只是当时的快照。流中的任何进程在你看到它们的时候可能已经终止了，而且可能已经启动了其他进程，而那些新启动的进程不在流中。</p></blockquote><p>info方法可以生成一个<code>ProcessHandle.Info</code>对象，它提供了一些方法来获得进程的有关信息。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token function">arguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">command</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">commandLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">startInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">totalCpuDuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有这些方法都返回<code>Optional</code>值，因为可能某个特定的操作系统不能报告这个信息。</p><p>要监视或强制进程终止，于Process类一样，<code>Processhandle</code>接口也有<code>isAlive</code>、<code>supportsNormalTermination</code>、<code>destroy</code>、<code>destroyForcibly</code>和<code>onExit</code>方法。不过，没有对应<code>waitFor</code>的方法。</p><h2 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a><code>Java</code>关键字</h2><p>本附录列出了Java语言的所有关键字。有些关键字是“受限的”，它们只在某些特定场合（例如。在模块声明中）有特殊含义。在其他情况下，它们可以是标识符。</p><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td><code>abstract</code></td><td>抽象类或方法</td></tr><tr><td><code>assert</code></td><td>用来查找内部程序错误</td></tr><tr><td><code>boolean</code></td><td>布尔类型</td></tr><tr><td><code>break</code></td><td>跳出一个选择语句或循环</td></tr><tr><td><code>byte</code></td><td>8位整数类型</td></tr><tr><td><code>case</code></td><td><code>switch</code>的一个分支</td></tr><tr><td><code>catch</code></td><td>捕获异常的<code>try</code>块子句</td></tr><tr><td><code>char</code></td><td><code>Unicode</code>字符类型</td></tr><tr><td><code>class</code></td><td>定义一个类类型</td></tr><tr><td><code>const</code></td><td>未使用</td></tr><tr><td><code>continue</code></td><td>在循环末尾继续</td></tr><tr><td><code>default</code></td><td><code>switch</code>的默认子句，或者接口的默认方法</td></tr><tr><td><code>do</code></td><td><code>do/while</code> 循环最前面的语句</td></tr><tr><td><code>double</code></td><td>双精度浮点数类型</td></tr><tr><td><code>else</code></td><td><code>if</code> 语句的 <code>else</code> 子句</td></tr><tr><td><code>enum</code></td><td>枚举类型</td></tr><tr><td><code>exports</code></td><td>导出一个模块的包（受限）</td></tr><tr><td><code>extends</code></td><td>定义一个类的父类，或者一个通配符的上届</td></tr><tr><td><code>final</code></td><td>一个常量，或一个不能被覆盖的类或方法</td></tr><tr><td><code>finally</code></td><td><code>try</code>块中总会执行的部分</td></tr><tr><td><code>float</code></td><td>单精度浮点数类型</td></tr><tr><td><code>for</code></td><td>一种循环类型</td></tr><tr><td><code>goto</code></td><td>未使用</td></tr><tr><td><code>if</code></td><td>一个条件语句</td></tr><tr><td><code>implements</code></td><td>定义一个类实现的接口</td></tr><tr><td><code>import</code></td><td>导入一个包</td></tr><tr><td><code>instanceof</code></td><td>测试一个对象是否为一个类的实例</td></tr><tr><td><code>int</code></td><td>32位整数类型</td></tr><tr><td><code>interface</code></td><td>一种抽象类型，其中包含可以由类实现的方法</td></tr><tr><td><code>long</code></td><td>64位长整数类型</td></tr><tr><td><code>native</code></td><td>由宿主系统实现的一个方法</td></tr><tr><td><code>new</code></td><td>分配一个新对象或数据</td></tr><tr><td><code>null</code></td><td>一个空引用（需要说明的是，<code>null</code>从技术上讲是一个字面量，而不是关键字）</td></tr><tr><td><code>module</code></td><td>声明一个模块（受限）</td></tr><tr><td><code>open</code></td><td>修改一个<code>module</code>声明（受限）</td></tr><tr><td><code>opens</code></td><td>打开一个模块的包（受限）</td></tr><tr><td><code>package</code></td><td>包含类的一个包</td></tr><tr><td><code>private</code></td><td>这个特性只能由该类的方法访问</td></tr><tr><td><code>protected</code></td><td>这个特性只能由该类、其子类以及同一个包中的其他类的方法访问</td></tr><tr><td><code>provides</code></td><td>只是一个模块使用一个服务（受限）</td></tr><tr><td><code>public</code></td><td>这个特性可以由所有类的方法访问</td></tr><tr><td><code>return</code></td><td>从一个方法返回</td></tr><tr><td><code>short</code></td><td>16位整数类型</td></tr><tr><td><code>static</code></td><td>这个特性是类或接口特有的，而不属于类的实例</td></tr><tr><td><code>strictfp</code></td><td>对浮点数计算使用严格的规则</td></tr><tr><td><code>super</code></td><td>超类对象或构造器，或一个通配符的下界</td></tr><tr><td><code>switch</code></td><td>一个选择语句</td></tr><tr><td><code>synchronized</code></td><td>对线程而言是原子的方法或代码块</td></tr><tr><td><code>this</code></td><td>当前类的一个方法或构造器的隐含参数</td></tr><tr><td><code>throw</code></td><td>抛出一个异常</td></tr><tr><td><code>to</code></td><td><code>exports</code> 或 <code>opens</code> 声明的一部分（受限）</td></tr><tr><td><code>throws</code></td><td>一个方法可能抛出的异常</td></tr><tr><td><code>transient</code></td><td>标记非永久的数据</td></tr><tr><td><code>transitive</code></td><td>修饰一个<code>require</code>声明（受限）</td></tr><tr><td><code>try</code></td><td>捕获异常的代码块</td></tr><tr><td><code>uses</code></td><td>指示一个模块使用一个服务（受限）</td></tr><tr><td><code>var</code></td><td>声明一个变量的类型是推导得出的（受限）</td></tr><tr><td><code>void</code></td><td>指示一个方法不返回任何值</td></tr><tr><td><code>volatile</code></td><td>确保一个字段可以由多个线程访问</td></tr><tr><td><code>with</code></td><td>在一个<code>provides</code>语句中定义服务类（受限）</td></tr><tr><td><code>while</code></td><td>一种循环</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul><li><code>-Xlint:unchecked</code>：编译时使用，可以看到警告的文本信息。</li><li><code>@SuppressWarnings("unchecked")</code>：标识编译器忽略<code>unchecked</code>警告信息，例如：使用<code>List</code>，<code>ArrayList</code>等未进行参数化产生的警告信息。</li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开心最重要</title>
      <link href="/2022/05/22/dui-zi-ji-shuo/happy-day/"/>
      <url>/2022/05/22/dui-zi-ji-shuo/happy-day/</url>
      
        <content type="html"><![CDATA[<h1 id="开心最重要"><a href="#开心最重要" class="headerlink" title="开心最重要"></a>开心最重要</h1><blockquote><p>今日感想</p></blockquote><p>不用记住今天发生了什么，只记住以后要自己开心最重要啊！！！</p><p>喜欢就去做呀，开开心心的，把自己搞的那么疲惫干啥，普普通通就行。</p>]]></content>
      
      
      <categories>
          
          <category> 对自己说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心情 </tag>
            
            <tag> 开心就好 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法与示例</title>
      <link href="/2022/05/15/note/markdown-notes/"/>
      <url>/2022/05/15/note/markdown-notes/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown语法与示例"><a href="#markdown语法与示例" class="headerlink" title="markdown语法与示例"></a>markdown语法与示例</h1><blockquote><p>注：所有例子，上面是效果，下面是源码。</p><p>部分效果展示由于hexo渲染网页的原因无法完全展示。</p></blockquote><h2 id="简单概述"><a href="#简单概述" class="headerlink" title="简单概述"></a>简单概述</h2><h4 id="宗旨"><a href="#宗旨" class="headerlink" title="宗旨"></a>宗旨</h4><p>Markdown 的目标是实现「易读易写」。</p><p>可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/">atx</a>、<a href="http://textism.com/tools/textile/">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p><hr><h4 id="兼容HTML"><a href="#兼容HTML" class="headerlink" title="兼容HTML"></a>兼容HTML</h4><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。但是需要注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。</p><p>eg. 这里的双星不在做强调处理。</p><p>这是一个普通段落。</p><table>    <tbody><tr>        <td>*Foo*</td>    </tr></tbody></table><p>这是另一个普通段落。</p><hr><h4 id="特殊字符自动转换"><a href="#特殊字符自动转换" class="headerlink" title="特殊字符自动转换"></a>特殊字符自动转换</h4><p>特殊字符的转义字符，可以自动直接的转换进行展现</p><p>eg.</p><p>&amp;copy;</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token entity named-entity" title="©">&amp;copy;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>A&amp;T</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">AT<span class="token entity named-entity" title="&amp;">&amp;amp;</span>T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&lt;</p><pre class="line-numbers language-none"><code class="language-none">&lt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&gt;</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token entity named-entity" title=">">&amp;gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>"</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token entity named-entity" title="&quot;">&amp;quot;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&amp;nbsp;</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>支持两种标题的语法，类 <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a> 和类 <a href="http://www.aaronsw.com/2002/atx/">atx</a> 形式</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题）<span class="token title important">This is an H1<span class="token punctuation">=============</span></span><span class="token title important">This is an H2<span class="token punctuation">-------------</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶<span class="token title important"><span class="token punctuation">#</span> 这是 H1</span><span class="token title important"><span class="token punctuation">##</span> 这是 H2</span><span class="token title important"><span class="token punctuation">###</span> 这是 H3</span><span class="token title important"><span class="token punctuation">####</span> 这是 H4</span><span class="token title important"><span class="token punctuation">#####</span> 这是 H5</span><span class="token title important"><span class="token punctuation">######</span> 这是 H6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="区块引用-Blockquotes"><a href="#区块引用-Blockquotes" class="headerlink" title="区块引用 Blockquotes"></a>区块引用 Blockquotes</h4><blockquote><p>这是一个区块引用</p></blockquote><blockquote><blockquote><p>也可以使用多个 </p></blockquote></blockquote><blockquote><h6 id="这是一个标题。"><a href="#这是一个标题。" class="headerlink" title="这是一个标题。"></a>这是一个标题。</h6></blockquote><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token blockquote punctuation">&gt;</span> 这是一个区块引用<span class="token blockquote punctuation">&gt; &gt;</span> 也可以使用多个 <span class="token blockquote punctuation">&gt;</span> <span class="token title important"><span class="token punctuation">######</span> 这是一个标题。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><ul><li><p>1</p></li><li><p>2</p><ul><li><p>a</p><ul><li>bb</li></ul><ul><li>aa</li></ul></li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">在无序列表中 使用 { + ， - ， * }三个符号来标识无序列表，三者功能相同，相同层级下的列表表示建议使用相同的标识符，配合四个空白字符缩进，三者的组合则可以搭配出层级效果+ 1+ 2* a* bb- aa&gt; bb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><ol><li>第一</li><li>第二<ul><li>a<br>3. 反斜杠避免被识别为有序列表</li></ul></li><li>第三</li></ol><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">使用数字接着一个英文句点，则是有序列表。可以配合使用缩进配合与无序列表，区块引用等配合使用<span class="token list punctuation">1.</span> 第一<span class="token list punctuation">2.</span> 第二<span class="token list punctuation">+</span> a3\. 反斜杠避免被识别为有序列表<span class="token list punctuation">3.</span> 第三<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h4><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">这是一个代码区块<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是<code>一个</code>小段 <code>的</code> 代码 <code>显示</code></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">代码区块可以进行缩进区分，或者使用六个个反引号来进行包围，前三个反引号之后可以跟着指定的代码格式。（这里使用\,是为了展示源码）\```markdown\这是一个代码区块\```小段代码这是``` 一个 ```小段 <span class="token code-snippet code keyword">``的``</span> 代码 <span class="token code-snippet code keyword">`显示`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><hr><hr><hr><hr><hr><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。也可以在星号或是减号中间插入空格<span class="token hr punctuation">* * *</span><span class="token hr punctuation">***</span><span class="token hr punctuation">*****</span><span class="token hr punctuation">- - -</span><span class="token hr punctuation">---------------------------------------</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>两种形式的链接语法： 行内式和参考式两种形式</p><hr><h6 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h6><p><a href="http://www.baidu.com/" title="百度">示例1</a> 链接中的title文字可以使用双引号包裹起来显示。<br><a href="http://www.baidu.com/">示例2</a> 这是一个链接。</p><p><a href="/about/">示例3</a> 相对路径链接.</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">下面为行内式<span class="token url">[<span class="token content">示例1</span>](<span class="token url">http://www.baidu.com/</span> <span class="token string">"百度"</span>)</span> 链接中的title文字可以使用双引号包裹起来显示。<span class="token url">[<span class="token content">示例2</span>](<span class="token url">http://www.baidu.com/</span>)</span> 这是一个链接。要链接到同样主机的资源，可以使用相对路径<span class="token url">[<span class="token content">示例3</span>](<span class="token url">/about/</span>)</span> 相对路径链接.参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h6 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h6><p><a href="http://www.baidu.com/" title="百度">参考式</a> 此处引用的链接是参考，id标签中定义的.</p><p><a href="http://www.baidu.com/" title="百度">id</a> 此处第二个标签中不指明使用的参考，默认会寻找与名称相同的标记链接</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记<span class="token url">[<span class="token content">参考式</span>][<span class="token variable">id</span>]</span> 此处引用的链接是参考，id标签中定义的.[id][] 此处第二个标签中不指明使用的参考，默认会寻找与名称相同的标记链接接着，在文件的任意处，你可以把这个标记的链接内容定义出来此处的注释 使用 "" , '' , () 三种标识效果相同，且注意需要 [] 后紧跟 ：<span class="token url-reference url"><span class="token punctuation">[</span><span class="token variable">id</span><span class="token punctuation">]</span><span class="token punctuation">:</span> http://www.baidu.com/  <span class="token string">"百度"</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h6><p>即引用本文章中的其他标题或者另一个文件中的其他标题</p><p><a href="#%E5%AE%97%E6%97%A8">引用到宗旨部分</a></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">引用同一个文件的某个标题<span class="token url">[<span class="token content">title</span>](<span class="token url">#title</span>)</span>使用 # 选中章节。 注意要将大写字母改成小写，并删除特殊字符，空格使用 - 代替, 几级标题就时几个#引用另一个文件<span class="token url">[<span class="token content">title</span>](<span class="token url">./dir/file.md</span>)</span>引用另一个我呢见的某一个标题<span class="token url">[<span class="token content">title</span>](<span class="token url">./dir/file.md#title</span>)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h4><p><em>斜体-星号</em></p><p><em>斜体-下划线</em></p><p><strong>加粗-星号</strong></p><p><strong>加粗-下划线</strong></p><p><del>删除线</del></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token italic"><span class="token punctuation">*</span><span class="token content">斜体-星号</span><span class="token punctuation">*</span></span><span class="token italic"><span class="token punctuation">_</span><span class="token content">斜体-下划线</span><span class="token punctuation">_</span></span><span class="token bold"><span class="token punctuation">**</span><span class="token content">加粗-星号</span><span class="token punctuation">**</span></span><span class="token bold"><span class="token punctuation">__</span><span class="token content">加粗-下划线</span><span class="token punctuation">__</span></span><span class="token strike"><span class="token punctuation">~~</span><span class="token content">删除线</span><span class="token punctuation">~~</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>同样也允许两种样式： <em>行内式</em>和<em>参考式</em></p><hr><h6 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h6><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">与超链接相似，只是在·[]·前添加 !<span class="token url"><span class="token operator">!</span>[<span class="token content">图片</span>](<span class="token url">/path/to/img.jpg</span>)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h6 id="参考式-1"><a href="#参考式-1" class="headerlink" title="参考式"></a>参考式</h6><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">同样与超链接的参考式相同 只是在<span class="token code-snippet code keyword">`[]`</span>前添加 <span class="token code-snippet code keyword">`!`</span>!图片][id]<span class="token url-reference url"><span class="token punctuation">[</span><span class="token variable">id</span><span class="token punctuation">]</span><span class="token punctuation">:</span> url/to/image  <span class="token string">"图片注释"</span></span>注意这里的参考链接 <span class="token code-snippet code keyword">`[]`</span> 前不需要添加 <span class="token code-snippet code keyword">`!`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h4><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接</p><hr><p><a href="http://www.baidu.com/">http://www.baidu.com/</a></p><p><a href="mailto:address@example.com">address@example.com</a></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&lt;http://www.baidu.com/&gt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>address@example.com</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h4><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，即转义字符，使得其后的字符不被markdown识别处理，方便与插入普通字符。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">\   反斜线`   反引号<span class="token list punctuation">*</span>   星号_   底线{}  花括号[]  方括号()  括弧<span class="token title important"><span class="token punctuation">#</span>   井字号</span><span class="token list punctuation">+</span>   加号<span class="token list punctuation">-</span>   减号.   英文句点!   惊叹号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>基于markdown可以适配html语言，所以我们也可以使用html语言中简单的标签来达到更多的扩展效果</p><hr><h4 id="颜色设置"><a href="#颜色设置" class="headerlink" title="颜色设置"></a>颜色设置</h4><p><font size="3" color="red">红色</font></p><p><font size="2" color="blue">蓝色</font></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>红色<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>blue<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>红色<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h4><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">与行内式的超链接相似,只是在<span class="token code-snippet code keyword">`[]`</span>中添加 <span class="token code-snippet code keyword">`^`</span><span class="token url-reference url"><span class="token punctuation">[</span><span class="token variable">^注脚</span><span class="token punctuation">]</span><span class="token punctuation">:</span> https://www.appinn.com/markdown/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h4><p><a href="E:/Study/studyNote/Study/other-notes/git-nodes.md">绝对地址文件</a><br><a href="git-nodes.md">相对地址文件</a></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">链接文件与超链接语法类似，<span class="token url">[<span class="token content">绝对地址文件</span>](<span class="token url">E:/Study/studyNote/Study/other-notes/git-nodes.md</span>)</span><span class="token url">[<span class="token content">相对地址文件</span>](<span class="token url">git-nodes.md</span>)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LR方<span class="token text string">[方形]</span> <span class="token arrow operator">--&gt;</span>圆<span class="token text string">(圆角)</span>    圆 <span class="token arrow operator">--&gt;</span> A<span class="token text string">{条件a}</span>    A <span class="token arrow operator">--&gt;</span><span class="token label property">|a=1|</span> B<span class="token text string">[结果B]</span>    A <span class="token arrow operator">--&gt;</span><span class="token label property">|a=2|</span> C<span class="token text string">[结果C]</span>    F<span class="token text string">[横向流程图]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TD方<span class="token text string">[方形]</span> <span class="token arrow operator">--&gt;</span>圆<span class="token text string">(圆角)</span>    圆 <span class="token arrow operator">--&gt;</span> A<span class="token text string">{条件a}</span>    A <span class="token arrow operator">--&gt;</span><span class="token label property">|a=1|</span> B<span class="token text string">[结果B]</span>    A <span class="token arrow operator">--&gt;</span><span class="token label property">|a=2|</span> C<span class="token text string">[结果C]</span>    F<span class="token text string">[横向流程图]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">本质上是代码块，不过使用的语言是『mermaid』，详细操作可以查询『mermaid』\ ```mermaidgraph LR方[方形] --&gt;圆(圆角)    圆 --&gt; A{条件a}    A --&gt;|a=1| B[结果B]    A --&gt;|a=2| C[结果C]    F[横向流程图]\ ```\ ```mermaidgraph TD方[方形] --&gt;圆(圆角)    圆 --&gt; A{条件a}    A --&gt;|a=1| B[结果B]    A --&gt;|a=2| C[结果C]    F[横向流程图]\ ```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代办"><a href="#代办" class="headerlink" title="代办"></a>代办</h4><ul><li><input disabled="" type="checkbox"> 这是一个代办</li><li><input checked="" disabled="" type="checkbox"> 这是一个已办</li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">-</span> [ ] 这是一个代办<span class="token list punctuation">-</span> [x] 这是一个已办ps：并不是所有情况下，代办的效果都可以实现<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">[TOC]  # 即插入一个文章目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="https://www.appinn.com/markdown/">https://www.appinn.com/markdown/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-FAQ</title>
      <link href="/2022/05/08/faq/faq-docker/"/>
      <url>/2022/05/08/faq/faq-docker/</url>
      
        <content type="html"><![CDATA[<h1 id="FAQ-docker"><a href="#FAQ-docker" class="headerlink" title="FAQ-docker"></a>FAQ-docker</h1><blockquote><p>自己在使用docker做开发的过程中遇到的一些问题的记录</p></blockquote><h5 id="Q-Dockerfile中COPY-指令的-lt-src-gt-是否支持"><a href="#Q-Dockerfile中COPY-指令的-lt-src-gt-是否支持" class="headerlink" title="Q:Dockerfile中COPY 指令的<src> 是否支持../"></a>Q:<code>Dockerfile</code>中<code>COPY</code> 指令的<code>&lt;src&gt;</code> 是否支持<code>../</code></h5><p><strong>A:</strong></p><blockquote><p><code>COPY</code>的源文件目录不支持使用 <code>../</code>来访问其上册目录，<src>路径必须构建在上下文中，因为docker构建的第一步就是将上下文目录和子目录发送到docker守护进程</src></p></blockquote><h5 id="Q-docker-run-detach-keys-quot-quot-中参数-detach-keys的作用"><a href="#Q-docker-run-detach-keys-quot-quot-中参数-detach-keys的作用" class="headerlink" title="Q: docker run --detach-keys=&quot;&quot;中参数--detach-keys的作用"></a>Q: <code>docker run --detach-keys=""</code>中参数<code>--detach-keys</code>的作用</h5><p> <strong>A：</strong></p><blockquote><p>官网解释为：Override the key sequence for detaching a container</p><p>用于容器的键盘映射键位，在容器被连接到前台时，若宿主机的键盘键位与容器键位冲突，可以使用该指令对容器的键位进行重新映射。</p></blockquote><h5 id="Q：Dockerfile中的COPY指令，拷贝文件夹时只会拷贝文件夹中的内容"><a href="#Q：Dockerfile中的COPY指令，拷贝文件夹时只会拷贝文件夹中的内容" class="headerlink" title="Q：Dockerfile中的COPY指令，拷贝文件夹时只会拷贝文件夹中的内容"></a>Q：<code>Dockerfile中</code>的<code>COPY</code>指令，拷贝文件夹时只会拷贝文件夹中的内容</h5><p><strong>A:</strong></p><blockquote><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">COPY data/ /home/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>data中的目录结构为：</p><p>｜—— data</p><p>｜｜——dir1</p><p>｜｜｜a.txt</p><p>｜｜——dir2</p><p>｜｜｜b.txt</p><p>｜｜c.txt</p><p>拷贝到容器中后目录结构为，也就是并不会拷贝目录本身，只会拷贝目录中的内容文件</p><p>｜—— home</p><p>｜｜——dir1</p><p>｜｜｜a.txt</p><p>｜｜——dir2</p><p>｜｜｜b.txt</p><p>｜｜c.txt</p></blockquote><h5 id="Q：Dockerfile-build过程中出现错误，如何去调试"><a href="#Q：Dockerfile-build过程中出现错误，如何去调试" class="headerlink" title="Q：Dockerfile build过程中出现错误，如何去调试"></a>Q：<code>Dockerfile</code> <code>build</code>过程中出现错误，如何去调试</h5><p><strong>A：</strong></p><blockquote><p>执行 <code>docker build</code> 命令使用<code>Dockerfile</code>构建一个新的镜像的时候，dokcer内部的执行的构建步骤大致为如下几步：</p><ol><li>使用<code>Dockerfile</code> 中定义的基础镜像<code>FROM centos</code>运行一个容器</li><li>依次执行<code>Dockerfile</code> 中后续的指令，来对启动的容器进行修改；<ol><li>每执行完一条指令后，执行一个类似于<code>commit</code>的操作，来生成一个新的镜像层。(<code>build</code> <code>Dockerfile</code>的时候若不关闭使用缓存构建，用的镜像层的缓存就是以此方式构建的)</li><li>基于上一步提交的镜像来运行一个新的容器</li><li>重复1，2步骤来完成对<code>Dockerfile</code>中所有指令的执行</li></ol></li><li>完成镜像的构建</li></ol><p>所以基于上述的构建步骤，可以通过重新启动出错前一步的build出来的容器还原现场，之后再执行出错一行的命令来分析错误的原因。</p><p>eg.</p><p>执行 <code>docker build . -t test:1.0.0</code> 时某一行出现错误：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">Sending build context to Docker daemon  67.37MBStep 1/5 : FROM java:8 ---&gt; d23bdf5b1b1bStep 2/5 : COPY ./target/*.jar /app/app.jarCOPY failed: no source files were specified<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到在执行<em><strong>Step 2/5</strong></em>出现错误，在其上一步<em><strong>Step 1/5</strong></em>会保留一个临时容器<code>d23bdf5b1b1b</code> ，所以就可以启动这个临时容器来达到还原出错前的现场</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ docker container run -it d23bdf5b1b1b /bin/bash# 之后在容器中执行错误命令来排查错误# 注意 这里是使用交互模式启动，使用exit退出后 容器就会关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> FAQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> FAQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS安装docker和kubernetes</title>
      <link href="/2022/05/04/devops/docker-k8s-mac-install/"/>
      <url>/2022/05/04/devops/docker-k8s-mac-install/</url>
      
        <content type="html"><![CDATA[<h1 id="MacOS安装docker和kubernetes"><a href="#MacOS安装docker和kubernetes" class="headerlink" title="MacOS安装docker和kubernetes"></a>MacOS安装docker和kubernetes</h1><blockquote><p>在mac电脑上安装 Docker Desktop 以及对应的kubernetes(k8s)</p><p>相关资源下载地址：</p><p><a href="https://docs.docker.com/desktop/mac/install/">Docker Desktop</a></p><p><a href="https://github.com/AliyunContainerService/k8s-for-docker-desktop">k8s-for-docker-desktop</a></p></blockquote><h2 id="Docker-Desktop-安装"><a href="#Docker-Desktop-安装" class="headerlink" title="Docker Desktop 安装"></a>Docker Desktop 安装</h2><ol><li>在docker官网上下载对应芯片版本的<a href="https://docs.docker.com/desktop/mac/install/">Docker Desktop</a> dmg文件</li></ol><img src="/2022/05/04/devops/docker-k8s-mac-install/0001.png" class="" title="下载"><hr><ol start="2"><li>打开下载的dmg文件 安装docker</li></ol><img src="/2022/05/04/devops/docker-k8s-mac-install/0002.png" class="" title="安装"><ol start="3"><li>在启动台找到docker的图标即可启动</li></ol><img src="/2022/05/04/devops/docker-k8s-mac-install/0003.png" class="" title="启动"><h2 id="Kubernetes-安装"><a href="#Kubernetes-安装" class="headerlink" title="Kubernetes 安装"></a>Kubernetes 安装</h2><blockquote><p>这里没有使用docker destop自带的k8s安装按钮安装应用，而是使用阿里云的k8s-for-docker-desktop来进行安装。</p></blockquote><ol><li>在docker desktop中查看关联的k8s版本</li></ol><img src="/2022/05/04/devops/docker-k8s-mac-install/0004.png" class="" title="关联的k8s版本"><ol start="2"><li>访问<a href="https://github.com/AliyunContainerService/k8s-for-docker-desktop">k8s-for-docker-desktop</a>的github项目地址找到对应的版本下载项目</li></ol><img src="/2022/05/04/devops/docker-k8s-mac-install/0005.png" class="" title="下载"><ol start="3"><li><p>解压文件，执行其中的脚本 load_images.sh</p><blockquote><p>如果安装时下载资源比较慢，可以为docker daemon配置国内的镜像加速，阿里云镜像服务或者中科大镜像加速地址：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></p></blockquote><img src="/2022/05/04/devops/docker-k8s-mac-install/0007.png" class="" title="配置镜像加速"></li></ol><img src="/2022/05/04/devops/docker-k8s-mac-install/0006.png" class="" title="执行load_images.sh"><ol start="4"><li>等待执行成功，可以执行命令 kubectl version 查看版本来确定是否安装成功</li></ol><img src="/2022/05/04/devops/docker-k8s-mac-install/0008.png" class="" title="查看安装版本"><ol start="5"><li>打开docker desktop控制面板查看相关信息</li></ol><img src="/2022/05/04/devops/docker-k8s-mac-install/0009.png" class="" title="查看相关信息"><ol start="6"><li><p>配置kubernetes</p><blockquote><p>可选操作：切换kubernetes运行上下文到docker-desktop（之前版本的context为docker-for-desktop）</p></blockquote></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 切换运行上下文[root@qing centos]$ kubectl config use-context docker-desktop# 查看配置[root@qing centos]$ kubectl config view# 验证kubernetes集群状态[root@qing centos]$ kubectl cluster-info[root@qing centos]$ kubectl get nodes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>完</strong></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> kubernetes </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes</title>
      <link href="/2022/04/30/devops/kubernetes/"/>
      <url>/2022/04/30/devops/kubernetes/</url>
      
        <content type="html"><![CDATA[<h1 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h1><blockquote><p>大规模容器编排系统</p></blockquote><p><strong>特性</strong></p><ul><li><strong>服务发现和负载均衡</strong><ul><li>Kubernetes可以使用DNS名称或者IP地址公开容器，如果进入容器的流量很大，Kubernetes可以负载均和冰粉配网络流量，从而使部署稳定</li></ul></li><li><strong>存储编排</strong><ul><li>Kubernetes允许自动挂在所选择的存储系统。eg. 本地存储、公共云提供商</li></ul></li><li><strong>自动部署和回滚</strong><ul><li>使用Kubernetes描述已部署的所需状态，可以将受控的速率将实际状态更改为期望状态。比如可以自动化Kubernetes来部署创建新容器，删除现有容器并将它们的所有资源用于新容器</li></ul></li><li><strong>自动完成装箱计算</strong><ul><li>Kubernetes允许指定每个容器所需的CPU和RAM。当容器指定来资源请求时，Kubernetes可以做出更好的决策来管理容器资源。</li></ul></li><li><strong>自我修复</strong><ul><li>Kubernetes重新启动失败的容器、替换容器、杀死不相应用户定义的运行状态检查的容器，并且在准备好服务之前不将其通告给客户端。</li></ul></li><li><strong>密钥和配置管理</strong><ul><li>Kubernetes可以存储和管理敏感信息，例如密码、OAuth令牌和ssh密钥。可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</li></ul></li></ul><p>Kubernetes提供了一个可弹性运行分布式系统的框架，可以更轻松管理系统的Canary部署。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>Kubernetes Cluster = N Master Node + N Worker Node =&gt; N主节点 + N工作节点；</p><h3 id="平面组件结构"><a href="#平面组件结构" class="headerlink" title="平面组件结构"></a>平面组件结构</h3><img src="/2022/04/30/devops/kubernetes/components-of-kubernetes.svg" class="" title="components-of-kubernetes"><img src="/2022/04/30/devops/kubernetes/0001.png" class="" title="平面结构图-1"><p><strong>控制平面组件</strong>(control plane)</p><ul><li><p><strong>kube-apiserver</strong></p><p>API服务器为K8s集群资源操作提供唯一入口，并提供认证、授权、访问控制、API 注册和发现机制。</p><p>Kubernetes API 服务器验证并配置 API 对象的数据， 这些对象包括 pods、services、replicationcontrollers 等。 API 服务器为 REST 操作提供服务，并为集群的共享状态提供前端， 所有其他组件都通过该前端进行交互。</p></li><li><p><strong>etcd</strong></p><p>兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库(例如 Pod 的数量、状态、命名空间等）、API 对象和服务发现细节。 在生产级k8s中etcd通常会以集群的方式存在，安全原因，它只能从 API 服务器访问。</p></li><li><p><strong>kube-scheduler</strong></p><p>kube-scheduler 负责监视新创建、未指定运行Node的 Pods，决策出一个让pod运行的节点。</p><p>调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。</p></li><li><p><strong>kube-controller-manager</strong></p><p>k8s在后台运行许多不同的控制器进程，当服务配置发生更改时（例如，替换运行 pod 的镜像，或更改配置 yaml 文件中的参数），控制器会发现更改并开始朝着新的期望状态工作。</p><p>控制器包括:</p><ul><li>节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应</li><li>任务控制器（Job controller）: 监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li><li>端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)</li><li>服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌</li></ul></li><li><p><strong>cloud-controller-manager</strong></p><p>云控制器管理器使得你可以将你的集群连接到云提供商的 API 之上， 同时可以将云平台交互组件与本地集群中组件分离。</p><p>下面的控制器都包含对云平台驱动的依赖：</p><ul><li>节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除</li><li>路由控制器（Route Controller）: 用于在底层云基础架构中设置路由</li><li>服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器</li></ul></li></ul><p><strong>Node中组件</strong></p><blockquote><p>节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。</p></blockquote><ul><li><p><strong>kubelet</strong></p><p>一个在集群中每个node上运行的代理。 它保证容器都 运行在 Pod 中。kubelet 定期接收新的或修改过的 pod 规范 PodSpecs（主要通过 kube-apiserver）并确保 pod 及容器健康并以所需状态运行。该组件还向 kube-apiserver 报告运行它的主机的健康状况。</p><p><strong>kubelet 不会管理不是由 Kubernetes 创建的容器。</strong></p></li><li><p><strong>kube-proxy</strong></p><p>kube-proxy是集群中每个节点上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。用于处理单个主机子网划分并向外部世界公开服务。它跨集群中的各种隔离网络将请求转发到正确的 pod/容器。</p><p>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><p>如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。</p></li></ul><blockquote><p>该部分组件说明参考自： <a href="https://zhuanlan.zhihu.com/p/409971135">https://zhuanlan.zhihu.com/p/409971135</a></p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>docker kubelet kebectl kubeadm</p></blockquote><ol><li><strong>docker</strong> : 容器运行环境</li><li><strong>kubelet</strong> : 基本运行环境</li><li>kubectl : 帮助管理员输入相关操作命令， 可以只安装在admin</li><li>kubeadm : 帮助管理人员快速搭建集群环境</li></ol><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><ol><li><strong>配置yum源</strong></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ yum <span class="token function">install</span> -y yum-utils<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ yum-config-manager <span class="token punctuation">\</span>--add-repo <span class="token punctuation">\</span>https://download.docker.com/linux/centos/docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>安装docker</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">sudo</span> yum <span class="token function">install</span> -y docker-ce docker-ce-cli containerd.io<span class="token comment"># 安装指定版本</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">sudo</span> yum <span class="token function">install</span> -y docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io-1.4.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>启动docker</strong></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> docker --now<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>配置镜像加速</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="集群创建"><a href="#集群创建" class="headerlink" title="集群创建"></a>集群创建</h3><blockquote><p>请先保证docker安装完成</p></blockquote><p><strong>安装kebuadm</strong></p><ul><li>一台兼容的Linux主机。Kubernetes项目为基于Debian和Red Hat的Linux发行版以及一些不提供包管理器的发行版提供通用的指令</li><li>每台机器2GB或者更多的内存（较少会影响应用的运行内存）</li><li>2 CPU核或更多</li><li>集群中的所有机器的网络彼此均能相互连接（公网和内网都可以）<ul><li><strong>设置防火墙放行规则</strong></li></ul></li><li>节点之中不可以用重复的主机名、MAC地址和product_uuid<ul><li><strong>设置不同的hostname</strong></li></ul></li><li>开启机器上的某些端口<ul><li><strong>内网通信</strong></li></ul></li><li>禁用交换分区。为了保证kubelet正常工作，<strong>必须禁用交换分区</strong><ul><li><strong>永久关闭</strong></li></ul></li></ul><blockquote><p>设置主机名：hostnamectl set-hostname k8s-master</p><p>查看主机名：hostname</p><p>查看分区：free -m </p></blockquote><img src="/2022/04/30/devops/kubernetes/0003.png" class="" title="集群结构"><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 设置独立域名</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ hostnamectl set-hostname xxxx<span class="token comment"># 将SELinux设置为 permissive模式（相当于禁用）</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ setenforce <span class="token number">0</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">sed</span> -i <span class="token string">'s/^SELINUX=enforcing$/SELINUX=permissive/'</span> /etc/selinux/config<span class="token comment"># 关闭swap</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ swapoff -a<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">sed</span> -ri <span class="token string">'s/.*swap.*/#&amp;/'</span> /etc/fstab<span class="token comment"># 允许 iptables 检查桥接流量</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/modules-load.d/k8s.conf</span>br_netfilterEOF</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/sysctl.d/k8s.conf</span>net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ sysctl --system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="安装kubelet、kubeadm、kubectl"><a href="#安装kubelet、kubeadm、kubectl" class="headerlink" title="安装kubelet、kubeadm、kubectl"></a>安装kubelet、kubeadm、kubectl</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/yum.repos.d/kubernetes.repo</span>[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg   http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgexclude=kubelet kubeadm kubectlEOF</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ yum <span class="token function">install</span> -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes<span class="token operator">=</span>kubernetes<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> --now kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>kubelet 现在每隔几秒就会重启，因为它陷入了一个等待kubeadm指令的死循环在等待指令</p><p>可以使用命令  systemctl status kubelet 查看状态</p></blockquote><h4 id="使用kubeadm引导集群"><a href="#使用kubeadm引导集群" class="headerlink" title="使用kubeadm引导集群"></a>使用kubeadm引导集群</h4><h5 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h5><blockquote><p>下载各个机器需要的镜像</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">tee</span> ./images.sh <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'#!/bin/bashimages=(kube-apiserver:v1.20.9kube-proxy:v1.20.9kube-controller-manager:v1.20.9kube-scheduler:v1.20.9coredns:1.7.0etcd:3.4.13-0pause:3.2)for imageName in ${images[@]} ; dodocker pull $imageNamedoneEOF</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">chmod</span> +x ./images.sh <span class="token operator">&amp;&amp;</span> ./images.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="设置主节点"><a href="#设置主节点" class="headerlink" title="设置主节点"></a>设置主节点</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 所有机器添加master域名映射，以下需要修改为自己的master的内网ip地址</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"10.140.122.4 cluster-endpoint"</span> <span class="token operator">&gt;&gt;</span> /etc/hosts<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"10.140.122.39 node01"</span> <span class="token operator">&gt;&gt;</span> /etc/hosts<span class="token comment"># 在其他节点可以ping通主节点</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">ping</span> cluster-endpoint<span class="token comment"># 主节点运行 注意 --apiserver-advertise-address 映射的ip改成自己的</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubeadm init <span class="token punctuation">\</span>--apiserver-advertise-address<span class="token operator">=</span><span class="token number">10.140</span>.122.4 <span class="token punctuation">\</span>--control-plane-endpoint<span class="token operator">=</span>cluster-endpoint <span class="token punctuation">\</span>--image-repository registry.aliyuncs.com <span class="token punctuation">\</span>--kubernetes-version v1.20.9 <span class="token punctuation">\</span>--service-cidr<span class="token operator">=</span><span class="token number">10.96</span>.0.0/16 <span class="token punctuation">\</span>--pod-network-cidr<span class="token operator">=</span><span class="token number">192.168</span>.0.0/16<span class="token comment">## --apiserver-advertise-address  主节点的ip</span><span class="token comment">## --control-plane-endpoint       主节点的域名</span><span class="token comment">## --image-repository             镜像仓库</span><span class="token comment">## --kubernetes-version           k8s版本</span><span class="token comment">## service-cidr                   k8s内部进行负载均衡使用ip范围  不可与机器的ip有所重叠</span><span class="token comment">## --pod-network-cidr             k8s启动的pod的ip地址的范围   不可与机器的ip有所重叠</span><span class="token comment"># 保证每个配置之间的网络范围不重叠 --apiserver-advertise-address、--service-cidr、--pod-network-cidr</span><span class="token comment"># 如果这里修改了 后两个配置项的ip域，后续的 calico.yaml 文件中要进行对应修改</span><span class="token comment">## 复制保留 Your Kubernetes control-plane has initialized successfully 后面的内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="后续操作"><a href="#后续操作" class="headerlink" title="后续操作"></a>后续操作</h5><blockquote><p>根据安装后的提示选择执行部分</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># To start using your cluster, you need to run the following as a regular user:</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p <span class="token environment constant">$HOME</span>/.kube<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">cp</span> -i /etc/kubernetes/admin.conf <span class="token environment constant">$HOME</span>/.kube/config<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> <span class="token environment constant">$HOME</span>/.kube/config<span class="token comment"># Alternatively, if you are the root user, you cna run:</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">KUBECONFIG</span><span class="token operator">=</span>/etc/kubernetes/admin.conf<span class="token comment"># You should now deploy a pod network to the cluster.</span><span class="token comment"># RUN "kubectl apply -f [podnetwork].yaml" with one of the options # listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="部署网络组件"><a href="#部署网络组件" class="headerlink" title="部署网络组件"></a>部署网络组件</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 官方文档 https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">curl</span> https://docs.projectcalico.org/manifests/calico.yaml -O<span class="token comment">## 如果出现警告（k8s使用高于1.21版本）</span><span class="token comment">## Warning: policy/v1beta1 PodDisruptionBudget is deprecated in v1.21+, unavailable in v1.25+; use policy/v1 PodDisruptionBudget poddisruptionbudget.policy "calico-kube-controllers" deleted</span><span class="token comment">## 1. 原因在于policy/v1beta1 在1.22之后使用 policy/v1, 1.25正式移除，暂不影响使用，</span><span class="token comment">## 2. 如果想去除 可以修改下载的calico.yaml，找到其中的`policy/v1beta1`修改为`policy/v1`即可</span><span class="token comment"># -f 应用文件</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl apply -f calico.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="加入node节点"><a href="#加入node节点" class="headerlink" title="加入node节点"></a>加入node节点</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 根据之前的提示 将node节点加入集群</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubeadm <span class="token function">join</span> cluster-endpoint:6443 --token xxxxxxxxx<span class="token comment"># 上述的令牌只有24小时有效 过期了使用下述命令重新生成</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubeadm token create -print-join-command<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h5><blockquote><p>kubectl 只有在主节点有效</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看集群所有节点</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get nodes<span class="token comment"># 根据配置文件，给集群创建资源</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl apply -f xxx.yaml<span class="token comment"># 查看集群部署了哪些应用</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pods -A<span class="token comment">## === docker ps</span><span class="token comment">## docker中叫做容器 在 k8s中叫做pos</span><span class="token comment">## kubectl get pods -A -w 保留窗口信息监控</span><span class="token comment">## watch -n 1 kubectl get pods -A</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="部署dashboard"><a href="#部署dashboard" class="headerlink" title="部署dashboard"></a>部署dashboard</h4><ol><li><strong>部署</strong></li></ol><blockquote><p>kubernetes官方提供的可视化界面</p><p><a href="https://github.com/kubernetes/dashboard">https://github.com/kubernetes/dashboard</a></p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.5.1/aio/deploy/recommended.yaml<span class="token comment"># 备注: raw.githubusercontent.com 属于外网 由于域名污染的问题 可能直接执行无法访问，可以选择在浏览器中复制上面的链接 在本地创建文件保存内容 (科学上网？)</span><span class="token comment"># 复制保存到本地后 使用命令 kubectl apply -f ./recommended.yaml 执行文件</span><span class="token comment"># 拉取dashboard镜像报CarshLoopBackoff 需要调整yaml文件两处 添加主机名 nodeName   eg. k8s_master</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>附本人github复制文件下载链接：<a href="https://github.com/RobertSunq/data/blob/master/qing/blog/hexo/kubernetes/recommended_v2.5.1.yaml" title="v2.5.1 recommended.yaml 下载链接 ">recommended</a></p></blockquote><ol start="2"><li><strong>设置访问端口</strong></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard<span class="token comment"># 暴露dashboard的端口号</span><span class="token comment">### 1. 打开文件后  </span><span class="token comment">### 2. 输入 `/` </span><span class="token comment">### 3. 之后输入 `type:` ，找到文本 `type: ClusterIP` </span><span class="token comment">### 4. 修改为 NodePort</span><span class="token comment">### 5. 退出并保存</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>NodeIP： node节点的IP地址，即物理网卡的IP地址</p><p>PodIp：Pod的IP地址，即docker容器的IP地址，此为虚拟IP地址</p><p>ClusterIP：Service的IP地址，此为虚拟IP地址</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 通过公网ip访问的话需要在虚拟机或者云服务器中开放端口</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get svc -A <span class="token operator">|</span> <span class="token function">grep</span> kubernetes-dashboard<span class="token comment">## 找到端口，在安全组放行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之后通过:  https://集群任意IP:Port 就可以访问了</p><ol start="3"><li><strong>创建访问账号</strong></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">vim</span> dash_manager.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 创建dash_manager.yaml文件，并键入以下文本，使用kebuctl apply -f dash_manager.yaml 来创建相关账号</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin   <span class="token comment"># 该处为命名空间，注意跟上面安装的dashboard配置中的命名空间相同</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>dashboard<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span> <span class="token punctuation">:</span> cluster<span class="token punctuation">-</span>admin<span class="token key atrule">subjects</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin  <span class="token comment"># 该处为命名空间，注意跟上面安装的dashboard配置中的命名空间相同</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>dashboard<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl apply -f dash_manager.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 如果启动失败通过下面命令查看pod信息</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pods,svc -n kubernetes-dashboard -o wide<span class="token comment"># 找到对应启动失败pod的name 查看详细信息 {{pod-name}}为上一步查出的问题</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl describe pod/<span class="token punctuation">{</span><span class="token punctuation">{</span>pod-name<span class="token punctuation">}</span><span class="token punctuation">}</span> -n kubernetes-dashboard<span class="token comment"># 修改后 可以从master节点重启下pod , 删除后k8s可以自动恢复</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl delete pod/<span class="token punctuation">{</span><span class="token punctuation">{</span>pod-name<span class="token punctuation">}</span><span class="token punctuation">}</span> -n kubernetes-dashboard<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2022/04/30/devops/kubernetes/0004.png" class="" title="错误演示"><ol start="4"><li><strong>令牌访问</strong></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl -n kubernetes-dashboard get secret <span class="token variable"><span class="token variable">$(</span>kubectl -n kubernetes-dashboard get sa/admin -o <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">"{.secrets[0].name}"</span><span class="token variable">)</span></span> -o go-template<span class="token operator">=</span><span class="token string">"{{.data.token | base64decode}}"</span><span class="token comment"># 将输出的密钥复制保留</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="5"><li>mac上通过代理访问</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 启用代理</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl proxy  <span class="token comment"># 访问网址：http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#!/overview?namespace=default</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="核心实战"><a href="#核心实战" class="headerlink" title="核心实战"></a>核心实战</h2><p>资源创建方式主要有两种</p><ul><li>命令行：键入命令</li><li>YAML：编写yaml文件来执行</li></ul><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><blockquote><p>命名空间 ： 用来隔离资源，分组。默认只隔离资源，不隔离网络。</p></blockquote><h4 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查询命名空间</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get namespace<span class="token comment"># [root@qing centos]$ kubectl get ns # ns 为namespace缩写</span><span class="token comment"># ----------------------------------------------------</span>NAME                   STATUS   AGEdefault                Active   6d3hkube-node-lease        Active   6d3hkube-public            Active   6d3hkube-system            Active   6d3hkubernetes-dashboard   Active   4m23s<span class="token comment"># ----------------------------------------------------</span><span class="token comment"># 获取部署的应用</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pods -A <span class="token comment"># -A 获取所有的应用 不添加时获取 namespace=default 下的应用</span><span class="token comment"># -n namespace 查询指定命名空间下面的应用 kubectl get pods -n kubernetes-dashboard</span><span class="token comment"># 创建命名空间</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create ns kube-qing<span class="token comment"># 删除命名空间</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl delete ns kube-qing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">注意：删除命名空间的时候会连带删除该命名空间下的所有资源</font></p><h4 id="YAML操作"><a href="#YAML操作" class="headerlink" title="YAML操作"></a>YAML操作</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">tee</span> ./kube_qing.yaml <span class="token operator">&lt;&lt;-</span><span class="token string">EOFapiVersion: v1 # 版本号kind: Namespace # 指定资源类型  命名空间metadata: # 元数据  name: kube-qingEOF</span><span class="token comment"># 应用该文件创建命名空间</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl apply -f ./kube_qing.yaml<span class="token comment"># 删除时也可以使用配置文件删除</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl delete -f ./kube_qing.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="命令小结-1"><a href="#命令小结-1" class="headerlink" title="命令小结"></a>命令小结</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 获取所有的命令空间</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get namespace<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get ns<span class="token comment"># 获取部署的pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod -A<span class="token comment"># -n {{命名空间}}  指定命名空间</span><span class="token comment"># 创建命名空间</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create ns <span class="token punctuation">{</span><span class="token punctuation">{</span>namespace<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment"># 删除命名空间</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create ns <span class="token punctuation">{</span><span class="token punctuation">{</span>namespace<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><blockquote><p>运行中的一组容器，Pod是kubernetes中应用的最小单位</p></blockquote><p>下图中为一个pod包含两个容器组成一个小应用</p><img src="/2022/04/30/devops/kubernetes/0005.png" class="" title="pod结构"><ol><li>Pod和container都运行在以docker为基础的环境上</li><li>container（容器）为dokcer管理的单位，每个应用包装为一个容器在运行</li><li>Pod为k8s在container的基础上再包装一层用于作为最小单位用于管理，Pod中可以只包含一个容器也可以包含多个容器</li></ol><img src="/2022/04/30/devops/kubernetes/0006.png" class="" title="Pod和container"><h4 id="命令行操作-1"><a href="#命令行操作-1" class="headerlink" title="命令行操作"></a>命令行操作</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 启动一个pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl run qing-nginx --image<span class="token operator">=</span>nginx -n kube-qing<span class="token comment"># --image=nginx  指定镜像为nginx启动容器</span><span class="token comment"># -n 指定命名空间  不指定是为 default 命名空间</span><span class="token comment"># 包装为pod 命名为qing-nginx</span><span class="token comment"># 查看kube-qing命名空间下的pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod -n kube-qing<span class="token comment"># 查看pod的详情  describe 描述pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl describe pod qing-nginx -n kube-qing<span class="token comment"># ------------------------------------------------</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.Events:  <span class="token comment"># 启动pod中的事件过程</span>  Type    Reason     Age   From               Message  ----    ------     ----  ----               -------  Normal  Scheduled  116s  default-scheduler  Successfully assigned kube-qing/qing-nginx to docker-desktop   <span class="token comment"># 116s 前 成功将任务分配给docker-desktop节点</span>  Normal  Pulling    116s  kubelet            Pulling image <span class="token string">"nginx"</span>   <span class="token comment"># 116s 前 kubelet拉取镜像</span>  Normal  Pulled     99s   kubelet            Successfully pulled image <span class="token string">"nginx"</span> <span class="token keyword">in</span> <span class="token number">16</span>.555086628s  Normal  Created    99s   kubelet            Created container qing-nginx   <span class="token comment"># 99s 前 创建容器成功</span>  Normal  Started    99s   kubelet            Started container qing-nginx   <span class="token comment"># 99s 前 启动容器成功</span><span class="token comment"># ------------------------------------------------</span><span class="token comment"># 集群环境下 该容器只会在第一步分配的节点上启动 其他节点上不会启动</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看日志</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl logs qing-nginx -n kube-qing<span class="token comment"># -f 追踪显示日志</span><span class="token comment"># 删除刚刚启动的pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl delete pod qing-nginx -n kube-qing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="YAML操作-1"><a href="#YAML操作-1" class="headerlink" title="YAML操作"></a>YAML操作</h4><ol><li>一个pod包含一个容器</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod <span class="token comment"># 资源类型</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>   <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">run</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx  <span class="token comment"># pod 的名字</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>qing <span class="token comment"># 所在的命名空间</span><span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment"># 所要创建的pod的详细信息</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token comment"># 指定启动的容器， 可以启动多个容器，使用多个 - image 形式</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx <span class="token comment"># 镜像名称</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx <span class="token comment"># 容器的名字， docker ps 可查询</span>  <span class="token comment"># - image: mysql</span>  <span class="token comment">#   name: qing-mysql</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>一个pod包含多个容器</p><blockquote><p>同一个pod中共享网络空间，使用的是同一个ip地址，所以这里可以通过分别访问启动的qing-nginx-tomcat Pod的80和8080端口可以验证启动的两个容器</p><p>可以将pod类比理解为一个小的虚拟机环境，可以启动多个容器，但是容器间不能端口冲突</p></blockquote></li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod <span class="token comment"># 资源类型</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>   <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">run</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>tomcat  <span class="token comment"># pod 的名字</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>qing <span class="token comment"># 所在的命名空间</span><span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment"># 所要创建的pod的详细信息</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token comment"># 指定启动的容器， 可以启动多个容器，使用多个 - image 形式</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx <span class="token comment"># 镜像名称</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx <span class="token comment"># 容器的名字， docker ps 可查询</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> tomcat<span class="token punctuation">:</span>8.5.68 <span class="token comment"># 镜像名+版本</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动成功后</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看命名空间kube-qing下的pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod -n kube-qing -o wideNAME                READY   STATUS    RESTARTS   AGE     IP          NODE             NOMINATED NODE   READINESS GATESqing-nginx          <span class="token number">1</span>/1     Running   <span class="token number">0</span>          2m34s   <span class="token number">192.168</span>.0.57   docker-desktop   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>qing-nginx-tomcat   <span class="token number">2</span>/2     Running   <span class="token number">0</span>          2m22s   <span class="token number">192.168</span>.0.58   docker-desktop   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span><span class="token comment"># 访问qing-nginx-tomcat中的容器</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token number">192.168</span>.0.58:80<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token number">192.168</span>.0.58:8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="命令小结-2"><a href="#命令小结-2" class="headerlink" title="命令小结"></a>命令小结</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">## 以下 -n 为可选参数  不指明时为 default 空间</span><span class="token comment">## 每个pod k8s都会分配一个ip</span><span class="token comment">## 集群中的任意一个机器以及任意的应用都能通过pod分配的ip来访问，但是在集群外部不能访问</span><span class="token comment"># 启动pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl run <span class="token punctuation">{</span><span class="token punctuation">{</span>自定义名称<span class="token punctuation">}</span><span class="token punctuation">}</span> --image<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>镜像名<span class="token punctuation">}</span><span class="token punctuation">}</span> -n <span class="token punctuation">{</span><span class="token punctuation">{</span>命名空间<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment"># 查看命名空间中的pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod -n <span class="token punctuation">{</span><span class="token punctuation">{</span>命名空间<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment"># 描述启动中的pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl describe pod <span class="token punctuation">{</span><span class="token punctuation">{</span>pod名称<span class="token punctuation">}</span><span class="token punctuation">}</span> -n <span class="token punctuation">{</span><span class="token punctuation">{</span>命名空间<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment"># 删除命名空间中的pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl delete pod <span class="token punctuation">{</span><span class="token punctuation">{</span>pod名称<span class="token punctuation">}</span><span class="token punctuation">}</span> -n <span class="token punctuation">{</span><span class="token punctuation">{</span>命名空间<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment"># 查看pod的运行日志</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl logs <span class="token punctuation">{</span><span class="token punctuation">{</span>pod名称<span class="token punctuation">}</span><span class="token punctuation">}</span> -n <span class="token punctuation">{</span><span class="token punctuation">{</span>命名空间<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment"># 打印pod更完善的信息</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod -o wide<span class="token comment"># 进入pod中容器的 /bin/bash</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> -it qing-nigin -- /bin/bash<span class="token comment"># 监控pod的操作</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod -w<span class="token comment"># 用,分割获取多种资源</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod,svc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><blockquote><p>部署应用：控制Pod，使Pod拥有多个副本、自愈、阔缩容等能力</p></blockquote><h4 id="命令行操作-2"><a href="#命令行操作-2" class="headerlink" title="命令行操作"></a>命令行操作</h4><ol><li>创建pod</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl run mynginx --image<span class="token operator">=</span>nginx<span class="token comment"># 使用deployment创建pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create deployment mytomcat --image<span class="token operator">=</span>tomcat:8.5.68<span class="token comment">## 但是使用 kubectl delete pod mytomcat-xxxx的时候 会触发自愈 重新启动一个pod </span><span class="token comment">## 想要删除的话 使用命令 kubectl delete deploy mytomcat</span><span class="token comment">## 查询所有的部署  kubectl get deploy</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>启用多副本</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create deployment qing-app --image<span class="token operator">=</span>nginx --replicas<span class="token operator">=</span><span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>阔缩容</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 扩容</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl scale --replicas<span class="token operator">=</span><span class="token number">5</span> deployment/qing-app<span class="token comment"># 缩容 将replicas缩小</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl scale --replicas<span class="token operator">=</span><span class="token number">2</span> deployment/qing-app<span class="token comment"># 也可也直接去修改对应的YAML</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl edit deployment qing-app<span class="token comment"># 修改其中的 replicas 参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="YAML操作-2"><a href="#YAML操作-2" class="headerlink" title="YAML操作"></a>YAML操作</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment <span class="token comment"># 资源类型 </span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span> <span class="token comment"># 副本个数</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app  <span class="token key atrule">template</span><span class="token punctuation">:</span> <span class="token comment"># 副本的模版</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span> <span class="token comment"># 启动的容器</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx <span class="token comment"># 使用的镜像</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="自愈和故障转移"><a href="#自愈和故障转移" class="headerlink" title="自愈和故障转移"></a>自愈和故障转移</h4><p><strong>自愈</strong>：当Pod出现停机、删除Pod、容器崩溃等时，k8s可以自行重启Pod</p><p><strong>故障转移</strong>：集群状态下，如果一台机器因为断电等原因掉线，k8s在监控到这种情况后，会将这台机器上之前运行的所有Pod转移到当前集群中状态正常的节点上。</p><h4 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h4><blockquote><p>灰度发布</p><p>当更新某个pod时：</p><ol><li><p>先启动V2版本的Pod，此时V1版本的Pod依旧接受流量处理任务</p></li><li><p>当V2版本的Pod稳定后，会将流量请求切换到V2版本的Pod，然后关闭掉V1版本的Pod</p></li></ol></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 以Deployment中yaml部署的应用为例</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">set</span> image deployment/qing-app <span class="token assign-left variable">nginx</span><span class="token operator">=</span>nginx:1.16.1  --record<span class="token comment"># set image 设置镜像 </span><span class="token comment"># deployment/qing-app 目标应用的名称  </span><span class="token comment"># nginx=nginx:1.16.1 修改的内容</span><span class="token comment"># --record  </span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl rollout status deployment/qing-app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 历史记录</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl rollout <span class="token function">history</span> deployment/qing-app<span class="token comment"># 查看某个历史详情</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl rollout <span class="token function">history</span> deployment/qing-app --revision<span class="token operator">=</span><span class="token number">2</span><span class="token comment"># 回滚（上个版本）</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl rollout undo deployment/qing-app<span class="token comment"># 回滚（指定版本）</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl rollout undo deployment/qing-app --to-revision<span class="token operator">=</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Deployment-StatefulSet-DaemonSet-Job-CronJob"><a href="#Deployment-StatefulSet-DaemonSet-Job-CronJob" class="headerlink" title="Deployment StatefulSet DaemonSet Job/CronJob"></a><code>Deployment</code> <code>StatefulSet</code> <code>DaemonSet</code> <code>Job/CronJob</code></h4><p><strong>延伸</strong>：</p><p>除了<code>Deployment</code>之外，k8s还有<code>StatefulSet</code>、<code>DaemonSet</code>、<code>Job</code>等类型资源。统称为<font color="blue">工作负载</font>。</p><ul><li><code>Deployment</code>：无状态应用部署，例如微服务，提供多副本等功能</li><li><code>StatefulSet</code>：有状态应用部署，例如redis，提供稳定的存储、网络等功能</li><li><code>DaemonSet</code>：守护型应用部署，例如日志收集组件，在每个机器都运行一份(有且只有一份)</li><li><code>Job</code>/<code>CronJob</code>：定时任务部署，例如垃圾清理组件，可以在指定时间运行</li></ul><p>有状态应用使用  <code>StatefulSet</code>  部署，无状态应用使用 <code>Deployment</code> 部署</p><blockquote><p><a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/">https://kubernetes.io/zh/docs/concepts/workloads/controllers/</a></p></blockquote><p>在dashboard上也有对应管理菜单页</p><img src="/2022/04/30/devops/kubernetes/0007.png" class="" title="dashboard"><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><blockquote><p>将一组Pods公开为网络服务等抽象方法。</p><p>Pod的服务发现与负载均衡</p></blockquote><img src="/2022/04/30/devops/kubernetes/0008.png" class="" title="service"><h4 id="命令行操作-3"><a href="#命令行操作-3" class="headerlink" title="命令行操作"></a>命令行操作</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 暴露Deploy 默认在集群内有效</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl expose deployment qing-app --port<span class="token operator">=</span><span class="token number">8000</span> --target-port<span class="token operator">=</span><span class="token number">80</span><span class="token comment">## deployment qing-app  --port=8000 暴露的port  指的是service的端口</span><span class="token comment">## --target-port=80  映射目标的port  指的是pods的端口</span><span class="token comment">## 后面存在默认参数 --type=ClusterIP</span><span class="token comment"># 查看服务 </span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get <span class="token function">service</span><span class="token comment"># 使用标签检索Pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod -l <span class="token assign-left variable">app</span><span class="token operator">=</span>qing-app<span class="token comment"># 查询pod的标签</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod --show-labels<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#测试</span><span class="token comment"># 进入容器内部，修改/usr/share/nginx/html/index.html 文件来进行测试</span><span class="token punctuation">[</span>root@qing-tomcat-bxx<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token number">1111</span> <span class="token operator">&gt;</span> /usr/share/nginx/html/index.html<span class="token comment">## 将多个pod设置为不同的值</span><span class="token comment"># 在宿主机上</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">curl</span> ip:8000<span class="token comment"># 可以访问到 nginx pod的80端口的内容</span><span class="token comment"># 在容器内使用域名访问</span><span class="token punctuation">[</span>root@qing-tomcat-bxx<span class="token punctuation">]</span>$ <span class="token function">curl</span> qing-app.kube-qing.svc:8000<span class="token comment"># 组成规则 qing-app.kube-qing.svc:8000 -&gt; 服务名.命名空间.svc     -&gt; svc:service</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="YAMl操作"><a href="#YAMl操作" class="headerlink" title="YAMl操作"></a>YAMl操作</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service <span class="token comment"># 资源名称</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app <span class="token comment"># 筛选指定的pod  名为：app  值为：qing-app</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span> <span class="token comment"># 一组port，可以配置多个</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8000</span>  <span class="token comment"># 暴露的端口号 指的是service的端口</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP <span class="token comment"># 端口协议</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span> <span class="token comment"># 目标端口  指的是pods的端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h3><blockquote><p>集群IP，只能在集群中访问。</p><p>service中操作时，默认的类型就是 clusterIP。</p></blockquote><h4 id="命令行操作-4"><a href="#命令行操作-4" class="headerlink" title="命令行操作"></a>命令行操作</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl expose deployment qing-app --port<span class="token operator">=</span><span class="token number">8000</span> --target-port<span class="token operator">=</span><span class="token number">80</span> --type<span class="token operator">=</span>ClusterIP <span class="token comment"># 只能在集群内通过 CLUSTER-IP 访问</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="YAMl操作-1"><a href="#YAMl操作-1" class="headerlink" title="YAMl操作"></a>YAMl操作</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8000</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app  <span class="token key atrule">type</span><span class="token punctuation">:</span> ClusterIP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h3><blockquote><p>节点ip，集群外面也可以访问，即可以在公网中访问。</p></blockquote><h4 id="命令行操作-5"><a href="#命令行操作-5" class="headerlink" title="命令行操作"></a>命令行操作</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl expose deployment qing-app --port<span class="token operator">=</span><span class="token number">8000</span> --target-port<span class="token operator">=</span><span class="token number">80</span> --type<span class="token operator">=</span>NodePort <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2022/04/30/devops/kubernetes/0009.png" class="" title="服务列表"><p>可以看出<code>qing-app</code>的<code>PORT</code>部分多出来一个<code>30002</code>端口，由kubernetes开启，并且在所以的<code>pod</code>上面均开启。 此时就可以通过 <code>公网IP:30002</code>进行访问了</p><blockquote><p>NodePort默认范围在 30000 - 32767之间</p></blockquote><h4 id="YAMl操作-2"><a href="#YAMl操作-2" class="headerlink" title="YAMl操作"></a>YAMl操作</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8000</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><blockquote><p>流量入口，是Service的统一网关入口</p><p>基于nginx实现</p><p>安装时用的<code>ingress yaml</code>只是一个声明，本身不做任何事情。如果需要实际的<code>ingress</code>功能，就需要部署<code>ingress controller</code>。这个 <code>controller</code> 也使用了 <code>LoadBalancer service type</code>，使得集群外流量通过 <code>Cloud LB</code> 可以被转发到 <code>ingress controller</code> 上。</p></blockquote><img src="/2022/04/30/devops/kubernetes/0010.png" class="" title="ingress"><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">wget</span> https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.47.0/deploy/static/provider/baremetal/deploy.yaml<span class="token comment"># 如果其中镜像下载过慢，可以修改改yaml文件中images的值，指定为从国内的镜像仓库中下载</span><span class="token comment"># 检查安装的结果</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod,svc -n ingress-nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>附本人github复制文件下载链接：<a href="https://github.com/RobertSunq/data/blob/master/qing/blog/hexo/kubernetes/ingress_v0.47.yaml" title="v0.47.0 ingress.yaml 下载链接 ">ingress</a></p><p>出现两个端口，分别用于 <code>http</code> 和 <code>https</code></p></blockquote><img src="/2022/04/30/devops/kubernetes/0011.png" class="" title="安装会创建service"><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><blockquote><p>官方手册：<a href="https://kubernetes.github.io/ingress-nginx/">https://kubernetes.github.io/ingress-nginx/</a></p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 创建测试环境</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">vi</span> ingress-server.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server        <span class="token comment"># todo  待修改</span>        <span class="token key atrule">image</span><span class="token punctuation">:</span> robertsunq/hello<span class="token punctuation">-</span>server        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">9000</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8000</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server  <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8000</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">9000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>域名访问</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 访问规则</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">vi</span> ingress—test.yaml<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl apply -f ingress—test.yaml<span class="token comment"># 执行后，查看ingress</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get ingress<span class="token comment"># 注意需要将下方测试的域名映射填入到/etc/hosts文件中</span><span class="token comment"># master_ip  hello.qing.com</span><span class="token comment"># master_ip  demo.qing.com</span><span class="token comment"># 测试完后可以修改下 demo.qing.com 的映射path为 path: "/nginx"</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl edit ing ingress-host-bar<span class="token comment"># ing  ingress的缩写</span><span class="token comment"># ingress-host-bar 对应的ingress name</span><span class="token comment">#### 此时访问 demo.qing.com:31063 页面为  404 nignx</span><span class="token comment">#### 此时访问 demo.qing.com:31063/nginx 页面为  404 nignx/1.21.1</span><span class="token comment">##### 会发现第二个下面会带有版本号，</span><span class="token comment">##### 原因在于第一次访问是由ingress的nginx代理的 没有找到对应的服务pod所以返回的是ingress的404页面</span><span class="token comment">##### 第二次访问由ingress的代理找到了下属的服务nginx-demo  所以返回的是下属的服务nginx-demo对应的404页面也就是带有版本号的</span><span class="token comment"># 可以进入到nginx-demo部署下面的一个pod中</span><span class="token punctuation">[</span>root@qing nginx-demo-xxxx<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> /usr/share/nginx/html<span class="token punctuation">[</span>root@qing nginx-demo-xxxx<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token number">1111</span> <span class="token operator">&gt;</span> nginx<span class="token comment"># 此时再去访问demo.qing.com:31063/nginx 就可以看到哥哥添加的文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress  <span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>host<span class="token punctuation">-</span>bar<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ingressClassName</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token comment"># 指定域名,</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">"hello.qing.com"</span>    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token comment"># 路径模式为 前缀</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/"</span>        <span class="token comment"># 转发给对应服务</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">8000</span>  <span class="token comment"># 指定域名</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">"demo.qing.com"</span>    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/"</span>        <span class="token comment"># path: "/nginx" # 第二次修改修改为此path 对比两次的区别 </span>        <span class="token comment">## 会将请求路径/nginx转给下面的nginx-demo服务 如果此时nginx-demo不能处理路径/nginx就会出现 404</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">8000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2022/04/30/devops/kubernetes/0012.png" class="" title="ingress测试示例"><p><strong>路径重写</strong></p><blockquote><p>官方示例：<a href="https://kubernetes.github.io/ingress-nginx/examples/rewrite/">https://kubernetes.github.io/ingress-nginx/examples/rewrite/</a></p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token comment">## 重写路径  /$2  部分  即下方(/|$)(.*)捕获的部分都赋予$2</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/rewrite-target</span><span class="token punctuation">:</span> /$2        <span class="token comment">## 指定该部分路径是否只可以通过SSL访问</span>    <span class="token comment"># nginx.ingress.kubernetes.io/ssl-redirect: true </span>    <span class="token comment">## 指定在未启用TLS下，也强制重定向到HTTPS</span>    <span class="token comment"># nginx.ingress.kubernetes.io/force-ssl-redirect: true</span>    <span class="token comment">## 定义重定向 上下文到 root 即访问rewrite.qing.com将重定向到 rewrite.qing.com/app1</span>    <span class="token comment"># nginx.ingress.kubernetes.io/app-root: /app1</span>    <span class="token comment">## 路径上知否使用正则</span>    <span class="token comment"># nginx.ingress.kubernetes.io/use-regex: true</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> rewrite  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ingressClassName</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> rewrite.qing.com    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /something(/<span class="token punctuation">|</span>$)(.<span class="token important">*)</span>        <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo            <span class="token key atrule">port</span><span class="token punctuation">:</span>               <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重写后的效果为：</p><ul><li>rewrite.qing.com/something   -&gt; rewrite.qing.com/</li><li>rewrite.qing.com/something/   -&gt; rewrite.qing.com/</li><li>rewrite.qing.com/something/new   -&gt; rewrite.qing.com/new</li></ul><p><strong>流量限制</strong></p><blockquote><p>官方示例：<a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#rate-limiting">https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#rate-limiting</a></p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>limit<span class="token punctuation">-</span>rate  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/limit-rps</span><span class="token punctuation">:</span> <span class="token string">"1"</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ingressClassName</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">"haha.qing.com"</span>    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>        <span class="token comment"># 精确模式</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Exact        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/"</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">8000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="网络模型简述"><a href="#网络模型简述" class="headerlink" title="网络模型简述"></a>网络模型简述</h3><ul><li>所有的<code>Pod</code>属于<code>Pod</code>层，相互之间是网络共同的，其<code>IP</code>地址的区间为上面设置主节点配置时设置<code>--pod-network-cidr=192.168.0.0/16</code></li><li>根据<code>Pod</code>的功能属性氛围不同的<code>service</code>，<code>service</code>之间的网络也是相关联通的，而且与所有的<code>pod</code>之间网络联通，，其<code>IP</code>地址的区间为上面设置主节点配置时设置<code>--service-cidr=10.96.0.0/16</code></li><li><code>pod</code>之间可以相互直接访问，也可以通过其所属的<code>service</code>访问其他的<code>pod</code></li><li>外部请求流量通常是经由<code>LB</code>之后到达<code>Ingress</code>层做网关流量管控，之后在发送给对应的<code>serivce</code>来调用其具体的<code>pod</code>功能支持</li></ul><img src="/2022/04/30/devops/kubernetes/0013.png" class="" title="网络简述"><h3 id="存储抽象"><a href="#存储抽象" class="headerlink" title="存储抽象"></a>存储抽象</h3><p>原始的容器挂载目录在宿主机上，但是现在<code>kubernetes</code>在集群环境下，在不同的机器上启动<code>pod</code>，如果其中<code>C</code>机器上的一个<code>pod</code>出现问题退出了，由于故障转移的机制<code>kubernetes</code>可能会在<code>B</code>机器上新建这个出问题的<code>pod</code>，这时<code>pod</code>所挂载的目录就是在两台机器上了，存在物理上的隔离。</p><img src="/2022/04/30/devops/kubernetes/0014.png" class="" title="内存抽象"><p><strong>环境准备</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 所有机器安装 nfs文件管理工具</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ yum <span class="token function">install</span> -y nfs-utils<span class="token comment"># 主节点设置 </span><span class="token comment">############</span><span class="token comment"># 挂载nfs，以下是配置</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"/nfs/data/ *(insecure,rw,sync,no_root_squash)"</span> <span class="token operator">&gt;</span> /etc/exports<span class="token comment"># /nfs/data/ 需要暴露的目录 </span><span class="token comment"># * 所有人可以同步</span><span class="token comment"># insecure,rw,sync,no_root_squash 同步的方式</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p /nfs/data<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> rpcbind --now<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> nfs-server --now<span class="token comment"># 配置生效</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ exportfs -r<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ exportfs/nfs/data<span class="token operator">&lt;</span>world<span class="token operator">&gt;</span><span class="token comment">############</span><span class="token comment"># 从节点设置,挂载主节点的nfs目录</span><span class="token comment">############</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ showmount -e <span class="token punctuation">{</span><span class="token punctuation">{</span>主节点IP<span class="token punctuation">}</span><span class="token punctuation">}</span>Export list <span class="token keyword">for</span> <span class="token number">172.1</span>.1.1/nfs/data *<span class="token comment">#挂载 nfs 服务器上的共享目录到本机路径 /root/nfsmount</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p /nfs/data_bak<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mount</span> -t nfs <span class="token punctuation">{</span><span class="token punctuation">{</span>主节点IP<span class="token punctuation">}</span><span class="token punctuation">}</span>:/nfs/data /nfs/data_bak<span class="token comment"># {{主节点IP}}:/nfs/data 挂载到当前机器的 /nfs/data_bak目录</span><span class="token comment"># 写入一个测试文件</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"hello nfs server"</span> <span class="token operator">&gt;</span> /nfs/data/test.txt<span class="token comment">############</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="原生方式数据挂载"><a href="#原生方式数据挂载" class="headerlink" title="原生方式数据挂载"></a>原生方式数据挂载</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pv<span class="token punctuation">-</span>demo  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pv<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token comment"># 数量</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pv<span class="token punctuation">-</span>demo  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pv<span class="token punctuation">-</span>demo    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token comment"># nginx 镜像容器</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token comment"># 卷挂载</span>        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html          <span class="token comment"># 容器的内部目录</span>          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html          <span class="token comment"># 挂载方式  nfs</span>          <span class="token key atrule">nfs</span><span class="token punctuation">:</span>            <span class="token key atrule">server</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>主节点IP<span class="token punctuation">}</span><span class="token punctuation">}</span>            <span class="token comment"># 宿主机的目标路径</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data/nginx<span class="token punctuation">-</span>pv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>执行可能会出错，提示/nfs/data/nginx-pv不存在， 需要在宿主机上创建该目录重启</p></blockquote><h4 id="PV-amp-PVC"><a href="#PV-amp-PVC" class="headerlink" title="PV&amp;PVC"></a>PV&amp;PVC</h4><blockquote><p>PV：持久卷（Persistent Volume），将应用需要持久化的数据保存到指定位置</p><p>PVC：持久卷申明（Persistent Volume Claim），申明需要使用到持久卷规格，用来在PV中申请区间，也可以删除该申明来从PV中删除存储的内容</p></blockquote><h5 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h5><p><strong>创建PV池</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 主节点创建几块目录</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p /nfs/data/01<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p /nfs/data/02<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p /nfs/data/03<span class="token comment"># 查询当前所有的PV</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kebectl get <span class="token function">pv</span><span class="token comment"># pv PersistentVolume</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>创建PV</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume <span class="token comment"># 持久化卷</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv01<span class="token punctuation">-</span>10m<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token comment"># 容量, 静态供应，容量固定</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 10M  <span class="token comment"># 权限模式</span>  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteMany  <span class="token comment"># 存储空间明</span>  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token comment"># 路径</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data/01    <span class="token key atrule">server</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>主节点IP<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment"># 通过 --- 分割每部分的内容</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv02<span class="token punctuation">-</span>1gi<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteMany  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data/02    <span class="token key atrule">server</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>主节点IP<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv03<span class="token punctuation">-</span>3gi<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 3Gi  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteMany  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data/03    <span class="token key atrule">server</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>主节点IP<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="PVC"><a href="#PVC" class="headerlink" title="PVC"></a>PVC</h5><p><strong>创建PVC</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim <span class="token comment"># 资源类型 申请书</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pvc<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteMany  <span class="token key atrule">resources</span><span class="token punctuation">:</span>    <span class="token key atrule">requests</span><span class="token punctuation">:</span>      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 200Mi  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs  <span class="token comment"># 与PV中穿件的存储空间名字相同</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>创建Pod绑定PVC</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deploy<span class="token punctuation">-</span>pvc  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deploy<span class="token punctuation">-</span>pvc<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deploy<span class="token punctuation">-</span>pvc  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deploy<span class="token punctuation">-</span>pvc    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html         <span class="token comment"># 不是指定nfs 而是指定PVC去挂载申请到的目录</span>          <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>            <span class="token key atrule">claimName</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pvc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><blockquote><p>配置集，抽取应用配置，并且可以自动更新</p><ol><li>现将需要使用的配置 制作成 configMap</li><li>创建pod时饮用配置集</li></ol></blockquote><ol><li>将配置文件创建为ConfigMap</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 创建文件</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">tee</span> ./redis.conf <span class="token operator">&lt;&lt;-</span><span class="token string">EOF# rddis 数据需要持久化存储appendonly yesEOF</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create cm redis-conf --from-file<span class="token operator">=</span>redis.conf<span class="token comment"># cm   --&gt; comfigMap 缩写</span><span class="token comment"># --from-file  由什么文件制作配置集</span><span class="token comment"># 查询配置集</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get cmNAME               DATA   AGEredis-conf   <span class="token number">1</span>      8s<span class="token comment"># 查询配置集</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get cm redis-conf -oyaml<span class="token comment"># -oyaml 以 yaml形式 输出 redis-conf 配置集</span><span class="token comment"># 下面为该命令的输出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token comment"># data配置下 才是真实的数据 key -&gt; 文件名，value -&gt; 配置文件</span><span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token comment"># 默认是文件名 </span>  <span class="token key atrule">redis.conf</span><span class="token punctuation">:</span> <span class="token punctuation">|</span>  <span class="token comment"># 下方是配置文件中的内容</span>    <span class="token comment"># redis 数据需要持久化存储</span>    appendonly yes<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap  <span class="token comment"># 资源类型为配置集</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">creationTimestamp</span><span class="token punctuation">:</span> <span class="token string">"2022-05-11T11:16:32Z"</span> <span class="token comment"># 创建时间</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>conf  <span class="token comment"># 创建配置的名称</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default <span class="token comment"># 命名空间</span>  <span class="token key atrule">resourceVersion</span><span class="token punctuation">:</span> <span class="token string">"439924"</span>  <span class="token key atrule">uid</span><span class="token punctuation">:</span> adf679dd<span class="token punctuation">-</span>f040<span class="token punctuation">-</span>437c<span class="token punctuation">-</span>bffd<span class="token punctuation">-</span>7f5effb521ec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>创建Pod</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 使用docker 加载自定义的配置启动</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker run -v /data/redis/redis.conf:/etc/redis/redis.conf <span class="token punctuation">\</span>-v /data/redis/data:/data <span class="token punctuation">\</span>-d --name myredis <span class="token punctuation">\</span>-p <span class="token number">6379</span>:6379 <span class="token punctuation">\</span>redis:latest redis-server /etc/redis/redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> kubernetes yaml文件版</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">apiVersion: v1kind: Podmetadata:  name: redisspec:  containers:  - name: redis    image: redis    command:      - redis-server      <span class="token comment"># redis容器内部的位置 加载的配置文件</span>      - <span class="token string">"/redis-master/redis.conf"</span>      ports:    - containerPort: <span class="token number">6379</span>    <span class="token comment"># 卷挂载</span>    volumeMounts:    <span class="token comment"># 容器内的数据目录 /data</span>    - mountPath: /data      name: data    <span class="token comment"># 容器内的配置目录 挂载方式在下方定义</span>    - mountPath: /redis-master      name: config  <span class="token comment"># 宿主机中的卷</span>  volumes:    <span class="token comment"># 宿主机的对应配置</span>    - name: data      <span class="token comment"># 随机分配一个空目录</span>      emptyDir: <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token comment"># 对应上面 名为 config 的配置文件挂载</span>    - name: config      <span class="token comment"># 配置文件是从配置集中获取</span>      configMap:        <span class="token comment"># 要使用的配置集名称</span>        name: redis-conf        <span class="token comment"># 获取配置集中 data的那些项</span>        items:        <span class="token comment"># 引入 redis-conf 配置集中 data 下 key为 redis.conf的配置</span>        - key: redis.conf          <span class="token comment"># 指定上方通过key获取到的配置 放到什么目录下,在容器的/redis-master创建redis.conf</span>          path: redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2022/04/30/devops/kubernetes/0015.png" class="" title="配置集图示"><ol start="3"><li>检查默认配置</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> -it redis -- redis-cli<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> CONFIG GET appendonly<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> CONFIG GET requirepass<span class="token comment"># 修改配置集</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl edit cm redis-conf<span class="token comment">#####  以下为修改后的内容  ######</span>apiVersion: v1<span class="token comment"># data配置下 才是真实的数据 key -&gt; 文件名，value -&gt; 配置文件</span>data:  <span class="token comment"># 默认是文件名 </span>  redis.conf: <span class="token operator">|</span>  <span class="token comment"># 下方是配置文件中的内容</span>    <span class="token comment"># redis 数据需要持久化存储</span>    appendonly <span class="token function">yes</span>    <span class="token comment"># 添加密码配置</span>    requirepass <span class="token number">123456</span>kind: ConfigMap  <span class="token comment"># 资源类型为配置集</span>metadata:  creationTimestamp: <span class="token string">"2022-05-11T11:16:32Z"</span> <span class="token comment"># 创建时间</span>  name: redis-conf  <span class="token comment"># 创建配置的名称</span>  namespace: default <span class="token comment"># 命名空间</span>  resourceVersion: <span class="token string">"439924"</span>  uid: adf679dd-f040-437c-bffd-7f5effb521ec<span class="token comment">#####  以上为修改后的内容  ######</span><span class="token comment"># 修改后等待片刻 重启完成后就可以看到修改</span><span class="token comment"># 进入容器内 </span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> -it redis -- bin/bash<span class="token comment"># 查看配置文件，可以看到Pod具有热更新的能力</span><span class="token punctuation">[</span>root@qing redis-xxxx<span class="token punctuation">]</span> <span class="token function">cat</span> /redis-master/redis.conf  <span class="token comment"># 或者可以直接进入容器的 的 redis 客户端</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> -it redis -- redis-cli<span class="token comment"># 输入下面的命令</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> CONFIG GET appendonly<span class="token comment"># 这里没有更新 是因为pod需要重启 redis才可以生效，</span><span class="token comment"># pod中部署的 中间件 自己没有热更新的能力</span><span class="token number">27.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> CONFIG GET requirepass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h3><blockquote><p>Secret 对象类型用来保存敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 将这些信息放在 secret 中比放在 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a> 的定义或者 <a href="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-image">容器镜像</a>中来说更加安全和灵活。</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># kubectl create secret 创建密钥信息</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create secret docker-registry qing-docker <span class="token punctuation">\</span>--docker-username<span class="token operator">=</span>qing <span class="token punctuation">\</span>--docker-password<span class="token operator">=</span>qing123456 <span class="token punctuation">\</span>--docker-email<span class="token operator">=</span><span class="token number">111111</span>@qq.com<span class="token comment">### 格式说明</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create secret docker-registry regcred <span class="token punctuation">\</span>  --docker-server<span class="token operator">=</span><span class="token operator">&lt;</span>镜像仓库服务器<span class="token operator">&gt;</span> <span class="token punctuation">\</span>  --docker-username<span class="token operator">=</span><span class="token operator">&lt;</span>用户名<span class="token operator">&gt;</span> <span class="token punctuation">\</span>  --docker-password<span class="token operator">=</span><span class="token operator">&lt;</span>密码<span class="token operator">&gt;</span> <span class="token punctuation">\</span>  --docker-email<span class="token operator">=</span><span class="token operator">&lt;</span>邮箱地址<span class="token operator">&gt;</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get secret<span class="token comment"># 查看对应的yaml文件 可以发现是被加密的</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get secret qing-docker -oyaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> private<span class="token punctuation">-</span>nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> private<span class="token punctuation">-</span>nginx    <span class="token comment"># 该镜像为私有 需要账号密码下载</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> qing/privatengin<span class="token punctuation">:</span>v1.0  <span class="token key atrule">imagePullSecrets</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>docker <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p>【尚硅谷】 <a href="https://b23.tv/D8L82Jz">https://b23.tv/D8L82Jz</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> command </tag>
            
            <tag> note </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker compose教程</title>
      <link href="/2022/01/05/devops/docker-compose/"/>
      <url>/2022/01/05/devops/docker-compose/</url>
      
        <content type="html"><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>Docker Compose<ul><li>安装</li><li>Demo测试</li><li>compose yaml规则</li><li>测试开源项目</li><li>简单实战</li></ul></li></ul><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><blockquote><p>来轻松高效的管理容器，对多个容器进行管理，批量容器编排。</p><p>通过docker-compose编写yaml配置文件，进行一键启动多个相互配置的镜像以及网络配置。</p></blockquote><hr><p>Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose, see <a href="https://docs.docker.com/compose/#features">the list of features</a>.</p><p>Compose works in all environments: production, staging, development, testing, as well as CI workflows. You can learn more about each case in <a href="https://docs.docker.com/compose/#common-use-cases">Common Use Cases</a>.</p><p>Using Compose is basically a three-step process:</p><ol><li>Define your app’s environment with a <code>Dockerfile</code> so it can be reproduced anywhere.</li><li>Define the services that make up your app in <code>docker-compose.yml</code> so they can be run together in an isolated environment.</li><li>Run <code>docker compose up</code> and the <a href="https://docs.docker.com/compose/cli-command/">Docker compose command</a> starts and runs your entire app. You can alternatively run <code>docker-compose up</code> using the docker-compose binary.</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.9"</span>  <span class="token comment"># optional since v1.27.0</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">web</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span> .    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> .<span class="token punctuation">:</span>/code      <span class="token punctuation">-</span> logvolume01<span class="token punctuation">:</span>/var/log    <span class="token key atrule">links</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> redis  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token key atrule">logvolume01</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>概念说明</strong></p><ul><li>服务services：容器，应用。（web、redis、mysql……）</li><li>项目project：一组关联的容器组成一个完整的业务单元<ul><li>通过使用docker-compose up来启动多个服务是的项目的正常运行</li></ul></li></ul><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p>其他平台的安装详见官网：<a href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a></p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 下载[root@qing centos]$ curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose# 下载过慢时，备用地址[root@qing centos]$ curl -L https://get.daocloud.io/docker/compose/releases/download/v2.2.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose# 授权[root@qing centos]$ chmod +x /usr/local/bin/docker-compose# 查看版本，验证是否安装成功[root@qing centos]$ docker-compose versionDocker Compose version v2.2.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Demo测试"><a href="#Demo测试" class="headerlink" title="Demo测试"></a>Demo测试</h3><blockquote><p>demo来自官网文档：<a href="https://docs.docker.com/compose/gettingstarted/">https://docs.docker.com/compose/gettingstarted/</a></p></blockquote><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><ol><li><p>创建项目目录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ cd /home/qing[root@qing centos]$ mkdir composetest[root@qing centos]$ cd composetest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>创建python应用<code>app.py</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ vim app.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该项目Demo中，<code>redis</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> redis <span class="token comment"># 导入redis</span><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flaskapp <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>cache <span class="token operator">=</span> redis<span class="token punctuation">.</span>Redis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'redis'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">)</span> <span class="token comment"># 使用redis缓存 端口号为6379</span><span class="token keyword">def</span> <span class="token function">get_hit_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 对cache进行自增</span>    retries <span class="token operator">=</span> <span class="token number">5</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> cache<span class="token punctuation">.</span>incr<span class="token punctuation">(</span><span class="token string">'hits'</span><span class="token punctuation">)</span>        <span class="token keyword">except</span> redis<span class="token punctuation">.</span>exceptions<span class="token punctuation">.</span>ConnectionError <span class="token keyword">as</span> exc<span class="token punctuation">:</span>            <span class="token keyword">if</span> retries <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">raise</span> exc            retries <span class="token operator">-=</span> <span class="token number">1</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token comment"># 访问页面返回字符串 并调用cache自增</span><span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> get_hit_count<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">'Hello World! I have been seen {} times.\n'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建依赖说明<code>requirements.txt</code></p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">flaskredis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h4 id="创建Dockerfile"><a href="#创建Dockerfile" class="headerlink" title="创建Dockerfile"></a>创建Dockerfile</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ vim Dockerfile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># syntax=docker/dockerfile:1FROM python:3.7-alpine # 基本环境包WORKDIR /code # 工作目录ENV FLASK_APP=app.py # 环境ENV FLASK_RUN_HOST=0.0.0.0RUN apk add --no-cache gcc musl-dev linux-headers # 运行COPY requirements.txt requirements.txt # 复制文件RUN pip install --upgrade pipRUN pip install -r requirements.txt # 使用pip安装EXPOSE 5000 # 暴露端口COPY . .CMD ["flask", "run"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="在Compose-file中定义服务"><a href="#在Compose-file中定义服务" class="headerlink" title="在Compose file中定义服务"></a>在Compose file中定义服务</h4><p>创建一个<code>docker-compose.yml</code>文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ vim docker-compose.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.9"</span> <span class="token comment"># 说明版本</span><span class="token key atrule">services</span><span class="token punctuation">:</span> <span class="token comment"># 两个服务 web和redis</span>  <span class="token key atrule">web</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span> . <span class="token comment"># 通 docker build 使用Dockerfile生成一个镜像</span>    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"redis:alpine"</span> <span class="token comment"># 使用官方提供的镜像</span><span class="token comment"># 该compose定义了两个服务 web redis</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用Compose构建并启动应用"><a href="#使用Compose构建并启动应用" class="headerlink" title="使用Compose构建并启动应用"></a>使用Compose构建并启动应用</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ docker-compose up # 使用compose启动引用并运行##### 此处输出细节由于部分原因未保存，故不作具体展示，大概过程如下##### 下载redis镜像##### 根据Dockefile生成镜像##### 启动两个应用##### composetest-redis-1  | 1:M 06 Jan 2022 15:14:00.396 * Ready to accept connections##### composetest-web-1    |  * Running on http://172.19.0.2:5000/ (Press CTRL+C to quit)# 新打开ssh连接[root@qing centos]$ docker ps # 可以查看到两个容器正在运行CONTAINER ID   IMAGE             COMMAND                  CREATED        STATUS         PORTS                                       NAMESeab226264027   redis:alpine      "docker-entrypoint.s…"   23 hours ago   Up 4 minutes   6379/tcp                                    composetest-redis-1df7060ac4312   composetest_web   "flask run"              23 hours ago   Up 4 minutes   0.0.0.0:5000-&gt;5000/tcp, :::5000-&gt;5000/tcp   composetest-web-1[root@qing centos]$ curl localhost:5000Hello World! I have been seen 1 times.  # 测试访问，服务正常[root@qing centos]$ curl localhost:5000Hello World! I have been seen 2 times.[root@qing centos]$ docker images # 会自动根据配置下载镜像，而不用手动的一个一个去pullREPOSITORY        TAG                IMAGE ID       CREATED         SIZEcomposetest_web   latest             29a58f03ba24   23 hours ago    185MBredis             alpine             3900abf41552   5 weeks ago     32.4MBpython            3.7-alpine         a1034fd13493   5 weeks ago     41.8MB[root@qing centos]$ docker network ls # 通过compose启动的容器实例会自动创建一个网络，把所有的容器放在同一个容器下NETWORK ID     NAME                  DRIVER    SCOPE7d8581eaa5e7   composetest_default   bridge    local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>因此，在<code>app.py</code>中，可以通过redis的服务名来进行连接，因为在同一个网络下。</p></blockquote><img src="/2022/01/05/devops/docker-compose/0001.png" class="" title="示例"><h4 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 在工作目录下[root@qing centos]$ cd /home/qing/composetest# 方式一[root@qing centos]$ docker-compose stop # 方式二[root@qing centos]$ docker-compose down --volumes# 方式三# 在启动的地方 Ctrl+C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="compose-yaml规则"><a href="#compose-yaml规则" class="headerlink" title="compose yaml规则"></a>compose yaml规则</h3><blockquote><p>官网文档说明：<a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 三层结构</span><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.9"</span> <span class="token comment"># 版本号</span><span class="token key atrule">services</span><span class="token punctuation">:</span> <span class="token comment"># 服务</span>  <span class="token comment"># 服务配置</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span>alpine <span class="token comment"># 镜像</span>    <span class="token key atrule">ports</span><span class="token punctuation">:</span> <span class="token comment"># 暴露的端口号(多)</span>      <span class="token punctuation">-</span> <span class="token string">"6379"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span> <span class="token comment"># 设置要加入的网络(多)，网络配置文件中配置，也可以基于已有网络？</span>      <span class="token punctuation">-</span> frontend      <span class="token punctuation">-</span> other<span class="token punctuation">-</span>network    <span class="token key atrule">deploy</span><span class="token punctuation">:</span> <span class="token comment"># 部署运行时的配置</span>      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span> <span class="token comment"># 副本，指定给定时间内的容器运行数量</span>      <span class="token key atrule">update_config</span><span class="token punctuation">:</span> <span class="token comment"># 配置服务如何更新</span>        <span class="token key atrule">parallelism</span><span class="token punctuation">:</span> <span class="token number">2</span> <span class="token comment"># 一次更新的容器数量</span>        <span class="token key atrule">delay</span><span class="token punctuation">:</span> 10s <span class="token comment"># 更新一组容器间的等待时间</span>      <span class="token key atrule">restart_policy</span><span class="token punctuation">:</span> <span class="token comment"># 配置如何重启服务</span>        <span class="token key atrule">condition</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure <span class="token comment"># 失败是，eg. none/any</span>  <span class="token comment"># 服务配置</span>  <span class="token key atrule">db</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> postgres<span class="token punctuation">:</span><span class="token number">9.4</span> <span class="token comment"># 镜像</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span> <span class="token comment"># 配置挂载卷  宿主机 : 容器目录</span>      <span class="token punctuation">-</span> db<span class="token punctuation">-</span>data<span class="token punctuation">:</span>/var/lib/postgresql/data <span class="token comment"># 该方式需要在下方定义 交予docker默认挂载卷下管理 即具名挂载  通过 docker volume管理</span>      <span class="token comment"># - /data/qing/postgresql/data:/var/lib/postgresql/data # 也可以设置直接路径</span>      <span class="token comment"># - $PWD:/var/lib/postgresql/data # 特殊用法 $PWD 宿主机当前目录</span>      <span class="token comment"># - $(pwd):/var/lib/postgresql/data # 特殊用法 $(pwd)宿主机当前目录</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span> <span class="token comment"># 设置要加入的网络(多)</span>      <span class="token punctuation">-</span> backend    <span class="token key atrule">deploy</span><span class="token punctuation">:</span> <span class="token comment"># 部署运行时的配置</span>      <span class="token key atrule">placement</span><span class="token punctuation">:</span> <span class="token comment"># 设置约束和首选项</span>        <span class="token key atrule">max_replicas_per_node</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment"># 限制一个节点上运行的副本数量</span>        <span class="token key atrule">constraints</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token string">"node.role==manager"</span> <span class="token comment"># 通过约束表达式，限制节点的容器</span>  <span class="token comment"># 服务配置</span>  <span class="token key atrule">vote</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> dockersamples/examplevotingapp_vote<span class="token punctuation">:</span>before    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"5000:80"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> frontend    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span> <span class="token comment"># 依赖关系，在启动该服务之前，保证以下服务在其之前启动</span>      <span class="token punctuation">-</span> redis    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>      <span class="token key atrule">update_config</span><span class="token punctuation">:</span>        <span class="token key atrule">parallelism</span><span class="token punctuation">:</span> <span class="token number">2</span>      <span class="token key atrule">restart_policy</span><span class="token punctuation">:</span>        <span class="token key atrule">condition</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure  <span class="token comment"># 服务配置</span>  <span class="token key atrule">result</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> dockersamples/examplevotingapp_result<span class="token punctuation">:</span>before    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"5001:80"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> backend    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span> <span class="token comment"># 依赖关系，在启动该服务之前，保证以下服务在其之前启动</span>      <span class="token punctuation">-</span> db    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>      <span class="token key atrule">update_config</span><span class="token punctuation">:</span>        <span class="token key atrule">parallelism</span><span class="token punctuation">:</span> <span class="token number">2</span>        <span class="token key atrule">delay</span><span class="token punctuation">:</span> 10s      <span class="token key atrule">restart_policy</span><span class="token punctuation">:</span>        <span class="token key atrule">condition</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure  <span class="token comment"># 服务配置</span>  <span class="token key atrule">worker</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> dockersamples/examplevotingapp_worker    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> frontend      <span class="token punctuation">-</span> backend    <span class="token key atrule">deploy</span><span class="token punctuation">:</span> <span class="token comment"># 部署</span>      <span class="token key atrule">mode</span><span class="token punctuation">:</span> replicated      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>APP=VOTING<span class="token punctuation">]</span>      <span class="token key atrule">restart_policy</span><span class="token punctuation">:</span>        <span class="token key atrule">condition</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure        <span class="token key atrule">delay</span><span class="token punctuation">:</span> 10s        <span class="token key atrule">max_attempts</span><span class="token punctuation">:</span> <span class="token number">3</span>        <span class="token key atrule">window</span><span class="token punctuation">:</span> 120s      <span class="token key atrule">placement</span><span class="token punctuation">:</span>        <span class="token key atrule">constraints</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token string">"node.role==manager"</span>  <span class="token comment"># 服务配置</span>  <span class="token key atrule">visualizer</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> dockersamples/visualizer<span class="token punctuation">:</span>stable    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"8080:8080"</span>    <span class="token key atrule">stop_grace_period</span><span class="token punctuation">:</span> 1m30s    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"/var/run/docker.sock:/var/run/docker.sock"</span>    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>      <span class="token key atrule">placement</span><span class="token punctuation">:</span>        <span class="token key atrule">constraints</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token string">"node.role==manager"</span><span class="token comment"># 网络配置</span><span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token key atrule">frontend</span><span class="token punctuation">:</span>  <span class="token key atrule">backend</span><span class="token punctuation">:</span><span class="token comment"># 挂载卷配置</span><span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token key atrule">db-data</span><span class="token punctuation">:</span>    <span class="token comment"># external: true # 指定此卷是已存在的，docker不尝试自动创建，如果不存在则引发错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>服务中的配置项，可以在官网上查看</p></blockquote><img src="/2022/01/05/devops/docker-compose/0002.png" class="" title="示例"><h3 id="测试开源项目"><a href="#测试开源项目" class="headerlink" title="测试开源项目"></a>测试开源项目</h3><h4 id="WordPress"><a href="#WordPress" class="headerlink" title="WordPress"></a>WordPress</h4><blockquote><p>官网连接：<a href="https://docs.docker.com/samples/wordpress/">https://docs.docker.com/samples/wordpress/</a></p></blockquote><h5 id="创建项目文件夹"><a href="#创建项目文件夹" class="headerlink" title="创建项目文件夹"></a>创建项目文件夹</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ cd /home/qing[root@qing centos]$ mkdir word_press[root@qing centos]$ cd word_press<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="编写docker-compose-yml"><a href="#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写docker-compose.yml</h5><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ vim docker<span class="token punctuation">-</span>compose.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># docker-compose.yml</span><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.9"</span>    <span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">db</span><span class="token punctuation">:</span> <span class="token comment"># 数据库服务</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span><span class="token number">5.7</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> db_data<span class="token punctuation">:</span>/var/lib/mysql    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always <span class="token comment"># 重启规则 总是重启</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span> <span class="token comment"># 环境配置 key-value 数据库的账号密码等配置</span>      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> somewordpress      <span class="token key atrule">MYSQL_DATABASE</span><span class="token punctuation">:</span> wordpress      <span class="token key atrule">MYSQL_USER</span><span class="token punctuation">:</span> wordpress      <span class="token key atrule">MYSQL_PASSWORD</span><span class="token punctuation">:</span> wordpress      <span class="token key atrule">wordpress</span><span class="token punctuation">:</span> <span class="token comment"># wordpress服务</span>    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span> <span class="token comment"># 依赖关系，基于db服务启动</span>      <span class="token punctuation">-</span> db    <span class="token key atrule">image</span><span class="token punctuation">:</span> wordpress<span class="token punctuation">:</span>latest <span class="token comment"># 镜像</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> wordpress_data<span class="token punctuation">:</span>/var/www/html    <span class="token key atrule">ports</span><span class="token punctuation">:</span> <span class="token comment"># 暴露端口 映射</span>      <span class="token punctuation">-</span> <span class="token string">"8000:80"</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always <span class="token comment"># 重启规则 总是重启</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span> <span class="token comment"># 环境配置 key-value 连接的数据库配置</span>      <span class="token key atrule">WORDPRESS_DB_HOST</span><span class="token punctuation">:</span> db      <span class="token key atrule">WORDPRESS_DB_USER</span><span class="token punctuation">:</span> wordpress      <span class="token key atrule">WORDPRESS_DB_PASSWORD</span><span class="token punctuation">:</span> wordpress      <span class="token key atrule">WORDPRESS_DB_NAME</span><span class="token punctuation">:</span> wordpress<span class="token key atrule">volumes</span><span class="token punctuation">:</span> <span class="token comment"># 挂载卷设置</span>  <span class="token key atrule">db_data</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token key atrule">wordpress_data</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="编写自定义的Dockerfile"><a href="#编写自定义的Dockerfile" class="headerlink" title="编写自定义的Dockerfile"></a>编写自定义的Dockerfile</h5><blockquote><p>根据需求可选</p></blockquote><h5 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ docker-compose up -d # 后台运行<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后便可以访问自己的地址来查看</p><h3 id="简单实战"><a href="#简单实战" class="headerlink" title="简单实战"></a>简单实战</h3><ol><li><p>编写项目微服务</p><blockquote><p><a href="https://github.com/RobertSunq/data/blob/master/qing/blog/hexo/docker_compose/docker_compose_demo.zip" title="下载链接">demo</a></p></blockquote></li><li><p>dockerfile构建镜像</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM java:8 # 基本环境COPY ./*.jar /app/app.jar # 从宿主机拷贝jar包CMD ["--server.port=12233"] # 设置端口号EXPOSE 12233 # 暴露端口号ENTRYPOINT ["java", "-Xmx500m", "-jar", "-Dspring.profiles.active=docker", "/app/app.jar"] # 启动jar包<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>docker-compose.yml编排项目</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.8'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">qingdemo</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span> .<span class="token comment">#      dockerfile: Dockerfile # 指定使用的dockerfile文件 默认为当前目录下Dockerfile</span><span class="token comment">#      image: qingdemo # 指定镜像 查找不到将使用dockerfile编译镜像</span>    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> redis_a      <span class="token punctuation">-</span> db    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"12233:12233"</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"redis"</span>  <span class="token key atrule">db</span><span class="token punctuation">:</span> <span class="token comment"># 数据库服务</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"mysql:5.7"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> db_data<span class="token punctuation">:</span>/var/lib/mysql    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"3306:3306"</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always <span class="token comment"># 重启规则 总是重启</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span> <span class="token comment"># 环境配置 key-value 数据库的账号密码等配置</span>      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> qing<span class="token important">&amp;123456</span>      <span class="token key atrule">MYSQL_DATABASE</span><span class="token punctuation">:</span> demo_dev      <span class="token key atrule">MYSQL_USER</span><span class="token punctuation">:</span> qing      <span class="token key atrule">MYSQL_PASSWORD</span><span class="token punctuation">:</span> qing<span class="token important">&amp;123456</span>      <span class="token key atrule">MYSQL_ROOT_HOST</span><span class="token punctuation">:</span> <span class="token string">'%'</span> <span class="token comment"># 所有ip均可链接当前数据库</span><span class="token comment"># 挂载卷配置</span><span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token key atrule">db-data</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>放入到服务器</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ pwd/home/qing/demo_app[root@qing centos]$ lsdemo.jar  docker-compose.yml  Dockerfile[root@qing centos]$ docker-compose up -d # 后台运行 以下为日志输出# Sending build context to Docker daemon  60.95MB# Step 1/5 : FROM java:8#  ---&gt; d23bdf5b1b1b# Step 2/5 : COPY ./*.jar /app/app.jar#  ---&gt; Using cache#  ---&gt; fb647c018662# Step 3/5 : CMD ["--server.port=12233"]#  ---&gt; Using cache#  ---&gt; 8599345e23f4# Step 4/5 : EXPOSE 12233#  ---&gt; Using cache#  ---&gt; 11fd92f27368# Step 5/5 : ENTRYPOINT ["java", "-Xmx500m", "-jar", "-Dspring.profiles.active=docker", "/app/app.jar"]#  ---&gt; Running in 3dd19ac03609#  ---&gt; e930ce4c5f6f# Successfully built e930ce4c5f6f# Successfully tagged demo_app_qingdemo:latest# Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them# [+] Running 4/4#  ⠿ Network demo_app_default       Created                                                                                                   0.2s#  ⠿ Container demo_app-db-1        Started                                                                                                   1.0s#  ⠿ Container demo_app-redis-1     Started                                                                                                   0.9s#  ⠿ Container demo_app-qingdemo-1  Started                                                                                                   1.9s[root@qing centos]$ docker-compose logs -f # 查看启动日志 如果启动失败可以根据启动日志排查错误[root@qing centos]$ docker-compose down # 停止服务[root@qing centos]$ docker images # 查看镜像# 如果需要重新部署打包[root@qing centos]$ docker-compose up --build # 重新给构建<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><p><strong>完</strong></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?from=search&amp;seid=8833819761241839370">狂神说Docker</a> ：<a href="https://www.bilibili.com/video/BV1og4y1q7M4?share_source=copy_web">https://www.bilibili.com/video/BV1og4y1q7M4?share_source=copy_web</a></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> command </tag>
            
            <tag> note </tag>
            
            <tag> docker-compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令备忘录</title>
      <link href="/2021/12/30/note/command-note/"/>
      <url>/2021/12/30/note/command-note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由书籍、博客、网络、同事传授等整理而来，部分会附带转载学习来源。</p><p>由于是逐渐补充型文章，所以排版、标题分类上可能比较乱以及随时变更，敬请见谅。</p></blockquote><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><hr><blockquote><p>该部分命令多数不针对发行版本区分，由于内核版本、linux版本不同而有所不同。</p><p>${}  —&gt; 表示变量替换</p></blockquote><h3 id="使用SSH建立远程连接"><a href="#使用SSH建立远程连接" class="headerlink" title="使用SSH建立远程连接"></a>使用SSH建立远程连接</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 最简连接方式[root@qing centos]$ ssh username@hostname # 然后输入密码username@hostname's password:# 指定端口连接, 不指定时默认端口为22[root@qing centos]$ ssh -p 2233 username@hostnameusername@hostname's password:# 如何查看与修改ssh配置# mac linux系统中 SSH的配置文件在/etc/ssh/sshd_config# win 待查[root@qing centos]$ cat /etc/ssh/sshd_config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="maven-surefire单元测试"><a href="#maven-surefire单元测试" class="headerlink" title="maven-surefire单元测试"></a>maven-surefire单元测试</h3><blockquote><p>部分命令对版本有所要求，请注意。</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 根据配置文件，运行范围内的所有单元测试[root@qing centos]$ mvn test# 指定某个包下面的所有用例# [root@qing centos]$ mvn test -Dtest=${包完整路径}.*# 最后的 .* 是通配符表示运行该包下所有用例[root@qing centos]$ mvn test -Dtest=cn.qing.demo.*# 指定某个测试用例类# [root@qing centos]$ mvn test -Dtest=${包完整路径}.${测试用例类名}[root@qing centos]$ mvn test -Dtest=cn.qing.demo.DemoTest# 指定运行多个测试用例类# [root@qing centos]$ mvn test -Dtest=${测试用例类名1},${测试用例类名2}[root@qing centos]$ mvn test -Dtest=cn.qing.demo.DemoTest1, cn.qing.demo.DemoTest2# 指定运行测试用例类中的一个方法# [root@qing centos]$ mvn test -Dtest=${类路径}#${方法名}[root@qing centos]$ mvn test -Dtest=cn.qing.demo.DemoTest#demoTest# 以上方法可使用 * 进行通配# mvn test -Dtest=cn.qing.demo.DemoTest#demo_*# 上面的命令意思为 运行DemoTest测试类中的以demo_为开头的方法。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="系统编码-x2F-语言"><a href="#系统编码-x2F-语言" class="headerlink" title="系统编码/语言"></a>系统编码/语言</h3><blockquote><p>windows的默认编码为GBK，Linux的默认编码为UTF-8</p><p>因为在windows下编辑的中文，在linux下会显示为乱码。</p></blockquote><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ localeLANG=zh_CN.UTF-8# 系统语言   zh_CN.UTF-8 ----&gt; 中文,编码为UTF-8LC_CTYPE="zh_CN.UTF-8"# 语言符号与分类LC_NUMERIC="zh_CN.UTF-8"# 数字LC_TIME="zh_CN.UTF-8"# 时间显示格式LC_COLLATE="zh_CN.UTF-8"# 比较和排序LC_MONETARY="zh_CN.UTF-8"# 货币的单位LC_MESSAGES="zh_CN.UTF-8"# 信息的提示,eg. 提示信息、错误信息、状态信息、标题等LC_PAPER="zh_CN.UTF-8"# 打印纸张设置LC_NAME="zh_CN.UTF-8"# 姓名书LC_ADDRESS="zh_CN.UTF-8"# 地址LC_TELEPHONE="zh_CN.UTF-8"# 电话号码LC_MEASUREMENT="zh_CN.UTF-8"  # 度量衡LC_IDENTIFICATION="zh_CN.UTF-8"# 对locale自身信息对描述LC_ALL=# 分类属性的优先级上为: LC_ALL &gt; LC_* &gt; LANG<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ vim /etc/locale.conf # centos7[root@qing centos]$ vim /etc/sysconfig/i18n # centos6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="重新加载配置文件"><a href="#重新加载配置文件" class="headerlink" title="重新加载配置文件"></a>重新加载配置文件</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ source /etc/locale.conf # centos7[root@qing centos]$ source /etc/sysconfig/i18n # centos7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><h4 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># [root@qing centos]$ cp [option] ${source_file_path} ${target_file_path}[root@qing centos]$ cp /tmp/qing/source.log /tmp/qing/source.log-a archive 复制所有的目录# -d 源文件为连接文件时，则复制连接文件属性而非文件本身# -f 强制复制，如果遇到重复或者其他疑问，不会进行询问而强制复制# -i 若目标文件已存在，在覆盖时先询问是否真的操作# -I 建立硬连接的连接文件，而非复制文件本身# -p 与文件的属性一起复制，而非使用默认属性# -r 递归复制，用于目录的复制操作# -s 复制成符号连接文件，“快捷方式”# -u 若目标文件必源文件旧，则更新目标文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="强制复制"><a href="#强制复制" class="headerlink" title="强制复制"></a>强制复制</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 复制时，如果遇到重复或者其他疑问，不会进行询问而强制复制[root@qing centos]$ cp -f /tmp/qing/source.log /tmp/qing/source.log# 上述命令如果还是会询问，则可能是cp命令属于 其他命令组合的别名# 使用alias 查看[root@qing centos]$ aliasalias cp='cp -i'# 此配置即为还会进行提示# -f的替换方案## 使用命令 \cp    反斜杠来强制复制[root@qing centos]$ \cp /tmp/qing/source.log /tmp/qing/source.log## 修改别名  ### todo 待查证[root@qing centos]$ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>loading…</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><hr><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><p>loading…</p><h3 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h3><h4 id="转至管理员模式"><a href="#转至管理员模式" class="headerlink" title="转至管理员模式"></a>转至管理员模式</h4><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 在powershell中输入，会打开一个新的管理员模式的窗口</span><span class="token function">PS</span> G:\&gt; <span class="token function">Start-Process</span> powershell <span class="token operator">-</span>Verb runAs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MacOs"><a href="#MacOs" class="headerlink" title="MacOs"></a>MacOs</h2><hr><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>loading…</p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><h4 id="not-module的小总结"><a href="#not-module的小总结" class="headerlink" title="not module的小总结"></a>not module的小总结</h4><ol><li><p>环境中存在多个python与其对应的pip，按照的时候指定错误安装到其他版本的lib里面去了。eg. 使用pip2按照依赖到python2，但是需要在python3中使用。</p> <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ /opt/local/qing/python/lib/python -m pip list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>依赖所在的site地址，没有被加载到python的path。</p></li><li><p>安装的依赖，没有被加载到对应python的modules中</p></li></ol>   <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 进入到python命令界面查看 $ /opt/local/qing/python/lib/python</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token builtin">help</span><span class="token punctuation">(</span><span class="token string">'modules'</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li>没有安装这个依赖</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 进入到python命令界面查看 $ /opt/local/qing/python/lib/python</span><span class="token comment"># 查看python的lib路径</span><span class="token comment">## 引入依赖</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> site<span class="token comment">## 查看用户site-packages路径</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> site<span class="token punctuation">.</span>getusersitepackages<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'/home/robert/.local/lib/python2.7/site-packages'</span><span class="token comment">## 查看全局site-packages路径</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> site<span class="token punctuation">.</span>getsitepackages<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'/usr/lib64/python2.7/site-packages'</span><span class="token punctuation">,</span> <span class="token string">'/usr/lib/python2.7/site-packages'</span><span class="token punctuation">,</span> <span class="token string">'/usr/lib/site-python'</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> command </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程基础版</title>
      <link href="/2021/12/25/devops/docker-notes/"/>
      <url>/2021/12/25/devops/docker-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>Docker概述</li><li>Docker安装</li><li>Docker命令<ul><li>镜像命令</li><li>容器命令</li><li>操作命令</li><li>….</li></ul></li><li>Docker镜像</li><li>容器数据卷</li><li>DockerFile</li><li>Docker网络原理</li><li>IDEA整合Docker</li></ul><blockquote><p>Docker Compose、Docker Swarm （简化版K8s）、CI/CD Jenkins进阶版</p></blockquote><h2 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h2><h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><p>开发、测试、预生产、生产环境搭建的成本和一致性问题。在进行集群拓展的时候，每个机器上都要进行环境的部署安装（Reids ES Hadoop……）等费时费力，而且还可能因为机器的不同而产生各种各样的不一致问题。</p><p>针对java开发来说，一般通过jar/war包来部署的，但是运行jar包所需要的其他环境依赖，比如：JDK、Tomcat、Mysql、Redis这些都需要在机器上事先的安装配置完成。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>可以通过发包的时候直接带上软件运行所需要的环境和对环境的配置进行打包 “jar+”（app + jdk + mysql + redis + es），这样可以保证 开发 → 打包 → 部署 → 上线 所具有的环境保持一致，同时也可以避免在对新机器进行部署的时候，还需要进行复杂的环境配置。</p><p>Docker 便是这么一个类似的过程：打包项目带上环境（镜像） → 发布（Docker仓库）→ 下载发布的镜像 → 直接运行（容器）。</p><h4 id="虚拟机技术"><a href="#虚拟机技术" class="headerlink" title="虚拟机技术"></a>虚拟机技术</h4><p>虚拟化技术。可以直接通过虚拟机镜像文件，直接虚拟出一个具有完整环境的虚拟电脑，在其上面在运行所需要的App。</p><p><strong>缺点：</strong></p><p>对物理服务器资源的消耗，在物理服务器创建一台虚拟机时，便需要虚拟出一套硬件并在上面运行完整的操作系统，每台虚拟机都占用许多的服务器资源。是在<strong>物理层面上的隔离</strong>，启动慢 占用内存大，分钟级启动。当需要启动多个虚拟机时需要花费很大的时间</p><p><strong>物理资源层面上的隔离</strong></p><img src="/2021/12/25/devops/docker-notes/0012.png" class="" title="虚拟机结构示意图"><h4 id="Docker容器化技术"><a href="#Docker容器化技术" class="headerlink" title="Docker容器化技术"></a>Docker容器化技术</h4><p>也是一种虚拟化技术。镜像：包含所需要的最基础环境（最核心的Linux环境4M + 其他环境），没有其他额外的文件，只集成需要的便可以做到很小巧，启动运行镜像也十分快速，秒级别启动。</p><p><strong>优点：</strong></p><ul><li><p>传统虚拟机，虚拟出硬件，运行一个完整的操作系统，然后再这个系统上安装和运行软件，Docker并不是选择去模拟一个完整的操作系统</p></li><li><p>容器内的应用直接运行在宿主机的内核，容器时没有自己的内核的，并不去虚拟硬件所以十分的轻便</p></li><li><p>每个容器是相互隔离，每个容器都有一套自己的文件系统，互相不影响</p></li><li><p>更快速的交付和部署</p><ul><li>打包镜像发布测试 一键运行</li></ul></li><li><p>更便捷的升级和扩缩容</p><ul><li>在不同的机器上直接运行相同的镜像来扩容</li></ul></li><li><p>更简单的系统运维</p><ul><li>开发测试生产环境高度一致</li></ul></li><li><p>更高效的计算机资源利用</p></li></ul><p><strong>缺点：</strong></p><p>由于是<strong>操作系统进程层面上的隔离</strong>不是绝对的物理隔离，所以在安全性上时低于虚拟机的。</p><p><strong>操作系统进程层面上的隔离</strong></p><img src="/2021/12/25/devops/docker-notes/0013.png" class="" title="docker多容器结构"><h4 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h4><p>C/S模式：docker-client，docker-service</p><img src="/2021/12/25/devops/docker-notes/0000.png" class="" title="基本组成"><p>Docker daemon（守护进程）：Docker Client通过命令行与Docker Damon通信，完成Docker相关操作</p><p>Images（镜像）：类似于软件安装包</p><p>Containers（容器）：软件的运行</p><p><strong>镜像（image）：</strong></p><p>在docker中，镜像就类似于一个模板，可以通过这个模板来创建容器服务，同时也可以通过这个镜像去创建多个容器（最终服务运行或者项目运行就是在容器中）。</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TDA<span class="token text string">[tomcat镜像]</span> <span class="token arrow operator">--&gt;</span> B<span class="token text string">[run]</span>B <span class="token arrow operator">--&gt;</span> C<span class="token text string">[tomcat 1容器&lt;提供服务器&gt;]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>容器（container）：</strong></p><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建。</p><p>启动、停止、删除等基本命令！</p><p><strong>仓库（repository）：</strong></p><p>即存放镜像的地方，仓库分为私用仓库与公有仓库。但Docker Hub默认为国外服务器，所有可以通过配置为阿里云下镜像仓库来加速下载公用镜像。</p><h3 id="底层原理概述"><a href="#底层原理概述" class="headerlink" title="底层原理概述"></a>底层原理概述</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><ul><li>镜像<ul><li>将所有需要的内容放到不同的镜像（集装箱）中，需要哪些环境就直接拿哪个镜像（集装箱）就可以</li></ul></li><li>标准化<ul><li>镜像管理标准化，所有的镜像都放置于仓库中统一管理，当需要某些环境需要哪些镜像就使用docker去仓库中获取。</li><li>命令标准化，Docker提供了一系列的命令，来帮助我们对镜像进行一系列的操作</li></ul></li><li>隔离性<ul><li>运行镜像中的内容（容器）时，会在Linux的内核中单独开辟一片空间，这片空间不会影响到其他程序</li></ul></li></ul><h4 id="基本工作原理概述"><a href="#基本工作原理概述" class="headerlink" title="基本工作原理概述"></a>基本工作原理概述</h4><ol><li><p>Docker 是一个Client - Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！</p></li><li><p>DockerServer接收到Docker-Client的指令，就会执行这个命令！</p></li><li><p>容器内部的端口号是私有独立的，如果外部的想要访问，就需要通过linux服务器的端口号进行端口映射。</p></li></ol><img src="/2021/12/25/devops/docker-notes/0002.png" class="" title="工作原理"><p>Docker 为什么比VM快</p><ol><li><p>docker更少的抽象层</p></li><li><p>docker利用的是宿主机的内核，vm需要的是Guest OS</p></li></ol><img src="/2021/12/25/devops/docker-notes/0003.png" class="" title="对比图1"><p>所以新建一个容器的时候，docker 不需要像虚拟机一样重新加载操作系统内核，避免引导。虚拟机时加载Guest OS，分钟级别的，而docker时利用宿主机的操作系统，省略了这个复杂的过程，秒级。</p><img src="/2021/12/25/devops/docker-notes/0004.png" class="" title="对比图2"><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><h4 id="环境查看"><a href="#环境查看" class="headerlink" title="环境查看"></a>环境查看</h4><p>已在centos7上进行安装为例</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看系统内核版本</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">uname</span> -r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看系统版本</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/os-release<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h4><p><a href="https://docs.docker.com/engine/install/" title="install">官方手册</a> <a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 1、卸载历史版本的docker</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ yum remove docker <span class="token punctuation">\</span>                  docker-client <span class="token punctuation">\</span>                  docker-client-latest <span class="token punctuation">\</span>                  docker-common <span class="token punctuation">\</span>                  docker-latest <span class="token punctuation">\</span>                  docker-latest-logrotate <span class="token punctuation">\</span>                  docker-logrotate <span class="token punctuation">\</span>                  docker-engine                  <span class="token comment"># 2、安装基础安装包</span><span class="token punctuation">[</span>root@centos7<span class="token punctuation">]</span>$ yum <span class="token function">install</span> -y yum-utils <span class="token comment"># 3、设置镜像仓库</span><span class="token comment"># yum-config-manager \</span><span class="token comment">#    --add-repo \</span><span class="token comment">#     https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外仓库</span>    <span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ yum-config-manager <span class="token punctuation">\</span>    --add-repo <span class="token punctuation">\</span>    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo <span class="token comment"># 阿里云的镜像地址</span>    <span class="token comment"># 4、更新yum</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ yum makecache fast<span class="token comment"># 5、安装 ce--社区，ee--企业  核心、客户端、容器</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> docker-ce docker-ce-cli containerd.io<span class="token comment"># 指定版本 yum install docker-ce--&lt;VERSION_STRING&gt; docker-ce-cli--&lt;VERSION_STRING&gt; containerd.io</span><span class="token comment"># 查看其他版本</span><span class="token comment"># [root@centos7 ~]$ yum list docker-ce --showduplicates | sort -r</span><span class="token comment"># 6、启动</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ systemctl start docker<span class="token comment"># 7、验证docker是否启动成功</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ docker version<span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ docker run hello-world<span class="token comment"># 8、查看下载的镜像</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    d1165f221234   <span class="token number">4</span> months ago   <span class="token number">13</span>.3kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/12/25/devops/docker-notes/0001.png" class="" title="输出"><h4 id="快速卸载"><a href="#快速卸载" class="headerlink" title="快速卸载"></a>快速卸载</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 1、卸载依赖 </span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ yum remove docker-ce docker-ce-cli containerd.io<span class="token comment"># 2、删除资源</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> -rf /var/lib/docker<span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> -rf /var/lib/containerd<span class="token comment"># /var/lib/docker docker的默认工作路径</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 以阿里云为列</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p /etc/docker <span class="token comment"># 创建文件</span><span class="token comment"># 编写配置文件 下面的地址需要换成阿里云中自己实例中创建的</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'{"registry-mirrors":["https://qiyb9988.mirror.aliyuncs.com"]}EOF</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ systemctl daemon-reload <span class="token comment"># 编译配置文件</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ systemctl restart docker <span class="token comment"># 重启docker</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><h4 id="基本帮助"><a href="#基本帮助" class="headerlink" title="基本帮助"></a>基本帮助</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token comment">## 帮助文档 https://docs.docker.com/reference/</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ docker version <span class="token comment">#  显示docker版本信息</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ docker info <span class="token comment"># 显示docker的系统信息，包括镜像和容器的数量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h4><p><a href="https://docs.docker.com/reference/" title="reference">官方命令说明</a>  <a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p><p><a href="https://hub.docker.com/" title="dockerHub">官方仓库</a>    <a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p><strong>查看与搜索镜像</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker images REPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    d1165f221234   <span class="token number">4</span> months ago   <span class="token number">13</span>.3kB<span class="token comment">#################################</span><span class="token comment"># REPOSITORY镜像的仓库源</span><span class="token comment"># TAG镜像的标签</span><span class="token comment"># IMAGE ID镜像的ID</span><span class="token comment"># CREATED镜像的创建时间</span><span class="token comment"># SIZE镜像的大小</span><span class="token comment"># 可选项</span><span class="token comment">#--all , -a查看所有镜像</span><span class="token comment">#--quiet , -q只显示镜像ID</span><span class="token comment">#################################</span><span class="token comment">########################################################################</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker search mysql  <span class="token comment"># 搜索镜像</span>NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDmysql                             MySQL is a widely used, open-source relation…   <span class="token number">11099</span>     <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       mariadb                           MariaDB Server is a high performing <span class="token function">open</span> sou…   <span class="token number">4209</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       <span class="token comment"># 可选项，通过搜索来过滤</span>--filter<span class="token operator">=</span>STARS<span class="token operator">=</span><span class="token number">3000</span> <span class="token comment"># 搜索出来的镜像是STARS大于3000的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>下载镜像</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker pull mysql  <span class="token comment"># 下载镜像</span>Using default tag: latest  <span class="token comment"># 不声明tag，默认时 latest</span>latest: Pulling from library/mysqlb4d181a07f80: Download complete  <span class="token comment"># 分层下载，docker image的核心 联合文件系统？</span>a462b60610f5: Download complete 578fafb77ab8: Download complete <span class="token number">524046006037</span>: Download complete d0cbe54c8855: Download complete aa18e05cc46d: Download complete 32ca814c833f: Download complete 9ecc8abdb7f5: Download complete ad042b682e0f: Download complete 71d327c6bb78: Download complete 165d1d10a3fa: Download complete 2f40c47d0626: Download complete Digest: sha256:52b8406e4c32b8cf0557f1b74517e14c5393aff5cf0384eff62d9e81f4985d4b <span class="token comment">#签名</span>Status: Downloaded newer image <span class="token keyword">for</span> mysql:latestdocker.io/library/mysql:latest<span class="token comment"># 真实地址</span><span class="token comment">######## 等价于</span><span class="token comment"># docker pull musql</span><span class="token comment"># docker pull docker.io/library/mysql:latest</span><span class="token comment">################################</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker pull mysql:5.7  <span class="token comment"># 指定版本</span><span class="token number">5.7</span>: Pulling from library/mysqlb4d181a07f80: Already exists <span class="token comment"># 共用分层文件，节省空间和下载速度，不用重复下载</span>a462b60610f5: Already exists 578fafb77ab8: Already exists <span class="token number">524046006037</span>: Already exists d0cbe54c8855: Already exists aa18e05cc46d: Already exists 32ca814c833f: Already exists 52645b4af634: Pull complete bca6a5b14385: Pull complete 309f36297c75: Pull complete 7d75cacde0f8: Pull complete Digest: sha256:1a2f9cd257e75cc80e9118b303d1648366bc2049101449bf2c8d82b022ea86b7Status: Downloaded newer image <span class="token keyword">for</span> mysql:5.7docker.io/library/mysql:5.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除镜像</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 删除镜像 rmi -&gt; remove image</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker rmi -f <span class="token punctuation">[</span>image id<span class="token punctuation">]</span>  <span class="token comment"># 删除指定镜像</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker rmi -f <span class="token variable"><span class="token variable">$(</span>docker images -aq<span class="token variable">)</span></span>  <span class="token comment"># 删除所有，${} 传递参数，查出所有的image id</span><span class="token comment"># [root@qing centos]$ docker rmi -f (mysql5.7) 会发现只删除了mysql5.7不同的文件，和mysql8公用的部分并没有删除 </span><span class="token comment"># 待确定？注意这里删除的是镜像，运行过的镜像创建的容器并没有被删除 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><blockquote><p>通过镜像来创建容器</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 以下载并启动 centos镜像为列子</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker pull centos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>新建容器并启动</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker run <span class="token punctuation">[</span>可选参数<span class="token punctuation">]</span> image<span class="token comment">###################################################</span><span class="token comment"># --name="name"容器名字 tomcat01 tomcat02，用来区分容器</span><span class="token comment"># -d后台方式运行 ja nohup</span><span class="token comment"># -it使用交互方式运行，进入容器查看内容</span><span class="token comment"># -t交互式操作</span><span class="token comment"># -i终端</span><span class="token comment"># -p指定容器的端口 -p 8080:8080</span><span class="token comment"># -p 主机端口：容器端口  (常用)</span><span class="token comment"># -p ip:主机端口:容器端口</span><span class="token comment"># -p 容器端口</span><span class="token comment"># 容器端口</span><span class="token comment"># -P随机指定端口</span><span class="token comment">###################################################</span><span class="token comment"># 启动并进入容器</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker run -it centos /bin/bash<span class="token comment"># 放在镜像名后的是命令，打开一个交互式 Shell，因此用的是 /bin/bash。</span><span class="token punctuation">[</span>root@75dcc58b2b3d /<span class="token punctuation">]</span>$ <span class="token function">ls</span><span class="token comment"># 此时主机已经指向启动的容器，此时centos为基础版本。</span>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<span class="token punctuation">[</span>root@75dcc58b2b3d /<span class="token punctuation">]</span>$ <span class="token builtin class-name">exit</span><span class="token comment"># 从容器中退出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/12/25/devops/docker-notes/0014.png" class="" title="运行流程"><p><strong>查看所有运行的容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token comment"># 查看运行中的容器</span><span class="token comment">###################################################</span><span class="token comment">#列出当前正在运行的容器</span><span class="token comment"># -a列出当前正在运行的容器+历史运行过的容器</span><span class="token comment"># -n=?显示最近创建的容器个数</span><span class="token comment"># -q只显示容器的编号</span><span class="token comment">###################################################</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span> -a<span class="token comment"># 查看所有运行过的容器</span>CONTAINER ID   IMAGE         COMMAND       CREATED         STATUS                       PORTS     NAMES3c8ef01a7eb6   centos        <span class="token string">"/bin/bash"</span>   <span class="token number">6</span> minutes ago   Exited <span class="token punctuation">(</span><span class="token number">130</span><span class="token punctuation">)</span> <span class="token number">5</span> minutes ago             nice_austinceafc51e6972   hello-world   <span class="token string">"/hello"</span>      <span class="token number">2</span> days ago      Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">2</span> days ago                  focused_burnell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>退出容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># exit 停止当前容器并退出</span><span class="token comment"># Ctrl + P + Q 仅退出当前容器，不停止运行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>删除容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">rm</span> 容器id<span class="token comment"># 删除指定容器，不能删除正在运行的容器 rm -f 强制删除</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -aq<span class="token variable">)</span></span><span class="token comment"># 删除所有容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span> -a -q<span class="token operator">|</span><span class="token function">xargs</span> docker <span class="token function">rm</span><span class="token comment"># 删除所有的容器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>启动和停止容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker start 容器id<span class="token comment"># 启动容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker restart 容器id<span class="token comment"># 重启容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stop 容器id<span class="token comment"># 停止当前正在运行的容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">kill</span> 容器id<span class="token comment"># 强制停止容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker start 容器id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><strong>后台启动</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 命令 docker run -d 镜像名！</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d centos<span class="token comment"># 后台启动</span><span class="token comment"># 输入docker ps ， 发现centos停止了</span><span class="token comment"># 常见的坑：</span><span class="token comment"># docker容器使用后台运行，就必须要有一个前台的进程，docker发现没有应用，就会自动停止</span><span class="token comment"># nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就没有程序了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看日志</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker logs --help<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker logs-tf --tail <span class="token number">10</span> 容器id<span class="token comment"># -f 保留打印窗口，-t 添加时间戳 --tail 10 最后10行</span><span class="token comment"># 自定义shell脚本</span><span class="token comment"># "while true;do echo qing;sleep 1; done"</span><span class="token comment"># [root@qing /]$ docker run -d centos /bin/sh -c "while true;do echo qing;sleep 1;done"</span><span class="token comment"># -c 执行命令</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">top</span> 容器id<span class="token comment"># 查看容器内进程信息</span><span class="token environment constant">UID</span>                 PID                 <span class="token environment constant">PPID</span>                C                   STIME               TTY                 TIME                CMDroot                <span class="token number">32718</span>               <span class="token number">32697</span>               <span class="token number">33</span>                  <span class="token number">23</span>:07               ?                   00:00:23            /bin/sh -c <span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token builtin class-name">echo</span> qing<span class="token punctuation">;</span>sheep <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看容器元数据</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect 容器id<span class="token comment"># 查看容器信息</span><span class="token comment"># "Id" 比通过ps查询到的要长，ps中只是对其进行了部分截取</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><details>  <summary>      <mark>          <font color="green">详细输出</font>      </mark>    </summary>  <p>[root@qing /]$ docker inspect ${container id}</p>  <pre>  <code>  [    {        "Id": "2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4",        "Created": "2021-12-28T15:07:57.17357075Z",        "Path": "/bin/sh",        "Args": [            "-c",            "while true;do echo qing;sheep 1;done"        ],        "State": {            "Status": "running",            "Running": true,            "Paused": false,            "Restarting": false,            "OOMKilled": false,            "Dead": false,            "Pid": 32718,            "ExitCode": 0,            "Error": "",            "StartedAt": "2021-12-28T15:07:57.691697573Z",            "FinishedAt": "0001-01-01T00:00:00Z"        },        "Image": "sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6",        "ResolvConfPath": "/var/lib/docker/containers/2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4/resolv.conf",        "HostnamePath": "/var/lib/docker/containers/2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4/hostname",        "HostsPath": "/var/lib/docker/containers/2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4/hosts",        "LogPath": "/var/lib/docker/containers/2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4/2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4-json.log",        "Name": "/jovial_davinci",        "RestartCount": 0,        "Driver": "overlay2",        "Platform": "linux",        "MountLabel": "",        "ProcessLabel": "",        "AppArmorProfile": "",        "ExecIDs": null,        "HostConfig": {            "Binds": null,            "ContainerIDFile": "",            "LogConfig": {                "Type": "json-file",                "Config": {}            },            "NetworkMode": "default",            "PortBindings": {},            "RestartPolicy": {                "Name": "no",                "MaximumRetryCount": 0            },            "AutoRemove": false,            "VolumeDriver": "",            "VolumesFrom": null,            "CapAdd": null,            "CapDrop": null,            "CgroupnsMode": "host",            "Dns": [],            "DnsOptions": [],            "DnsSearch": [],            "ExtraHosts": null,            "GroupAdd": null,            "IpcMode": "private",            "Cgroup": "",            "Links": null,            "OomScoreAdj": 0,            "PidMode": "",            "Privileged": false,            "PublishAllPorts": false,            "ReadonlyRootfs": false,            "SecurityOpt": null,            "UTSMode": "",            "UsernsMode": "",            "ShmSize": 67108864,            "Runtime": "runc",            "ConsoleSize": [                0,                0            ],            "Isolation": "",            "CpuShares": 0,            "Memory": 0,            "NanoCpus": 0,            "CgroupParent": "",            "BlkioWeight": 0,            "BlkioWeightDevice": [],            "BlkioDeviceReadBps": null,            "BlkioDeviceWriteBps": null,            "BlkioDeviceReadIOps": null,            "BlkioDeviceWriteIOps": null,            "CpuPeriod": 0,            "CpuQuota": 0,            "CpuRealtimePeriod": 0,            "CpuRealtimeRuntime": 0,            "CpusetCpus": "",            "CpusetMems": "",            "Devices": [],            "DeviceCgroupRules": null,            "DeviceRequests": null,            "KernelMemory": 0,            "KernelMemoryTCP": 0,            "MemoryReservation": 0,            "MemorySwap": 0,            "MemorySwappiness": null,            "OomKillDisable": false,            "PidsLimit": null,            "Ulimits": null,            "CpuCount": 0,            "CpuPercent": 0,            "IOMaximumIOps": 0,            "IOMaximumBandwidth": 0,            "MaskedPaths": [                "/proc/asound",                "/proc/acpi",                "/proc/kcore",                "/proc/keys",                "/proc/latency_stats",                "/proc/timer_list",                "/proc/timer_stats",                "/proc/sched_debug",                "/proc/scsi",                "/sys/firmware"            ],            "ReadonlyPaths": [                "/proc/bus",                "/proc/fs",                "/proc/irq",                "/proc/sys",                "/proc/sysrq-trigger"            ]        },        "GraphDriver": {            "Data": {                "LowerDir": "/var/lib/docker/overlay2/5070e57b3b1ab1533ba4b1a8cb7de79e3655f6d78ba43c4640c2d25cedb00fa5-init/diff:/var/lib/docker/overlay2/0e6d8ab67489cffea7560a7fdc382658d599dc415839d4bf5f4d6c2b71dadf79/diff",                "MergedDir": "/var/lib/docker/overlay2/5070e57b3b1ab1533ba4b1a8cb7de79e3655f6d78ba43c4640c2d25cedb00fa5/merged",                "UpperDir": "/var/lib/docker/overlay2/5070e57b3b1ab1533ba4b1a8cb7de79e3655f6d78ba43c4640c2d25cedb00fa5/diff",                "WorkDir": "/var/lib/docker/overlay2/5070e57b3b1ab1533ba4b1a8cb7de79e3655f6d78ba43c4640c2d25cedb00fa5/work"            },            "Name": "overlay2"        },        "Mounts": [],        "Config": {            "Hostname": "2d2c8f54b427",            "Domainname": "",            "User": "",            "AttachStdin": false,            "AttachStdout": false,            "AttachStderr": false,            "Tty": false,            "OpenStdin": false,            "StdinOnce": false,            "Env": [                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"            ],            "Cmd": [                "/bin/sh",                "-c",                "while true;do echo qing;sheep 1;done"            ],            "Image": "centos",            "Volumes": null,            "WorkingDir": "",            "Entrypoint": null,            "OnBuild": null,            "Labels": {                "org.label-schema.build-date": "20210915",                "org.label-schema.license": "GPLv2",                "org.label-schema.name": "CentOS Base Image",                "org.label-schema.schema-version": "1.0",                "org.label-schema.vendor": "CentOS"            }        },        "NetworkSettings": {            "Bridge": "",            "SandboxID": "6ef9320864e6daa4195b284e3c60fb56edb95be77010eda7cff755ab315cffeb",            "HairpinMode": false,            "LinkLocalIPv6Address": "",            "LinkLocalIPv6PrefixLen": 0,            "Ports": {},            "SandboxKey": "/var/run/docker/netns/6ef9320864e6",            "SecondaryIPAddresses": null,            "SecondaryIPv6Addresses": null,            "EndpointID": "3d08880669d8a5f2ad913bef248471a0377eeeb7793f83450cd514d0b43e7a39",            "Gateway": "172.18.0.1",            "GlobalIPv6Address": "",            "GlobalIPv6PrefixLen": 0,            "IPAddress": "172.18.0.2",            "IPPrefixLen": 16,            "IPv6Gateway": "",            "MacAddress": "02:42:ac:12:00:02",            "Networks": {                "bridge": {                    "IPAMConfig": null,                    "Links": null,                    "Aliases": null,                    "NetworkID": "73abca2ea3673a8f7f4919d8141708a47bc0851025083aefa25a3bec6286704d",                    "EndpointID": "3d08880669d8a5f2ad913bef248471a0377eeeb7793f83450cd514d0b43e7a39",                    "Gateway": "172.18.0.1",                    "IPAddress": "172.18.0.2",                    "IPPrefixLen": 16,                    "IPv6Gateway": "",                    "GlobalIPv6Address": "",                    "GlobalIPv6PrefixLen": 0,                    "MacAddress": "02:42:ac:12:00:02",                    "DriverOpts": null                }            }        }    }]  </code>  </pre></details><p><strong>进入当前正在运行的容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 通常容器都是使用后台方式运行的，需要进入容器修改一些配置</span><span class="token comment"># -it  通过交互模式运行</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it 容器id /bin/bash  <span class="token comment"># 进入后台运行的容器，/bin/bash 位置开启一个新的终端，可以进行一些操作(常用)</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker attach 容器id<span class="token comment">#  进入正在执行的容器进入正在运行的中断，不会启动新的进程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>从容器内拷贝文件到宿主机</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">cp</span> 容器id:容器内路径目的主机路径<span class="token comment"># 容器内文件拷贝到主机</span><span class="token comment"># test 进入之前启动的centos容器内</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker attach <span class="token variable">${id}</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ls</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> /home<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">touch</span> test.java<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token builtin class-name">exit</span> <span class="token comment"># 注意 此处是退出了容器，容器停止运行，但是在没有被清理时容器的数据依旧存在</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span> -a<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">cp</span> <span class="token variable">${id}</span>:/home/test.java /home <span class="token comment"># 类似与socp命令</span><span class="token comment">## 拷贝时一个手动的过程，后期使用中可以通过 -v 卷的方式，实现自动同步，将容器中的目录与宿主机的进行同步</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其他</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker --help<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2021/12/25/devops/docker-notes/0005.png" class="" title="命令简图"><h4 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker attach      <span class="token comment"># Attach local standard input, output, and error streams to a running container</span><span class="token comment"># 当前shell下attach连接指定运行镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build<span class="token comment"># Build an image from a Dockerfile</span><span class="token comment"># 通过Dockerfile 定制镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker commit<span class="token comment"># Create a new image from a container's changes</span><span class="token comment"># 提交当前容器为新的镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">cp</span><span class="token comment"># Copy files/folders between a container and the local filesystem</span><span class="token comment"># 从容器中拷贝指定文件或目录到宿主机中</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker create<span class="token comment"># Create a new container</span><span class="token comment"># 创建一个新的容器，同run，但不启动容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">diff</span><span class="token comment"># Inspect changes to files or directories on a container's filesystem</span><span class="token comment"># 查看docker容器的变化</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker events<span class="token comment"># Get real time events from the server</span><span class="token comment"># 从docker服务获取容器实时事件</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span><span class="token comment"># Run a command in a running container</span><span class="token comment"># 在已存在的容器上运行命令</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">export</span><span class="token comment"># Export a container's filesystem as a tar archive</span><span class="token comment"># 到处容器的内容流作为一个tar归档文件，对应import</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">history</span><span class="token comment"># Show the history of an image</span><span class="token comment"># 查看一个镜像的历史</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker images<span class="token comment"># List images</span><span class="token comment"># 列出当前系统中所有的镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">import</span><span class="token comment"># Import the contents from a tarball to create a filesystem image</span><span class="token comment"># 从tar包中的内容创建一个新的文件系统，对应export</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker info<span class="token comment"># Display system-wide information</span><span class="token comment"># 显示系统相关信息</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect<span class="token comment"># Return low-level information on Docker objects</span><span class="token comment"># 查看容器详细信息</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">kill</span><span class="token comment"># Kill one or more running containers</span><span class="token comment"># kill指定docker容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker load<span class="token comment"># Load an image from a tar archive or STDIN</span><span class="token comment"># 从一个tar包中加载一个镜像，对应save</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker login<span class="token comment"># Log in to a Docker registry</span><span class="token comment"># 注册或者登录一个docker源服务器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">logout</span><span class="token comment"># Log out from a Docker registry</span><span class="token comment"># 从当前docker registry退出</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker logs<span class="token comment"># Fetch the logs of a container</span><span class="token comment"># 输出当前容器日志信息</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker pause<span class="token comment"># Pause all processes within one or more containers</span><span class="token comment"># 暂停容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker port<span class="token comment"># List port mappings or a specific mapping for the container</span><span class="token comment"># 查看映射端口对应容器内幕源端口</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token comment"># List containers</span><span class="token comment"># 列出容器列表</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker pull<span class="token comment"># Pull an image or a repository from a registry</span><span class="token comment"># 从docker镜像源服务器拉取指定镜像或者库镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker push<span class="token comment"># Push an image or a repository to a registry</span><span class="token comment"># 推送指定镜像或者库镜像到dicker源服务器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">rename</span><span class="token comment"># Rename a container</span><span class="token comment"># 对容器重命名</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker restart<span class="token comment"># Restart one or more containers</span><span class="token comment"># 重启运行的容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">rm</span><span class="token comment"># Remove one or more containers</span><span class="token comment"># 移除一个或者多个容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker rmi<span class="token comment"># Remove one or more images</span><span class="token comment"># 移除一个或者多个镜像，五容器使用该镜像才可删除，否则需要删除相关容器才可以或者强制删除</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run<span class="token comment"># Run a command in a new container</span><span class="token comment"># 创建一个新的容器并运行一个命令</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker save<span class="token comment"># Save one or more images to a tar archive (streamed to STDOUT by default)</span><span class="token comment"># 保存一个镜像为一个tar包，对应load</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker search<span class="token comment"># Search the Docker Hub for images</span><span class="token comment"># 在docker hub中搜索镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker start<span class="token comment"># Start one or more stopped containers</span><span class="token comment"># 启动容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stats<span class="token comment"># Display a live stream of container(s) resource usage statistics</span><span class="token comment"># 显示容器资源的状态</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stop<span class="token comment"># Stop one or more running containers</span><span class="token comment"># 停止容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker tag<span class="token comment"># Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><span class="token comment"># 给源镜像打一个标签</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">top</span><span class="token comment"># Display the running processes of a container</span><span class="token comment"># 查看容器中运行的进程信息</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker unpause<span class="token comment"># Unpause all processes within one or more containers</span><span class="token comment"># 取消暂停容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker update<span class="token comment"># Update configuration of one or more containers</span><span class="token comment"># 更新一个或者多个容器的配置</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker version<span class="token comment"># Show the Docker version information</span><span class="token comment"># 查看docker版本号</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">wait</span><span class="token comment"># Block until one or more containers stop, then print their exit codes</span><span class="token comment"># 截取容器停止时的退出状态值。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><h4 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker search nginx<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker pull nginx<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d --name nginx00 -p <span class="token number">2233</span>:80 nginx<span class="token comment"># 后台启动nginx 并设置名称 nginx00 映射端口 宿主机2233 -&gt; 容器80</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:2233<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it nginx00 /bin/bashroot@fca2fac49368:/$ <span class="token function">whereis</span> nginx <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>存在问题</strong></p><p>每次改动nignx配置文件，都需要进入容器内部，十分的麻烦</p><p><strong>解决方案</strong></p><p>在容器外部宿主机上提供一个映射路径，达到在容器外修改文件，容器内不就可以修改的目的，-v 数据卷</p></blockquote><h4 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a><strong>tomcat</strong></h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it --rm tomcat:9.0 <span class="token comment"># 一般用来测试，用完就删除，及--rm</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker search tomcat<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker pull tomcat:9.0<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d --name tomcat9.0_00 -p <span class="token number">2233</span>:8080 tomcat:9.0<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:2233root@714059eea83c$ docker <span class="token builtin class-name">exec</span> -it tomcat9.0_00 /bin/bash<span class="token function">ls</span> -al<span class="token builtin class-name">cd</span> /usr/local/tomcat<span class="token function">cp</span> -r webapps.dist/* webapps<span class="token comment"># 实际上，这里启动的时阉割版镜像，及默认最小的镜像，所以不必要的都被剔除掉了</span><span class="token comment"># 故：linux命令少，没有webapps。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>存在问题</p><p>每次部署项目，需要进入到容器进行拷贝文件十分麻烦。如果所有的文件都放到容器内部，eg. mysql 如果删除了镜像或者容器，导致所有数据丢失？</p><p>解决方案</p><p>同上</p></blockquote><h4 id="es-kibana"><a href="#es-kibana" class="headerlink" title="es+kibana"></a><strong>es+kibana</strong></h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># elasticsearch 暴露的端口很多、十分的耗内存、数据一般需要放置到安全目录 挂载</span><span class="token comment"># 官方启动命令</span><span class="token comment"># $ docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:tag</span><span class="token comment"># --net somenetwork ？ docker的网络配置</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d --name elasticsearch -p <span class="token number">9200</span>:9200 -p <span class="token number">9300</span>:9300 -e <span class="token string">"discovery.type=single-node"</span> elasticsearch:7.6.2<span class="token comment"># 启动后十分的卡 docker stats 查看cpu状态</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stats  <span class="token variable">${id}</span>?<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stop elasticsearch<span class="token comment"># 添加限制的启动</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d --name elasticsearch -p <span class="token number">9200</span>:9200 -p <span class="token number">9300</span>:9300 -e <span class="token string">"discovery.type=single-node"</span> -e <span class="token assign-left variable">ES_JAVA_OPTS</span><span class="token operator">=</span><span class="token string">"-Xms64m -Xmax512m"</span> elasticsearch:7.6.2<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:9200<span class="token comment">####################################</span><span class="token comment"># kibana 连接  es</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><ul><li>portainer</li><li>rancher（CI/CD）</li></ul><h4 id="portainer"><a href="#portainer" class="headerlink" title="portainer"></a>portainer</h4><p>Docker图像化管理工具，提供了一个后台面板</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">root@qing /<span class="token punctuation">]</span>$ docker run -d -p <span class="token number">8088</span>:9000 <span class="token punctuation">\</span>--restart<span class="token operator">=</span>always -v /var/run/docker.sock:/var/run/docker.sock --privileged<span class="token operator">=</span>true portainer/portainer<span class="token comment"># -v 挂载  宿主机:容器</span><span class="token comment"># --privileged 授权</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h3 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h3><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时的库、环境变量和配置文件</p><p>所有的应用，直接打包docker镜像，就可以直接跑起来</p><ul><li>从远程仓库pull</li><li>拷贝文件</li><li>自己制作一个镜像 dockerFile</li></ul><h3 id="Docker镜像加速原理"><a href="#Docker镜像加速原理" class="headerlink" title="Docker镜像加速原理"></a>Docker镜像加速原理</h3><blockquote><p>UnionFS（联合文件系统）</p></blockquote><p>UnionFS（联合文件系统）：Union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual file system）。Union文件系统时Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><blockquote><p>Docker镜像加载原理</p></blockquote><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层就是bootfs。这一层与我们典型的Linux/Unix系统一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已有bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs（root file system），在bootfs之上，包含典型Linux系统中的/dev 、/proc、/bin、/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版本，eg. Ubuntu Centos…</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect 镜像id<span class="token comment"># 查看镜像信息</span><span class="token comment"># rootFS</span><span class="token comment">#  "RootFS": {</span><span class="token comment">#             "Type": "layers",</span><span class="token comment">#             "Layers": [</span><span class="token comment">#                 "sha256:764055ebc9a7a290b64d17cf9ea550f1099c202d83795aa967428ebdf335c9f7",</span><span class="token comment">#                 "sha256:71a14cc55692a4edac5da18be420acf085c681ec95f7af5ff64bb1c236440d59",</span><span class="token comment">#                 "sha256:50854886015e8e202f3197c6a95ae60632a432aba673188bb7c3f9ee80ed2f30",</span><span class="token comment">#                 "sha256:1952fb2b0eb4d355f05a815c6d804243f089e05c0b8f3b1c1eaf0a1109e8293a",</span><span class="token comment">#                 "sha256:893f6aea2ce23f813c44180ccb7a41e8a4d151cb02f7c365cc4e837c0872b211",</span><span class="token comment">#                 "sha256:b8d0aeaeeee8ed55cb6bfc7e061d0bb0491e91024790c45d0c56b07c29cea080",</span><span class="token comment">#                 "sha256:d7cde20f3f6895bd6e6b2ef5767ee60d7034babe62093340ac22df5c8622db74",</span><span class="token comment">#                 "sha256:ae8fcba6091c17b6691f9a1c49621f193e2f475b3eee44d83b4f78b0d0fd31ae",</span><span class="token comment">#                 "sha256:1a4de2199d77be12009ed995b8db1c5a85d9a9b5e19673a8af4824de03f4ce0a",</span><span class="token comment">#                 "sha256:eeabd280c12ee308111950fd99ba8ffdd75130b6d948ba6a34fe6221b82f20dd",</span><span class="token comment">#                 "sha256:cd0c4980990f734130353adfa00f88ba57bc946b868468d633eeb75abd465fa0",</span><span class="token comment">#                 "sha256:027a41439ba438753333f44da1bc57b86e2211f708ace53343cc733151dc2380"</span><span class="token comment">#             ]</span><span class="token comment">#         },</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>精简后的OS，rootfs可以很小，只包含最基本的命令，工具和程序库就可以了，因为底层直接用Host到Kernel，自己只需要提供rootfs就可以了。达到公用bootfs的目的。</p><img src="/2021/12/25/devops/docker-notes/0006.png" class="" title="多层文件1"><img src="/2021/12/25/devops/docker-notes/0007.png" class="" title="多层文件2"><blockquote><p>进一步说明</p></blockquote><p>所有的Docker镜像都起始于一个既相互镜像层，当进行修改或者增加新的内容时，就会在当前镜像层之上，创建一个新的镜像层。</p><img src="/2021/12/25/devops/docker-notes/0008.png" class="" title="示意图"><p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合。及每个镜像层包含了3个文件，而镜像包含了来及两个镜像层的六个文件</p><img src="/2021/12/25/devops/docker-notes/0009.png" class="" title="示意图"><p>一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，因为最上层中的app2.0是app1.0的一个更新版本。</p><img src="/2021/12/25/devops/docker-notes/0010.png" class="" title="示意图"><p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件，使得文件的更新版本作为一个新镜像层添加到镜像中。</p><p>Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一 文件系统。</p><p>Linux上可用的存储引擎由AUFS、Overlay2、Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于Linux中对应的文件系统或者块设备技术，并且每种存储引擎都有其独特的性能特点</p><p>Docker在Windows上仅支持windowsfilter一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW [①]。</p><p>所有镜像层堆叠合并后，对外统一提供如上图所示的合并图</p><blockquote><p>特点</p></blockquote><p>Docker镜像都是只读的，当容器启动是，一个新的可写层被加载到镜像的顶部，这一层就是容器层，容器之下的都是叫镜像层。（无限套娃？？？）</p><h3 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 提交容器成为一个新的副本容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker commit<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker commit -m<span class="token operator">=</span><span class="token string">"description"</span> -a<span class="token operator">=</span><span class="token string">"author"</span> 容器id 目标镜像:<span class="token punctuation">[</span>TAG<span class="token punctuation">]</span><span class="token comment"># test</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it -p <span class="token number">8080</span>:8080 tomcat<span class="token comment"># new terminal</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it <span class="token variable">${id}</span> /bin/bashroot@sdfj0adf98 /$ <span class="token builtin class-name">cd</span> /usr/local/tomcatroot@sdfj0adf98 /$ <span class="token function">cp</span> -r webapps.dist/* webapps <span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker commit -m<span class="token operator">=</span><span class="token string">"description"</span> -a<span class="token operator">=</span><span class="token string">"author"</span> 容器id 目标镜像:<span class="token punctuation">[</span>TAG<span class="token punctuation">]</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker images<span class="token comment"># 将镜像保存为压缩包</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker save -o qing.tar qing:v1.0<span class="token comment"># 在别的机器上加载该镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker load -i qing.tar<span class="token comment"># 将旧镜像名称修改为新版名称</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker tag qing:v1.0 sunq/qing:v1.0<span class="token comment"># 登录到docker hub</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker login<span class="token comment"># 推送至仓库</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker push sunq/qing:v1.0<span class="token comment"># 完成推送后，退出登录</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">logout</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/12/25/devops/docker-notes/0011.png" class="" title="示意图"><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><p>Q：数据可用放在容器里面么？</p><p>A：不能，因为容器如果被删除，会导致数据永久的丢失，所以需要<strong>数据持久化</strong></p><p>所以就有了容器的卷技术，容器之间可用有一个数据共享，将Docker容器中产生的数据同步到本地中 —— 目录挂载，将我们容器内的目录，挂载到Linux上面。将宿主机的内存共享给容器，双向绑定。</p><p><strong>容器持久化和同步操作，容器间也可以数据共享。</strong></p><h3 id="挂载链接"><a href="#挂载链接" class="headerlink" title="挂载链接"></a>挂载链接</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 直接使用命令来挂载 -v</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it 主机目录:容器目录 （镜像）<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it -v /home/ceshi:/home centos /bin/bash<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect 容器Id<span class="token comment"># “Mounts”</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> /home/ceshi<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ls</span><span class="token comment"># 在容器内创建文件</span><span class="token punctuation">[</span>root@sdfuo098sadf /<span class="token punctuation">]</span>$ <span class="token function">ls</span> /home<span class="token punctuation">[</span>root@sdfuo098sadf /<span class="token punctuation">]</span>$ <span class="token function">touch</span> test.java<span class="token comment"># 在宿主机中查看是否文件被同步创建</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ls</span> /home/ceshi<span class="token comment"># [root@qing /]$ docker exec -it 容器id /bin/bash  # 进入后台运行的容器，/bin/bash 位置开启一个新的终端，可以进行一些操作(常用)</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker attach 容器id<span class="token comment">#  进入正在执行的容器进入正在运行的中断，不会启动新的进程</span><span class="token punctuation">[</span>root@sdfuo098sadf /<span class="token punctuation">]</span>$ <span class="token builtin class-name">exit</span><span class="token comment"># 退出容器后，在宿主机上修改文件</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> /home/ceshi/test.java<span class="token comment"># 重新启动容器，查看容器中的该文件是被同步修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 拉取镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker pull mysql:5.7<span class="token comment"># 官方的启动命令</span><span class="token comment"># 启动容器时挂载目录, 配置密码</span><span class="token comment"># -e 环境配置</span><span class="token comment"># $ docker run -it --network some-network --rm mysql mysql -hsome-mysql -uexample-user -p</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -p <span class="token number">2233</span>:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> --name mysql01 mysql:5.7<span class="token comment"># 可用连接创建数据库查看是否持久化成功。</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">rm</span> -f mysql01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 不指定主机目录，会自动挂载</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$  docker run -d -P --name nginx01 -v /etc/nginx nginx<span class="token comment"># 注意 -v 后不添加/ 表明不是目录</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$  docker run -d -P --name nginx02 -v juming_nginx:/etc/nginx nginx<span class="token comment"># 查看所有的卷情况</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker volume <span class="token function">ls</span>DRIVER    VOLUME NAME<span class="token builtin class-name">local</span>     0a99e217ac4ba4842c205b7fe1aae0146425e56b96df7628d78e10198f1337ce<span class="token builtin class-name">local</span>     juming_nginx<span class="token comment"># 可用看出，第一个就是匿名挂载，在 -v 之后只写了容器内的路径，没有写宿主机的路径</span><span class="token comment"># 第二个就是具名挂载 -v 卷名:容器内路径 </span><span class="token comment"># 查看卷的所在目录</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker volume inspect juming_nginx<span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"CreatedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-12-29T23:28:25+08:00"</span>,        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,        <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> null,        <span class="token string">"Mountpoint"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/volumes/juming_nginx/_data"</span>,        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"juming_nginx"</span>,        <span class="token string">"Options"</span><span class="token builtin class-name">:</span> null,        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token comment"># Mountpoint 就是挂载的目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的docker容器内的卷，没有指定目录的情况下都是在 <code>/var/lib/docker/volumes/xxxxxx/_data</code></p><p>通过具名挂载可用很方便的找到一个卷，通常情况下都是使用具名挂载</p><h4 id="挂载小总结"><a href="#挂载小总结" class="headerlink" title="挂载小总结"></a>挂载小总结</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 具名挂载、匿名挂载、指定路径挂载</span>-v 容器内路径<span class="token comment"># 匿名挂载</span>-v 卷名:容器内路径<span class="token comment"># 具名挂载</span>-v /宿主机路径:容器内路径<span class="token comment"># 指定路径挂载</span><span class="token comment"># 通过 -v 容器内路径:ro rw 改变读写权限</span><span class="token comment"># 一旦设置了容器权限，容器对我们挂载出来的容器就有了限定 </span><span class="token comment"># ro 这个路径就只能通过宿主机来操作，容器内部是无法操作的</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name nginx03: -v juming_nginx:/etc/nginx:ro nginx<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name nginx04 -v juming_nginx:/etc/nginx:rw nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dockerFile实现挂载"><a href="#dockerFile实现挂载" class="headerlink" title="dockerFile实现挂载"></a>dockerFile实现挂载</h3><p>命令脚本，可用通过这个脚本来生成镜像，镜像是一层一层的卷，脚本就是一个一个的命令，每个命令就是一层！</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> /home/docker-test-volume<span class="token comment"># 创建dockerFile文件</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> dockerFile1<span class="token comment">#############################dockerFile1##############</span>FROM centosVOLUME <span class="token punctuation">[</span><span class="token string">"volume01"</span>,<span class="token string">"volume02"</span><span class="token punctuation">]</span>CMD <span class="token builtin class-name">echo</span> <span class="token string">"------end------"</span>CMD /bin/bash<span class="token comment">############################dockerFile1##############</span><span class="token comment"># 根据dockerFile 生成镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build -f ./dockerFile1 -t qing/centos:1.0 <span class="token builtin class-name">.</span>Sending build context to Docker daemon  <span class="token number">240</span>.7MBStep <span class="token number">1</span>/4 <span class="token builtin class-name">:</span> FROM centos ---<span class="token operator">&gt;</span> 5d0da3dc9764Step <span class="token number">2</span>/4 <span class="token builtin class-name">:</span> VOLUME <span class="token punctuation">[</span><span class="token string">"volume01"</span>,<span class="token string">"volume02"</span><span class="token punctuation">]</span> ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> eb142d0e83adRemoving intermediate container eb142d0e83ad ---<span class="token operator">&gt;</span> ba3e07adb20bStep <span class="token number">3</span>/4 <span class="token builtin class-name">:</span> CMD <span class="token builtin class-name">echo</span> <span class="token string">"------end------"</span> ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 372a86750520Removing intermediate container 372a86750520 ---<span class="token operator">&gt;</span> 8feb17962dffStep <span class="token number">4</span>/4 <span class="token builtin class-name">:</span> CMD /bin/bash ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> b198098a4925Removing intermediate container b198098a4925 ---<span class="token operator">&gt;</span> 0a15ea858d6bSuccessfully built 0a15ea858d6bSuccessfully tagged qing/centos:1.0<span class="token comment"># 查看镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker imagesREPOSITORY    TAG       IMAGE ID       CREATED         SIZEqing/centos   <span class="token number">1.0</span>       0a15ea858d6b   <span class="token number">6</span> seconds ago   231MB<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it qing/centos:1.0 <span class="token function">bash</span><span class="token punctuation">[</span>root@ef4ca52a471a /<span class="token punctuation">]</span><span class="token comment"># ls</span>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01volume02<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect ef4ca52a471a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="容器间共享数据"><a href="#容器间共享数据" class="headerlink" title="容器间共享数据"></a>容器间共享数据</h3><p>通过数据卷容器来达到容器间的共享</p><img src="/2021/12/25/devops/docker-notes/0015.png" class="" title="示意图"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 启动父容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it --name docker01 qing/centos:1.0 <span class="token function">bash</span><span class="token comment"># 启动第二个</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it --name docker02 --volumes-from docker01 qing/centos:1.0 <span class="token function">bash</span><span class="token comment"># 在父容器中创建文件 会被同步到子容器中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：这里其实是容器都挂载到宿主机的同一个目录下了，并不是多个目录之间在同步，如果删除宿主机下的这个目录的文件，容器内的数据就会消失</p><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><p>dockerFile 是用来构建docker镜像的构建脚本。</p><p>大致步骤</p><ol><li>编写一个dockerFile文件</li><li>docker build 构建一个镜像</li><li>docker  run 运行镜像</li><li>docker push 发布镜像</li></ol><blockquote><p>每个保留关键字（指令）都是大写</p><p>执行从上到下顺序执行</p><p>/# 表示注释</p><p>每个指令都会创建提交一个新的镜像层，并提交。</p></blockquote><img src="/2021/12/25/devops/docker-notes/0016.png" class="" title="示意图"><h3 id="指令简述"><a href="#指令简述" class="headerlink" title="指令简述"></a>指令简述</h3><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>基础镜像，从这里开始</td></tr><tr><td>MAINTAINER</td><td>镜像的作者</td></tr><tr><td>RUN</td><td>镜像构建的时候需要运行的命令</td></tr><tr><td>ADD</td><td>编译镜像时复制文本到镜像中</td></tr><tr><td>COPY</td><td>类似ADD，将文件拷贝到镜像中</td></tr><tr><td>WORKDIR</td><td>镜像的工作目录，设置RUN CMD ENTRYPOINT COPY ADD指令的工作目录</td></tr><tr><td>LABEL</td><td>设置镜像的标签</td></tr><tr><td>VOLUME</td><td>挂载的目录</td></tr><tr><td>EXPOSE</td><td>设置镜像暴露的端口</td></tr><tr><td>CMD</td><td>指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被代替</td></tr><tr><td>ENTRYPOINT</td><td>指定这个容器启动的时候要运行的命令，可用追加命令</td></tr><tr><td>ONBUILD</td><td>当构建一个被继承DockerFile这个时候就会运行onbuild的指令，触发指令</td></tr><tr><td>ARG</td><td>设置编译镜像时加入的参数</td></tr><tr><td>ENV</td><td>构建的时候设置的环境变量</td></tr><tr><td>USER</td><td>设置运行RUN CMD ENTRYPOINT的用户名</td></tr><tr><td>STOPSIGNAL</td><td>设置容器的退出信号量</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><p>Docker Hub中99%镜像都是从一个基础镜像scratch过来的。</p><blockquote><p>FROM scratch</p></blockquote><h4 id="制作一个简单的centos扩展镜像"><a href="#制作一个简单的centos扩展镜像" class="headerlink" title="制作一个简单的centos扩展镜像"></a>制作一个简单的centos扩展镜像</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> docker_file_centos<span class="token comment">############################docker_file_centos##############</span>FROM centosMAINTAINER qing<span class="token operator">&lt;</span><span class="token number">111</span>@qq.com<span class="token operator">&gt;</span>ENV MYPATH /usr/localWORKDIR <span class="token variable">$MYPATH</span>RUN yum -y <span class="token function">install</span> <span class="token function">vim</span>RUN yum -y insatll net-toolsEXPOSE <span class="token number">80</span>CMD <span class="token builtin class-name">echo</span> <span class="token string">"------end-----"</span>CMD /bin/bash<span class="token comment">############################docker_file_centos##############</span><span class="token comment"># 在官方的centos基础上添加了vim 和 net-tools</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build -f home/doker_files/docker_file_centos -t qing/centos:1.1 <span class="token builtin class-name">.</span><span class="token comment"># 可用启动测试下 ipconfig vim 命令</span><span class="token comment"># 查看下镜像构建的历史</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">history</span> 镜像id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用tar制作tomcat镜像"><a href="#使用tar制作tomcat镜像" class="headerlink" title="使用tar制作tomcat镜像"></a>使用tar制作tomcat镜像</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ls</span>apache-tomcat-9.0.56.tar.gz jdk1.8.0_181<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">touch</span> readme.md<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> Dockerfile <span class="token comment"># 该命令 build是会自动讯在，不用-f指定 </span><span class="token comment">############################Dockerfile##############</span>FROM centosMAINTAINER qing<span class="token operator">&lt;</span><span class="token number">111</span>@qq.com<span class="token operator">&gt;</span>COPY readme.md /usr/local/readme.txt<span class="token comment"># 直接复制</span>COPY jdk1.8.0_181/ /usr/local/jdk1.8.0_181/<span class="token comment"># 会自动解压</span>ADD apache-tomcat-9.0.56.tar /usr/local/RUN yum -y <span class="token function">install</span> <span class="token function">vim</span> ENV MYPATH /usr/localWORKDIR <span class="token variable">$MYPATH</span>ENV JAVA_HOME /usr/local/jdk1.8.0_181ENV CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.56ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.56ENV <span class="token environment constant">PATH</span> <span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$JAVA_HOEM</span>/bin:<span class="token variable">$CATALINA_HOME</span>/lib:<span class="token variable">$CATALINA_HOME</span>/binEXPOSE <span class="token number">8080</span>CMD /usr/local/apache-tomcat-9.0.56/bin/startup.sh <span class="token operator">&amp;&amp;</span> <span class="token function">tail</span> -F /url/localapache-tomcat-9.0.56/bin/logs/catalina.out<span class="token comment">############################Dockerfile##############</span><span class="token comment"># 构建启动</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build -t qing/tomcat:1.0 <span class="token builtin class-name">.</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker images<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -p <span class="token number">2233</span>:8080 --name qingtomcat -v /home/qing/tomcat/test:/usr/local/apache-tomcat-9.0.56/webapps/test -v /home/qing/tomcat/logs:/usr/local/apache-tomcat-9.0.56/logs qing/tomcat:1.0<span class="token comment"># 测试</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:2233<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root@qing /]$ mkdir /home/qing/tomcat/test/EB-INF[root@qing /]$ cd /home/qing/tomcat/test/EB-INF[root@qing /]$ vim web.xml############################web.xml##############&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee                             http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"         ersion="2.5"&gt;&lt;/web-app&gt;  ############################web.xml##############[root@qing /]$ cd ..[root@qing /]$ vim index.jsp############################index.jsp##############&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;br/&gt;&lt;%System.out.println("Your IP address is " + request.getRemoteAddr());%&gt;&lt;/body&gt;&lt;/html&gt;############################index.jsp##############<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h3><h4 id="CMD和ENTRYPOINT的区别"><a href="#CMD和ENTRYPOINT的区别" class="headerlink" title="CMD和ENTRYPOINT的区别"></a>CMD和ENTRYPOINT的区别</h4><ul><li>CMD<ul><li>启动的时候如果在最后追加了命令会替换掉镜像中的命令</li></ul></li><li>ENRYPOINT<ul><li>启动后如果在最后追加了命令，不会替换镜像中的命令，而是在其后追加</li></ul></li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> docker_file_cmd<span class="token comment">############################docker_file_cmd##############</span>FROM centosCMD <span class="token punctuation">[</span><span class="token string">"ls"</span>,<span class="token string">"-a"</span><span class="token punctuation">]</span><span class="token comment">############################docker_file_cmd##############</span><span class="token comment"># 在官方的centos基础上添加了vim 和 net-tools</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build -f home/doker_files/docker_file_cmd -t qing/centos:1.2 <span class="token builtin class-name">.</span><span class="token comment"># 直接运行会发现 ls -a 执行了</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span><span class="token variable">$dovker</span> run centos:1.2<span class="token comment"># 追加命令执行</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span><span class="token variable">$dovker</span> run centos:1.2 -lerror<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> docker_file_entrypoint<span class="token comment">############################docker_file_entrypoint##############</span>FROM centosENTRYPOINT <span class="token punctuation">[</span><span class="token string">"ls"</span>,<span class="token string">"-a"</span><span class="token punctuation">]</span><span class="token comment">############################docker_file_entrypoint##############</span><span class="token comment"># 在官方的centos基础上添加了vim 和 net-tools</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build -f home/doker_files/docker_file_entrypoint -t qing/centos:1.3 <span class="token builtin class-name">.</span><span class="token comment"># 直接运行会发现 ls -a 执行了</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ dovker run centos:1.2<span class="token comment"># 追加命令执行，会发现 执行了 ls -a -l</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ dovker run centos:1.2 -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h3><h4 id="DockerHub"><a href="#DockerHub" class="headerlink" title="DockerHub"></a>DockerHub</h4><ol><li><p>地址<a href="http://hub.docker.com/">http://hub.docker.com/</a> 注册自己的账号</p></li><li><p>在服务器上提交自己的镜像</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 登录自己账户号</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker login -u qingPassword:Login Succeeded<span class="token comment"># 提交镜像 尽量带上自己的版本号</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker push  qing/tomcat:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="阿里云容器镜像服务"><a href="#阿里云容器镜像服务" class="headerlink" title="阿里云容器镜像服务"></a>阿里云容器镜像服务</h4><ol><li>登录阿里云，找到容器镜像服务</li><li>根据需求创建命名空间、</li><li>创建容器镜像</li><li>根据阿里云上的操作指南进行提交</li></ol><h2 id="流程小结"><a href="#流程小结" class="headerlink" title="流程小结"></a>流程小结</h2><img src="/2021/12/25/devops/docker-notes/0017.png" class="" title="流程图"><h2 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h2><h3 id="实验查看"><a href="#实验查看" class="headerlink" title="实验查看"></a>实验查看</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看IP地址</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ip</span> addr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2021/12/25/devops/docker-notes/0018.png" class="" title="输出说明"><p>Q：docker如何处理容器网络访问的？</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat01 tomcat<span class="token comment"># 查看容器的内部Ip地址</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat01 <span class="token function">ip</span> addr<span class="token comment">## 如果 报错 OCI runtime exec failed: </span><span class="token comment">## 因为该tomcat镜像为了最小化，可能没有安装ip addr命令，故需要安装 iproute2</span><span class="token comment"># [root@qing /]$ docker exec -it tomcat01 bash</span><span class="token comment"># root@bd19d226252e $ apt update &amp;&amp; apt install -y iproute2</span><span class="token comment"># 再次输入</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat01 <span class="token function">ip</span> addr<span class="token comment"># 查看一下容器的内部网络地址，发现容器启动的时候会得到一个eth0@if61的ip地址，该地址是由docker分配的 详细见 图0019</span>       <span class="token comment"># 可用通过宿主机ping 改ip</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ping</span> <span class="token number">172.18</span>.0.2<span class="token comment"># 与图片0018中的 docker0 172.18.0.1/16 可用得知该网络与docker0属于同一个网段</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/12/25/devops/docker-notes/0019.png" class="" title="输出说明"><h3 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h3><ol><li><p>每启动一个docker容器，docker就会给docker容器分配一个ip，只要安装了docker，就会有一个网卡docker0。通过桥接模式，使用的技术veth-pair技术进行连接。</p></li><li><p>再次在宿主机测试<code>ip addr</code>，对比图0019和图0020，可以看到了宿主机多了一个网卡，序号上与容器中是对应的</p><blockquote><p>容器带来的网卡都是一对存在的</p><p>veth-pair 就是一对虚拟设备接口，都是成对出现，一段连着协议，一段彼此相连。基于此特性，veth-pair充当一个桥梁，连接各种虚拟网络设备的</p><p>OpenStac、Docker容器之间的连接、OVS的连接，都是使用veth-pair 技术</p></blockquote><img src="/2021/12/25/devops/docker-notes/0020.png" class="" title="输出说明"></li><li><p>所以在启动多个容器的时候，由于都是由docker0分配的网卡的ip都属于同一个网段，所以容器之间也是可以相互访问的。</p></li></ol><img src="/2021/12/25/devops/docker-notes/0021.png" class="" title="示意图"><ol start="4"><li>所以，在启动容器时不指定网络的情况下，都是哟docker来分配一个默认的可用IP，且由docker0来进行路由</li></ol><p><strong>小结</strong></p><blockquote><p>Docker使用的是Linux的桥接，宿主机中的一个网卡docker0就是Docker的网桥 </p><p>docker中的所有网络接口都是虚拟的，虚拟的转发效率高、</p></blockquote><img src="/2021/12/25/devops/docker-notes/0022.png" class="" title="示意图"><h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><h4 id="–Link"><a href="#–Link" class="headerlink" title="–Link"></a>–Link</h4><blockquote><p>但是并不推荐使用 –link 进行容器连接。因为部分的自定义网络不适于使用docker0 进行路由，例如：不支持使用容器名进行连接</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat01 tomcat<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat02 tomcat<span class="token comment"># 直接在容器间进行ping</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat02 <span class="token function">ping</span> tomcat01<span class="token comment">## 如果 报错 OCI runtime exec failed: </span><span class="token comment">## 不支持ping命令时，则需要进入容器手动安装该命令</span><span class="token comment"># [root@qing /]$ docker exec -it tomcat02 bash</span><span class="token comment"># root@bd19d226252e $ apt update &amp;&amp; apt install iputils-ping</span>ping: tomcat01: Name or <span class="token function">service</span> not known  <span class="token comment"># 可知无法与tomcat01进行通信</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat03 --link tomcat02 tomcat<span class="token comment"># 如果不存在ping命令，则需要同上面的方式安装 </span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat03 <span class="token function">ping</span> tomcat02PING tomcat02 <span class="token punctuation">(</span><span class="token number">172.18</span>.0.3<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.<span class="token number">64</span> bytes from tomcat02 <span class="token punctuation">(</span><span class="token number">172.18</span>.0.3<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.104</span> ms<span class="token number">64</span> bytes from tomcat02 <span class="token punctuation">(</span><span class="token number">172.18</span>.0.3<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.059</span> ms<span class="token comment"># 可用发现 通过--link 便可以在容器之间 通过服务名联通(不用指定ip)</span><span class="token comment"># 但是反向却无法ping通</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat02 <span class="token function">ping</span> tomcat03<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里 –link 是将tomcat03对tomcat02的连接添加到了配置项中，所以可用tomcat03可用访问到tomcat02。使用inspect命令查看docker的元数据可以看到如下配置</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect tomcat03<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/12/25/devops/docker-notes/0023.png" class="" title="输出"><blockquote><p>也可以通过查看hosts配置</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat03 <span class="token function">cat</span> /etc/hosts<span class="token comment"># 可以理解为在host文件中添加了域名映射</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2021/12/25/devops/docker-notes/0024.png" class="" title="输出"><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker network <span class="token function">ls</span> <span class="token comment"># 查看所有网络</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/12/25/devops/docker-notes/0025.png" class="" title="输出"><h4 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h4><ul><li>bridge：桥接模式 （docker 默认）</li><li>none：不配置网络</li><li>host：与宿主机共享模式</li><li>container：容器网络连通（局限较大）</li></ul><h4 id="自定义网络-1"><a href="#自定义网络-1" class="headerlink" title="自定义网络"></a>自定义网络</h4><blockquote><p>可以修复docker0中，在不适用–link是，不支持直接使用容器名进行连接</p></blockquote><p><strong>自定义网络选择使用bridge模式</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 直接启动的容器，有一个默认参数为： --net bridge，这里使用的就是docker0</span><span class="token comment"># docker run -d -P --name tomcat01 --net bridge tomcat</span><span class="token comment"># 自定义一个网络</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker network create --driver bridge --subnet <span class="token number">192.168</span>.0.0/16 --gateway <span class="token number">192.168</span>.0.1 mynet<span class="token comment">## --driver 连接模式</span><span class="token comment">## --subnet 子网掩码</span><span class="token comment">## --gateway 路由ip</span><span class="token comment"># 故可以在启动的时候指定使用该自定义的网络</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat-net-01 --net mynet tomcat<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat-net-02 --net mynet tomcat<span class="token comment"># 查看此时自定义网络的元数据</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker network inspect mynet <span class="token comment"># 图片0026中可以看到容器的网络</span><span class="token comment"># 此时使用自定义的网络直接通过容器名进行ping</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat-net-01 <span class="token function">ping</span> tomcat-net-02<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/12/25/devops/docker-notes/0026.png" class="" title="输出"><h4 id="将不同网络连接"><a href="#将不同网络连接" class="headerlink" title="将不同网络连接"></a>将不同网络连接</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 将网络docker0下的tomcat01连接到 mynet网络下（达成一个容器两个ip）</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker network connect mynet tomcat01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2021/12/25/devops/docker-notes/0027.png" class="" title="示意图"><h4 id="demo-redis集群"><a href="#demo-redis集群" class="headerlink" title="demo-redis集群"></a>demo-redis集群</h4><blockquote><p>分片 集群 高可用</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 创建网卡</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker network create redis --subnet <span class="token number">172.38</span>.0.0/16<span class="token comment"># 通过脚本创建六个redis配置</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token keyword">for</span> <span class="token for-or-select variable">port</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> <span class="token number">1</span> <span class="token number">6</span><span class="token variable">)</span></span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token keyword">do</span> <span class="token punctuation">\</span><span class="token function">mkdir</span> -p /data/qing/redis/node-<span class="token variable">${port}</span>/conf<span class="token function">touch</span> /data/qing/redis/node-<span class="token variable">${port}</span>/conf/redis.conf<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span>/data/qing/redis/node-<span class="token variable">${port}</span>/conf/redis.conf</span>port 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1<span class="token variable">${port}</span>cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOF</span><span class="token keyword">done</span><span class="token comment"># 启动六个容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token keyword">for</span> <span class="token for-or-select variable">port</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> <span class="token number">1</span> <span class="token number">6</span><span class="token variable">)</span></span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token keyword">do</span> <span class="token punctuation">\</span>docker run -p <span class="token number">637</span><span class="token variable">${port}</span>:6379 -p <span class="token number">1637</span><span class="token variable">${port}</span>:16379 --name redis-<span class="token variable">${port}</span> <span class="token punctuation">\</span>-v /data/qing/redis/node-<span class="token variable">${port}</span>/data:/data <span class="token punctuation">\</span>-v /data/qing/redis/node-<span class="token variable">${port}</span>/conf/redis.conf:/etc/redis/redis.conf <span class="token punctuation">\</span>-d --net redis --ip <span class="token number">172.38</span>.0.1<span class="token variable">${port}</span> redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token keyword">done</span><span class="token comment"># 进入容器创建集群</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it redis-1 /bin/sh<span class="token comment"># 创建集群</span>/data $ redis-cli --cluster create <span class="token number">172.38</span>.0.11:6379 <span class="token number">172.38</span>.0.12:6379 <span class="token number">172.38</span>.0.13:6379 <span class="token number">172.38</span>.0.14:6379 <span class="token number">172.38</span>.0.15:6379 <span class="token number">172.38</span>.0.16:6379 --cluster-replicas <span class="token number">1</span><span class="token comment">#### 以下为输出 部分省略####</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Performing <span class="token builtin class-name">hash</span> slots allocation on <span class="token number">6</span> nodes<span class="token punctuation">..</span>.Master<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> -<span class="token operator">&gt;</span> Slots <span class="token number">0</span> - <span class="token number">5460</span>Master<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> -<span class="token operator">&gt;</span> Slots <span class="token number">5461</span> - <span class="token number">10922</span>Master<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> -<span class="token operator">&gt;</span> Slots <span class="token number">10923</span> - <span class="token number">16383</span>Adding replica <span class="token number">172.38</span>.0.15:6379 to <span class="token number">172.38</span>.0.11:6379<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All nodes agree about slots configuration.<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Check <span class="token keyword">for</span> <span class="token function">open</span> slots<span class="token punctuation">..</span>.<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Check slots coverage<span class="token punctuation">..</span>.<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All <span class="token number">16384</span> slots covered.<span class="token comment">#### 以上为输出 ####</span><span class="token comment"># 测试</span>/data $ redis-cli -c<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> cluster info<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> cluster nodes<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> a b-<span class="token operator">&gt;</span> Redirected to slot <span class="token punctuation">[</span><span class="token number">15495</span><span class="token punctuation">]</span> located at <span class="token number">172.38</span>.0.13:6379OK <span class="token comment"># 可以看出保存到了3号节点</span><span class="token comment"># 关闭一个容器 测试 172.38.0.13:6379 这里是 13 所以停掉3号</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stop redis-3<span class="token comment"># 在容器内获取刚刚存入的值</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get a-<span class="token operator">&gt;</span> Redirected to slot <span class="token punctuation">[</span><span class="token number">15495</span><span class="token punctuation">]</span> located at <span class="token number">172.38</span>.0.14:6379<span class="token string">"b"</span> <span class="token comment"># 可以看到这里从4号机器中获取</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="IDEA整合Docker"><a href="#IDEA整合Docker" class="headerlink" title="IDEA整合Docker"></a>IDEA整合Docker</h2><ol><li><p>安装插件</p><blockquote><p>为了文件高亮，以及可以直接连接仓库</p></blockquote><img src="/2021/12/25/devops/docker-notes/0028.png" class="" title="示意图"><img src="/2021/12/25/devops/docker-notes/0029.png" class="" title="示意图"></li><li><p>通过package进行打包</p><blockquote><p>通过使用maven 的打包功能进行打包</p></blockquote></li><li><p>编写Dockerfile文件</p><blockquote><p>其他功能暂未研究</p></blockquote><img src="/2021/12/25/devops/docker-notes/0030.png" class="" title="示意图"></li><li><p>通过Dockerfile构建镜像与发布</p></li></ol><hr><p><strong>完</strong></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?from=search&amp;seid=8833819761241839370">狂神说Docker</a> ：<a href="https://www.bilibili.com/video/BV1og4y1q7M4?share_source=copy_web">https://www.bilibili.com/video/BV1og4y1q7M4?share_source=copy_web</a></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> command </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令详解</title>
      <link href="/2021/12/18/tool/git-note/"/>
      <url>/2021/12/18/tool/git-note/</url>
      
        <content type="html"><![CDATA[<h2 id="命令脑图"><a href="#命令脑图" class="headerlink" title="命令脑图"></a>命令脑图</h2><blockquote><p>鹅厂程序猿常用的 Git 命令思维导图</p></blockquote><img src="/2021/12/18/tool/git-note/git-notes-0000.svg" class="" title="脑图"><h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="配置级别"><a href="#配置级别" class="headerlink" title="配置级别"></a>配置级别</h3><p><code>git</code>的配置级别主要分为三类</p><blockquote><ol><li>仓库级别 <code>local</code> [优先级最高]<ol><li><code>git</code> 仓库级别对应的配置文件是当前仓库下的<code>.git/config</code>，默认是隐藏的 </li><li><strong><code>git config --local -l</code></strong>  or <strong><code>git config --local --list</code></strong>  [查看仓库级别的配置] </li><li><code>git config --local -e</code> 编辑仓库级别配置文件</li></ol></li><li>用户级别 <code>global</code>[优先级次之]<ol><li><code>git</code> 用户级别对应的配置文件是用户宿主目录下的<code>~/.gitconfig</code>（<code>C:\Users\XXX\.gitconfig</code>）</li><li>**<code>git config --global -l</code>**or <strong><code>git config --global --list</code></strong>  [查看用户级别的配置]</li><li><code>git config --global -e</code> 编辑用户级别配置文件</li></ol></li><li>系统级别 <code>system</code>[优先级最低]<ol><li><code>git</code>系统级别对应的配置文件是git安装目录下的<code> /etc/gitconfig</code>（<code>[install-path]\mingw64\etc\gitconfig</code>）</li><li><strong><code>git config --system -l</code></strong> or <strong><code>git config --system --list</code></strong> [查看系统级别的配置</li><li><code>git config --system -e</code> 编辑系统级别配置文件</li></ol></li><li>查看全部<ol><li><strong><code>git config -l</code></strong> or <strong><code>git config --list</code></strong> </li><li>其中的分类为<ul><li><code>core.XXX</code>为仓库级配置</li><li><code>user.XXX</code>    为用户级配置</li><li><code>http.XXX</code>    为系统级配置</li></ul></li></ol></li></ol></blockquote><blockquote><p>添加邮箱和用户名</p><ul><li><code>git config --global user.email “XXX@xxx.com” </code>    # 用户级</li><li><code>git config --global user.name “XXX” </code>                # 用户级</li></ul></blockquote><h2 id="功能性配置"><a href="#功能性配置" class="headerlink" title="功能性配置"></a>功能性配置</h2><h3 id="通用SSH配置"><a href="#通用SSH配置" class="headerlink" title="通用SSH配置"></a>通用SSH配置</h3><ol><li>首先确保用户名与账号的配置完成</li><li>生成密钥对</li></ol><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"> $ ssh-keygen -t rsa -C "xxx@xxx.com" # 生成秘钥# 之后会又两个输入选项：# 1、第一个是指定生成的密钥文件名(将会放在用户文件目录下)，如果不指定，则使用默认的文件名称# id_rsa.pub  公钥id_rsa  私钥# 2、第二个是指定验证密码，不输入则默认为空。设置密码后，每次使用git时都需要输入在此设置的密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/12/18/tool/git-note/git-notes-0001.png" class="" title="生成密钥"><ol start="3"><li><p>进入到用户宿主目录下，获取公钥 <code>cat ~/.ssh/id_rsa.pub</code>(也可以直接访问id_rsa.pub文件查看)</p></li><li><p>进入github或者其他版本管理系统，添加此处获得的公钥</p></li><li><p>测试访问 <code>ssh -T git@github.com</code> </p><p>​返回如下提示则配置成功 <code>Hi xxxx! You've successfully authenticated, but GitHub does not provide shell access.</code></p><p>​<img src="/2021/12/18/tool/git-note/git-notes-0002.png" class="" title="测试连接效果"></p></li><li><p>修改<code>git</code>的<code>remote url</code></p></li></ol><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 查看当前的 remote url$ git remote -vorigin https://github.com/XXX/XXXproject.git (fetch) # 此结果说明 使用https协议进行访问origin https://github.com/XXX/XXXproject.git (push)#  复制SSH链接，进行调整$ git remote set-url origin git@github.com:XXX/XXXproject.git# 之后可再次使用查看 remote url 会发现已经被修改$ git remote -vorigin  git@github.com:XXX/XXXproject.git (fetch)  # git开头则表示是git协议origin  git@github.com:XXX/XXXproject.git (push)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多仓库源多密钥设置"><a href="#多仓库源多密钥设置" class="headerlink" title="多仓库源多密钥设置"></a>多仓库源多密钥设置</h3><p>通过在配置项中指定服务器与对应的密钥对，来达到在同一个机器上对不同的git仓库使用不同的密钥对进行匹配。</p><blockquote><p>注意，这里指定的证书文</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">% vim ~/.ssh/config# 在config文件中增加一下内容Host github.comHostName github.comUser 账号IdentityFile &lt;自定义的目录&gt;/id_rsaIdentitiesOnly yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.processon.com/view/link/5c6e2755e4b03334b523ffc3#map">脑图来源</a>：<a href="https://www.processon.com/view/link/5c6e2755e4b03334b523ffc3#map">https://www.processon.com/view/link/5c6e2755e4b03334b523ffc3#map</a></p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> configuration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/12/12/helloworld/hello-world/"/>
      <url>/2021/12/12/helloworld/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> HelloWorld </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HelloWorld </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
