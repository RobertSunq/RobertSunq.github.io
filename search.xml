<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于Linux系统安装Gitea</title>
      <link href="/2023/05/09/cs-frameworks-tools/linux-install-gitea/"/>
      <url>/2023/05/09/cs-frameworks-tools/linux-install-gitea/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Linux系统安装Gitea"><a href="#基于Linux系统安装Gitea" class="headerlink" title="基于Linux系统安装Gitea"></a>基于Linux系统安装Gitea</h1><blockquote><p>说明：基于 <code>Rocky Linux</code> 系统安装 <code>Gitea</code></p><p><a href="https://gitea.io/zh-cn/" title="点击跳转">项目首页</a>：<a href="https://gitea.io/zh-cn/">https://gitea.io/zh-cn/</a></p><p><a href="https://docs.gitea.io/zh-cn/" title="点击跳转">文档地址</a>：<a href="https://docs.gitea.io/zh-cn/">https://docs.gitea.io/zh-cn/</a></p><p><a href="https://github.com/go-gitea/gitea" title="点击跳转">项目地址</a>：<a href="https://github.com/go-gitea/gitea">https://github.com/go-gitea/gitea</a></p></blockquote><h2 id="Gitea和其他工具对比"><a href="#Gitea和其他工具对比" class="headerlink" title="Gitea和其他工具对比"></a>Gitea和其他工具对比</h2><p>具体可以参考以下两篇文章，第一篇是官方文档上的说明，第二篇是一个博主的文章。</p><p><code>Gitea</code>和其他<code>Git</code>托管工具对比：<a href="https://docs.gitea.io/zh-cn/installation/comparison/">https://docs.gitea.io/zh-cn/installation/comparison/</a></p><p><code>Gitea</code>与<code>Gitlab</code>部署踩坑经理与对比总结：<a href="https://zhuanlan.zhihu.com/p/486410391">https://zhuanlan.zhihu.com/p/486410391</a></p><h2 id="安装简介"><a href="#安装简介" class="headerlink" title="安装简介"></a>安装简介</h2><p>以下安装方式均在官方文档上有详细教程，这里记录下自己安装过程于配置，方便自己下次安装参考。</p><p><a href="https://gitea.io/zh-cn/" title="点击跳转">官方地址</a>：<a href="https://gitea.io/zh-cn/">https://gitea.io/zh-cn/</a></p><p><a href="https://docs.gitea.io/zh-cn/installation/comparison/" title="点击跳转">官方文档</a>：<a href="https://docs.gitea.io/zh-cn/installation/comparison/">https://docs.gitea.io/zh-cn/installation/comparison/</a></p><p><a href="https://dl.gitea.com/gitea/" title="点击跳转">下载地址</a>：<a href="https://dl.gitea.com/gitea/">https://dl.gitea.com/gitea/</a></p><p>在 Linux 下可以使用如下 5 种方式来安装：</p><ul><li><a href="https://docs.gitea.io/zh-cn/installation/install-from-package/" title="点击跳转">RPM</a>（<code>RedHat Package Manage</code>）<ul><li>安装简单，适合初学者学习使用，一台服务器只能安装一个。</li></ul></li><li><a href="https://docs.gitea.io/zh-cn/installation/install-from-binary/" title="点击跳转">二进制</a>（<code>Binary Package</code>）<ul><li>安装简单，可以按照到任何路径下，灵活性好，一台服务器可以安装多个。</li></ul></li><li><a href="https://docs.gitea.io/zh-cn/installation/install-from-source/" title="点击跳转">源码</a>（<code>Source Package</code>）<ul><li>在实际安装的操作系统进行可根据需要做定制编译，灵活性最高，性能最好，一台服务器可以安装多个。</li></ul></li><li><a href="https://docs.gitea.io/zh-cn/installation/install-with-docker/" title="点击跳转">Docker安装</a><ul><li>直接基于<code>Docker</code>镜像安装，简单方便，也可也安装多个，但是需要先安装<code>Docker</code>环境</li></ul></li><li><a href="https://docs.gitea.io/zh-cn/installation/install-on-kubernetes/" title="点击跳转">Kubernetes安装</a><ul><li>直接基于<code>Docker</code>镜像安装，简单方便，也可也安装多个，但是需要先安装<code>Docker</code>和<code>Kubernetes</code>环境</li></ul></li></ul><blockquote><p>直接点击可以到官网安装教程</p></blockquote><h2 id="前置环境"><a href="#前置环境" class="headerlink" title="前置环境"></a>前置环境</h2><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><ol><li><p>将系统更新到最新版本的软件包列表</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ sudo dnf makecache --refresh$ sudo dnf install dnf-utils<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>安装Git</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ sudo dnf install git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>验证安装</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置Git配置</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 可选配置# 设置全局配置的用户名与邮箱$ git config --global user.name "qing"$ git config --global user.email "qing@email.cn"# 验证配置$ git config --list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="数据库安装"><a href="#数据库安装" class="headerlink" title="数据库安装"></a>数据库安装</h3><p>Gitea的安装需要基于数据库，官方具体<a href="https://docs.gitea.io/zh-cn/installation/database-prep/" title="点击跳转">说明文档</a>：<a href="https://docs.gitea.io/zh-cn/installation/database-prep/">https://docs.gitea.io/zh-cn/installation/database-prep/</a></p><p>目前支持的数据库版本如下：</p><blockquote><p>数据拷贝于 2023-05-09，最新支持请看上面的官方说明文档</p></blockquote><table><thead><tr><th>数据库</th><th>版本</th><th>备注</th></tr></thead><tbody><tr><td>PostgreSQL</td><td>&gt;=10</td><td></td></tr><tr><td>MySQL</td><td>&gt;=5.7</td><td></td></tr><tr><td>SQLite</td><td>~</td><td></td></tr><tr><td>MSSQL</td><td>&gt;=2008R2 SP3</td><td></td></tr></tbody></table><p>MySQL安装教程可以参考本博客文章<a href="https://robertsunq.github.io/2023/04/13/cs-data/linux-install-mysql" title="点击跳转">基于Linux系统安装Mysql</a>：<a href="https://robertsunq.github.io/2023/04/13/cs-data/linux-install-mysql">https://robertsunq.github.io/2023/04/13/cs-data/linux-install-mysql</a></p><p>其他数据库安装请另行查询。</p><h3 id="Mysql数据库初始化"><a href="#Mysql数据库初始化" class="headerlink" title="Mysql数据库初始化"></a>Mysql数据库初始化</h3><h4 id="设置MySQL监听IP"><a href="#设置MySQL监听IP" class="headerlink" title="设置MySQL监听IP"></a>设置MySQL监听IP</h4><p>对于远程数据库，需要使<code>MySQL</code>监听自己要使用的IP地址，可以将数据库实例的 <code>/etc/mysql/my.cnf</code> 上的绑定地址选项编辑为</p><pre class="line-numbers language-cnf" data-language="cnf"><code class="language-cnf">bind-address = 192.0.2.10 # 你自己的IP, 具体作用没查<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>数据库与Gitea同主机可忽略</p></blockquote><h4 id="登录数据库"><a href="#登录数据库" class="headerlink" title="登录数据库"></a>登录数据库</h4><p>使用root账号登录数据库</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="创建gitea用户"><a href="#创建gitea用户" class="headerlink" title="创建gitea用户"></a>创建gitea用户</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 以下所使用数据库和密码可以替换为自己所需</span><span class="token comment">-- 如果是本地数据</span><span class="token keyword">SET</span> old_passwords<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'gitea'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'gitea'</span><span class="token punctuation">;</span><span class="token comment">-- 如果是远端数据库</span><span class="token keyword">SET</span> old_passwords<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'gitea'</span><span class="token variable">@'192.0.2.10'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'gitea'</span><span class="token punctuation">;</span>  <span class="token comment">-- 为了安全，最好是限定该账号的访问IP</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建database"><a href="#创建database" class="headerlink" title="创建database"></a>创建database</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 根据需求修改数据库名，这里推荐 utf8mb4 字符集和排序规则创建</span><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> giteadb <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token string">'utf8mb4'</span> <span class="token keyword">COLLATE</span> <span class="token string">'utf8mb4_unicode_ci'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="赋予权限"><a href="#赋予权限" class="headerlink" title="赋予权限"></a>赋予权限</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 如果是本地数据</span><span class="token keyword">GRANT</span> <span class="token keyword">ALL</span> <span class="token keyword">PRIVILEGES</span> <span class="token keyword">ON</span> giteadb<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'gitea'</span><span class="token punctuation">;</span>FLUSH <span class="token keyword">PRIVILEGES</span><span class="token punctuation">;</span><span class="token comment">-- 如果是远端数据库</span><span class="token keyword">GRANT</span> <span class="token keyword">ALL</span> <span class="token keyword">PRIVILEGES</span> <span class="token keyword">ON</span> giteadb<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'gitea'</span><span class="token variable">@'192.0.2.10'</span><span class="token punctuation">;</span>FLUSH <span class="token keyword">PRIVILEGES</span><span class="token punctuation">;</span><span class="token comment">-- 之后就可以退出数据库了</span><span class="token keyword">exit</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="测试对数据库连接"><a href="#测试对数据库连接" class="headerlink" title="测试对数据库连接"></a>测试对数据库连接</h4><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 根据自己的实际配置，测试下用户是否可以正常访问数据库$ mysql -u gitea -h 192.0.2.10 -p giteadb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h2><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p><a href="https://dl.gitea.com/gitea/" title="点击跳转">官网下载地址</a>：<a href="https://dl.gitea.com/gitea/">https://dl.gitea.com/gitea/</a></p><p>按照需求下载指定的版本</p><ul><li><strong>对于 Linux</strong>，<code>linux-amd64</code> 适用于 64-bit 的 Intel/AMD 平台。更多架构包含 <code>arm64</code> (Raspberry PI 4)，<code>386</code> (32-bit)，<code>arm-5</code> 以及 <code>arm-6</code>。</li><li><strong>对于 Windows</strong>，<code>windows-4.0-amd64</code> 适用于 64-bit 的 Intel/AMD 平台，<code>386</code> 适用于 32-bit 的 Intel/AMD 平台。（提示：<code>gogit-windows</code> 版本内建了 gogit 可能缓解在旧的 Windows 平台上 Go 程序调用 git 子程序时面临的 <a href="https://github.com/go-gitea/gitea/pull/15482">性能问题</a>）</li><li><strong>对于 macOS</strong>，<code>darwin-arm64</code> 适用于 Apple Silicon 架构，<code>darwin-amd64</code> 适用于 Intel 架构.</li><li><strong>对于 FreeBSD</strong>，<code>freebsd12-amd64</code> 适用于 64-bit 的 Intel/AMD 平台。</li></ul><p>可以使用以下命令在服务器上下载文件</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 下载二进制文件压缩包[root]$ wget -c https://dl.gitea.com/gitea/1.19.3/gitea-1.19.3-linux-amd64.xz -P /data/downloads# -P 指定下载目录# -c --continue 如果首次下载中断，可用使用该参数进行续点下载# 也可也直接下载二进制文件[root]$ wget -O gitea https://dl.gitea.com/gitea/1.19.0/gitea-1.19.0-linux-amd64# 验证签名 [root]$ gpg --keyserver keys.openpgp.org --recv 7C9E68152594688862D62AF62D9AE806EC1592E2[root]$ gpg --verify gitea-1.19.0-linux-amd64.asc gitea-1.19.0-linux-amd64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>校验正确时的信息为 <code>Good signature from "Teabot &lt;teabot@gitea.io&gt;"</code>。 校验错误时的信息为 <code>This key is not certified with a trusted signature!</code>。</p></blockquote><h3 id="添加用户及组"><a href="#添加用户及组" class="headerlink" title="添加用户及组"></a>添加用户及组</h3><p>为了方便管理和维护Gitea的应用，这里建议创建一个单独的用户组和用户用来管理Gitea进程。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root]$ adduser --system --shell /bin/bash --comment 'Git Version Control'  --create-home --home /home/git git# --system：指示该用户账户将是一个系统账户，这是一种专门用于系统进程和守护进程的特殊账户类型。系统账户具有UID（用户标识符）小于1000，并且通常在系统安装或软件包安装期间创建# --shell /bin/bash：指定用户账户的默认shell为/bin/bash，即Bourne-Again SHell# --comment 'Git Version Control'：为用户账户设置注释为“Git Version Control”，账户用途的描述。# --create-home：为用户账户创建一个主目录，如果不存在的话。# --home /home/git：该选项指定用户账户的主目录为/home/git。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装Gitea"><a href="#安装Gitea" class="headerlink" title="安装Gitea"></a>安装Gitea</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 解压压缩文件 [root]$ unxz gitea-1.19.3-linux-amd64.xz# 如果未安装 unxz 使用命令安装： $ dnf install xz-utils # 将 gitea 二进制文件移动到 /usr/local/bin[root]$ mv gitea-1.19.3-linux-amd64  /usr/local/bin# 为了方便使用，这里修改下文件名[root]$ cd /usr/local/bin/[root]$ mv gitea-1.19.3-linux-amd64 gitea# 授予可以执行权限[root]$ chmod +x /usr/local/bin/gitea# 创建所需目录[root]$ mkdir -p /var/lib/gitea/{custom,data,indexers,public,log}# 创建多个目录# -p ：指示mkdir命令创建任何不存在的父目录。# custom：存储自定义配置文件和其他自定义内容。# data：存储Gitea应用程序的数据文件和存储库。# indexers：存储用于搜索和索引数据的文件。# public：存储公共文件，如用户上传的头像和其他静态文件。# log：存储日志文件，包括应用程序日志和访问日志等。[root]$ chown git:git /var/lib/gitea/{data,indexers,log}# 或者chown -R git:git /var/lib/gitea/# 将这几个目录的所有者改为 git[root]$ chmod 750 /var/lib/gitea/{data,indexers,log}# 修改这几个目录的权限[root]$ mkdir /etc/gitea# 创建目录# 用户保存配置[root]$ chown -R git:git /etc/gitea# 修改目录的组和用户[root]$ chmod 770 /etc/gitea# 修改权限[root]$ restorecon -rv /usr/local/bin/gitea# 恢复指定文件或目录的SELinux上下文，以确保它们与系统中其他文件的安全上下文一致，以提高安全性和可靠性。# -r 递归修改子目录和文件# -v 显示详细的输出信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>配置 <code>Gitea</code> 工作路径, 修改配置文件，可以设置全局的，也可设置用户基本的。主机这里这是的路径是前面配置的一致的：</p><p><code>export GITEA_WORK_DIR=/var/lib/gitea/</code></p><p>如果使用 <code>Systemd</code> 管理 <code>Gitea</code> 的 <code>Linux</code> 服务，你可以采用 <code>WorkingDirectory</code> 参数来配置工作路径。 否则，使用环境变量 <code>GITEA_WORK_DIR</code> 来明确指出程序工作和数据存放路径。</p><p>以下选择其一配置即可：</p><h4 id="设置系统环境变量"><a href="#设置系统环境变量" class="headerlink" title="设置系统环境变量"></a>设置系统环境变量</h4><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 打开环境变量配置文件[root]$ sudo vi /etc/profile# 这个文件是系统级别的 shell 配置文件，可以在其中添加全局环境变量# 在最后一行加入，或者合适位置export GITEA_WORK_DIR=/var/lib/gitea/# 然后保存文件# 使环境变量生效[root]$ source /etc/profile# 或者，可以重新启动系统来使环境变量生效。# 验证环境变量[root]$ echo $GITEA_WORK_DIR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置用户环境变量"><a href="#设置用户环境变量" class="headerlink" title="设置用户环境变量"></a>设置用户环境变量</h4><blockquote><p>用户的配置文件，通常是 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code>。</p></blockquote><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 打开用户环境变量配置文件[git]$ vi ~/.bashrc# 以这个配置文件为例# 在最后一行加入，或者合适位置export GITEA_WORK_DIR=/var/lib/gitea/ # 创建一个名为 MY_VARIABLE 的环境变量PATH=$GITEA_WORK_DIR:$PATH  # 把 MY_VARIABLE 变量的值添加到 PATH 环境变量的前面。这样，系统会优先在 "/path/to/my/directory" 目录中查找命令# 然后保存文件# 使环境变量生效[root]$ source ~/.bashrc# 或者，可以重新启动系统来使环境变量生效。# 验证环境变量[git]$ echo $GITEA_WORK_DIR[git]$ echo $PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Gitea-的文件目录"><a href="#Gitea-的文件目录" class="headerlink" title="Gitea 的文件目录"></a>Gitea 的文件目录</h4><ul><li><code>GITEA_WORK_DIR</code>：工作目录的绝对路径</li><li><code>GITEA_CUSTOM</code>：默认情况下 Gitea 使用默认目录 <code>GITEA_WORK_DIR</code>/custom，您可以使用这个参数来配置 <em>custom</em> 目录</li><li><code>GOGS_WORK_DIR</code>： 已废弃，请使用 <code>GITEA_WORK_DIR</code> 替代</li><li><code>GOGS_CUSTOM</code>： 已废弃，请使用 <code>GITEA_CUSTOM</code> 替代</li></ul><h4 id="操作系统配置"><a href="#操作系统配置" class="headerlink" title="操作系统配置"></a>操作系统配置</h4><ul><li><code>USER</code>：Gitea 运行时使用的系统用户，它将作为一些 repository 的访问地址的一部分</li><li><code>USERNAME</code>： 如果没有配置 <code>USER</code>， Gitea 将使用 <code>USERNAME</code></li><li><code>HOME</code>： 用户的 home 目录，在 Windows 中会使用 <code>USERPROFILE</code> 环境变量</li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>这里以配置systemd启动为例子，<a href="https://docs.gitea.io/zh-cn/installation/linux-service/" title="点击跳转">官方参考教程</a>：<a href="https://docs.gitea.io/zh-cn/installation/linux-service/">https://docs.gitea.io/zh-cn/installation/linux-service/</a></p><p>当然非systemd的<a href="https://docs.gitea.io/zh-cn/installation/install-from-binary/#2-%E9%9D%9E-systemd-%E9%87%8D%E5%90%AF%E6%96%B9%E6%B3%95" title="点击跳转">启动配置参考文档</a>：<a href="https://docs.gitea.io/zh-cn/installation/install-from-binary/#2-%E9%9D%9E-systemd-%E9%87%8D%E5%90%AF%E6%96%B9%E6%B3%95">https://docs.gitea.io/zh-cn/installation/install-from-binary/#2-%E9%9D%9E-systemd-%E9%87%8D%E5%90%AF%E6%96%B9%E6%B3%95</a></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 测试下是否可以正常启动[root] $ GITEA_WORK_DIR=/var/lib/gitea/ /usr/local/bin/gitea web -c /etc/gitea/app.ini# GITEA_WORK_DIR=/var/lib/gitea/ 设置启动时的环境变量# web 传递给 Gitea 二进制文件的参数，告诉它启动 Web 服务器# -c /etc/gitea/app.ini 它使用位于 /etc/gitea/app.ini 的配置文件，目前还没有这个文件，不过没有事，后续会自动生成，当然也可以去官网上拷贝默认的配置项  # 配置文件地址  https://github.com/go-gitea/gitea/blob/main/custom/conf/app.example.ini<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/05/09/cs-frameworks-tools/linux-install-gitea/image-006.png" class="" title="image-006"><h4 id="拷贝gitea-service文件"><a href="#拷贝gitea-service文件" class="headerlink" title="拷贝gitea.service文件"></a>拷贝<code>gitea.service</code>文件</h4><p>链接地址如图 <code>image-004</code></p><img src="/2023/05/09/cs-frameworks-tools/linux-install-gitea/image-004.png" class="" title="image-004"><p>可以从<a href="https://github.com/go-gitea/gitea/blob/main/contrib/systemd/gitea.service" title="跳转地址">官方项目</a>中拷贝：<a href="https://github.com/go-gitea/gitea/blob/main/contrib/systemd/gitea.service">https://github.com/go-gitea/gitea/blob/main/contrib/systemd/gitea.service</a></p><p>注意根据实际配置修改其中的配置项，这里根据所使用的数据库，打开对应数据库服务的注释</p><img src="/2023/05/09/cs-frameworks-tools/linux-install-gitea/image-008.png" class="" title="image-008"><p>修改相关文件地址</p><img src="/2023/05/09/cs-frameworks-tools/linux-install-gitea/image-005.png" class="" title="image-005"><h4 id="拷贝app-ini配置文件"><a href="#拷贝app-ini配置文件" class="headerlink" title="拷贝app.ini配置文件"></a>拷贝app.ini配置文件</h4><blockquote><p>可以提前拷贝配置文件，并修改其中的配置项启动，这样再初次进入系统时候就会有直接引用默认配置了，当然不做设置，当启动服务，在页面配置自动生成也可以。</p></blockquote><p><a href="https://github.com/go-gitea/gitea/blob/main/custom/conf/app.example.ini" title="点击跳转">配置文件原文地址</a>：<a href="https://github.com/go-gitea/gitea/blob/main/custom/conf/app.example.ini">https://github.com/go-gitea/gitea/blob/main/custom/conf/app.example.ini</a></p><p><a href="https://docs.gitea.io/zh-cn/administration/config-cheat-sheet/" title="点击跳转">配置文件说明地址</a>：<a href="https://docs.gitea.io/zh-cn/administration/config-cheat-sheet/">https://docs.gitea.io/zh-cn/administration/config-cheat-sheet/</a></p><img src="/2023/05/09/cs-frameworks-tools/linux-install-gitea/image-007.png" class="" title="image-007"><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 切换用户为 root[root]$ su# 将git服务设置为系统自启动[root]$ sudo systemctl enable gitea# 启动服务[root]$ sudo systemctl start gitea# 查看状态[root]$ systemctl status gitea### 配置防火墙[root]$ firewall-cmd --permanent --zone=public --add-port=3000/tcp[root]$ firewall-cmd --reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意：</strong> 为了让 Web 安装程序可以写入配置文件，临时为 <code>/etc/gitea</code> 路径授予了组外用户 <code>git</code> 写入权限。建议在安装结束后将配置文件的权限设置为只读。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">chmod 750 /etc/giteachmod 640 /etc/gitea/app.ini<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果您不希望通过 <code>Web</code> 安装程序创建配置文件，可以将配置文件设置为仅供 <code>Git</code> 用户只读（owner/group <code>root:git</code>, mode <code>0640</code>）并手工创建配置文件：</p><ul><li>设置 <code>INSTALL_LOCK=true</code> 关闭安装界面</li><li>手动配置数据库连接参数</li><li>使用 <code>gitea generate secret</code> 创建 <code>SECRET_KEY</code> 和 <code>INTERNAL_TOKEN</code></li><li>提供所有必要的密钥</li></ul><p>详情参考 <a href="https://docs.gitea.io/zh-cn/command-line/">命令行文档</a> 中有关 <code>gitea generate secret</code> 的内容。</p></blockquote><h3 id="进入系统"><a href="#进入系统" class="headerlink" title="进入系统"></a>进入系统</h3><p>根据所在服务器地址以及所配置的端口号，通过网页进入<code>Gitea</code></p><blockquote><p>默认地址：<a href="http://localhost:3000/">http://localhost:3000/</a></p></blockquote><p>首次进入系统，可以看到如下截图中的配置页面，根据情况修改配置后，点击立即安装按钮即可</p><img src="/2023/05/09/cs-frameworks-tools/linux-install-gitea/image-000.png" class="" title="image-000"><img src="/2023/05/09/cs-frameworks-tools/linux-install-gitea/image-001.png" class="" title="image-001"><img src="/2023/05/09/cs-frameworks-tools/linux-install-gitea/image-001.png" class="" title="image-20230511000638626"><img src="/2023/05/09/cs-frameworks-tools/linux-install-gitea/image-003.png" class="" title="image-20230510235843254"><img src="/2023/05/09/cs-frameworks-tools/linux-install-gitea/image-002.png" class="" title="image-002"><p>至此安装完成。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>项目首页：<a href="https://gitea.io/zh-cn/">https://gitea.io/zh-cn/</a></p><p>文档地址：<a href="https://docs.gitea.io/zh-cn/">https://docs.gitea.io/zh-cn/</a></p><p>项目地址：<a href="https://github.com/go-gitea/gitea">https://github.com/go-gitea/gitea</a></p>]]></content>
      
      
      <categories>
          
          <category> cs-frameworks-tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> git </tag>
            
            <tag> linux </tag>
            
            <tag> gitea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL学习笔记</title>
      <link href="/2023/04/23/cs-data/data-sql/"/>
      <url>/2023/04/23/cs-data/data-sql/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL学习笔记"><a href="#SQL学习笔记" class="headerlink" title="SQL学习笔记"></a>SQL学习笔记</h1><blockquote><p>本文将基于<code>MySql</code>数据库来进行测试。</p></blockquote><h2 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h2><p>数据库是一种以易于访问的格式存储数据的集合。为了方便管理数据库，使用了一种叫做“<strong>数据库管理系统</strong>”或 <code>DBMS</code>（<code>Database Management System</code>） 的软件应用。我么连接到一个<code>DBMS</code>然后下达查询或者修改数据的指令，<code>DBMS</code>就会执行我们输入的指令并返回结果。</p><img src="/2023/04/23/cs-data/data-sql/image_000.png" class="" title="image_000"><p>现有的几种<code>DBMS</code>被分为两个大类：</p><ul><li><p>关系型（<code>Relational</code>）</p><ul><li><p>在关系型数据库中，把数据存储在利用关系相互链接的表中。每张表都存储一类特定对象的数据，这也是被叫做关系型数据库的原因。</p></li><li><p><code>SQL</code>或者<code>SQUEL</code>就是用来处理这些关系型<code>DBMS</code>的语言。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 类似于</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> products<span class="token keyword">where</span> category <span class="token operator">=</span> <span class="token string">'food'</span><span class="token keyword">order</span> <span class="token keyword">by</span> price<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>目前通用的数据库有 <code>MySql</code>、<code>SQL server</code>、<code>Oracle</code>。每种数据库的<code>SQL</code>语句有所不同，但是操作类似，且都是基于<code>SQL</code>规范。</p></li></ul></li><li><p>非关系型（<code>NoSql</code>）</p></li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h3><p>见本博客文章 <a href="https://robertsunq.github.io/2023/04/13/cs-data/linux-install-mysql/">基于Linux系统安装Mysql</a></p><p>MacOS和Windows系统可以按照安装包的UI界面进行配置安装即可。</p><h3 id="基础数据表创建"><a href="#基础数据表创建" class="headerlink" title="基础数据表创建"></a>基础数据表创建</h3><p>详见脚本：<a href="https://github.com/RobertSunq/data/tree/master/qing/blog/hexo/sql/create-databases.sql" title="点击跳转">create-databases.sql</a> <a href="https://github.com/RobertSunq/data/tree/master/qing/blog/hexo/sql/load_1000_customers.sql" title="点击跳转">load_1000_customers.sql</a>  </p><p>其中<code>load_1000_customers.sql</code> 可在索引部分再使用</p><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><blockquote><p><code>Retrieving Data</code></p></blockquote><h3 id="SELECT-语句"><a href="#SELECT-语句" class="headerlink" title="SELECT 语句"></a>SELECT 语句</h3><h4 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h4><p>首先是选择一个数据库，使用 <code>USE</code> 关键词，在SQL种这些关键词是不区分大小写的，但是最好的写法是使用大写。</p><blockquote><p>当然也可以不用事前选择一个数据库，可以在查询语句种的表名前添加上数据库名的前缀。</p><p><code>SELECT * FROM sql_store.customers;</code></p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 选择一个数据库</span><span class="token keyword">USE</span> sql_store<span class="token punctuation">;</span><span class="token comment">-- Database changed</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>在<code>SQL</code>语句中，使用<code>--</code>作为注释符号，用来注释不需要执行的语句</p></blockquote><p>然后指定需要查询的列，这里使用<code>SELECT</code>关键词，可以指定具体的列名，也可以使用 <code>*</code>来获取<strong>所有的列</strong>。</p><p>在然后是指定明确要查询的表，这里使用<code>FROM</code> 关键词。</p><p>最后使用<code>;</code>来终止每条要执行的语句。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 指定列</span><span class="token keyword">SELECT</span> customer_id<span class="token punctuation">,</span> first_name <span class="token keyword">FROM</span> customers<span class="token punctuation">;</span><span class="token comment">-- 查询所有列</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> customers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>选择语句这里有两个子句就是，<code>SELECT</code>子句和<code>FROM</code>子句。当然还可以搭配其他子句，这里会在后续逐步介绍到。</p><blockquote><p>当然也可以指使用<code>SELECT</code>子句，例如：<code>SELECT 1, 2;</code></p></blockquote><blockquote><p>在SQL语句中，换行符、空白符、制表符在执行SQL语句时都是没有作用的，例如</p><p><code>SELECT 1, 2;</code> 与 <code>SELECT 1,2;</code> 结果相同，没有区别。</p></blockquote><img src="/2023/04/23/cs-data/data-sql/image_001.png" class="" title="image_001"><h4 id="字段运算"><a href="#字段运算" class="headerlink" title="字段运算"></a>字段运算</h4><p>在<code>SELECT</code>子句中，不仅仅可以指定列表，也可以对列进行一些函数计算，例如对于<code>customers</code>表中的<code>points</code>字段（该字段是个数字），我们可以进行一些数学运算。这里的运算优先级与数学中的相同。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> customer_id<span class="token punctuation">,</span> first_name<span class="token punctuation">,</span> points<span class="token punctuation">,</span> points <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">,</span> points <span class="token operator">%</span> <span class="token number">10</span> <span class="token keyword">FROM</span> customers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_002.png" class="" title="image_002"><h4 id="AS关键词"><a href="#AS关键词" class="headerlink" title="AS关键词"></a>AS关键词</h4><p>可以使用<code>()</code>来改变运算顺序，同时也可以使用<code>AS</code> 关键词来设置别名，将结果列设置一个易于读取的名称。同时别名也可以设置在已有列上。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 使用括号来改变运算顺序</span><span class="token comment">-- 并使用 AS 设置别名</span><span class="token keyword">SELECT</span>customer_id<span class="token punctuation">,</span>first_name <span class="token keyword">as</span> tmp_first_name<span class="token punctuation">,</span>points<span class="token punctuation">,</span>points <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">(</span> points <span class="token operator">+</span> <span class="token number">10</span> <span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span> <span class="token keyword">AS</span> discount_factor <span class="token keyword">FROM</span>customers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_003.png" class="" title="image_003"><h4 id="DISTINCT关键词"><a href="#DISTINCT关键词" class="headerlink" title="DISTINCT关键词"></a>DISTINCT关键词</h4><p>使用<code>DISTINCT</code> 关键词可以达到对结果进行去重的效果，即相同的字段只显示一个。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 数据准备</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">`</span>customers<span class="token punctuation">`</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token string">'Babara_1'</span><span class="token punctuation">,</span><span class="token string">'MacCaffrey_1'</span><span class="token punctuation">,</span><span class="token string">'1986-03-29'</span><span class="token punctuation">,</span><span class="token string">'781-932-9755'</span><span class="token punctuation">,</span><span class="token string">'0 Sage Terrace 1'</span><span class="token punctuation">,</span><span class="token string">'Waltham_1'</span><span class="token punctuation">,</span><span class="token string">'MA'</span><span class="token punctuation">,</span><span class="token number">2274</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 查询单列数据，可以看到 state 字段重复值 MA, 如图 image_004</span><span class="token keyword">SELECT</span> state <span class="token keyword">FROM</span> customers<span class="token punctuation">;</span><span class="token comment">-- 然后使用 DISTINCT 来做去重查询, 如图 image_005</span><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> state <span class="token keyword">FROM</span> customers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_004.png" class="" title="image_004"><img src="/2023/04/23/cs-data/data-sql/image_005.png" class="" title="image_005"><h3 id="WHERE语句"><a href="#WHERE语句" class="headerlink" title="WHERE语句"></a>WHERE语句</h3><h4 id="基础结构-1"><a href="#基础结构-1" class="headerlink" title="基础结构"></a>基础结构</h4><p>如果不需要数据表中列，只需要一些符合某种条件的数据是，就可以使用<code>WHERE</code>关键词，来添加过滤条件。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 检索积分值高于 3000 的顾客, 这里 &gt; 是比较运算符之一</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>points <span class="token operator">&gt;</span> <span class="token number">3000</span><span class="token punctuation">;</span><span class="token comment">-- 检索 state 等于 MA 的数据</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>state <span class="token operator">=</span> <span class="token string">'MA'</span><span class="token punctuation">;</span><span class="token comment">-- 检索 birth_date 大于 1990-01-01 的数据</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>birth_date <span class="token operator">&gt;</span> <span class="token string">'1991-01-01'</span><span class="token punctuation">;</span><span class="token comment">-- 注意，在SQL中可以使用字符串来对 date （日期）的字段进行比较，这里并不是进行字符串比较</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>在<code>WHERE</code>语句中的比较运算符包含：</p><ul><li><code>&gt;</code> <ul><li>小于</li></ul></li><li><code>&gt;=</code><ul><li>小于等于</li></ul></li><li><code>&lt;</code><ul><li>大于</li></ul></li><li><code>&lt;=</code><ul><li>大于等于</li></ul></li><li><code>=</code><ul><li>等于</li></ul></li><li><code>!=</code><ul><li>不等于</li></ul></li><li><code>&lt;&gt;</code><ul><li>不等于</li></ul></li></ul><h4 id="AND、OR、NOT运算符"><a href="#AND、OR、NOT运算符" class="headerlink" title="AND、OR、NOT运算符"></a>AND、OR、NOT运算符</h4><p>如果对数据要有多个条件进行逻辑运算组合筛选，就需要使用到逻辑运算符 <code>AND</code>、<code>OR</code>、<code>NOT</code>关键词</p><p><code>AND</code> 逻辑与，即需要多个条件并列满足</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询 生日大于  1991-01-01 且 小于 1993-01-01 的消费者</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>birth_date <span class="token operator">&gt;</span> <span class="token string">'1991-01-01'</span> <span class="token operator">AND</span> birth_date <span class="token operator">&lt;</span> <span class="token string">'1993-01-01'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>OR</code> 逻辑或，即多个条件满足一个即可</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询 生日大于  1993-01-01 或者 小于 1991-01-01 的消费者</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>birth_date <span class="token operator">&gt;</span> <span class="token string">'1993-01-01'</span> <span class="token operator">OR</span> birth_date <span class="token operator">&lt;</span> <span class="token string">'1991-01-01'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>NOT</code> 逻辑非，即对条件进行取反。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询不符合条件 （生日大于 1991-01-01 且 积分大于 1000 ）的消费者</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span><span class="token operator">NOT</span> <span class="token punctuation">(</span>birth_date <span class="token operator">&gt;</span> <span class="token string">'1991-01-01'</span> <span class="token operator">AND</span> points <span class="token operator">&gt;</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="IN-运算符"><a href="#IN-运算符" class="headerlink" title="IN 运算符"></a>IN 运算符</h4><p>用于对数据中某个字段符合多个指定值时的行，例如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 要查询 state 是MA或者VA或者CO的消费者，可以使用如下方式。</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>    state <span class="token operator">=</span> <span class="token string">'MA'</span> <span class="token operator">OR</span> state <span class="token operator">=</span> <span class="token string">'VA'</span> <span class="token operator">OR</span> state <span class="token operator">=</span> <span class="token string">'CO'</span><span class="token punctuation">;</span>    <span class="token comment">-- 但是这样的使用 OR 进行排列导致语句什么臃肿，所有可以使用运算符 IN 来进行简化</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>    state <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'MA'</span><span class="token punctuation">,</span> <span class="token string">'VA'</span><span class="token punctuation">,</span> <span class="token string">'CO'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以理解为数学中，一个属性是否属于一个集合。 <code>a ∈ A , (A = [a, b, c])</code>  </p></blockquote><h4 id="BETWEEN-运算符"><a href="#BETWEEN-运算符" class="headerlink" title="BETWEEN 运算符"></a>BETWEEN 运算符</h4><p>用于查询数据中某个字段属于一个范围的行，例如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询 积分在 1000 与 3000 之间的用户，可以使用如下方式</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>points <span class="token operator">&gt;=</span> <span class="token number">1000</span> <span class="token operator">AND</span> points <span class="token operator">&lt;=</span> <span class="token number">3000</span><span class="token punctuation">;</span><span class="token comment">-- 也可以使用 BETWEEN 进行范围过滤</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>points <span class="token operator">BETWEEN</span> <span class="token number">1000</span> <span class="token operator">AND</span> <span class="token number">3000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以理解为数学中国的，  值属于一个闭合区间， <code>a ∈[1000, 3000]</code></p></blockquote><h4 id="LIKE-运算符"><a href="#LIKE-运算符" class="headerlink" title="LIKE  运算符"></a>LIKE  运算符</h4><p>用于查询某个字段中是否包含特定字符串的行，例如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询名字中以 b 开头的任意长度的行</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>    last_name <span class="token operator">LIKE</span> <span class="token string">'b%'</span><span class="token punctuation">;</span><span class="token comment">-- 查询名字中以 b 结尾</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>    last_name <span class="token operator">LIKE</span> <span class="token string">'%b'</span><span class="token punctuation">;</span>    <span class="token comment">-- 查询名字中包含 b 的行</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>    last_name <span class="token operator">LIKE</span> <span class="token string">'%b%'</span><span class="token punctuation">;</span>    <span class="token comment">-- 查询名字是两个字符长度，且以 y 为结尾的行</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>    last_name <span class="token operator">LIKE</span> <span class="token string">'_y'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="模糊匹配符"><a href="#模糊匹配符" class="headerlink" title="模糊匹配符"></a>模糊匹配符</h5><p> <strong><code>%</code> 为任意长度字符模糊匹配符</strong>，表示任意字段</p><p><strong><code>_</code>为单字符模糊匹配符</strong>，表示一个字段</p><p>对其使用规则总结如下：</p><table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td><code>A%</code></td><td><strong>右模糊匹配</strong>，即以A开头后，右侧可以是任意长度字符（任意长度包含长度为 0）</td></tr><tr><td><code>%B</code></td><td><strong>左模糊匹配</strong>， 即以B为结尾，左侧可以是任意长度字符</td></tr><tr><td><code>%C%</code></td><td><strong>全模糊匹配</strong>，即包含C字符，左右两侧都可以谁任意长度字符</td></tr><tr><td><code>y_</code></td><td><strong>固定长度模糊匹配</strong>，<code>_</code>用来代表任意一个字符。</td></tr><tr><td><code>y_A___c%</code></td><td>两个模糊匹配符号可以混合使用。</td></tr></tbody></table><h4 id="REGEXP-运算符"><a href="#REGEXP-运算符" class="headerlink" title="REGEXP 运算符"></a>REGEXP 运算符</h4><p>该运算符是<strong>正则表达式</strong>（<code>regular expression</code>）的缩写，即使用正则表达式来进行搜索字符串，使用正则表达式可以进行比上述 <code>LIKE</code> 运算符更加复杂且多样化的匹配模式（匹配符号不再仅限于 <code>%</code> 和 <code>_</code>）。</p><p>至于正则表达式子的语法，这里不做过多的介绍，感兴趣的可以另行查询。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 搜索名字中包含 field 字符的顾客</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>   last_name <span class="token operator">REGEXP</span> <span class="token string">'field'</span><span class="token punctuation">;</span> <span class="token comment">-- 搜索名字中以 field 开头或者结尾的顾客</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>   last_name <span class="token operator">REGEXP</span> <span class="token string">'^field|field$'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="IS-NULL-运算符"><a href="#IS-NULL-运算符" class="headerlink" title="IS NULL 运算符"></a>IS NULL 运算符</h4><p>用于查询某些字段缺失的行，可以认为是字段值为 <code>NULL</code></p><blockquote><p>注意：这里说的是数据行中某列没有属性值时，此时字段的值认为时 NULL （一种缺省状态），而不是字段真实值为字符串 NULL</p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询数据中手机号 不存在的 顾客</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>   phone <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="IS-NOT-NULL-运算符"><a href="#IS-NOT-NULL-运算符" class="headerlink" title="IS NOT NULL 运算符"></a>IS NOT NULL 运算符</h4><p>用于从查询某些字段值存在，不为 <code>NULL</code> 的行。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询数据中手机号 存在的 顾客</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">WHERE</span>   phone <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ORDER-BY-语句"><a href="#ORDER-BY-语句" class="headerlink" title="ORDER BY 语句"></a>ORDER BY 语句</h3><p>用于对查询的结果数据进行排序，可以指定排序使用的列以及大小顺序（递增(<code>ASC</code>)、递减(<code>DESC</code>)）。</p><p>在不指定的情况下，默认按照主键递增排序；指定排序字段但是不指定大小顺序时默认递增。（<em>是否跟具体的数据库管理系统有关未查证，待查证</em>）</p><blockquote><p>这里使用的时<code>MySql</code>数据库，所有在排序的时候，排序字段可以不用存在于查询结果列中（即可以不用在 <code>SELECT</code> 子句中），即可以不用查询<code>A</code>列，但是使用<code>A</code>列排序。</p><p>一些其他数据库管理系统中，默认配置下需要排序字段必须存在于查询结果列中。</p></blockquote><p>例如</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 这里我们通过关键词 order by 指定按照姓氏排序</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">ORDER</span> <span class="token keyword">BY</span>first_name<span class="token punctuation">;</span><span class="token comment">-- 可以指定递减排序</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">ORDER</span> <span class="token keyword">BY</span>first_name <span class="token keyword">DESC</span><span class="token punctuation">;</span><span class="token comment">-- 也可以指定多个字段排序，即先按照第一个字段排序，在按照第二个字段排序</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">ORDER</span> <span class="token keyword">BY</span>first_name <span class="token keyword">DESC</span><span class="token punctuation">,</span> state<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="LIMIT-语句"><a href="#LIMIT-语句" class="headerlink" title="LIMIT 语句"></a>LIMIT 语句</h3><p>限制返回数据的数量，以及偏移量。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 限制只返回 3 条数据。限制数量超过了总数时，将返回所有数据</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">LIMIT</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">-- 限制偏移量以及数据量，通常应用于分页查询</span><span class="token comment">-- page 1: 1 - 3</span><span class="token comment">-- page 2: 4 - 6</span><span class="token comment">-- page 3: 7 - 9</span><span class="token comment">-- 从第6条记录开始偏移计数，返回三条数据</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">LIMIT</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">-- 查询结果中 id 是从 7 - 9</span><span class="token comment">-- 于上节的排序同时使用，就是返回某个顺序下的限制数量</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>customers <span class="token keyword">ORDER</span> <span class="token keyword">BY</span>points <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>通常情况下，可能需要使用到多列数据会存在于不同的表之中，这时候就需要使用到<code>连接</code>来将多张表连接到一块来获取到不同表中的多列数据。</p><img src="/2023/04/23/cs-data/data-sql/image_006.png" class="" title="image_006"><blockquote><p>图片来源：百度百科</p></blockquote><ul><li><strong>内连接</strong>（<code>INNER JOIN</code>）<ul><li>只连接匹配的行</li><li><code>SELECT &lt;select_list&gt; FROM TableA A INNER JOIN TableB B ON A.Key = B.Key;</code></li><li>图<code>image_006</code>最中间的图列</li></ul></li><li><strong>左连接</strong>（<code>LEFT JOIN</code>）<ul><li>左外连接</li><li>包含左边表的全部行（不管右边的表中是否存在于左边表适配的行）以及右边表中全部匹配的行</li><li><code>SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key;</code></li><li>图<code>image_006</code>左上角的图列</li></ul></li><li><strong>右连接</strong>（<code>RIGHT JOIN</code>）<ul><li>右外连接</li><li>包含右边表的全部行（不管左边的表中是否存在与右边表适配的行）以及左边表中全部匹配的行</li><li><code>SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key;</code></li><li>图<code>image_006</code>右上角的图列</li></ul></li><li><strong>全连接</strong>（<code>FULL JOIN</code>）<ul><li>全外简介</li><li>包含左、右两个表的全部行，不管在另一边的表中是否存在于它们匹配的行</li><li><code>SELECT &lt;select_list&gt; FROM TableA A FULL JOIN TableB B ON A.Key = B.Key;</code></li><li>图<code>image_006</code>左下角的图列</li></ul></li><li><strong>θ连接</strong><ul><li>使用等值以外的条件来匹配左、右两个表中的行</li><li><code>SELECT &lt;select_list&gt; FROM TableA A FULL OUTER JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL OR B.Key IS NULL;</code></li><li><code>SELECT &lt;select_list&gt; FROM TableA A JOIN TableB B ON A.Key != B.Key;</code></li><li>图<code>image_006</code>右下角的图列</li></ul></li><li><strong>交叉连接</strong><ul><li>生成笛卡尔积——不适用任何匹配或者选取条件，而是直接将一个数据源中的每个行于另一个数据源的每个行一一匹配</li><li><code>SELECT &lt;select_list&gt; FROM TableA A, TableB B</code></li></ul></li></ul><h4 id="INNER-JOIN-内连接"><a href="#INNER-JOIN-内连接" class="headerlink" title="INNER JOIN 内连接"></a>INNER JOIN 内连接</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 内连接，这里的 INNER 可以省略不写。</span><span class="token comment">-- 使用 ON 来指定两张表的连接条件</span><span class="token comment">-- 通过顾客ID将 订单和顾客关联起来</span><span class="token keyword">SELECT</span><span class="token operator">*</span><span class="token keyword">FROM</span>orders<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> customers  <span class="token keyword">ON</span> orders<span class="token punctuation">.</span>customer_id <span class="token operator">=</span> customers<span class="token punctuation">.</span>customer_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="LEFT-JOIN-左外连接"><a href="#LEFT-JOIN-左外连接" class="headerlink" title="LEFT JOIN 左外连接"></a>LEFT JOIN 左外连接</h4><p>又称为左连接。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 返回 包含右边表的全部行（不管左边的表中是否存在与右边表适配的行）以及左边表中全部匹配的行</span><span class="token keyword">SELECT</span>c<span class="token punctuation">.</span>customer_id<span class="token punctuation">,</span>c<span class="token punctuation">.</span>first_name<span class="token punctuation">,</span>o<span class="token punctuation">.</span>order_id <span class="token keyword">FROM</span>customers c<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> orders o <span class="token keyword">ON</span> o<span class="token punctuation">.</span>customer_id <span class="token operator">=</span> c<span class="token punctuation">.</span>customer_id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span>c<span class="token punctuation">.</span>customer_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="RIGHT-JOIN-右外连接"><a href="#RIGHT-JOIN-右外连接" class="headerlink" title="RIGHT JOIN 右外连接"></a>RIGHT JOIN 右外连接</h4><p>又称为右连接。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 返回 包含左边表的全部行（不管右边的表中是否存在于左边表适配的行）以及右边表中全部匹配的行</span><span class="token keyword">SELECT</span>c<span class="token punctuation">.</span>customer_id<span class="token punctuation">,</span>c<span class="token punctuation">.</span>first_name<span class="token punctuation">,</span>o<span class="token punctuation">.</span>order_id <span class="token keyword">FROM</span>customers c<span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> orders o <span class="token keyword">ON</span> o<span class="token punctuation">.</span>customer_id <span class="token operator">=</span> c<span class="token punctuation">.</span>customer_id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span>c<span class="token punctuation">.</span>customer_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 生成笛卡尔积——不适用任何匹配或者选取条件，而是直接将一个数据源中的每个行于另一个数据源的每个行一一匹配</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> customers c<span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> products p<span class="token punctuation">;</span><span class="token comment">-- 也可也直接省略关键词 CROSS JOIN</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> customers c<span class="token punctuation">,</span> products p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="指定列名"><a href="#指定列名" class="headerlink" title="指定列名"></a>指定列名</h4><p>在连接查询中，SELECT 语句中可以指定所有连接表中的字段，例如</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 指定 订单表中的订单ID 和 顾客表中的顾客名</span><span class="token keyword">SELECT</span>order_id<span class="token punctuation">,</span> first_name<span class="token keyword">FROM</span>orders<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> customers  <span class="token keyword">ON</span> orders<span class="token punctuation">.</span>customer_id <span class="token operator">=</span> customers<span class="token punctuation">.</span>customer_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果连接的表中存在列表相同的，可以通过在列名前指定表前缀来查询（不重复的列也可以使用表前缀指定，但是通常可以省略）。</p><p>如果不指定表前缀的话，数据库管理器将会无法确定查询的是哪张表中列而报错。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 使用前缀指定表的列</span><span class="token keyword">SELECT</span>orders<span class="token punctuation">.</span>customer_id<span class="token punctuation">,</span> customers<span class="token punctuation">.</span>customer_id<span class="token punctuation">,</span> order_id<span class="token punctuation">,</span> first_name<span class="token keyword">FROM</span>orders<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> customers  <span class="token keyword">ON</span> orders<span class="token punctuation">.</span>customer_id <span class="token operator">=</span> customers<span class="token punctuation">.</span>customer_id<span class="token punctuation">;</span><span class="token comment">-- 设置别名来区分</span><span class="token keyword">SELECT</span>orders<span class="token punctuation">.</span>customer_id <span class="token keyword">as</span> customer_id_in_orders<span class="token punctuation">,</span>    customers<span class="token punctuation">.</span>customer_id <span class="token keyword">as</span> customer_id_in_customers<span class="token punctuation">,</span>    order_id<span class="token punctuation">,</span>    first_name<span class="token keyword">FROM</span>orders<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> customers  <span class="token keyword">ON</span> orders<span class="token punctuation">.</span>customer_id <span class="token operator">=</span> customers<span class="token punctuation">.</span>customer_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以对表设置别名来简化指定表名时的复杂度</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 其中给表设置别名的关键词 AS 可以省略</span><span class="token keyword">SELECT</span>o<span class="token punctuation">.</span>order_id<span class="token punctuation">,</span> c<span class="token punctuation">.</span>first_name<span class="token keyword">FROM</span>orders <span class="token keyword">AS</span> o<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> customers <span class="token keyword">AS</span> c<span class="token keyword">ON</span> o<span class="token punctuation">.</span>customer_id <span class="token operator">=</span> c<span class="token punctuation">.</span>customer_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="跨数据库连接"><a href="#跨数据库连接" class="headerlink" title="跨数据库连接"></a>跨数据库连接</h4><p>有时候需要跨数据库来进行表之间的连接，这里就需要对访问的表指定其所在数据库前缀了，例如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 注意，保证使用的账号具有跨数据库的权限</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>sql_store<span class="token punctuation">.</span>order_items oi<span class="token keyword">JOIN</span> sql_inventory<span class="token punctuation">.</span>products p <span class="token keyword">ON</span> oi<span class="token punctuation">.</span>product_id <span class="token operator">=</span> p<span class="token punctuation">.</span>product_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意这里对所有的数据表都添加了数据库前缀，如果你当前指定了默认使用的数据库，可以对这个库中的表不添加前缀</p></blockquote><h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><p>即表自身与自身进行连接。</p><p>例如，在表 <code>employees</code> 表中，有一个员工<code>ID</code>（<code>employee_id</code>），以及一个 上级管理者<code>ID</code>（<code>reports_to</code>）。这里可以选择表中一行将 <code>reports_to</code> 字段设置为<code>NULL</code>， 标识这个员工没有上级管理者，是公司的<code>CEO</code>。这时候如果我们需要同时查询员工以及员工的上级管理者的信息，就需要使用自连接。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 切换数据库</span><span class="token keyword">USE</span> sql_hr<span class="token punctuation">;</span><span class="token comment">-- 自内连接</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>employees e<span class="token keyword">JOIN</span> employees m <span class="token keyword">ON</span> e<span class="token punctuation">.</span>reports_to <span class="token operator">=</span> m<span class="token punctuation">.</span>employee_id<span class="token punctuation">;</span><span class="token comment">-- 指定查询列，由于是一张表，所以所有的列都是重复的</span><span class="token keyword">SELECT</span>e<span class="token punctuation">.</span>employee_id<span class="token punctuation">,</span>e<span class="token punctuation">.</span>first_name<span class="token punctuation">,</span>m<span class="token punctuation">.</span>first_name manager_name<span class="token keyword">FROM</span>employees e<span class="token keyword">JOIN</span> employees m <span class="token keyword">ON</span> e<span class="token punctuation">.</span>reports_to <span class="token operator">=</span> m<span class="token punctuation">.</span>employee_id<span class="token punctuation">;</span><span class="token comment">-- 自外连接</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>employees e<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> employees m <span class="token keyword">ON</span> e<span class="token punctuation">.</span>reports_to <span class="token operator">=</span> m<span class="token punctuation">.</span>employee_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h4><p>在需要使用到多张表进行连接的时候，其语法与上述章节中两张表的类似，就是添加需要的合适连接关联词与<code>ON</code>关联条件连接即可。例如</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span>o<span class="token punctuation">.</span>order_id<span class="token punctuation">,</span>    o<span class="token punctuation">.</span>order_date<span class="token punctuation">,</span>    c<span class="token punctuation">.</span>first_name<span class="token punctuation">,</span>    c<span class="token punctuation">.</span>last_name<span class="token punctuation">,</span>    os<span class="token punctuation">.</span>name <span class="token keyword">AS</span> <span class="token keyword">status</span><span class="token keyword">FROM</span>orders o<span class="token keyword">JOIN</span> customers c <span class="token keyword">ON</span> o<span class="token punctuation">.</span>customer_id <span class="token operator">=</span> c<span class="token punctuation">.</span>customer_id<span class="token keyword">JOIN</span> order_statuses os <span class="token keyword">ON</span> o<span class="token punctuation">.</span><span class="token punctuation">`</span><span class="token keyword">status</span><span class="token punctuation">`</span> <span class="token operator">=</span> os<span class="token punctuation">.</span>order_status_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复合连接条件"><a href="#复合连接条件" class="headerlink" title="复合连接条件"></a>复合连接条件</h4><p>在进行连接的时候，如果做连接的条件不止一个时，就需要使用到复合连接条件了，其具体语法就是在关键词 ON 后添加多个连接条件，连接条件语法与WHERE语句中类似。例如</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 将订单元素表与订单元素备注关联起来，这里需要符合两张表中的产品ID和订单ID相同才符合连接条件</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>order_items oi<span class="token keyword">JOIN</span> order_item_notes oin <span class="token keyword">ON</span> oi<span class="token punctuation">.</span>order_id <span class="token operator">=</span> oin<span class="token punctuation">.</span>order_id <span class="token operator">AND</span> oi<span class="token punctuation">.</span>product_id <span class="token operator">=</span> oin<span class="token punctuation">.</span>product_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="隐式连接语法"><a href="#隐式连接语法" class="headerlink" title="隐式连接语法"></a>隐式连接语法</h4><p><code>Implpicit Join Syntax</code>。进来还是使用显式的连接语法，隐式连接语法尽管可以省略部分语句，但是叫容易出错。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 对于简单的连接关系，可以省略 JOIN 关键词，采用 WHERE 条件来隐式的连接</span><span class="token keyword">SELECT</span><span class="token operator">*</span><span class="token keyword">FROM</span>orders <span class="token keyword">AS</span> o<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> customers <span class="token keyword">AS</span> c<span class="token keyword">ON</span> o<span class="token punctuation">.</span>customer_id <span class="token operator">=</span> c<span class="token punctuation">.</span>customer_id<span class="token punctuation">;</span><span class="token comment">-- 隐式连接语法如下</span><span class="token keyword">SELECT</span><span class="token operator">*</span><span class="token keyword">FROM</span>orders o<span class="token punctuation">,</span> customers c<span class="token keyword">WHERE</span>o<span class="token punctuation">.</span>customer_id <span class="token operator">=</span> c<span class="token punctuation">.</span>customer_id<span class="token punctuation">;</span><span class="token comment">-- 注意这里 WHERE 条件语句不可省略，如果省略了就成交叉连接了，数据结果就是 n * m</span><span class="token keyword">SELECT</span><span class="token operator">*</span><span class="token keyword">FROM</span>orders o<span class="token punctuation">,</span> customers c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="USING-语句"><a href="#USING-语句" class="headerlink" title="USING 语句"></a>USING 语句</h4><p>在<code>mysql</code>中可以使用 <code>USING</code>来省略连接条件（<code>o.customer_id = c.customer_id</code>），这需要<strong>连接的两列在两张表中列名相同</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span>c<span class="token punctuation">.</span>customer_id<span class="token punctuation">,</span>c<span class="token punctuation">.</span>first_name<span class="token punctuation">,</span>o<span class="token punctuation">.</span>order_id<span class="token punctuation">,</span>sh<span class="token punctuation">.</span>name <span class="token keyword">AS</span> shipper <span class="token keyword">FROM</span>customers c<span class="token keyword">JOIN</span> orders o <span class="token comment">-- ON o.customer_id = c.customer_id </span><span class="token keyword">USING</span> <span class="token punctuation">(</span> customer_id <span class="token punctuation">)</span><span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> shippers sh<span class="token comment">-- ON o.shipper_id = sh.customer_id </span><span class="token keyword">USING</span> <span class="token punctuation">(</span> shipper_id <span class="token punctuation">)</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span>c<span class="token punctuation">.</span>customer_id<span class="token punctuation">;</span><span class="token comment">-- 多个连接条件时</span><span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span>order_items oi<span class="token keyword">JOIN</span> order_item_notes oin <span class="token comment">-- ON oi.order_id = oin.order_id AND oi.product_id = oin.product_id;</span><span class="token keyword">USING</span> <span class="token punctuation">(</span> order_id<span class="token punctuation">,</span> product_id <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><p>连接时不需要输入连接条件，交由数据库引擎自行决定基于共同的列连接。不推荐使用，因为不可控。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> orders o<span class="token keyword">NATURAL</span> <span class="token keyword">JOIN</span> customers c<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h4><p>结合多个查询的结果</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 2019-01-01 之后的为活跃的订单</span><span class="token keyword">SELECT</span>order_id<span class="token punctuation">,</span>order_date<span class="token punctuation">,</span><span class="token string">'Active'</span> <span class="token keyword">AS</span> <span class="token keyword">STATUS</span> <span class="token keyword">FROM</span>orders <span class="token keyword">WHERE</span>order_date <span class="token operator">&gt;=</span> <span class="token string">'2019-01-01'</span><span class="token punctuation">;</span><span class="token comment">-- 2019-01-01 之后的为完成的订单</span><span class="token keyword">SELECT</span>order_id<span class="token punctuation">,</span>order_date<span class="token punctuation">,</span><span class="token string">'Archived'</span> <span class="token keyword">AS</span> <span class="token keyword">STATUS</span> <span class="token keyword">FROM</span>orders <span class="token keyword">WHERE</span>order_date <span class="token operator">&lt;</span> <span class="token string">'2019-01-01'</span><span class="token punctuation">;</span><span class="token comment">-- 通过使用 UNION 将两个查询结果合并， 其中返回结果的列明，取决于第一个查询的结果</span><span class="token keyword">SELECT</span>order_id<span class="token punctuation">,</span>order_date<span class="token punctuation">,</span><span class="token string">'Active'</span> <span class="token keyword">AS</span> <span class="token keyword">STATUS</span> <span class="token keyword">FROM</span>orders <span class="token keyword">WHERE</span>order_date <span class="token operator">&gt;=</span> <span class="token string">'2019-01-01'</span> <span class="token keyword">UNION</span><span class="token keyword">SELECT</span>order_id<span class="token punctuation">,</span>order_date<span class="token punctuation">,</span><span class="token string">'Archived'</span> <span class="token keyword">AS</span> <span class="token keyword">STATUS</span> <span class="token keyword">FROM</span>orders <span class="token keyword">WHERE</span>order_date <span class="token operator">&lt;</span> <span class="token string">'2019-01-01'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><blockquote><p><code>Inserting Data</code></p></blockquote><h3 id="插入单行"><a href="#插入单行" class="headerlink" title="插入单行"></a>插入单行</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 第一列为主键列，因为这里对主键列设置了自增，以及主键不可重复，所以最好不要使用手动设置值，而是由引擎自动生成</span><span class="token comment">-- DEFAULT 由引擎根据默认值自动填充</span><span class="token comment">-- 不指定列名时，默认按照创建表时候的顺序插入</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token keyword">DEFAULT</span><span class="token punctuation">,</span> <span class="token string">'John'</span><span class="token punctuation">,</span> <span class="token string">'Smith'</span><span class="token punctuation">,</span> <span class="token string">'1990-01-01'</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token string">'address'</span><span class="token punctuation">,</span> <span class="token string">'city'</span><span class="token punctuation">,</span> <span class="token string">'CA'</span><span class="token punctuation">,</span> <span class="token keyword">DEFAULT</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 也可也指定列表</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers <span class="token punctuation">(</span>customer_id<span class="token punctuation">,</span> first_name<span class="token punctuation">,</span> last_name<span class="token punctuation">,</span> birth_date<span class="token punctuation">,</span> phone<span class="token punctuation">,</span> address<span class="token punctuation">,</span> city<span class="token punctuation">,</span> state<span class="token punctuation">,</span> points<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token keyword">DEFAULT</span><span class="token punctuation">,</span> <span class="token string">'John'</span><span class="token punctuation">,</span> <span class="token string">'Smith'</span><span class="token punctuation">,</span> <span class="token string">'1990-01-01'</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token string">'address'</span><span class="token punctuation">,</span> <span class="token string">'city'</span><span class="token punctuation">,</span> <span class="token string">'CA'</span><span class="token punctuation">,</span> <span class="token keyword">DEFAULT</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 当然也可以对列名的顺序进行调整，只需要保证值与其一一对应即可</span><span class="token comment">-- 这里调整了名字和姓氏的顺序</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers <span class="token punctuation">(</span>customer_id<span class="token punctuation">,</span> last_name<span class="token punctuation">,</span> first_name<span class="token punctuation">,</span> birth_date<span class="token punctuation">,</span> phone<span class="token punctuation">,</span> address<span class="token punctuation">,</span> city<span class="token punctuation">,</span> state<span class="token punctuation">,</span> points<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token keyword">DEFAULT</span><span class="token punctuation">,</span> <span class="token string">'Smith'</span><span class="token punctuation">,</span> <span class="token string">'John'</span><span class="token punctuation">,</span> <span class="token string">'1990-01-01'</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token string">'address'</span><span class="token punctuation">,</span> <span class="token string">'city'</span><span class="token punctuation">,</span> <span class="token string">'CA'</span><span class="token punctuation">,</span> <span class="token keyword">DEFAULT</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 如果对于一些由默认值的列，或者没有设置必填的列可以在插入的时候不指定值</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers <span class="token punctuation">(</span>first_name<span class="token punctuation">,</span> last_name<span class="token punctuation">,</span> address<span class="token punctuation">,</span> city<span class="token punctuation">,</span> state<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'John_1'</span><span class="token punctuation">,</span> <span class="token string">'Smith_1'</span><span class="token punctuation">,</span> <span class="token string">'address'</span><span class="token punctuation">,</span> <span class="token string">'city'</span><span class="token punctuation">,</span> <span class="token string">'CA'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入多行"><a href="#插入多行" class="headerlink" title="插入多行"></a>插入多行</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 插入多行语法基本于上节的单行类似。 不同的地方在于 VALUES 之后的值可以设置多组。</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> shippers <span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'Shipper1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'Shipper2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'Shipper3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多张表插入行"><a href="#多张表插入行" class="headerlink" title="多张表插入行"></a>多张表插入行</h3><p>主要应用于有多张表关联之间存在<code>ID</code>关联的情况。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> orders <span class="token punctuation">(</span>customer_id<span class="token punctuation">,</span> order_date<span class="token punctuation">,</span> <span class="token keyword">status</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'2019-01-02'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> order_items<span class="token keyword">VALUES</span><span class="token punctuation">(</span>LAST_INSERT_ID<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.95</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>LAST_INSERT_ID<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.95</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 在MYSQL中有一个内置方法用来获取 最近插入的ID， 即 LAST_INSERT_ID(); 这个方法视不同的数据库有不同的方法</span><span class="token keyword">SELECT</span> LAST_INSERT_ID<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 将一张表中的数据复制到另一张表</span><span class="token comment">-- 如果没有表，创建一张表，复制原始表的结构以及数据</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> orders_archived <span class="token keyword">AS</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> orders<span class="token punctuation">;</span><span class="token comment">-- 这里有个问题，复制的新表会忽略掉原始表中的索引以及自增这些属性</span><span class="token comment">-- 这里的 “SELECT * FROM orders” 属于sql中子查询的部分</span><span class="token comment">-- 如果已经有表的存在，只需要复制数据，（当然子查询部分可以使用一些条件属性来复制部分的数据）</span><span class="token keyword">INSERT</span>  <span class="token keyword">INTO</span> orders_archived <span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> orders <span class="token keyword">WHERE</span> order_date <span class="token operator">&lt;</span> <span class="token string">'2019-01-01'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><blockquote><p><code>Updating Data</code></p></blockquote><h3 id="更新单行"><a href="#更新单行" class="headerlink" title="更新单行"></a>更新单行</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> sql_invoicing<span class="token punctuation">;</span><span class="token comment">-- 根据条件更新一行数据, 这里指定了ID为过滤条件，所以只有一行会符合条件，故只会更新一行数据，本质上是根据条件更新</span><span class="token keyword">UPDATE</span> invoices <span class="token keyword">SET</span> payment_total <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> payment_date <span class="token operator">=</span> <span class="token string">'2019-03-01'</span><span class="token keyword">WHERE</span> invoice_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">-- 有默认值的行，也可以设置为默认值</span><span class="token keyword">UPDATE</span> invoices <span class="token keyword">SET</span> payment_total <span class="token operator">=</span> <span class="token keyword">DEFAULT</span><span class="token punctuation">,</span> payment_date <span class="token operator">=</span> <span class="token string">'2019-03-01'</span><span class="token keyword">WHERE</span> invoice_id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="更新多行"><a href="#更新多行" class="headerlink" title="更新多行"></a>更新多行</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 更新多行基本语法于上节更新一行一样，不过是限定条件去匹配多行就可以更新了，本质上也是根据条件更新</span><span class="token keyword">UPDATE</span> invoices<span class="token keyword">SET</span> payment_total <span class="token operator">=</span> invoice_total <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">,</span>payment_date <span class="token operator">=</span> due_date<span class="token keyword">WHERE</span> client_id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="更新语句中使用子查询"><a href="#更新语句中使用子查询" class="headerlink" title="更新语句中使用子查询"></a>更新语句中使用子查询</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 通过子查询部分来更新，本质上也是根据条件更新</span><span class="token keyword">UPDATE</span> invoices<span class="token keyword">SET</span> payment_total <span class="token operator">=</span> invoice_total <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">,</span>payment_date <span class="token operator">=</span> due_date<span class="token keyword">WHERE</span> client_id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> client_id                   <span class="token keyword">FROM</span> clients                  <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'Myworks'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 如果子查询结果有多行，中间的连接关键字可以换成 IN， 当然这里可以根据实际需求可以使用多种限定的组合</span><span class="token keyword">UPDATE</span> invoices<span class="token keyword">SET</span> payment_total <span class="token operator">=</span> invoice_total <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">,</span>payment_date <span class="token operator">=</span> due_date<span class="token keyword">WHERE</span> client_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> client_id                   <span class="token keyword">FROM</span> clients                  <span class="token keyword">WHERE</span> state <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'CA'</span><span class="token punctuation">,</span> <span class="token string">'NY'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">UPDATE</span> invoices<span class="token keyword">SET</span> payment_total <span class="token operator">=</span> invoice_total <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">,</span>payment_date <span class="token operator">=</span> due_date<span class="token keyword">WHERE</span> payment_date <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><blockquote><p><code>Deleting Data</code></p></blockquote><h3 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 类似于更新语句，根据指定条件删除数据</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> invoices <span class="token keyword">WHERE</span> invoice_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">-- 这里如果去掉了限制条件，将会是删除所有数据</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> invoices<span class="token punctuation">;</span><span class="token comment">-- 类似于更新语句，也可以使用子查询</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> invoices<span class="token keyword">WHERE</span> client_id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>     <span class="token keyword">FROM</span> clients    <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'Myworks'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><blockquote><p><code>Summarizing Data</code></p></blockquote><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>MySql中有很多函数，其中有一写聚合函数是取一系列的只并根据规则合并为一个单一的值。例如</p><ul><li><code>MAX()</code><ul><li>最大值</li></ul></li><li><code>MIN()</code><ul><li>最小值</li></ul></li><li><code>AVG()</code><ul><li>平均值</li></ul></li><li><code>SUM()</code><ul><li>求和</li></ul></li><li><code>COUNT()</code><ul><li>计数</li></ul></li></ul><blockquote><p>注意，这里的聚合函数默认只统计非空值的行，如果所统计的列中存在空值，将不会被计算。</p><p>使用<code>COUNT()</code>时，如果想要统计空值，可以使用<code>COUNT(*)</code>语法来统计。</p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> sql_invoicing<span class="token punctuation">;</span><span class="token comment">-- 应用函数在指定的列上，当然下方也可以添加 WHERE 语句来过滤数据后统计</span><span class="token keyword">SELECT</span><span class="token function">MAX</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span> <span class="token keyword">AS</span> highest<span class="token punctuation">,</span><span class="token function">MIN</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span> <span class="token keyword">AS</span> lowest<span class="token punctuation">,</span><span class="token function">AVG</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span> <span class="token keyword">AS</span> average<span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span> <span class="token keyword">AS</span> total<span class="token punctuation">,</span><span class="token function">COUNT</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span> <span class="token keyword">AS</span> number_of_invoices<span class="token punctuation">,</span><span class="token function">COUNT</span><span class="token punctuation">(</span> <span class="token keyword">DISTINCT</span> client_id <span class="token punctuation">)</span> <span class="token keyword">AS</span> total_records<span class="token punctuation">,</span> <span class="token comment">-- 将列去重后再计数</span><span class="token function">SUM</span><span class="token punctuation">(</span> invoice_total <span class="token operator">*</span> <span class="token number">1.1</span> <span class="token punctuation">)</span> <span class="token keyword">AS</span> total_1_1 <span class="token comment">-- 这里将先对所有列 * 1.1，后计算总和</span><span class="token keyword">FROM</span>invoices<span class="token keyword">WHERE</span> invoice_date <span class="token operator">&gt;</span> <span class="token string">'2019-07-01'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="GROUP-BY-子句"><a href="#GROUP-BY-子句" class="headerlink" title="GROUP BY 子句"></a>GROUP BY 子句</h3><p>根据指定一个或多个列进行分组。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 根据client_id分组，即该列字段值相同就会分为一组，对每组分别执行聚合函数。 最终是每组分别求和</span><span class="token keyword">SELECT</span> client_id<span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span> <span class="token keyword">AS</span> total_sales<span class="token keyword">FROM</span> invoices<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> client_id<span class="token punctuation">;</span><span class="token comment">-- 当然这个也可也搭配其他语句使用, 这里将会先进行WHERE过滤语句，然后分组之后，根据计算的总和进行排序返回</span><span class="token keyword">SELECT</span> client_id<span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span> <span class="token keyword">AS</span> total_sales<span class="token keyword">FROM</span> invoices<span class="token keyword">WHERE</span> invoice_date <span class="token operator">&gt;=</span> <span class="token string">'2019-07-01'</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> client_id<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> total_sales <span class="token keyword">DESC</span><span class="token punctuation">;</span><span class="token comment">-- 这里是根据多列进行分组，即这两列字段分别相同将分为一组，就可以获得每个state和city组合下的total_sales了。</span><span class="token keyword">SELECT</span> state<span class="token punctuation">,</span>city<span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span> <span class="token keyword">AS</span> total_sales<span class="token keyword">FROM</span> invoices i<span class="token keyword">JOIN</span> clients <span class="token keyword">USING</span> <span class="token punctuation">(</span> client_id <span class="token punctuation">)</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> state<span class="token punctuation">,</span> city<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HAVING-子句"><a href="#HAVING-子句" class="headerlink" title="HAVING 子句"></a>HAVING 子句</h3><p>如果需要对聚合后的值进行过滤，除了使用内查询的方式来解决，也可也尝试使用 <code>HAVING</code></p><blockquote><p>注意，<code>HAVING</code>中使用的列必须要存在于 <code>SELECT</code> 结果列中，这点不同于<code>WHERE</code>语句可以使用结果列中不存在但是存在于表中的字段。</p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 获得销售总额大于 500 的数据 </span><span class="token keyword">SELECT</span> client_id<span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span> <span class="token keyword">AS</span> total_sales<span class="token keyword">FROM</span> invoices<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> client_id<span class="token keyword">HAVING</span> total_sales <span class="token operator">&gt;</span> <span class="token number">500</span><span class="token punctuation">;</span><span class="token comment">-- 当然 HAVING 中也可以添加多个过滤条件</span><span class="token keyword">SELECT</span> client_id<span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span> <span class="token keyword">AS</span> total_sales<span class="token punctuation">,</span><span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> number_of_invoices<span class="token keyword">FROM</span> invoices<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> client_id<span class="token keyword">HAVING</span> total_sales <span class="token operator">&gt;</span> <span class="token number">500</span> <span class="token operator">AND</span> number_of_invoices <span class="token operator">&gt;</span> <span class="token number">5</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ROLLUP运算符"><a href="#ROLLUP运算符" class="headerlink" title="ROLLUP运算符"></a>ROLLUP运算符</h3><p><code>MySql</code>中在使用了<code>GROUP BY</code>之后再跟上 <code>WITH ROLLUP</code> 将会汇总整个结果集。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 返回对invoice_total的汇总</span><span class="token keyword">SELECT</span> client_id<span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span> <span class="token keyword">AS</span> total_sales<span class="token keyword">FROM</span> invoices<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> client_id <span class="token keyword">WITH ROLLUP</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_008.png" class="" title="image_008"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 将会对每个组以及整个结果集进行汇总</span><span class="token keyword">SELECT</span> state<span class="token punctuation">,</span>city<span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span> <span class="token keyword">AS</span> total_sales<span class="token keyword">FROM</span> invoices i<span class="token keyword">JOIN</span> clients <span class="token keyword">USING</span> <span class="token punctuation">(</span> client_id <span class="token punctuation">)</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> state<span class="token punctuation">,</span> city <span class="token keyword">WITH ROLLUP</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_009.png" class="" title="image_009"><h2 id="复杂查询语句"><a href="#复杂查询语句" class="headerlink" title="复杂查询语句"></a>复杂查询语句</h2><blockquote><p><code>Writing Complex Queries</code></p></blockquote><p>这里主要就是应用前几章简单应用过的子查询语句。</p><h3 id="子查询-x2F-内查询"><a href="#子查询-x2F-内查询" class="headerlink" title="子查询/内查询"></a>子查询/内查询</h3><p>子查询就是再另一个SQL语句中嵌套执行的一个查询语句。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> sql_store<span class="token comment">-- 再这个示例中，将会先执行括号中的内查询语句（也就是子查询），将获取到的结果返回给外部的查询</span><span class="token comment">-- 注意这里使用了 &gt; 比较符号，是因为结果只有一个，所以可以使用比较符号。 如果内查询返回多个的话就会出现错误</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> products<span class="token keyword">WHERE</span> unit_price <span class="token operator">&gt;</span> <span class="token punctuation">(</span>    <span class="token keyword">SELECT</span> unit_price    <span class="token keyword">FROM</span> products    <span class="token keyword">WHERE</span> product_id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，上述示例使用了 <code>&gt;</code> 比较符号，是因为结果只有一个，所以可以使用比较符号。 如果内查询返回多个的话就会出现错误。</p><p>解决方案可以参考 ALL 关键字的使用。</p></blockquote><h3 id="IN-运算符-1"><a href="#IN-运算符-1" class="headerlink" title="IN 运算符"></a>IN 运算符</h3><p>针对内查询有多个返回结果的情况，就可以使用<code>IN</code>进行连接。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 这里是返回 product_id 不再子查询结果中的行</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> products<span class="token keyword">WHERE</span> product_id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span>    <span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> product_id<span class="token keyword">FROM</span> order_items<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，这里外查询时使用一个列的数据进行对比，所以内查询返回的数据也是一列。如果内查询返回多列数据的话，同样也会执行错误。</p></blockquote><h3 id="子查询-VS-连接"><a href="#子查询-VS-连接" class="headerlink" title="子查询 VS 连接"></a>子查询 VS 连接</h3><p>通常简单的子查询语句也可以使用连接来达到相同的结果。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> sql_invoicing<span class="token punctuation">;</span><span class="token comment">-- 对比下以下两个语句</span><span class="token comment">-- 内查询方式</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> clients<span class="token keyword">WHERE</span> client_id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> client_id    <span class="token keyword">FROM</span> invoices<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 连接方式</span><span class="token keyword">SELECT</span> c<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> clients c<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> invoices <span class="token keyword">USING</span> <span class="token punctuation">(</span>client_id<span class="token punctuation">)</span><span class="token keyword">WHERE</span> invoice_id <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>具体使用哪种实现方式，视自己的需求来决定，选择相对简单易读的</p></blockquote><h3 id="ALL-关键字"><a href="#ALL-关键字" class="headerlink" title="ALL 关键字"></a>ALL 关键字</h3><p><code>ALL</code> ，将数值对比应用到子查询的每一行上，可以用来对子查询返回多个结果但需要使用单一的比较操作符时。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> sql_invoicing<span class="token punctuation">;</span><span class="token comment">-- 查询比 client_id = 3 的发票总额还要大的所以发票信息</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> invoices<span class="token keyword">WHERE</span> invoice_total <span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>invoice_total<span class="token punctuation">)</span><span class="token keyword">FROM</span> invoices<span class="token keyword">WHERE</span> client_id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 这中查询，就可以使用 ALL 关键词来简化查询</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> invoices<span class="token keyword">WHERE</span> invoice_total <span class="token operator">&gt;</span> <span class="token keyword">ALL</span> <span class="token punctuation">(</span> <span class="token comment">-- 即于子查询中所有返回结果进行对比</span><span class="token keyword">SELECT</span> invoice_total <span class="token comment">-- 注意这里返回了多个结果，如果不添加ALL关键词，将无法进行数值对比</span><span class="token keyword">FROM</span> invoices<span class="token keyword">WHERE</span> client_id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以解决 子查询章节中说的数值对比，内查询返回不唯一的问题。</p></blockquote><h3 id="ANY-关键字"><a href="#ANY-关键字" class="headerlink" title="ANY 关键字"></a>ANY 关键字</h3><p><code>MySql</code>里还有一些其他字段于 <code>ALL</code> 字段类似，例如 <code>ANY</code>、<code>SOME</code>，作用于<code>ALL</code>略用不同，<code>ALL</code>时针对子查询中的所有行都需要符合比较符，而 <code>ANY</code>、<code>SOME</code>则是有任意一个或多个符合比较符即可。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 子查询返回结果有多个，这里是获取客户的发票数多于2两张的信息</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> clients<span class="token keyword">WHERE</span> client_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> client_id    <span class="token keyword">FROM</span> invoices    <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> client_id    <span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 使用 ANY 改造</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> clients<span class="token keyword">WHERE</span> client_id <span class="token operator">=</span> <span class="token keyword">ANY</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> client_id    <span class="token keyword">FROM</span> invoices    <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> client_id    <span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h3><p>即子查询和外查询具有相关性，例如下方的示例中，在子查询的过滤条件上使用到了外查询的字段。之前章节的查询都非相关子查询。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> employees e<span class="token keyword">WHERE</span> salary <span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span>    <span class="token keyword">FROM</span> employees    <span class="token keyword">WHERE</span> office_id <span class="token operator">=</span> e<span class="token punctuation">.</span>office_id <span class="token comment">-- 注意这里的比较条件，第二个office_id前有表名前缀，针对的是外查询的 employees</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 在这个查询中，将会先扫描外部查询表 employees 的第一行，然后在执行内部查询计算平均值，和外部查询的第一行对比，符合条件则返回；之后会扫描外部查询表 employees 的第二行执行相同的操作，直到所有行遍历完。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<strong>非相关子查询</strong>中，因为没有利用到外查询中的属性，所有子查询只会执行一次就返回结果给外查询。</p><p>在<strong>相关子查询</strong>中，子查询将会在主查询每一行的层面执行，所有执行的非常慢，数据越多，查询越非时间也会占用更多的存储。所以通常不推荐使用。</p><h3 id="EXISTS-运算符"><a href="#EXISTS-运算符" class="headerlink" title="EXISTS 运算符"></a>EXISTS 运算符</h3><p>将外查询表的<strong>每一行</strong>，代入内查询作为检验，如果内查询返回的结果取非空值，则EXISTS子句返回TRUE，这一行行可作为外查询的结果行，否则不能作为结果。</p><p>执行顺序如下：</p><ol><li><strong>首先执行一次外查询</strong></li><li><strong>对于外查询中的每一行分别执行一次子查询，而且每次执行子查询时都会引用外查询中当前行的值</strong></li><li><strong>使用子查询的结果来确定外查询的结果集。 如果外部查询返回10行，SQL 就将执行11次查询，一次执行外查询，然后为外查询返回的每一行执行一次子查询</strong></li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 使用子查询来查询在 invoices 中拥有发票记录的 client 信息</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> clients <span class="token keyword">WHERE</span> client_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> client_id    <span class="token keyword">FROM</span> invoices<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 这种可以使用 EXISTS 来实现同样的结果</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> clients c<span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span> <span class="token comment">-- 使用 EXISTS 运算符来查看是否有符合条件的行</span><span class="token keyword">SELECT</span> client_id    <span class="token keyword">FROM</span> invoices    <span class="token keyword">WHERE</span> client_id <span class="token operator">=</span> c<span class="token punctuation">.</span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用 <code>IN</code> 的方式执行子查询，实际上是先执行子查询，将子查询的结果返回给外查询，<code>SQL</code>类似于：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> clients <span class="token keyword">WHERE</span> client_id <span class="token operator">IN</span> <span class="token punctuation">(</span>    <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是当符合条件的数据成千上万或者上亿时，<code>IN</code> 的列表就会有很多数据，性能将会降低很多。</p><p>这样的情况下，使用<code>EXISTS</code>运算符会能够极大的提高效率。</p><p>使用 <code>EXISTS</code> 并不会给外查询返回一个结果，而是返回一个指令，说明这个子查询是否符合这个搜索条件的行，符合时即返回 <code>TRUE</code>。</p></blockquote><h3 id="SELECT-语句中的子查询"><a href="#SELECT-语句中的子查询" class="headerlink" title="SELECT 语句中的子查询"></a>SELECT 语句中的子查询</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 在SELECT语句中也可也嵌入子查询</span><span class="token keyword">SELECT</span>invoice_id<span class="token punctuation">,</span>invoice_total<span class="token punctuation">,</span><span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span>    <span class="token keyword">FROM</span> invoices<span class="token punctuation">)</span> <span class="token keyword">AS</span> invoice_average<span class="token punctuation">,</span> <span class="token comment">-- 子查询计算</span>    invoice_total <span class="token operator">-</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span>    <span class="token keyword">FROM</span> invoices<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">-- 这里的计算方式可以简化为下面列的子查询</span>    invoice_total <span class="token operator">-</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> invoice_average <span class="token punctuation">)</span> <span class="token comment">-- 这里 ( SELECT invoice_average ) 也是一个子查询</span><span class="token keyword">FROM</span> invoices<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="FROM-语句中的子查询"><a href="#FROM-语句中的子查询" class="headerlink" title="FROM 语句中的子查询"></a>FROM 语句中的子查询</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 本质上时通过 子查询产生一个临时表，然后在基于这个临时表做一些查询过滤</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> client_id<span class="token punctuation">,</span>    name<span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span>    <span class="token keyword">FROM</span> invoices    <span class="token keyword">WHERE</span> client_id <span class="token operator">=</span> c<span class="token punctuation">.</span>client_id<span class="token punctuation">)</span> <span class="token keyword">AS</span> total_sales<span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span> <span class="token keyword">FROM</span> invoices<span class="token punctuation">)</span> <span class="token keyword">AS</span> average<span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token keyword">SELECT</span> total_sales <span class="token operator">-</span> average<span class="token punctuation">)</span> <span class="token keyword">AS</span> difference    <span class="token keyword">FROM</span> clients c<span class="token punctuation">)</span> <span class="token keyword">AS</span> sales_summary <span class="token comment">-- 这里到上面的 FROM 部分就是属于一个子查询</span><span class="token keyword">WHERE</span> total_sales <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MySql常用内置函数"><a href="#MySql常用内置函数" class="headerlink" title="MySql常用内置函数"></a>MySql常用内置函数</h2><blockquote><p><code>Built-in Functions</code></p></blockquote><p>当然不同数据库中内置的函数有所区别，具体使用方式可以去翻看对应的数据库文档</p><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p>这里汇总了MySQL中部分函数，<a href="https://dev.mysql.com/doc/refman/8.0/en/numeric-functions.html" title="点击跳转">完整函数名单</a>详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/numeric-functions.html">https://dev.mysql.com/doc/refman/8.0/en/numeric-functions.html</a></p><ul><li><p><code>SELECT ROUND(5.7346)</code> </p><ul><li>四舍五入为整数</li></ul></li><li><p><code>SELECT ROUND(5.7346, 2)</code></p><ul><li>指定四舍五入后的数据精度为保留两位小数</li></ul></li><li><p><code>SELECT TRUNCATE(5.7346, 2)</code></p><ul><li>截断数字</li></ul></li><li><p><code>SELECT CEILING(5.7346)</code></p><ul><li>向上取整，返回大于或等于这个数字的最小整数</li></ul></li><li><p><code>SELECT FLOOR(5.7346, 2)</code></p><ul><li>向下取整，返回小于或等于这个数字的最大整数</li></ul></li><li><p><code>SELECT ABS(5.7346, 2)</code></p><ul><li>计算绝对值</li></ul></li><li><p><code>SELECT RAND()</code></p><ul><li>生成 0——1 区间的随机浮点数</li></ul></li></ul><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>这里汇总了MySQL中部分函数，<a href="https://dev.mysql.com/doc/refman/8.0/en/string-functions.html" title="点击跳转">完整函数名单</a>详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/string-functions.html">https://dev.mysql.com/doc/refman/8.0/en/string-functions.html</a></p><ul><li><p><code>SELECT LENGTH('sky')</code></p><ul><li>返回字符串长度</li></ul></li><li><p><code>SELECT UPPER('sky')</code></p><ul><li>返回字符串的大写模式</li></ul></li><li><p><code>SELECT LOWER('sky')</code></p><ul><li>返回字符串的小写模式</li></ul></li><li><p><code>SELECT LTRIM('sky')</code>、<code>left trim的缩写</code></p><ul><li>移除字符串左侧空白字符或其他预定义字符</li></ul></li><li><p><code>SELECT RTRIM('sky')</code>、<code>right trim的缩写</code></p><ul><li>移除字符串右侧空白字符或其他预定义字符</li></ul></li><li><p><code>SELECT TRIM('sky')</code></p><ul><li>移除字符串左右侧空白字符或其他预定义字符</li></ul></li><li><p><code>SELECT LEFT('Kindergarten', 4)</code></p><ul><li>返回字符串左侧4个字符</li></ul></li><li><p><code>SELECT RIGHT('Kindergarten', 6)</code></p><ul><li>返回字符串右侧6个字符</li></ul></li><li><p><code>SELECT SUBSTRING('Kindergarten', 3, 5)</code></p><ul><li>返回字符串的子字符串，从3号位之后5个字符长度的字符串<code>nderg</code>。第三个参数不填写时返回剩余字符串。索引由 1 开始增长。</li></ul></li><li><p><code>SELECT LOCATE('n','Kindergarten')</code></p><ul><li>返回字符串中<code>Kindergarten</code>中<code>n</code>第一次出现的位置3。如果字符串不存在则返回0，因为这里索引由1开始增长。</li></ul></li><li><p><code>SELECT REPLACE('Kindergarten', 'garten', 'garden')</code></p><ul><li>使用<code>garden</code>来替换<code>Kindergarten</code>中出现的<code>garten</code>。</li></ul></li><li><p><code>SELECT CONCAT('frist', 'last', '_n')</code></p><ul><li><p>将多个字符串拼接为一个字符串</p></li><li><p>```sql<br>SELECT CONCAT(first_name, ‘ ‘, last_name) AS full_name<br>FROM customers;</p><pre class="line-numbers language-none"><code class="language-none">  + ### 日期函数这里汇总了MySQL中部分函数，[完整函数名单](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html '点击跳转')详见 https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html+ `SELECT NOW()`  + 返回当前系统的日期和时间+ `SELECT CURDATE()`  + 返回当前系统的日期+ `SELECT CURTIME()`  + 返回当前系统的时间+ `SELECT YEAR(NOW()), MONTH(NOW()), DAY(NOW()), HOUR(NOW()), MINUTE(NOW()), SECOND(NOW()). DAYNAME(NOW()), MONTHNAME(NOW())`  + 分别返回时间中的年、月、日、小时、分钟、秒、字符串的星期、字符串的月份+ `SELECT EXTRACT(DAY FROM NOW())`， `SELECT EXTRACT(YEAR FROM NOW())`  + 这是SQL标准语言中的函数，获得时间中指定的参数### 格式化日期函数+ `SELECT DATE_FORMAT(NOW(), '%M %d %Y')`  + 按照指定的模式串返回时间的字符串形式。[模式串在线文档](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_date-format '点击跳转')。### 计算日期和时间+ `SELECT DATE_ADD(NOW(), INTERVAL 1 DAY)`，`SELECT DATE_ADD(NOW(), INTERVAL 1 YEAR)`，`SELECT DATE_ADD(NOW(), INTERVAL -1 DAY)`  + 给时间加上指定的天数，或者其他单位时间+ `SELECT DATE_SUB(NOW(), INTERVAL 1 DAY)`  + 给时间减去指定的天数+ `SELECT DATEDIFF('2019-01-05 09:00', '2019-01-01 10:00')`  + 返回两个时间之间天数的差距，如果后面的更大则返回小数+ `SELECT TIME_TO_SEC('09:00')`  + 计算当前时间在当天的第几秒。即转换单位为秒### IFNULL 函数```sqlSELECT order_id,IFNULL(shipper_id, 'Not assigned') AS shipper -- 如果shipper_id是NULL,则返回第二个参数FROM orders;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><img src="/2023/04/23/cs-data/data-sql/image_010.png" class="" title="image_010"><h3 id="COALESCE函数"><a href="#COALESCE函数" class="headerlink" title="COALESCE函数"></a>COALESCE函数</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> order_id<span class="token punctuation">,</span><span class="token keyword">COALESCE</span><span class="token punctuation">(</span>shipper_id<span class="token punctuation">,</span> comments<span class="token punctuation">,</span> <span class="token string">'Not assigned'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> shipper <span class="token comment">-- 如果shipper_id是NULL,则返回第二个参数, 如果第二个参数还是NULL，则返回第三个参数</span><span class="token keyword">FROM</span> orders<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_011.png" class="" title="image_011"><h3 id="IF-函数"><a href="#IF-函数" class="headerlink" title="IF 函数"></a>IF 函数</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span>order_id<span class="token punctuation">,</span>order_date<span class="token punctuation">,</span><span class="token keyword">IF</span> <span class="token punctuation">(</span>  <span class="token comment">-- if 判断</span>    <span class="token keyword">YEAR</span><span class="token punctuation">(</span>order_date<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span><span class="token string">'2019-01-01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">-- 判断条件</span>        <span class="token string">'Active'</span><span class="token punctuation">,</span> <span class="token comment">-- 如果判断条件是 TRUE 返回该参数</span>        <span class="token string">'Archived'</span> <span class="token comment">-- 如果判断条件是 FALSE 返回该参数</span>    <span class="token punctuation">)</span><span class="token keyword">FROM</span> orders<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CASE-运算符"><a href="#CASE-运算符" class="headerlink" title="CASE 运算符"></a>CASE 运算符</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span>order_id<span class="token punctuation">,</span>order_date<span class="token punctuation">,</span><span class="token keyword">CASE</span>  <span class="token comment">-- 多条件判断</span><span class="token keyword">WHEN</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>order_date<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span><span class="token string">'2019-01-01'</span><span class="token punctuation">)</span> <span class="token keyword">THEN</span> <span class="token string">'Active'</span> <span class="token comment">-- 判断条件为 真 则返回 THEN 之后的数据</span><span class="token keyword">WHEN</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>order_date<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span><span class="token string">'2019-01-01'</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">THEN</span> <span class="token string">'Last Year'</span><span class="token keyword">WHEN</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>order_date<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span><span class="token string">'2019-01-01'</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">THEN</span> <span class="token string">'Archived'</span><span class="token keyword">ELSE</span> <span class="token string">'Future'</span>  <span class="token comment">-- 以上所有判断条件都为 假 返回该数据</span><span class="token keyword">END</span> <span class="token keyword">AS</span> category<span class="token comment">-- 结束多条件判断</span><span class="token keyword">FROM</span> orders<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><blockquote><p><code>Views</code></p></blockquote><p>将查询或者子查询保存到视图里，这样可以直接通过视图查询，而不用每次查询数据都写一遍复杂的查询语句。</p><p><strong>视图提供了一种对表的抽象化</strong>。</p><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> sql_invoicing<span class="token punctuation">;</span><span class="token comment">-- 根据查询语句创建一个视图</span><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> sales_by_client <span class="token keyword">AS</span><span class="token keyword">SELECT</span>c<span class="token punctuation">.</span>client_id<span class="token punctuation">,</span>c<span class="token punctuation">.</span>name<span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span> <span class="token keyword">AS</span> total_sales<span class="token keyword">FROM</span> clients c<span class="token keyword">JOIN</span> invoices i <span class="token keyword">USING</span> <span class="token punctuation">(</span> client_id <span class="token punctuation">)</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> client_id<span class="token punctuation">,</span> name<span class="token punctuation">;</span><span class="token comment">-- 之后便可以直接基于视图查询了, 其查询语句语法和普通的表相同，也可以执行连接等语法。</span><span class="token comment">-- 将视图视为一张虚拟的表即可</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> sales_by_client<span class="token keyword">WHERE</span> total_sales <span class="token operator">&gt;</span> <span class="token number">500</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_012.png" class="" title="image_012"><h3 id="更改视图"><a href="#更改视图" class="headerlink" title="更改视图"></a>更改视图</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 如果要修改视图</span><span class="token comment">-- 方案一，是先删除原有的视图，之后再创建一个同名的新视图</span><span class="token comment">-- 方案二，是使用 REPLACE </span><span class="token keyword">CREATE</span> <span class="token operator">OR</span> <span class="token keyword">REPLACE</span> <span class="token keyword">VIEW</span> sales_by_client <span class="token keyword">AS</span>  <span class="token comment">-- 如果不存在就会创建，已存在就会替换</span><span class="token keyword">SELECT</span>c<span class="token punctuation">.</span>client_id<span class="token punctuation">,</span>c<span class="token punctuation">.</span>name<span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span> invoice_total <span class="token punctuation">)</span> <span class="token keyword">AS</span> total_sales<span class="token keyword">FROM</span> clients c<span class="token keyword">JOIN</span> invoices i <span class="token keyword">USING</span> <span class="token punctuation">(</span> client_id <span class="token punctuation">)</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> client_id<span class="token punctuation">,</span> name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> sales_by_client<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="可更新视图"><a href="#可更新视图" class="headerlink" title="可更新视图"></a>可更新视图</h3><p>当然，在一些特定的情况下，也可也针对视图使用 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code></p><p>即再视图中没有以下关键字的使用，就可以称为可更新的视图</p><ul><li><code>DISTINCT</code></li><li>聚合函数，例如：<code>MIN</code>、<code>MAX</code>、<code>SUM</code></li><li><code>GROUP BY</code>、<code>HAVING</code></li><li><code>UNION</code></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 创建一个视图</span><span class="token keyword">CREATE</span> <span class="token operator">OR</span> <span class="token keyword">REPLACE</span> <span class="token keyword">VIEW</span> invoices_with_balance <span class="token keyword">AS</span><span class="token keyword">SELECT</span>invoice_id<span class="token punctuation">,</span>number<span class="token punctuation">,</span>client_id<span class="token punctuation">,</span>payment_total<span class="token punctuation">,</span>invoice_total <span class="token operator">-</span> payment_total <span class="token keyword">AS</span> balance<span class="token punctuation">,</span>invoice_date<span class="token punctuation">,</span>due_date<span class="token punctuation">,</span>payment_date<span class="token keyword">FROM</span> invoices<span class="token keyword">WHERE</span> <span class="token punctuation">(</span>invoice_total <span class="token operator">-</span> payment_total<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">-- 之后就可以向操作一张表一样操作视图了</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> invoices_with_balance <span class="token keyword">WHERE</span> invoice_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> invoices_with_balance <span class="token keyword">SET</span> due_date <span class="token operator">=</span> DATE_ADD<span class="token punctuation">(</span>due_date<span class="token punctuation">,</span> <span class="token keyword">INTERVAL</span> <span class="token number">2</span> <span class="token keyword">DAY</span><span class="token punctuation">)</span> <span class="token keyword">WHERE</span> invoice_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">-- 在插入数据时，只有视图中具有基础表中的所有列是才能正常插入数据，比如，如果视图中少了基础表中的一个必填列时，将不能再视图中插入数据。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="WITH-OPTION-CHECK子句"><a href="#WITH-OPTION-CHECK子句" class="headerlink" title="WITH OPTION CHECK子句"></a>WITH OPTION CHECK子句</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 当使用如下语句更新视图中的数据后，再次查询视图，会发现缺少了一部分数据</span><span class="token keyword">UPDATE</span> invoices_with_balance<span class="token keyword">SET</span> payment_total <span class="token operator">=</span> invoice_total<span class="token keyword">WHERE</span> invoice_id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">-- 因为当通过视图更新或者删除数据时，会导致一些行的消失</span><span class="token comment">-- 如果不希望UPDATE或者DELETE语句将行从视图中删除，则需要再视图的最后一行添加上</span><span class="token comment">-- WITH CHECK OPTION</span><span class="token comment">-- 来防止行从视图中删除</span><span class="token keyword">CREATE</span> <span class="token operator">OR</span> <span class="token keyword">REPLACE</span> <span class="token keyword">VIEW</span> invoices_with_balance <span class="token keyword">AS</span><span class="token keyword">SELECT</span>invoice_id<span class="token punctuation">,</span>number<span class="token punctuation">,</span>client_id<span class="token punctuation">,</span>payment_total<span class="token punctuation">,</span>invoice_total <span class="token operator">-</span> payment_total <span class="token keyword">AS</span> balance<span class="token punctuation">,</span>invoice_date<span class="token punctuation">,</span>due_date<span class="token punctuation">,</span>payment_date<span class="token keyword">FROM</span> invoices<span class="token keyword">WHERE</span> <span class="token punctuation">(</span>invoice_total <span class="token operator">-</span> payment_total<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token keyword">WITH</span> <span class="token keyword">CHECK</span> <span class="token keyword">OPTION</span><span class="token punctuation">;</span> <span class="token comment">-- 防止数据被视图中删除， 这样如果导致被删除的语句操作会无法执行，有错误提示</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="视图的其他优点"><a href="#视图的其他优点" class="headerlink" title="视图的其他优点"></a>视图的其他优点</h3><ul><li>简化查询</li><li>减小因数据库设计改动的影响<ul><li>​当视图的基础表发生改变时，如果我们的查询都时基于视图，我们只需要修改视图重新基于基础表即可，而原本的基于视图的查询语句不需要进行修改。</li><li>视图提供了一种对表的抽象化</li></ul></li><li>使用视图限制基础表访问</li></ul><h2 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h2><blockquote><p><code>Stored Procedures</code></p></blockquote><h3 id="什么时存储过程"><a href="#什么时存储过程" class="headerlink" title="什么时存储过程"></a>什么时存储过程</h3><p>存储过程时一个包含一堆<code>SQL</code>代码的数据库对象，在应用代码中，可以通过调用这些过程来获取或保存数据，使用存储过程来存储和管理<code>SQL</code>代码。大多数<code>DBMS</code>可以对存储过程里的代码做一些优化，因此在存储过程里的<code>SQL</code>代码有时候可以执行起来更快，也能加强数据安全性。</p><ul><li><code>Store and orgainze SQL</code></li><li><code>Faster execution</code></li><li><code>Data security</code></li></ul><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> get_clients<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> clients<span class="token punctuation">;</span> <span class="token comment">-- 因为在存储过程中,存在多个SQL语句,所有须用另一个分隔符来表示结束符号， 这里可以使用系统默认的 ;</span><span class="token comment">-- 但是为了区分存储过程的结束，通常会临时修改为自定义的分隔符号来结束存储过程，如下所示</span><span class="token keyword">END</span><span class="token comment">-- 创建存储过程</span><span class="token keyword">DELIMITER</span> $$ <span class="token comment">-- 临时修改分隔符为 $$， 当然也可也修改为其他合适的自定义字符。 主要是因为具体的执行实体上会用';' 来分割语句的结束，如果在存储过程的结束也用 ';'，容易歧义，所有修改临时的分隔符用作存储过程的结束</span><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> get_clients<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> clients<span class="token keyword">END</span>$$ <span class="token comment">-- 结束符号，标示存储过程完毕</span><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span> <span class="token comment">-- 恢复分隔符</span><span class="token comment">-- 执行一个存储过程</span><span class="token keyword">CALL</span> get_clients<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> get_clients<span class="token punctuation">;</span> <span class="token comment">-- 不存在时会报错</span><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> get_clients<span class="token punctuation">;</span> <span class="token comment">-- 不存在时不执行，存在视图时才会执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 创建带参数的存储过程</span><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> get_clients_by_state<span class="token punctuation">;</span><span class="token keyword">DELIMITER</span> $$<span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> get_clients_by_state<span class="token punctuation">(</span>    state <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">-- 定义一个参数，类型是 CHAR(2)</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> clients c<span class="token keyword">WHERE</span> c<span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span> <span class="token comment">-- 注意这里要跟参数的名称和列名区分开，可以选择参数重命名，或者添加表前缀</span><span class="token keyword">END</span>$$<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span> <span class="token comment">-- 调用存储过程</span><span class="token keyword">CALL</span> get_clients_by_state<span class="token punctuation">(</span><span class="token string">'CA'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="带默认值的参数"><a href="#带默认值的参数" class="headerlink" title="带默认值的参数"></a>带默认值的参数</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 创建带参数的存储过程</span><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> get_clients_by_state<span class="token punctuation">;</span><span class="token keyword">DELIMITER</span> $$<span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> get_clients_by_state<span class="token punctuation">(</span>    state <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">-- 定义一个参数，类型是 CHAR(2)</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span><span class="token keyword">IF</span> state <span class="token operator">IS</span> <span class="token boolean">NULL</span> <span class="token keyword">THEN</span> <span class="token comment">-- 声明参数为NULL时的处理</span><span class="token keyword">SET</span> state <span class="token operator">=</span> <span class="token string">'CA'</span><span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span> <span class="token comment">-- 结束 IF 子句</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> clients c<span class="token keyword">WHERE</span> c<span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span> <span class="token comment">-- 注意这里要跟参数的名称和列名区分开，可以选择参数重命名，或者添加表前缀</span><span class="token keyword">END</span>$$<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span> <span class="token comment">-- 调用存储过程</span><span class="token keyword">CALL</span> get_clients_by_state<span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 注意这里声明传递 NULL 是必须的，不能省略</span><span class="token comment">-- 当然 IF 不仅可以给参数设置默认值 </span><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> get_clients_by_state<span class="token punctuation">;</span><span class="token keyword">DELIMITER</span> $$<span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> get_clients_by_state<span class="token punctuation">(</span>    state <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">-- 定义一个参数，类型是 CHAR(2)</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span><span class="token keyword">IF</span> state <span class="token operator">IS</span> <span class="token boolean">NULL</span> <span class="token keyword">THEN</span> <span class="token comment">-- 声明参数为NULL时的处理</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> clients<span class="token punctuation">;</span><span class="token keyword">ELSE</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> clients c<span class="token keyword">WHERE</span> c<span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span> <span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span> <span class="token comment">-- 结束 IF 子句</span><span class="token keyword">END</span>$$<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span> <span class="token comment">-- 也可也简化为如下</span><span class="token keyword">DELIMITER</span> $$<span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> get_clients_by_state<span class="token punctuation">(</span>    state <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">-- 定义一个参数，类型是 CHAR(2)</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> clients c<span class="token keyword">WHERE</span> c<span class="token punctuation">.</span>state <span class="token operator">=</span> IFNULL<span class="token punctuation">(</span>state<span class="token punctuation">,</span> c<span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">END</span>$$<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h3><p><code>SQL</code>错误码<a href="https://www.ibm.com/docs/en/db2-for-zos/11?topic=codes-sqlstate-values-common-error" title="点击跳转">连接地址</a> ：<a href="https://www.ibm.com/docs/en/db2-for-zos/11?topic=codes-sqlstate-values-common-error">https://www.ibm.com/docs/en/db2-for-zos/11?topic=codes-sqlstate-values-common-error</a></p><img src="/2023/04/23/cs-data/data-sql/image_013.png" class="" title="image_013"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> make_payment<span class="token punctuation">;</span> <span class="token comment">-- 创建带有参数验证的存储过程</span><span class="token keyword">DELIMITER</span> $$<span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> make_payment<span class="token punctuation">(</span>invoice_id <span class="token keyword">INT</span><span class="token punctuation">,</span>payment_amount <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>payment_date <span class="token keyword">DATE</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span> <span class="token keyword">IF</span> payment_amount <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token keyword">THEN</span>SIGNAL SQLSTATE <span class="token string">'22003'</span>  <span class="token comment">-- 设置错误信号，以及错误码</span><span class="token keyword">SET</span> MESSAGE_TEXT <span class="token operator">=</span> <span class="token string">'Invalid payment amount'</span><span class="token punctuation">;</span> <span class="token comment">-- 设置错误文本</span><span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> invoices i<span class="token keyword">SET</span>i<span class="token punctuation">.</span>payment_total <span class="token operator">=</span> payment_amount<span class="token punctuation">,</span> <span class="token comment">-- 因为这里 payment_total 有非空的校验，所以就不需要再参数那里添加校验了</span>i<span class="token punctuation">.</span>payment_date <span class="token operator">=</span> payment_date<span class="token keyword">WHERE</span> i<span class="token punctuation">.</span>invoice_id <span class="token operator">=</span> invoice_id<span class="token punctuation">;</span><span class="token keyword">END</span>$$<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span><span class="token comment">-- 测试</span><span class="token keyword">CALL</span> make_payment<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">'2023-05-05'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_014.png" class="" title="image_014"><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> get_unpaid_invoices_for_client<span class="token punctuation">;</span><span class="token keyword">DELIMITER</span> $$<span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> get_unpaid_invoices_for_client<span class="token punctuation">(</span>client_id <span class="token keyword">INT</span><span class="token punctuation">,</span><span class="token keyword">OUT</span> invoices_count <span class="token keyword">INT</span><span class="token punctuation">,</span> <span class="token comment">-- 标记该参数为输出参数</span><span class="token keyword">OUT</span> invoices_total <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">-- 标记该参数为输出参数</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span> <span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>invoice_total<span class="token punctuation">)</span><span class="token keyword">INTO</span> invoices_count<span class="token punctuation">,</span> invoices_total <span class="token comment">-- 将查询结果复制到指定参数中</span><span class="token keyword">FROM</span> invoices i<span class="token keyword">WHERE</span> i<span class="token punctuation">.</span>client_id <span class="token operator">=</span> client_id<span class="token operator">AND</span> payment_total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">END</span>$$<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span><span class="token keyword">set</span> <span class="token variable">@invoices_count</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">-- 用户自定义的变量，并设置默认值</span><span class="token keyword">set</span> <span class="token variable">@invoices_total</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">-- 用户自定义的变量，并设置默认值</span><span class="token keyword">CALL</span> get_unpaid_invoices_for_client<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token variable">@invoices_count</span><span class="token punctuation">,</span> <span class="token variable">@invoices_total</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 调用存储过程，并传递参数</span><span class="token keyword">SELECT</span> <span class="token variable">@invoices_count</span><span class="token punctuation">,</span> <span class="token variable">@invoices_total</span><span class="token punctuation">;</span> <span class="token comment">-- 显示参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 用户自定义参数的格式如下： SET @参数名</span><span class="token comment">-- 定义一个参数 invoices_count 并初始化为 0</span><span class="token keyword">SET</span> <span class="token variable">@invoices_count</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">-- 本地变量， 可以再存储过程和函数中使用</span><span class="token comment">-- 这些变量不会再整个客户端绘画过程中保存，存储过程完成任务后就被回收</span><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> get_risk_factor<span class="token punctuation">;</span><span class="token comment">-- 这里的 risk_factor、invoices_total、invoices_count 就是本地变量，也可也理解为局部变量</span><span class="token keyword">DELIMITER</span> $$<span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> get_risk_factor <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span> <span class="token comment">-- risk_factor = invoices_total / invoices_count * 5</span><span class="token keyword">DECLARE</span> risk_factor <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">-- 定义一个本地变量，并设置默认值</span><span class="token keyword">DECLARE</span> invoices_total <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">DECLARE</span> invoices_count <span class="token keyword">INT</span><span class="token punctuation">;</span> <span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>invoice_total<span class="token punctuation">)</span><span class="token keyword">INTO</span> invoices_count<span class="token punctuation">,</span> invoices_total <span class="token comment">-- 拷贝结果</span><span class="token keyword">FROM</span> invoices<span class="token punctuation">;</span><span class="token keyword">SET</span> risk_factor <span class="token operator">=</span> invoices_total <span class="token operator">/</span> invoices_count <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">-- 计算，并设置值</span><span class="token keyword">SELECT</span> risk_factor<span class="token punctuation">;</span> <span class="token comment">-- 展示结果</span><span class="token keyword">END</span>$$<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span><span class="token comment">-- 调用</span><span class="token keyword">CALL</span> get_risk_factor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数和存储过程很类似，不同的是<strong>函数只能返回单一值</strong>，比起存储过程，其无法返回拥有多行和多列的结果集。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">FUNCTION</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> get_risk_factor_for_client<span class="token punctuation">;</span><span class="token keyword">DELIMITER</span> $$<span class="token keyword">CREATE</span> <span class="token keyword">FUNCTION</span> get_risk_factor_for_client <span class="token punctuation">(</span>client_id <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">RETURNS</span> <span class="token keyword">INTEGER</span>  <span class="token comment">-- 设置返回值和类型，这里和存储过程有所区别</span><span class="token keyword">DETERMINISTIC</span> <span class="token comment">-- 声明返回值具有确定性，即数据一样的情况下，返回值一样</span><span class="token keyword">READS</span> <span class="token keyword">SQL</span> <span class="token keyword">DATA</span> <span class="token comment">-- 声明属性是 读取SQL数据</span><span class="token comment">-- MODIFIES SQL DATA  -- 声明属性是 修改SQL数据</span><span class="token keyword">BEGIN</span> <span class="token comment">-- risk_factor = invoices_total / invoices_count * 5</span><span class="token keyword">DECLARE</span> risk_factor <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">-- 定义一个本地变量，并设置默认值</span><span class="token keyword">DECLARE</span> invoices_total <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">DECLARE</span> invoices_count <span class="token keyword">INT</span><span class="token punctuation">;</span> <span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>invoice_total<span class="token punctuation">)</span><span class="token keyword">INTO</span> invoices_count<span class="token punctuation">,</span> invoices_total <span class="token comment">-- 拷贝结果</span><span class="token keyword">FROM</span> invoices i<span class="token keyword">WHERE</span> i<span class="token punctuation">.</span>client_id <span class="token operator">=</span> client_id<span class="token punctuation">;</span><span class="token keyword">SET</span> risk_factor <span class="token operator">=</span> invoices_total <span class="token operator">/</span> invoices_count <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">-- 计算，并设置值</span><span class="token keyword">RETURN</span> IFNULL<span class="token punctuation">(</span> risk_factor<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 设置返回值</span><span class="token keyword">END</span>$$<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span><span class="token comment">-- 调用</span><span class="token keyword">SELECT</span>client_id<span class="token punctuation">,</span>NAME<span class="token punctuation">,</span>get_risk_factor_for_client <span class="token punctuation">(</span> client_id <span class="token punctuation">)</span> <span class="token comment">-- 调用我们声明的函数</span><span class="token keyword">FROM</span>clients<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数中除了可以声明为 读取SQL数据类型外有，这些属性是可以同时声明的：</p><ul><li>READS SQL DATA<ul><li>读取SQL数据</li><li>即函数中有查询读取数据</li></ul></li><li>MODIFIES SQL DATA<ul><li>修改SQL数据</li><li>即函数中有插入、更新或者删除数据</li></ul></li></ul><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><blockquote><p><code>Triggers</code></p></blockquote><p>触发器实在插入、更新和删除语句前后自动执行的一堆SQL代码，通常使用触发器增强数据一致性。</p><h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 删除重名的触发器</span><span class="token keyword">DROP</span> <span class="token keyword">TRIGGER</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> payments_after_insert<span class="token punctuation">;</span><span class="token comment">-- 创建触发器</span><span class="token keyword">DELIMITER</span> $$  <span class="token comment">-- 修改分隔符</span><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> payments_after_insert <span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> payments <span class="token comment">-- 明确触发时机，在payments插入数据之后；-- BEFORE -- 在执行操作之前触发</span><span class="token keyword">FOR EACH ROW</span> <span class="token comment">-- 在每一个受影响的行触发，当然也有语句级别的触发范围，每次执行语句只触发一次（但目前mysql尚不支持）</span><span class="token keyword">BEGIN</span> <span class="token comment">-- 触发的实体内容</span><span class="token comment">-- 这部分可以写任意SQL修改代码，也可以写存储过程</span><span class="token comment">-- 示例, 每次插入 payments 后，就去修改 invoices表中对应数据的总额</span><span class="token keyword">UPDATE</span> invoices<span class="token keyword">SET</span> payment_total <span class="token operator">=</span> payment_total <span class="token operator">+</span> NEW<span class="token punctuation">.</span>amount <span class="token comment">-- NEW 关键词就是新的数据库（新增或更新后）； OLD 关键词就是旧的数据行(更新或删除前)</span><span class="token keyword">WHERE</span> invoice_id <span class="token operator">=</span> NEW<span class="token punctuation">.</span>invoice_id<span class="token punctuation">;</span><span class="token keyword">END</span>$$<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span> <span class="token comment">-- 恢复分隔符</span><span class="token comment">-- 测试</span><span class="token keyword">SELECT</span> payment_total <span class="token keyword">FROM</span> invoices <span class="token keyword">WHERE</span> invoice_id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">-- 0</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> payments<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token keyword">DEFAULT</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'2023-05-07'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> payment_total <span class="token keyword">FROM</span> invoices <span class="token keyword">WHERE</span> invoice_id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">-- 10</span><span class="token comment">-- </span><span class="token keyword">DELIMITER</span> $$  <span class="token comment">-- 修改分隔符</span><span class="token keyword">DROP</span> <span class="token keyword">TRIGGER</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> payments_after_insert<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> payments_after_delete<span class="token keyword">AFTER</span> <span class="token keyword">DELETE</span> <span class="token keyword">ON</span> payments <span class="token comment">-- 明确触发时机，在删除之后</span><span class="token keyword">FOR EACH ROW</span> <span class="token comment">-- 在每一个受影响的行触发</span><span class="token keyword">BEGIN</span> <span class="token keyword">UPDATE</span> invoices<span class="token keyword">SET</span> payment_total <span class="token operator">=</span> payment_total <span class="token operator">-</span> OLD<span class="token punctuation">.</span>amount <span class="token comment">-- OLD 关键词就是旧的数据行(更新或删除前)</span><span class="token keyword">WHERE</span> invoice_id <span class="token operator">=</span> OLD<span class="token punctuation">.</span>invoice_id<span class="token punctuation">;</span><span class="token keyword">END</span>$$<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span> <span class="token comment">-- 恢复分隔符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查看当前数据库的所有触发器</span><span class="token keyword">SHOW</span> TRIGGERS<span class="token punctuation">;</span><span class="token comment">-- 对名称进行过滤</span><span class="token keyword">SHOW</span> TRIGGERS <span class="token operator">LIKE</span> <span class="token string">'payment%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_015.png" class="" title="image_015"><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 删除触发器</span><span class="token keyword">DROP</span> <span class="token keyword">TRIGGER</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> payments_after_insert<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="使用触发器进行审计"><a href="#使用触发器进行审计" class="headerlink" title="使用触发器进行审计"></a>使用触发器进行审计</h3><p>触发器的另一个常用用途就是为了审计的目的来记录对数据库的修改，比如，记录谁对数据库进行了相关的什么操作。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 环境准备</span><span class="token keyword">USE</span> sql_invoicing<span class="token punctuation">;</span><span class="token comment">-- 用来记录对payments表的修改</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> payments_audit <span class="token punctuation">(</span>client_id <span class="token keyword">INT</span><span class="token punctuation">,</span><span class="token keyword">date</span><span class="token keyword">DATE</span><span class="token punctuation">,</span>amount <span class="token keyword">DECIMAL</span> <span class="token punctuation">(</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>action_type <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">50</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>action_date <span class="token keyword">DATETIME</span> <span class="token punctuation">)</span><span class="token comment">-- 创建触发器</span><span class="token keyword">DELIMITER</span> $$<span class="token keyword">DROP</span> <span class="token keyword">TRIGGER</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> payments_after_insert<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> payments_after_insert<span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> payments<span class="token keyword">FOR EACH ROW</span><span class="token keyword">BEGIN</span><span class="token keyword">UPDATE</span> invoices<span class="token keyword">SET</span> payment_total <span class="token operator">=</span> payment_total <span class="token operator">+</span> NEW<span class="token punctuation">.</span>amount<span class="token keyword">WHERE</span> invoice_id <span class="token operator">=</span> NEW<span class="token punctuation">.</span>invoice_id<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> payments_audit<span class="token keyword">VALUES</span><span class="token punctuation">(</span>NEW<span class="token punctuation">.</span>client_id<span class="token punctuation">,</span> NEW<span class="token punctuation">.</span><span class="token keyword">date</span><span class="token punctuation">,</span> NEW<span class="token punctuation">.</span>amount<span class="token punctuation">,</span> <span class="token string">'Insert'</span><span class="token punctuation">,</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">END</span>$$<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span><span class="token comment">-- 第二个</span><span class="token keyword">DELIMITER</span> $$  <span class="token comment">-- 修改分隔符</span><span class="token keyword">DROP</span> <span class="token keyword">TRIGGER</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> payments_after_delete<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> payments_after_delete<span class="token keyword">AFTER</span> <span class="token keyword">DELETE</span> <span class="token keyword">ON</span> payments <span class="token comment">-- 明确触发时机，在删除之后</span><span class="token keyword">FOR EACH ROW</span> <span class="token comment">-- 在每一个受影响的行触发</span><span class="token keyword">BEGIN</span> <span class="token keyword">UPDATE</span> invoices<span class="token keyword">SET</span> payment_total <span class="token operator">=</span> payment_total <span class="token operator">-</span> OLD<span class="token punctuation">.</span>amount <span class="token comment">-- OLD 关键词就是旧的数据行(更新或删除前)</span><span class="token keyword">WHERE</span> invoice_id <span class="token operator">=</span> OLD<span class="token punctuation">.</span>invoice_id<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> payments_audit<span class="token keyword">VALUES</span><span class="token punctuation">(</span>OLD<span class="token punctuation">.</span>client_id<span class="token punctuation">,</span> OLD<span class="token punctuation">.</span><span class="token keyword">date</span><span class="token punctuation">,</span> OLD<span class="token punctuation">.</span>amount<span class="token punctuation">,</span> <span class="token string">'Delete'</span><span class="token punctuation">,</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">END</span>$$<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span> <span class="token comment">-- 恢复分隔符</span><span class="token comment">-- 测试</span><span class="token comment">-- 查询操作表</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> payments_audit<span class="token punctuation">;</span><span class="token comment">-- 插入数据</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> payments<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token keyword">DEFAULT</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'2023-05-07'</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 再次查询查看记录</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> payments_audit<span class="token punctuation">;</span><span class="token comment">-- 删除刚刚插入的数据</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> payments <span class="token keyword">WHERE</span> payment_id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> LAST_INSERT_ID<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 再次查看记录</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> payments_audit<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_016.png" class="" title="image_016"><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><blockquote><p><code>Events</code></p></blockquote><p>事件是根据计划执行的任务或一堆SQL代码，可以只执行一次或者按照规律执行，例如：每天一次或每月一次。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 可以先打开 MySql 事件调度器，这是一个后台程序，时刻在检查需要执行的事件</span><span class="token comment">-- 查看系统变量，</span><span class="token keyword">SHOW</span> VARIABLES<span class="token punctuation">;</span><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'event%'</span><span class="token punctuation">;</span><span class="token comment">-- 关闭事件调度器</span><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> event_scheduler <span class="token operator">=</span> <span class="token keyword">OFF</span><span class="token punctuation">;</span><span class="token comment">-- 开始事件调度器</span><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> event_scheduler <span class="token operator">=</span> <span class="token keyword">ON</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_017.png" class="" title="image_017"><h3 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 创建事件</span><span class="token keyword">DELIMITER</span> $$<span class="token keyword">DROP</span> EVENT <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> yearly_delete_stale_audit_rows<span class="token punctuation">;</span><span class="token keyword">CREATE</span> EVENT yearly_delete_stale_audit_rows<span class="token keyword">ON</span> SCHEDULE  <span class="token comment">-- 设置调度规则</span><span class="token comment">-- AT '2023-05-07'  -- 在这天调度</span>EVERY <span class="token number">1</span> <span class="token keyword">HOUR</span> <span class="token comment">-- 每一小时， 当然也可也设置为 DAY、YAER</span>STARTS <span class="token string">'2023-05-01'</span> ENDS <span class="token string">'2023-05-10'</span>  <span class="token comment">-- 设置调度的启示时间和终止时间</span><span class="token keyword">DO</span> <span class="token keyword">BEGIN</span>  <span class="token comment">-- 执行的部分</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> payments_audit<span class="token keyword">WHERE</span> action_date <span class="token operator">&lt;</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">INTERVAL</span> <span class="token number">1</span> <span class="token keyword">YEAR</span><span class="token punctuation">;</span>  <span class="token comment">-- 当前时间 减去 一年。 这里和之前的 DATEADD() DATESUB() 函数表达式一致，当然也可以使用这两个函数</span><span class="token keyword">END</span>$$<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看事件"><a href="#查看事件" class="headerlink" title="查看事件"></a>查看事件</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查看事件</span><span class="token keyword">SHOW</span> EVENTS<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_018.png" class="" title="image_018"><h3 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 删除事件</span><span class="token keyword">DROP</span> EVENT <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> yearly_delete_stale_audit_rows<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="更改事件"><a href="#更改事件" class="headerlink" title="更改事件"></a>更改事件</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 更改事件, 这里可以使用 ALTER 来修改事件，就像修改一张表一样，而不用类似于存储过程一样，要先删除再创建</span><span class="token comment">-- 但是这里只能修改  执行体 部分，不能修改调度体</span><span class="token keyword">ALTER</span> EVENT yearly_delete_stale_audit_rows<span class="token keyword">ON</span> SCHEDULE  <span class="token comment">-- 设置调度规则</span><span class="token comment">-- AT '2023-05-07'  -- 在这天调度</span>EVERY <span class="token number">1</span> <span class="token keyword">HOUR</span> <span class="token comment">-- 每一小时， 当然也可也设置为 DAY、YAER</span>STARTS <span class="token string">'2023-05-01'</span> ENDS <span class="token string">'2023-05-10'</span>  <span class="token comment">-- 设置调度的启示时间和终止时间</span><span class="token keyword">DO</span> <span class="token keyword">BEGIN</span>  <span class="token comment">-- 执行的部分</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> payments_audit<span class="token keyword">WHERE</span> action_date <span class="token operator">&lt;</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">INTERVAL</span> <span class="token number">1</span> <span class="token keyword">YEAR</span><span class="token punctuation">;</span>  <span class="token comment">-- 当前时间 减去 一年。 这里和之前的 DATEADD() DATESUB() 函数表达式一致，当然也可以使用这两个函数</span><span class="token keyword">END</span>$$<span class="token comment">-- 关闭一个事件</span><span class="token keyword">ALTER</span> EVENT yearly_delete_stale_audit_rows <span class="token keyword">DISABLE</span><span class="token punctuation">;</span><span class="token comment">-- 开启一个事件</span><span class="token keyword">ALTER</span> EVENT yearly_delete_stale_audit_rows <span class="token keyword">ENABLE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote><p><code>Transactions</code></p></blockquote><p>事务是代表单个工作单元的一组<code>SQL</code>语句，所有的语句都成功完成才算完成，否则事务就会运行失败。</p><p>事务具有如下特性（<code>ACID</code>）</p><ul><li>原子性（<code>Atomicity</code>）<ul><li>每个事务都是一个工作单元，不管其包含了多少语句，要么这些语句都执行成功且事务被提交，要么就有所失败事务被退回所有更改都被撤销。</li></ul></li><li>一致性（<code>Consistency</code>）<ul><li>通过事务，数据库将始终保持一致的状态</li></ul></li><li>隔离性（<code>Isolation</code>）<ul><li>事务都是相互隔离的，互不干扰。如果多个事务需要更新同一行，受影响的行将会被锁定，只有上一个事务完成修改提交后才会释放锁，允许下一个事务的修改。</li></ul></li><li>持久性（<code>Durability</code>）<ul><li>一旦事务被提交，产生的修改将会是永久的</li></ul></li></ul><h3 id="创建事务"><a href="#创建事务" class="headerlink" title="创建事务"></a>创建事务</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> sql_store<span class="token punctuation">;</span><span class="token comment">-- 创建事务</span><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>  <span class="token comment">-- 开始创建一个事务</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> orders <span class="token punctuation">(</span>customer_id<span class="token punctuation">,</span> order_date<span class="token punctuation">,</span> <span class="token keyword">status</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> order_items<span class="token keyword">VALUES</span> <span class="token punctuation">(</span>LAST_INSERT_ID<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span> <span class="token comment">-- 提交，  如果前面的执行不错误，就会提交之前的所有修改，如果出现错误就会撤销修改。</span><span class="token comment">-- ROLLBACK; -- 替换COMMIT， 作用是退回事务并撤销所有的更改</span><span class="token comment">-- 查看MySql的自动提交配置</span><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'autocommit'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="并发和锁"><a href="#并发和锁" class="headerlink" title="并发和锁"></a>并发和锁</h3><blockquote><p><code>Concurrency</code></p></blockquote><p>真实的应用场景中，会存在有两个以及更多的用户同时访问相同数据的情况，这就是并发。而锁机制是为了控制并发访问时的数据访问权限。在 <code>SQL</code> 中，锁可以分为共享锁和排他锁两种。</p><ul><li>共享锁（<code>Shared Lock</code>）<ul><li>一种保护读操作的锁，它允许多个用户同时访问同一份数据，但是不允许写操作。当一个用户持有共享锁时，其他用户也可以获得共享锁，但是不能获得排他锁。</li></ul></li><li>排他锁（<code>Exclusive Lock</code>）<ul><li>一种保护写操作的锁，它只允许一个用户访问数据，其他用户必须等待该用户释放锁才能访问。当一个用户持有排他锁时，其他用户不可以获得共享锁或排他锁。</li></ul></li></ul><h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><ul><li>丢失更新（<code>Lost Updates</code>）<ul><li>当两个事务尝试更新相同的数据并且没有上锁时，就可能发生。较晚提交的事务会覆盖较早事务做的更改</li></ul></li><li>读脏数据（<code>Dirty Reads</code>）<ul><li>一个事务<code>A</code>读取了另一个事务<code>B</code>尚未被提交的数据，当另一个事务<code>B</code>发生错误回退了修改，数据恢复原始。这时候最开始的事务<code>A</code>就会读取一个已经不存在的脏数据。</li><li>使用<strong>读已提交隔离</strong>级别（<code>Read committed</code>）来解决</li></ul></li><li>不可重复度（<code>Non-repeating Reads</code>）<ul><li>在事务执行中，读取一个数据两次，在两次读取之间有另一个事务修改了这个数据，就会导致两次得到的结果不同。</li><li>使用<strong>可重复读隔离</strong>级别（<code>Repeatable read</code>）来解决</li></ul></li><li>幻读（<code>Phantom Reads</code>）<ul><li>当某个事务<code>A</code>范围查询数据时，另一个事务<code>B</code>在该范围内插入了数据，当事务<code>A</code>再次范围查询时，会产生幻行（即多了事务<code>B</code>插入的那行数据，因为是读已提交的，所以事务B为提交的读，A第一次查询时查询不到的）。</li><li>使用<strong>序列化隔离</strong>级别（<code>Serializable</code>）来解决</li></ul></li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>由上而下，隔离级别越高</p><ul><li><strong>读未提交</strong><ul><li>解决不了上述四个问题中的任何一个</li></ul></li><li><strong>读已提交</strong><ul><li>可以解决读藏数据的问题</li></ul></li><li><strong>可重复度</strong><ul><li>可以解决丢失更新、读脏数据、不可重复读三个问题</li></ul></li><li><strong>序列化</strong><ul><li>四个问题都可以解决</li></ul></li></ul><p>但是，随着隔离级别越高，存在着越大的性能和可扩展性问题，因为需要使用到了更多或更高级别的锁，并发的数量更少。</p><img src="/2023/04/23/cs-data/data-sql/image_019.png" class="" title="image_019"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查看当前数据库的事务的隔离级别</span><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'transaction_isolation'</span><span class="token punctuation">;</span><span class="token comment">-- 更改隔离级别</span><span class="token keyword">SET</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token keyword">SERIALIZABLE</span><span class="token punctuation">;</span>  <span class="token comment">-- 设置当前事务的隔离级别为 序列化级别。 只会影响当前事务的隔离级别，而不会影响其他事务的隔离级别</span><span class="token keyword">SET</span> <span class="token keyword">SESSION</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token keyword">SERIALIZABLE</span><span class="token punctuation">;</span> <span class="token comment">-- 设置当前会话的事务隔离级别</span><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token keyword">SERIALIZABLE</span><span class="token punctuation">;</span><span class="token comment">-- 为所有会话中所有新事务设置全局隔离级别</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>当不同的事务均因为拥有了别的事务锁需要的“<strong>锁</strong>”而无法完成的情况，两个事务之间都在等待对方释放锁，这种情况就是死锁。具体来说，当一个事务持有某个资源并试图获取另一个资源时，而另一个事务持有该资源并试图获取第一个事务持有的资源时，就会形成死锁。</p><p>死锁可能会导致系统崩溃或无响应，因此需要采取一些措施来避免或解决死锁问题。常用的解决方法包括：</p><ul><li><strong>避免死锁</strong><ul><li>通过一些算法和策略来避免死锁的产生，例如资源分配图算法、银行家算法等</li></ul></li><li><strong>检测死锁</strong><ul><li>在系统中定期扫描资源的使用情况，发现死锁后进行解除</li></ul></li><li><strong>恢复死锁</strong><ul><li>中断部分线程，释放资源使系统恢复正常</li></ul></li><li><strong>预防死锁</strong><ul><li>通过设计良好的程序和算法来避免死锁的发生</li></ul></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote><p><code>Designing Databases</code></p></blockquote><h3 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h3><p><code>Mysql</code>中的数据类型分为以下几类</p><ul><li>字符串类型</li><li>数值类型</li><li>日期时间类型</li><li>BLOB类型<ul><li>存储二进制数据</li></ul></li><li>空间类型<ul><li>存储几何或者地区值</li></ul></li></ul><p><a href="https://dev.mysql.com/doc/refman/8.0/en/data-types.html" title="点击跳转"><code>MySql</code>文档上的说明</a>：<a href="https://dev.mysql.com/doc/refman/8.0/en/data-types.html">https://dev.mysql.com/doc/refman/8.0/en/data-types.html</a></p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>在进行数据导入和导出时，需要注意数据是否正确地转换为其他数据类型。</p><ul><li><code>CHAR(x)</code><ul><li>用于存储固定长度的字符数据，其中<code>x</code>表示列的长度（以字符为单位）。这意味着<code>CHAR</code>类型始终使用<code>x</code>个字符的存储空间，无论实际存储的数据大小如何。<code>CHAR</code>类型的最大长度是<code>255</code>个字符。如果需要存储更大的数据，可以考虑使用<code>VARCHAR</code>、<code>MEDIUMTEXT</code>或<code>LONGTEXT</code>类型。</li><li><code>CHAR</code>类型始终使用固定长度的存储空间，这可能会浪费存储空间；</li></ul></li><li><code>VARCHAR(x)</code><ul><li>存储可变长度的字符数据，其中x表示列的最大长度（以字符为单位）。这意味着<code>VARCHAR</code>类型可以存储长度不等的字符串，最大长度为<code>x</code>个字符。存储空间是根据实际存储的数据大小而变化的，因此可以节省存储空间。例如，如果一个<code>VARCHAR(255)</code>列中只存储了<code>10</code>个字符的数据，则该列实际上只使用了<code>10</code>个字符的存储空间，而不是<code>255</code>个字符的存储空间。最大长度是<code>65535</code>个字符（<code>64KB</code>）。如果需要存储更大的数据，可以考虑使用<code>MEDIUMTEXT</code>或<code>LONGTEXT</code>类型。</li><li><code>VARCHAR</code>类型的大小可以动态变化，这可能会影响性能和存储空间的使用；</li></ul></li><li><code>MEDIUMTEXT</code><ul><li>存储中等长度的文本数据，最大长度为16MB。在<code>MySql</code>中，<code>MEDIUMTEXT</code>类型使用3字节来存储长度信息，因此其最大长度为16,777,215个字符。</li><li><code>MEDIUMTEXT</code>类型<strong>不支持索引</strong></li></ul></li><li><code>LONGTEXT</code><ul><li>用于存储较长的文本数据，最大长度为<code>4GB</code>.</li><li><code>LONGTEXT</code>类型<strong>不支持索引</strong></li></ul></li><li><code>TINYTEXT</code><ul><li>用于存储短文本数据，最大长度为<code>255</code>个字符，与<code>VARCHAR</code>和<code>TEXT</code>类型不同，<code>TINYTEXT</code>类型是固定长度的数据类型，始终使用<code>1</code>字节来存储长度信息。</li><li><code>TINYTEXT</code>类型<strong>不支持索引</strong>，因此在进行查询时可能会影响性能</li></ul></li><li><code>TEXT</code><ul><li>用于存储较长的文本数据，最大长度为<strong>64KB</strong>。</li><li><code>TEXT</code>类型<strong>不支持索引</strong></li></ul></li></ul><h4 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h4><p><code>UTF-8</code>编码是一种变长的字符编码方式，一个字符的存储空间可以是1到4个字节。由于<code>UTF-8</code>编码支持多种语言和字符集，不同真实语言中的字符可能占用不同数量的字节。常见的如下</p><ul><li>英文字母、数字和标点符号：1个字节</li><li>拉丁字母扩展字符集（如法语、德语、西班牙语中的字符）：1到2个字节</li><li>希腊字母、西里尔字母和亚美尼亚字母等：2个字节</li><li>中文、日文、韩文和泰文等字符：3个字节</li><li>图形符号和表情符号等：3到4个字节</li></ul><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>当用 <code>unsigned</code> 修饰时为无符号的整数。在进行数据导入和导出时，需要注意整数类型的数据是否正确地转换为其他数据类型。</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/integer-types.html" title="点击跳转"><code>MySql</code>文档上的说明</a>：<a href="https://dev.mysql.com/doc/refman/8.0/en/integer-types.html">https://dev.mysql.com/doc/refman/8.0/en/integer-types.html</a></p><ul><li><code>TINYINT</code><ul><li><code>TINYINT</code>是<code>MySql</code>数据库中一种整数数据类型，用于存储小整数值。<code>TINYINT</code>类型可以存储范围从<code>-128</code>到<code>127</code>的整数值，或者范围从<code>0</code>到<code>255</code>的无符号整数值。</li><li><code>TINYINT</code>类型占用<code>1</code>个字节的存储空间。</li></ul></li><li><code>SMALLINT</code><ul><li>用于存储较小的整数值。<code>SMALLINT</code>类型可以存储范围从<code>-32768</code>到<code>32767</code>的整数值，或者范围从<code>0</code>到<code>65535</code>的无符号整数值。</li><li><code>SMALLINT</code>类型占用<code>2</code>个字节的存储空间。</li></ul></li><li><code>MEDIUMINT</code><ul><li>用于存储中等大小的整数值。<code>MEDIUMINT</code>类型可以存储范围从<code>-8388608</code>到<code>8388607</code>的整数值，或者范围从<code>0</code>到<code>16777215</code>的无符号整数值。</li><li><code>MEDIUMINT</code>类型占用<code>3</code>个字节的存储空间。</li></ul></li><li><code>INT</code><ul><li>用于存储常规大小的整数值。<code>INT</code>类型可以存储范围从<code>-2147483648</code>到<code>2147483647</code>的整数值，或者范围从<code>0</code>到<code>4294967295</code>的无符号整数值。</li><li><code>INT</code>类型占用<code>4</code>个字节的存储空间</li></ul></li><li><code>BIGINT</code><ul><li>用于存储大整数值。<code>BIGINT</code>类型可以存储范围从<code>-9223372036854775808</code>到<code>9223372036854775807</code>的整数值，或者范围从<code>0</code>到<code>18446744073709551615</code>的无符号整数值。</li><li><code>BIGINT</code>类型占用<code>8</code>个字节的存储空间</li></ul></li></ul><h3 id="定点数类型"><a href="#定点数类型" class="headerlink" title="定点数类型"></a>定点数类型</h3><p><code>MySql</code>中的定点数类型是指<code>DECIMAL</code>和<code>NUMERIC</code>类型，用于存储精确的小数值。<code>DECIMAL</code>和<code>NUMERIC</code>类型可以指定精度和小数位数，因此可以确保存储的小数值具有一定的精确性。</p><p>在<code>MySql</code>中，<code>DECIMAL</code>和<code>NUMERIC</code>类型的定义形式如下：</p><ul><li><code>DECIMAL(M,D)</code></li><li><code>NUMERIC(M,D)</code></li></ul><p>其中，<code>M</code>表示数字的总位数，<code>D</code>表示小数点后的位数。例如，<code>DECIMAL(10,2)</code>表示一个最大值为<code>9999999999.99</code>的数值，其中<code>10</code>表示数字的总位数，<code>2</code>表示小数点后的位数。</p><p>在指定<code>DECIMAL</code>类型的精度和小数位数时，需要考虑存储的数据类型以及数据库的存储空间限制；</p><h3 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h3><p><code>MySql</code>数据库中有两种浮点数类型：<code>FLOAT</code>和<code>DOUBLE</code>。浮点数类型用于存储近似的小数值。<code>FLOAT</code>类型可以存储<code>4</code>个字节的单精度浮点数，而<code>DOUBLE</code>类型可以存储<code>8</code>个字节的双精度浮点数。</p><ul><li><code>FLOAT</code></li><li><code>DOUBLE</code></li></ul><p>浮点数类型的精度是有限的，因此在进行精确计算时需要注意精度损失的问题</p><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p><code>MySql</code>中的布尔类型是<code>TINYINT</code>类型，其值为<code>0</code>或<code>1</code>，用于表示逻辑真或假。</p><p><code>MySql</code>中会自动的把 <code>TRUE</code> 转为 <code>1</code>， <code>FALSE</code> 转为 <code>0</code>。</p><h3 id="枚举和集合类型"><a href="#枚举和集合类型" class="headerlink" title="枚举和集合类型"></a>枚举和集合类型</h3><p>枚举和集合类型用于存储离散的值，可以用于表示一组预定义的取值。枚举类型用于存储单个取值，而集合类型用于存储多个取值。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 枚举的定义方式</span><span class="token keyword">ENUM</span><span class="token punctuation">(</span>value1<span class="token punctuation">,</span> value2<span class="token punctuation">,</span> value3<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment">-- 例如</span><span class="token keyword">ENUM</span><span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">)</span><span class="token comment">-- 集合的定义方式</span><span class="token keyword">SET</span><span class="token punctuation">(</span>value1<span class="token punctuation">,</span> value2<span class="token punctuation">,</span> value3<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment">-- 例如</span><span class="token keyword">SET</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token string">'orange'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><p>有多种日期和时间类型，主要包括<code>DATE</code>、<code>TIME</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>和<code>YEAR</code>类型。</p><ul><li><code>DATE</code><ul><li>用于存储日期值，包括年、月、日。<code>DATE</code>类型的格式为<code>'YYYY-MM-DD'</code>。</li></ul></li><li><code>TIME</code><ul><li>用于存储时间值，包括时、分、秒。<code>TIME</code>类型的格式为<code>'HH:MM:SS'</code>。</li></ul></li><li><code>DATETIME</code><ul><li>有<code>8B</code>大小，用于存储日期和时间值，包括年、月、日、时、分、秒。<code>DATETIME</code>类型的格式为<code>'YYYY-MM-DD HH:MM:SS'</code>。</li></ul></li><li><code>TIMESTAMP</code><ul><li>只有<code>4B</code>大小，用于存储日期和时间值，包括年、月、日、时、分、秒。<code>TIMESTAMP</code>类型的格式为<code>'YYYY-MM-DD HH:MM:SS'</code>。与<code>DATETIME</code>类型不同的是，<code>TIMESTAMP</code>类型的取值范围比<code>DATETIME</code>类型更小，可以表示的时间范围为<code>'1970-01-01 00:00:01'</code>到<code>'2038-01-19 03:14:07'</code>。</li></ul></li><li><code>YEAR</code><ul><li><code>YEAR</code>类型用于存储年份值，包括<code>4</code>位数的年份值。<code>YEAR</code>类型的格式为<code>'YYYY'</code>。</li></ul></li></ul><h3 id="Blob类型"><a href="#Blob类型" class="headerlink" title="Blob类型"></a>Blob类型</h3><p>用于存储二进制大对象数据，例如图像、音频、视频等。<code>BLOB</code>类型可以存储任意长度的二进制数据，最大支持存储<code>4GB</code>的数据。</p><p><code>BLOB</code>类型可以分为以下几种：</p><ul><li><code>TINYBLOB</code><ul><li>最大长度为<code>255</code>个字节的BLOB类型。<code>255B</code></li></ul></li><li><code>BLOB</code><ul><li>最大长度为<code>65,535</code>个字节的BLOB类型。<code>65KB</code></li></ul></li><li><code>MEDIUMBLOB</code><ul><li>最大长度为<code>16,777,215</code>个字节的<code>BLOB</code>类型。<code>16MB</code></li></ul></li><li><code>LONGBLOB</code><ul><li>最大长度为<code>4GB</code>的<code>BLOB</code>类型。</li></ul></li></ul><h3 id="JSON类型"><a href="#JSON类型" class="headerlink" title="JSON类型"></a>JSON类型</h3><p>用于存储<code>JSON</code>格式的数据。</p><p><code>JSON</code>类型可以用于存储任何合法的<code>JSON</code>格式的数据，包括对象、数组、字符串、数字、布尔值和<code>null</code>值等。使用<code>JSON</code>类型时，可以使用<code>MySQL</code>提供的<code>JSON</code>函数对<code>JSON</code>数据进行操作和查询。</p><p>需要注意的是，由于<code>JSON</code>类型比较新，因此在一些老版本的<code>MySQL</code>中可能不支持JSON<code>类型</code>。在使用<code>JSON</code>类型时，需要确认<code>MySql</code>的版本是否支持该数据类型。</p><h2 id="设计数据库"><a href="#设计数据库" class="headerlink" title="设计数据库"></a>设计数据库</h2><h3 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h3><ol><li><code>Understand the requirements</code>，理解需求</li><li><code>Build a Conceptual Model</code>，构建业务的概念模型</li><li><code>Build a Logical Model</code>，构建逻辑模型</li><li><code>Build a Physical Model</code>，构建实体模型</li></ol><h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><p>概念模型是指对现实世界的某个领域或问题域进行抽象和概括，形成一个抽象的模型。在数据库设计中，概念模型是指对要设计的数据库中的实体、属性、关系等进行抽象和概括，形成一个高层次的模型，以便于后续的数据库设计和实现。</p><p>通常可以使用实体关系图或<code>UML</code>图（<code>uified modeling languages</code> 标准建模语言图）来直观的展示概念模型。</p><p><strong>实体-关系图</strong>(<code>Entity-Relationship Diagram, ERD</code>)。在<code>ERD</code>中，<strong>实体</strong>表示现实世界中的具体事物或概念，<strong>属性</strong>表示实体的特征或属性，<strong>关系</strong>表示实体之间的关联或联系。</p><p>一个典型的<code>ERD</code>包括以下几个部分：</p><ul><li><p><strong>实体</strong>(<code>Entity</code>)</p><ul><li>表示现实世界中的具体事物或概念，通常用矩形表示。</li></ul></li><li><p><strong>属性</strong>(<code>Attribute</code>)</p><ul><li>表示实体的特征或属性，通常用椭圆形表示。</li></ul></li><li><p><strong>主键</strong>(<code>Primary Key</code>)</p><ul><li>表示实体的唯一标识符，通常用下划线表示。</li></ul></li><li><p><strong>外键</strong>(<code>Foreign Key</code>)</p><ul><li>表示实体之间的关联或联系，通常用箭头表示。</li></ul></li><li><p><strong>关系</strong>(<code>Relationship</code>)</p><ul><li>表示实体之间的关联或联系，通常用菱形表示。</li></ul></li></ul><blockquote><p>推荐绘图工具 <a href="https://www.drawio.com/" title="点击跳转">draw.io</a> ：<a href="https://www.drawio.com/">https://www.drawio.com/</a></p><p>在线使用地址：<a href="https://app.diagrams.net/">https://app.diagrams.net/</a></p><p>下载地址：<a href="https://github.com/jgraph/drawio/releases">https://github.com/jgraph/drawio/releases</a></p><p>官网地址：<a href="https://www.diagrams.net/">https://www.diagrams.net/</a></p></blockquote><p>示例：</p><img src="/2023/04/23/cs-data/data-sql/image_020.png" class="" title="image_020"><h3 id="逻辑模型"><a href="#逻辑模型" class="headerlink" title="逻辑模型"></a>逻辑模型</h3><p>对概念模型进行细化和扩展，形成一个更加具体和详细的模型。在数据库设计中，逻辑模型是指在概念模型的基础上，进一步定义实体、属性、关系、约束等，形成一个更加具体和详细的模型，以便于后续的数据库实现和应用。</p><p>设计逻辑模型时需要注意以下几点：</p><ul><li><p>在设计表和字段时，需要考虑实体在逻辑模型中的属性和特征，以及在数据库中的存储需求和查询需求。</p></li><li><p>在设计关系时，需要考虑实体之间的联系和关联，以及在数据库中的存储需求和查询需求。</p></li><li><p>在设计主键和外键时，需要考虑实体之间的关系和约束，以确保数据的完整性和准确性。</p></li><li><p>在设计约束时，需要考虑数据的完整性和准确性，以确保数据库中的数据符合要求。</p></li></ul><p>示例：</p><p>对应关系示例图</p><img src="/2023/04/23/cs-data/data-sql/image_021.png" class="" title="image_021"><img src="/2023/04/23/cs-data/data-sql/image_022.png" class="" title="image-20230507205811634"><h3 id="实体模型"><a href="#实体模型" class="headerlink" title="实体模型"></a>实体模型</h3><p>对数据库中的实体、属性、关系等进行具体化和实现，形成一个实际的数据库模型。在数据库设计中，实体模型是最终的数据库设计结果，是一个具体的、可实现的数据库模型。</p><p>实体模型通常使用关系模型表示，与逻辑模型类似。不同的是，在实体模型中，需要对关系模型进行实现和优化，以便于实际的数据库应用和操作。</p><p>示例</p><img src="/2023/04/23/cs-data/data-sql/image_023.png" class="" title="image_023"><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>主键，是唯一标识给定表里每条记录的字段或字段组合。键的作用是确保表中的每一行数据都有一个唯一的标识符，以便于在表中查找、更新或删除数据。</p><p>主键具有以下特点：</p><ul><li><p>主键必须唯一：每行数据必须有一个唯一的主键值，以确保表中的每一行数据都可以被唯一地标识。</p></li><li><p>主键不能为空：主键值不能为<code>NULL</code>，以确保表中的每一行数据都有一个有效的主键值。</p></li><li><p>主键不可修改：主键值在插入后不能被修改，以确保表中的每一行数据都有一个唯一且不可修改的标识符。</p></li></ul><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>外键是指一个表中的字段，它与另一个表中的主键形成了关联。通过外键，可以建立表与表之间的联系，实现数据的关联和查询。</p><p>外键具有以下特点：</p><ul><li><p>外键是另一个表的主键或唯一键；</p></li><li><p>外键用于建立表与表之间的联系；</p></li><li><p>外键用于保持数据的一致性和完整性；</p></li><li><p>外键用于实现级联更新和级联删除。</p></li></ul><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>外键约束是关系型数据库中用于保证数据完整性的一种约束。它建立于一个表的一个或多个字段上，这些字段引用了另一个表中的主键或唯一键。外键约束确保了两个表之间的一致性，即引用表中的每个外键值必须对应于主表中的一个主键值或唯一键值。</p><p>外键约束的作用主要有以下几个方面：</p><ul><li><p>保证数据的完整性：外键约束可以防止向表中插入无效的数据，确保数据的一致性和完整性。</p></li><li><p>级联更新：外键约束可以实现级联更新，即当主表中的主键值发生变化时，外键表中的对应外键值也会自动更新。</p></li><li><p>级联删除：外键约束可以实现级联删除，即当主表中的某个主键值被删除时，外键表中对应的外键值也会自动删除。</p></li><li><p>查询优化：外键约束可以提高查询效率，因为它可以通过索引快速查找与主键或唯一键相关的数据。</p></li></ul><h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p>指对关系型数据库中的表进行优化和规范化，以提高数据库的效率、可靠性和灵活性。标准化的主要目的是消除数据冗余，减少数据存储空间，提高数据的一致性和完整性，避免数据更新异常和插入异常。</p><p>在关系型数据库中，标准化通常分为三个层次</p><ul><li>第一范式（<code>1NF</code>）<ul><li>要求每个列都是不可分的基本数据项，即每个列的值都是原子的，不能再分解成更小的数据项。这样可以消除表中的重复数据，减少数据冗余。</li></ul></li><li>第二范式（<code>2NF</code>）<ul><li>要求每个表必须有一个主键，并且每个非主键列都必须完全依赖于主键，即非主键列都与主键有直接关系，不能与其他非主键列有关系。这样可以消除数据更新异常和插入异常。</li></ul></li><li>第三范式（<code>3NF</code>）<ul><li>要求每个非主键列都必须直接依赖于主键，而不能间接依赖于主键。如果一个非主键列可以通过其他非主键列推导得出，那么就应该把这个非主键列独立出来形成一个新表。这样可以消除数据冗余，提高数据库的效率。</li></ul></li></ul><p>除了以上三个范式外，还有更高级别的范式，如巴斯-科德范式（<code>BCNF</code>）和第四范式（<code>4NF</code>），它们对数据的规范化要求更加严格和复杂</p><h3 id="创建和删除数据库"><a href="#创建和删除数据库" class="headerlink" title="创建和删除数据库"></a>创建和删除数据库</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 创建数据库</span><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> sql_store_2<span class="token punctuation">;</span><span class="token comment">-- 删除数据库</span><span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> sql_store_2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> sql_store_2<span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> customers<span class="token punctuation">;</span><span class="token comment">-- 创建表</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> customers <span class="token punctuation">(</span>customer_id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    first_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    points <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">,</span>    email <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="更改表"><a href="#更改表" class="headerlink" title="更改表"></a>更改表</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 修改表，添加字段</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> customers<span class="token keyword">ADD</span> last_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AFTER</span> first_name<span class="token punctuation">;</span> <span class="token comment">-- 在 first_name 表之后添加字段</span><span class="token comment">-- 当然一次可以执行多个操作</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> customers<span class="token keyword">ADD</span> last_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AFTER</span> first_name<span class="token punctuation">,</span> <span class="token comment">-- 在 first_name 表之后添加字段</span><span class="token keyword">ADD</span> city <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">MODIFY</span> <span class="token keyword">COLUMN</span> first_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">55</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment">-- 修改列</span><span class="token keyword">DROP</span> points<span class="token punctuation">;</span>  <span class="token comment">-- 删除列</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建外键关系"><a href="#创建外键关系" class="headerlink" title="创建外键关系"></a>创建外键关系</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> orders<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> orders <span class="token punctuation">(</span>order_id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    customer_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_orders_customers<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>customer_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">CONSTRAINT</span> fk_orders_customers <span class="token comment">-- 设置外键名</span>    <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>customer_id<span class="token punctuation">)</span>  <span class="token comment">-- 创建外键</span>    <span class="token keyword">REFERENCES</span> customers <span class="token punctuation">(</span>customer_id<span class="token punctuation">)</span> <span class="token comment">-- 连接的表和字段</span>    <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CASCADE</span> <span class="token comment">-- 设置更新操作为  级联</span>    <span class="token comment">-- ON UPDATE SET NULL -- 或者设置为空值</span>    <span class="token comment">-- ON UPDATE NO ACTION -- 或者设置不做操作 </span>    <span class="token keyword">ON</span> <span class="token keyword">DELETE</span> <span class="token keyword">NO</span> <span class="token keyword">ACTION</span> <span class="token comment">-- 设置更新时 ，不做操作  </span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="更改主键和外键约束"><a href="#更改主键和外键约束" class="headerlink" title="更改主键和外键约束"></a>更改主键和外键约束</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 给已有的表更改外键约束</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> orders<span class="token keyword">DROP</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>  <span class="token comment">-- 删除主键</span><span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>order_id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">-- 添加主键</span><span class="token keyword">DROP</span> <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> fk_orders_customers<span class="token punctuation">,</span><span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> fk_orders_customers <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>customer_id<span class="token punctuation">)</span>  <span class="token comment">-- 创建外键</span>    <span class="token keyword">REFERENCES</span> customers <span class="token punctuation">(</span>customer_id<span class="token punctuation">)</span> <span class="token comment">-- 连接的表和字段</span>    <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CASCADE</span> <span class="token comment">-- 设置更新操作为  级联</span>    <span class="token keyword">ON</span> <span class="token keyword">DELETE</span> <span class="token keyword">NO</span> <span class="token keyword">ACTION</span><span class="token punctuation">;</span> <span class="token comment">-- 设置更新时 ，不做操作 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符集和排序规则"><a href="#字符集和排序规则" class="headerlink" title="字符集和排序规则"></a>字符集和排序规则</h3><p>字符集是指计算机中用于表示字符的编码方式和字符集合。</p><p>在关系型数据库中，字符集通常用于指定数据库中存储的字符编码方式，以确保数据的正确性和一致性。</p><p>常见的字符集包括<code>ASCII</code>、<code>ISO-8859</code>、<code>Unicode</code>、<code>UTF-8</code>、<code>UTF-16</code>等。</p><ul><li><code>ASCII</code><ul><li>最早的字符集，只能表示英文字符和少量符号，不能表示其他语言的字符</li></ul></li><li><code>ISO-8859</code><ul><li><code>ASCII</code>的扩展，支持更多的语言字符，但仍有局限性</li></ul></li><li><code>Unicode</code><ul><li>一种国际标准，能够表示世界上所有语言的字符，包括中文、日文、韩文等</li></ul></li><li><code>UTF-8</code><ul><li><code>Unicode</code>的实现方式，<code>UTF-8</code>采用变长编码，可以节省存储空间</li></ul></li><li><code>UTF-16</code><ul><li><code>Unicode</code>的实现方式，<code>UTF-16</code>采用定长编码，可以提高查询效率</li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询当前支持的字符集</span><span class="token keyword">SHOW</span> <span class="token keyword">CHARSET</span><span class="token punctuation">;</span>  <span class="token comment">-- 在查询结果中还有一列 Default collation 是该字符集的默认排序规则，决定如何排序</span><span class="token comment">-- Maxlen， 是最大保存列，例如 UFT-8 对应的值是 3， 所以创建字段类型 CHAR(10), MySql就会为该字段预留 10 * 3 = 30 字节的空间</span><span class="token comment">-- 创建数据库时指定 字符集</span><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> db_name <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> latin1<span class="token punctuation">;</span><span class="token comment">-- 修改 字符集</span><span class="token keyword">ALTER</span> <span class="token keyword">DATABASE</span> db_name <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> latin1<span class="token punctuation">;</span><span class="token comment">-- 创建表时指定 字符集</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> table1 <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> latin1<span class="token punctuation">;</span><span class="token comment">-- 修改 字符集</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table1 <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> latin1<span class="token punctuation">;</span><span class="token comment">-- 当然也能为单独的一个字段设置字符集</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> customers <span class="token punctuation">(</span>customer_id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    first_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>  <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> latin1 <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    points <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">,</span>    email <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>存储引擎是指关系型数据库中用于存储和管理数据的软件组件或模块，它们实现了不同的存储方式、索引策略和事务特性等功能。在<code>MySql</code>数据库中，常用的存储引擎包括<code>InnoDB</code>、<code>MyISAM</code>、<code>MEMORY</code>等。</p><ul><li><p><code>InnoDB</code></p><ul><li><code>InnoDB</code>是<code>MySqL</code>数据库默认的存储引擎，支持事务、行级锁定、外键等特性。它采用<code>B+</code>树索引结构，可以提高查询效率，同时也支持全文搜索功能。</li><li><code>InnoDB</code>适用于需要高并发、可靠性和数据一致性的应用场景，如电商、金融和游戏等领域。</li></ul></li><li><p><code>MyISAM</code></p><ul><li><code>MyISAM</code>是<code>MySql</code>数据库最早的存储引擎，不支持事务和行级锁定，但支持全文索引和压缩等特性。</li><li>它采用<code>B</code>树索引结构，可以提高查询效率，但不适合高并发和写入频繁的应用场景。</li></ul></li><li><p><code>MEMORY</code></p><ul><li><code>MEMORY</code>是<code>MySql</code>数据库的内存存储引擎，数据存储在内存中，查询速度非常快，但数据容易丢失。</li><li>它适用于需要高速读写和临时存储数据的应用场景，如缓存和计数器等。</li></ul></li></ul><p>除了以上三个存储引擎外，<code>MySql</code>数据库还支持其他存储引擎，如<code>CSV</code>、<code>ARCHIVE</code>、<code>BLACKHOLE</code>等。每个存储引擎都有其特点和适用场景，需要根据实际需求进行选择和配置。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查看存储引擎</span><span class="token keyword">SHOW</span> ENGINES<span class="token punctuation">;</span><span class="token comment">-- 修改表使用的引擎</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> customers<span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span class="token comment">-- 当然也能在创建表的时候指定</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> table1 <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> latin1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高效索引"><a href="#高效索引" class="headerlink" title="高效索引"></a>高效索引</h2><blockquote><p><code>Indexing for High Performance</code></p></blockquote><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>用于提高关系型数据库的查询效率。索引可以帮助数据库快速定位表中的数据，降低查询的时间复杂度，提高数据库的性能。</p><p>在关系型数据库中，索引通常是在表的列上创建的，用于加速对该列的查询操作。索引可以分为<strong>聚簇索引</strong>和<strong>非聚簇索引</strong></p><p>可以通过索引快速的找到原始数据，</p><img src="/2023/04/23/cs-data/data-sql/image_024.png" class="" title="image_024"><p>索引通常很小，可以放到内存中进行查询，这也是其比直接检索在磁盘中的数据要快得多的一个原因、</p><img src="/2023/04/23/cs-data/data-sql/image_025.png" class="" title="image_025"><p>但是索引也存在一些弊端</p><ul><li>会增加数据库的大小，因为其必须永久存储在表的旁边</li><li>每次添加、更新或者删除记录时，MySQL必须更新对应的索引，这会影响我们正常操作的性能</li></ul><p>因为这些原因的存在，所以通常都是为比较关键的查询和字段添加索引。</p><p>如下图所示，索引通常是以树的形式存在的，这样是为了可以更快的查询遍历。这里就不对这类数据结构做过多的介绍了，有兴趣的话可以另行查询。</p><img src="/2023/04/23/cs-data/data-sql/image_026.png" class="" title="image_026"><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> customer_id <span class="token keyword">FROM</span> customers <span class="token keyword">WHERE</span> state <span class="token operator">=</span> <span class="token string">'CA'</span><span class="token punctuation">;</span> <span class="token comment">-- 用EXPLAIN分析语句</span><span class="token comment">-- 从图片 image_027 注意下 type 字段和 rows</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_027.png" class="" title="image_027"><p><code>EXPLAIN</code> 的具体说明可见本站文章：loading…</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 创建索引</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_state <span class="token keyword">ON</span> customers <span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 之后再次分析语句</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> customer_id <span class="token keyword">FROM</span> customers <span class="token keyword">WHERE</span> state <span class="token operator">=</span> <span class="token string">'CA'</span><span class="token punctuation">;</span><span class="token comment">-- 可以看到将会查询使用到的行数减少了， 而且使用到了索引</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_028.png" class="" title="image-20230507230354160"><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查看表的索引</span><span class="token keyword">SHOW</span> INDEXES <span class="token operator">IN</span> customers<span class="token punctuation">;</span><span class="token comment">-- 如果相关的参数评估不准确，可以使用下面的命令重新统计表的信息</span><span class="token keyword">ANALYZE</span> <span class="token keyword">TABLE</span> customers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行过之后可以看到两个索引，一个是主键索引名称为 <code>PRIMARY</code>，一个是二级索引名为为 <code>idx_state</code>，两者说明如下：</p><ul><li><p>主键索引</p><ul><li>主键索引是一种特殊的索引，用于加速对表中主键列的查询操作。</li><li>主键索引的特点是唯一性和非空性，即主键列的值必须唯一且不能为空。</li><li>主键索引可以帮助数据库快速定位表中的数据行，因此在设计表结构时通常会在主键列上创建主键索引。</li></ul></li><li><p>二级索引</p><ul><li>二级索引是指在表的非主键列上创建的索引。</li><li>与主键索引不同的是，二级索引并不要求列的值唯一或非空。</li><li>二级索引可以加速对非主键列的查询操作，提高查询效率。</li><li>在设计表结构时，可以根据实际需求在表的重要列上创建二级索引。</li><li><code>MySQL</code>自动的会将id或者主键列纳入到二级索引中。</li></ul></li></ul><p>需要注意的是，二级索引只是一种辅助索引，它只能加速对索引列的查询操作，而不能加速对其他列的查询操作。当查询条件不包含索引列时，数据库仍然需要进行全表扫描（这就是<strong>回表查询</strong>），查询效率会降低。</p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>一种特殊的索引，它是在字符串类型的列上创建的一种索引方式。与普通索引不同的是，前缀索引只索引字符串的前缀部分，而不是整个字符串。这样<strong>可以减少索引的大小，提高索引效率</strong>。通常应用在数据类型为 <code>CHAR</code>、<code>VARCHAR</code>、<code>TEXT</code>、<code>BLOB</code>的列上。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 创建前缀所用</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_lastname <span class="token keyword">ON</span> customers <span class="token punctuation">(</span>last_name<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 使用 last_name 的前20个字符创建索引</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>前缀索引锁设置的长度是根据实际需求选择。如果前缀长度太短，可能会导致索引失效，影响查询效率；如果前缀长度太长，可能会导致索引过大，降低数据库的性能。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 通过对比在不同前缀下记录的不重复数量，来简短的判断下选取多长的前缀区分度更高</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span> <span class="token keyword">DISTINCT</span> <span class="token keyword">LEFT</span><span class="token punctuation">(</span>last_name<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">-- 统计选取不同长度的前缀，不重复的记录个数</span><span class="token function">COUNT</span><span class="token punctuation">(</span> <span class="token keyword">DISTINCT</span> <span class="token keyword">LEFT</span><span class="token punctuation">(</span>last_name<span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">COUNT</span><span class="token punctuation">(</span> <span class="token keyword">DISTINCT</span> <span class="token keyword">LEFT</span><span class="token punctuation">(</span>last_name<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">FROM</span> customers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>一种特殊的索引，用于加速对文本类型列的模糊查询操作。与普通索引不同的是，全文索引可以对文本类型的列中的单词或短语进行索引，而不是对整个列进行索引。这样可以提高对文本内容的模糊查询效率。</p><p>在创建全文索引时，需要注意以下几点：</p><ul><li><p>只有<code>MyISAM</code>和<code>InnoDB</code>存储引擎支持全文索引，其他存储引擎不支持。</p></li><li><p>只有<code>CHAR</code>、<code>VARCHAR</code>和<code>TEXT</code>类型的列才能创建全文索引。</p></li><li><p>全文索引只能对英文、中文、日文等一些特定的语言进行索引，对于其他语言可能不支持或效果不佳。及对语言进行分词查询。</p></li><li><p>全文索引使用了一些特殊的算法，如<strong>自然语言搜索</strong>（<code>Natural Language Search</code>）和<strong>布尔搜索</strong>（<code>Boolean Search</code>），可以根据实际需求选择合适的搜索方式。</p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> sql_blog<span class="token punctuation">;</span><span class="token comment">-- 创建全文索引前， 模糊匹配查询数据比较大的字段</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> posts<span class="token keyword">WHERE</span> title <span class="token operator">LIKE</span> <span class="token string">'%react redux%'</span> <span class="token operator">OR</span>body <span class="token operator">LIKE</span> <span class="token string">'%react redux%'</span><span class="token punctuation">;</span><span class="token comment">-- 创建全文索引</span><span class="token keyword">CREATE</span> FULLTEXT <span class="token keyword">INDEX</span> idx_title_body <span class="token keyword">ON</span> posts <span class="token punctuation">(</span>title<span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 使用全文检索</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> posts<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> body<span class="token punctuation">)</span> <span class="token comment">-- 注意这里需要把索引中的列都包含</span>AGAINST <span class="token punctuation">(</span><span class="token string">'react redux'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 查询的关键词</span><span class="token comment">-- 查看结果，可以发现 title中只有redux的也可以查询出来，这是全文搜索的 '相关性得分' 所匹配的</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> body<span class="token punctuation">)</span> AGAINST <span class="token punctuation">(</span><span class="token string">'react redux'</span><span class="token punctuation">)</span> <span class="token comment">-- 相关性得分</span><span class="token keyword">FROM</span> posts<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> body<span class="token punctuation">)</span>  AGAINST <span class="token punctuation">(</span><span class="token string">'react redux'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 还有一种布尔模式，可以包含或者排除某些单词</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> body<span class="token punctuation">)</span> AGAINST <span class="token punctuation">(</span><span class="token string">'react redux'</span><span class="token punctuation">)</span> <span class="token comment">-- 相关性得分</span><span class="token keyword">FROM</span> posts<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> body<span class="token punctuation">)</span>  AGAINST <span class="token punctuation">(</span><span class="token string">'react -redux'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 查找包含 react 但是不包含 redux的行</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> body<span class="token punctuation">)</span> AGAINST <span class="token punctuation">(</span><span class="token string">'react redux'</span><span class="token punctuation">)</span> <span class="token comment">-- 相关性得分</span><span class="token keyword">FROM</span> posts<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> body<span class="token punctuation">)</span>  AGAINST <span class="token punctuation">(</span><span class="token string">'react -redux +form'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 查找包含 react 但是不包含 redux的行 还必须包含form</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> body<span class="token punctuation">)</span> AGAINST <span class="token punctuation">(</span><span class="token string">'react redux'</span><span class="token punctuation">)</span> <span class="token comment">-- 相关性得分</span><span class="token keyword">FROM</span> posts<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> body<span class="token punctuation">)</span>  AGAINST <span class="token punctuation">(</span><span class="token string">'"handling a form"'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 查找包含短语 handling a form 的行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>一种在多个列上创建的联合索引。与单列索引不同的是，复合索引可以同时索引多个列，可以提高多列查询的效率</p><p>在创建复合索引时，需要注意以下几点：</p><ul><li><p>复合索引的顺序很重要，不同的顺序可能会影响查询效率。一般来说，将选择性高的列放在前面可以提高索引的效率。</p></li><li><p>复合索引只适用于同时查询多个列的场景，对于单列查询可能不适用。</p></li><li><p>复合索引的大小和效率受到列类型、列长度、数据分布等多种因素的影响，需要根据实际情况进行优化。</p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> sql_store<span class="token punctuation">;</span><span class="token comment">-- 在只有 idx_state 索引的情况下分析该语句</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> customer_id <span class="token keyword">FROM</span> customers <span class="token keyword">WHERE</span> state <span class="token operator">=</span> <span class="token string">'CA'</span> <span class="token operator">AND</span> points <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_029.png" class="" title="image_029"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 创建联合索引</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_state_points <span class="token keyword">ON</span> customers <span class="token punctuation">(</span>state<span class="token punctuation">,</span> points<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 重新分析语句</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> customer_id <span class="token keyword">FROM</span> customers <span class="token keyword">WHERE</span> state <span class="token operator">=</span> <span class="token string">'CA'</span> <span class="token operator">AND</span> points <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token comment">-- 可以发现过滤的行数 rows 减少了很多，且使用了联合索引， 需要遍历的行数减少，查询也就会相对更快。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_030.png" class="" title="image_030"><p>如果某个索引中存在多列，数据排序也会加快。</p><p>这里很容易发生错误认知，为了方便使用，为每列创建单独的索引，但是有且情况如上面的例子所示，单列索引并不能帮助获得最佳性能，并且这些索引占用很多空间，每次修改表中的数据时，必须更新这些索引，索引越多，写入操作越慢，同时，<code>MySQL</code>会自动将表的主键包含在每个二级索引中，这些单列索引会浪费很多空间。因此使用复合索引会更好。</p><p>那么索引中应该包含多少列？<code>MySQL</code>中，一个索引中最多可以包含<code>16</code>列，但是通常不会使用这么多，一般推荐<code>4——6</code>个列，当然这不是最佳实践，最重要的是要根据使用的数据量和需求决定。</p><h4 id="复合索引中列的顺序"><a href="#复合索引中列的顺序" class="headerlink" title="复合索引中列的顺序"></a>复合索引中列的顺序</h4><p>有两个常用规则的推荐</p><ul><li>对列进行排序<ul><li>让更频繁被使用的列排在最前面。通过被频繁使用的列可以更快的缩小对索引遍历查询的范围</li></ul></li><li>基数更高的列排在最前面<ul><li>基数表示索引中唯一值的数量。这样也是为了更快速的缩小查询范围，因为唯一值更多，所以重复的可能性就更低，在指定条件时可以更快的缩小查询的数据范围。</li></ul></li></ul><p>但是，不一定要必须遵守上述的规则，<strong>更重要的是根据自己的实际情况来选择索引的顺序</strong>。</p><h3 id="指定索引查询"><a href="#指定索引查询" class="headerlink" title="指定索引查询"></a>指定索引查询</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> customer_id <span class="token keyword">FROM</span> customers<span class="token keyword">USE</span> <span class="token keyword">INDEX</span> <span class="token punctuation">(</span>idx_state_points<span class="token punctuation">)</span> <span class="token comment">-- 指定使用索引的范围，可以指定多个</span><span class="token keyword">WHERE</span> state <span class="token operator">=</span> <span class="token string">'CA'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> customer_id <span class="token keyword">FROM</span> customers<span class="token keyword">FORCE</span> <span class="token keyword">INDEX</span> <span class="token punctuation">(</span>idx_state_points<span class="token punctuation">)</span> <span class="token comment">-- 强制使用指定的索引查询</span><span class="token keyword">WHERE</span> state <span class="token operator">=</span> <span class="token string">'CA'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> customer_id <span class="token keyword">FROM</span> customers<span class="token keyword">IGNORE</span> <span class="token keyword">INDEX</span> <span class="token punctuation">(</span>idx_state_points<span class="token punctuation">)</span> <span class="token comment">-- 忽略指定的索引</span><span class="token keyword">WHERE</span> state <span class="token operator">=</span> <span class="token string">'CA'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="索引无效时"><a href="#索引无效时" class="headerlink" title="索引无效时"></a>索引无效时</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> customer_id <span class="token keyword">FROM</span> customers <span class="token keyword">WHERE</span> state <span class="token operator">=</span> <span class="token string">'CA'</span> <span class="token operator">OR</span> points <span class="token operator">&gt;</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token comment">-- 查看图 image_03 可以看到，使用了索引，但是将会使用到的行数基本等于整张表，类似于一个全索引扫描。</span><span class="token comment">-- 这时候就是没能正确使用索引，一般通过改造sql来更好的使用索引</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> customer_id <span class="token keyword">FROM</span> customers <span class="token keyword">WHERE</span> state <span class="token operator">=</span> <span class="token string">'CA'</span> <span class="token keyword">UNION</span> <span class="token keyword">SELECT</span> customer_id <span class="token keyword">FROM</span> customers <span class="token keyword">WHERE</span> points <span class="token operator">&gt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token comment">-- 但是这里并不能使用到索引 idx_state_points， 因为最左匹配原则存在（即在联合索引中，需要先匹配第一个列的值才能去匹配第二列，无法直接匹配第二列，这个和联合索引的使用B+树存储的有关）</span><span class="token comment">-- 所以推荐再单独为 points 字段创建一个索引来加速查询</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_031.png" class="" title="image_031"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> customer_id <span class="token keyword">FROM</span> customers <span class="token keyword">WHERE</span> points <span class="token operator">+</span> <span class="token number">10</span> <span class="token operator">&gt;</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token comment">-- 分析下上面的语句，可以看到这里还是基本进行了全局检索，如果数据很多，查询将会很慢</span><span class="token comment">-- 这里没有正确使用索引的原因在于，我们对列进行了计算，MySQL无法以最优方式利用索引了，索引最好的方式是将计算放到表达式的右侧，不要直接对列进行计算</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_032.png" class="" title="image_032"><p>常见的索引失效原因和场景包括以下几种：</p><ul><li><p>索引列未被使用</p><ul><li>如果查询中未包含索引列，那么索引将无法被使用。</li><li>例如，如果一个表有一个包含两个列的联合索引 (<code>col1, col2</code>)，但是查询只包含 ` col12 列，那么该索引将无法被使用。</li></ul></li><li><p>列类型不匹配</p><ul><li>索引列的类型必须与查询中的列类型相匹配，否则索引将无法被使用。</li><li>例如，如果一个表的索引列为字符串类型，但是查询中使用的是数值类型，那么该索引将无法被使用。</li></ul></li><li><p>函数操作</p><ul><li>如果查询中使用了函数操作，那么索引将无法被使用。</li><li>例如，如果一个表有一个包含两个列的联合索引 (<code>col1, col2</code>)，但是查询中使用了 <code>col1</code> 的函数操作，那么该索引将无法被使用。</li></ul></li><li><p>数据不均匀</p><ul><li>如果表中的数据分布不均匀，那么索引可能无法有效加速查询。</li><li>例如，如果一个表的索引列中有大量的重复值，那么该索引将无法有效加速查询。</li></ul></li></ul><h3 id="使用索引排序"><a href="#使用索引排序" class="headerlink" title="使用索引排序"></a>使用索引排序</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> customer_id <span class="token keyword">FROM</span> customers <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> first_name<span class="token punctuation">;</span><span class="token comment">-- 如图 image_033 这里可以看到，没有使用索引，还使用了 “外部排序” 这是一种十分耗时的操作</span><span class="token comment">-- 查看数据库的状态</span><span class="token keyword">SHOW</span> <span class="token keyword">STATUS</span><span class="token punctuation">;</span><span class="token comment">-- 执行排序</span><span class="token keyword">SELECT</span> customer_id <span class="token keyword">FROM</span> customers <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> first_name<span class="token punctuation">;</span><span class="token comment">-- 查看 上次查询 的消耗, 注意和下面的查询再一个连接中同时执行</span><span class="token keyword">SHOW</span> <span class="token keyword">STATUS</span> <span class="token operator">LIKE</span> <span class="token string">'last_query_cost'</span><span class="token punctuation">;</span><span class="token comment">-- Last_query_cost 1117.149000</span><span class="token comment">-- 之后使用有索引的字段来排序</span><span class="token keyword">SELECT</span> customer_id <span class="token keyword">FROM</span> customers <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> state<span class="token punctuation">;</span><span class="token keyword">SHOW</span> <span class="token keyword">STATUS</span> <span class="token operator">LIKE</span> <span class="token string">'last_query_cost'</span><span class="token punctuation">;</span><span class="token comment">-- Last_query_cost 103.149000</span><span class="token comment">-- 可以看到查询成本的下降 </span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> customer_id <span class="token keyword">FROM</span> customers <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> state<span class="token punctuation">;</span><span class="token comment">-- 如图 image_034 可以看到这里不在使用 “外部排序”， 而是使用了索引</span><span class="token comment">-- 当然排序的 递增和递减也会有区别， 以及在使用联合索引时，根据不同的字段排序也有所区别，这里就不做过多说明了</span><span class="token comment">-- 基本的规则就是 能基于索引的排序是效率最高的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/23/cs-data/data-sql/image_033.png" class="" title="image_033"><img src="/2023/04/23/cs-data/data-sql/image_034.png" class="" title="image_034"><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>指一个索引包含了所有需要查询的列或者排序使用到的列，因此查询可以直接使用该索引来返回结果，而不需要再次访问表中的数据行。覆盖索引可以大大提高查询的性能，因为它可以避免了访问表中的数据行，减少了磁盘I/O的开销。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> customer_id<span class="token punctuation">,</span> state <span class="token keyword">FROM</span> customers <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> state<span class="token punctuation">;</span><span class="token comment">-- 这类查询就是使用到的数据和返回的数据，都在索引中，而不需要进行回表查询去查找访问表中的数据行。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h2><blockquote><p><code>Securing databases</code></p></blockquote><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 创建一个用户</span><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> qing<span class="token variable">@127.0.0.1</span> <span class="token comment">-- 创建用户和用户可以通过什么主机IP访问数据库</span><span class="token comment">-- qing@localhost  -- 也可以指定主机名</span><span class="token comment">-- qing@code.com  -- 也可以指定域名</span><span class="token comment">-- qing@'%.code.com' -- 当然也可以使用匹配符，不过这时候就需要使用 引号包裹</span><span class="token comment">-- qing@'%' -- 不做限定，任意IP均可访问</span>IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'1234'</span><span class="token punctuation">;</span>  <span class="token comment">-- 设置认证密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询用户</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mysql<span class="token punctuation">.</span><span class="token keyword">user</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 删除用户</span><span class="token keyword">DROP</span> <span class="token keyword">USER</span> qing<span class="token variable">@127.0.0.1</span><span class="token punctuation">;</span> <span class="token comment">-- 注意这里要同时指定用户和设置的访问权限地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 修改其他用户的密码</span><span class="token keyword">SET</span> PASSWORD <span class="token keyword">FOR</span> qing <span class="token operator">=</span> <span class="token string">'12345'</span><span class="token punctuation">;</span><span class="token comment">-- 修改自己的尼玛</span><span class="token keyword">SET</span> PASSWORD <span class="token operator">=</span> <span class="token string">'12345'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h3><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" title="点击跳转"><code>MySQL</code>权限相关文档</a>：<a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html">https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html</a></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 创建用户</span><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> qing<span class="token variable">@127.0.0.1</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'1234'</span><span class="token punctuation">;</span><span class="token comment">-- 授予一些所需要的权限</span><span class="token keyword">GRANT</span><span class="token keyword">SELECT</span><span class="token punctuation">,</span>  <span class="token comment">-- 指定权限范围</span><span class="token keyword">INSERT</span><span class="token punctuation">,</span><span class="token keyword">UPDATE</span><span class="token punctuation">,</span><span class="token keyword">DELETE</span><span class="token punctuation">,</span><span class="token keyword">EXECUTE</span><span class="token keyword">ON</span> sql_store<span class="token punctuation">.</span><span class="token operator">*</span>  <span class="token comment">-- 数据库 sql_store 的所有表</span>sql_store<span class="token punctuation">.</span>customers <span class="token comment">-- 当然也可是单独一张表</span><span class="token keyword">TO</span> qing<span class="token variable">@127.0.0.1</span> <span class="token comment">-- 指定账号，如果设置了主机地址这里也需要加上</span><span class="token comment">-- 给与管理员权限， 可以查看上面的文档来确定所需要的权限</span><span class="token keyword">GRANT</span> <span class="token keyword">ALL</span> <span class="token comment">-- 给与所有权限，当然也可以根据上面的文档，选取部分</span><span class="token keyword">ON</span> sql_store<span class="token punctuation">.</span><span class="token operator">*</span>  <span class="token comment">-- 指定数据库中的所有表</span><span class="token comment">-- ON *.* -- 指定所有数据库所有表</span><span class="token keyword">TO</span> qing<span class="token variable">@127.0.0.1</span><span class="token punctuation">;</span><span class="token keyword">GRANT</span> <span class="token keyword">ALL</span> <span class="token keyword">PRIVILEGES</span> <span class="token keyword">ON</span> <span class="token punctuation">`</span>sql_store<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> qing<span class="token variable">@127.0.0.1</span><span class="token punctuation">;</span>  <span class="token comment">-- 当然也可以一次给与所有权限</span><span class="token keyword">GRANT</span> <span class="token keyword">USAGE</span> <span class="token keyword">ON</span> <span class="token punctuation">`</span>sql_store<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> qing<span class="token variable">@127.0.0.1</span><span class="token punctuation">;</span> <span class="token comment">-- 授予 最基础的权限</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查看权限</span><span class="token keyword">SHOW</span> GRANTS <span class="token keyword">FOR</span> qing<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="撤销权限"><a href="#撤销权限" class="headerlink" title="撤销权限"></a>撤销权限</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 撤销权限</span><span class="token keyword">REVOKE</span> <span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> <span class="token comment">-- 需要取消的权限</span><span class="token keyword">ON</span> sql_store<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token comment">-- 所需要取消的数据库和表范围</span><span class="token keyword">FROM</span> qing<span class="token variable">@127.0.0.1</span><span class="token punctuation">;</span> <span class="token comment">-- 指定用户</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>B站视频，SQL进阶教程：<a href="https://www.bilibili.com/video/BV1UE41147KC?p=1&amp;vd_source=524a1f1a08bc3654682c93e61bb0b959">https://www.bilibili.com/video/BV1UE41147KC?p=1&amp;vd_source=524a1f1a08bc3654682c93e61bb0b959</a></p>]]></content>
      
      
      <categories>
          
          <category> cs-data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> note </tag>
            
            <tag> mysql </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes yaml配置详解——StatefulSet篇</title>
      <link href="/2023/04/23/cs-dev-ops/k8s-statefulset-yaml/"/>
      <url>/2023/04/23/cs-dev-ops/k8s-statefulset-yaml/</url>
      
        <content type="html"><![CDATA[<blockquote><p>k8s 集群中对资源管理和资源对象编排部署都可以通过声明样式（YAML）文件来解决，通过使用kubectl 命令直接使用资源清单文件就可以实现对大量的资源对象进行编排部署了。一般情况下，都是通过配置YAML文件来部署集群的。</p><p><a href="https://kubernetes.io/docs/concepts/" title="前往">官网概念文档</a> : <a href="https://kubernetes.io/docs/concepts/">https://kubernetes.io/docs/concepts/</a></p><p><a href="https://kubernetes.io/docs/tasks/" title="前往">官网示例文档</a> : <a href="https://kubernetes.io/docs/tasks/">https://kubernetes.io/docs/tasks/</a></p><p><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/" title="前往">官网API文档</a> : <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/">https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/</a></p><p><font color="red">注意：在k8s应用的yaml文件中不支持使用制表符为缩紧，所以要保证所有缩进都是空格。</font></p></blockquote><h1 id="kubernetes-yaml配置详解——StatefulSet篇"><a href="#kubernetes-yaml配置详解——StatefulSet篇" class="headerlink" title="kubernetes yaml配置详解——StatefulSet篇"></a>kubernetes yaml配置详解——StatefulSet篇</h1><blockquote><p>管理有状态应用的工作负载 <code>API</code> 对象，为<code> Pod</code> 提供持久存储和持久标识符</p><p>适用于：稳定的、唯一的网络标识符；稳定的、持久的存储；有序的、优雅的部署和缩放；有序的、自动的滚动更新；</p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 一些重复 功能相同的配置不在过多赘述，前往 Pod/Deployment/ 的配置部分查看</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> StatefulSet <span class="token comment"># 资源类型 常用 Pod/Deployment/Service/Ingress/ConfigMap/PersistentVolume/PersistentVolumeClaim/Secret</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>deploy <span class="token comment"># 名称，在同一个namespace中需要唯一</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>kube <span class="token comment"># 命名空间，需要已经存在</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>deploy <span class="token comment">#</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> deploy  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment"># 指定资源类型的规格定义 这里的是对 StatefulSet 对定义</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx <span class="token comment"># 必须匹配 .spec.template.metadata.labels</span>  <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> <span class="token string">"nginx"</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span> <span class="token comment"># 默认值是 1</span>  <span class="token key atrule">minReadySeconds</span><span class="token punctuation">:</span> <span class="token number">10</span> <span class="token comment"># 默认值是 0</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx <span class="token comment"># 必须匹配 .spec.selector.matchLabels</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">terminationGracePeriodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>  <span class="token comment"># 终止活跃探测器或启动探测器的宽限时间</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx          <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/nginx<span class="token punctuation">-</span>slim<span class="token punctuation">:</span><span class="token number">0.8</span>          <span class="token key atrule">ports</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> web          <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span> <span class="token comment"># 指定容器的挂载卷</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> www              <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html  <span class="token key atrule">volumeClaimTemplates</span><span class="token punctuation">:</span> <span class="token comment"># 挂载卷申请的模版 StatefulSet 的卷挂载必须是PV提供 将通过 PersistentVolumes 驱动提供的 PersistentVolumes 来提供稳定的存储</span>    <span class="token punctuation">-</span> <span class="token key atrule">metadata</span><span class="token punctuation">:</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> www      <span class="token key atrule">spec</span><span class="token punctuation">:</span>        <span class="token key atrule">accessModes</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"ReadWriteOnce"</span> <span class="token punctuation">]</span> <span class="token comment"># 权限模式</span>        <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> <span class="token string">"my-storage-class"</span> <span class="token comment">#</span>        <span class="token key atrule">resources</span><span class="token punctuation">:</span>          <span class="token key atrule">requests</span><span class="token punctuation">:</span>            <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi <span class="token comment"># 申请的容量</span><span class="token comment"># loading ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> cs-dev-ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 待续 </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes yaml配置详解——Deployment篇</title>
      <link href="/2023/04/23/cs-dev-ops/k8s-deplyment-yaml/"/>
      <url>/2023/04/23/cs-dev-ops/k8s-deplyment-yaml/</url>
      
        <content type="html"><![CDATA[<blockquote><p>k8s 集群中对资源管理和资源对象编排部署都可以通过声明样式（YAML）文件来解决，通过使用kubectl 命令直接使用资源清单文件就可以实现对大量的资源对象进行编排部署了。一般情况下，都是通过配置YAML文件来部署集群的。</p><p><a href="https://kubernetes.io/docs/concepts/" title="前往">官网概念文档</a> : <a href="https://kubernetes.io/docs/concepts/">https://kubernetes.io/docs/concepts/</a></p><p><a href="https://kubernetes.io/docs/tasks/" title="前往">官网示例文档</a> : <a href="https://kubernetes.io/docs/tasks/">https://kubernetes.io/docs/tasks/</a></p><p><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/" title="前往">官网API文档</a> : <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/">https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/</a></p><p><font color="red">注意：在k8s应用的yaml文件中不支持使用制表符为缩紧，所以要保证所有缩进都是空格。</font></p></blockquote><h1 id="kubernetes-yaml配置详解——Deployment篇"><a href="#kubernetes-yaml配置详解——Deployment篇" class="headerlink" title="kubernetes yaml配置详解——Deployment篇"></a>kubernetes yaml配置详解——Deployment篇</h1><blockquote><p>部署控制<code>Pod</code>，使<code>Pod</code>拥有多个副本、自愈、阔缩容等能力</p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 一些重复 功能相同的配置不在过多赘述，前往Pod的配置部分查看</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment <span class="token comment"># 资源类型 常用 Pod/Deployment/Service/Ingress/ConfigMap/PersistentVolume/PersistentVolumeClaim/Secret</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>deploy <span class="token comment"># 名称，在同一个namespace中需要唯一</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>kube <span class="token comment"># 命名空间，需要已经存在</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>deploy <span class="token comment">#</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> deploy  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment"># 指定资源类型的规格定义 这里的是对 Deployment 对定义</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span> <span class="token comment"># 启动对Pod副本数量</span>  <span class="token key atrule">revisionHistoryLimit</span><span class="token punctuation">:</span> <span class="token number">10</span> <span class="token comment"># 保留历史版本的个数，旧 ReplicaSet 会消耗 etcd 中的资源 默认是10</span>  <span class="token key atrule">paused</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 暂停部署 处于暂定状态的deployment中的template 发生任何修改都不会出发新的上线  默认是false</span>  <span class="token key atrule">progressDeadlineSeconds</span><span class="token punctuation">:</span> <span class="token number">500</span> <span class="token comment"># 部署超时时间 等待 Deployment 取得进展的秒数 此字段需要大于下方的 minReadySeconds ，默认是600</span>  <span class="token key atrule">minReadySeconds</span><span class="token punctuation">:</span> <span class="token number">5</span> <span class="token comment"># 最短就绪时间，指定新创建的 Pod 在没有任意容器崩溃情况下的最小就绪时间 只有超出这个时间 Pod 才被视为可用，默认值为 0</span>  <span class="token key atrule">strategy</span><span class="token punctuation">:</span> <span class="token comment"># 策略</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> RollingUpdate <span class="token comment"># 策略类型 [Recreate 重建，会先kill当前所有的Pods] [RollingUpdate 滚动更新]</span>    <span class="token key atrule">rollingUpdate</span><span class="token punctuation">:</span> <span class="token comment"># 滚动更新策略 通过下面的两个参数控制过程</span>      <span class="token key atrule">maxSurge</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment"># 最大的额外存在副本数量，两种形式 百分比和整数  默认 25%</span>      <span class="token key atrule">maxUnavaliable</span><span class="token punctuation">:</span> <span class="token number">5</span> <span class="token comment"># 最大不可用状态的Pod的数量 两种形式 百分比和整数 默认 25%</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span> <span class="token comment"># 过滤规则的定义，定义的规则是 AND 的逻辑, 这里定义的匹配条件推荐是只匹配下方 template 中定义的pod，如果此时有别的Pod也符合要求，会导致该部署也会管理到别的Pod造成交叉不可预估的问题</span>    <span class="token comment"># matchLabels 与 matchExpressions 具体区别暂未搞懂，等待测试</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span> <span class="token comment"># 查找匹配对标签，对应的是 labels中定义的 &lt;key&gt;:&lt;value&gt; 用来匹配过滤带有这写label的Pod</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx    <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span> <span class="token comment"># Expression匹配规则</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx  <span class="token key atrule">template</span><span class="token punctuation">:</span> <span class="token comment"># Pod的模版配置， 会根据这个模版配置来创建Pod，基本的参数和Pod部分的相同</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx          <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.14.2          <span class="token key atrule">port</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> cs-dev-ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes yaml配置详解——Pod篇</title>
      <link href="/2023/04/23/cs-dev-ops/k8s-pods-yaml/"/>
      <url>/2023/04/23/cs-dev-ops/k8s-pods-yaml/</url>
      
        <content type="html"><![CDATA[<blockquote><p>k8s 集群中对资源管理和资源对象编排部署都可以通过声明样式（YAML）文件来解决，通过使用kubectl 命令直接使用资源清单文件就可以实现对大量的资源对象进行编排部署了。一般情况下，都是通过配置YAML文件来部署集群的。</p><p><a href="https://kubernetes.io/docs/concepts/" title="前往">官网概念文档</a> : <a href="https://kubernetes.io/docs/concepts/">https://kubernetes.io/docs/concepts/</a></p><p><a href="https://kubernetes.io/docs/tasks/" title="前往">官网示例文档</a> : <a href="https://kubernetes.io/docs/tasks/">https://kubernetes.io/docs/tasks/</a></p><p><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/" title="前往">官网API文档</a> : <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/">https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/</a></p><p><font color="red">注意：在k8s应用的yaml文件中不支持使用制表符为缩紧，所以要保证所有缩进都是空格。</font></p></blockquote><h1 id="kubernetes-yaml配置详解——Pod篇"><a href="#kubernetes-yaml配置详解——Pod篇" class="headerlink" title="kubernetes yaml配置详解——Pod篇"></a>kubernetes yaml配置详解——Pod篇</h1><blockquote><p>运行中的一组容器，<code>Pod</code>是<code>kubernetes</code>中应用的最小单位</p></blockquote><ol><li><p><code>Pod</code>和<code>container</code>都运行在以docker为基础的环境上</p></li><li><p><code>container</code>（容器）为<code>dokcer</code>管理的单位，每个应用包装为一个容器在运行</p></li><li><p><code>Pod</code>为<code>k8s</code>在<code>container</code>的基础上再包装一层用于作为最小单位用于管理，<code>Pod</code>中可以只包含一个容器也可以包含多个容器</p></li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1 <span class="token comment"># api的版本 需要在命令 `kubectl api-versions` 的查询列表中</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod <span class="token comment"># 资源类型 常用 Pod/Deployment/Service/Ingress/ConfigMap/PersistentVolume/PersistentVolumeClaim/Secret</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span> <span class="token comment"># 指定资源的元数据配置，对于所有的API对象来说这部分基本相同，是用来表示这个对象资源的，从Kubernetes中找到这个对象的主要依据</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>pod <span class="token comment"># 名称，在同一个namespace中需要唯一</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>kube <span class="token comment"># 命名空间，需要已经存在</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span> <span class="token comment"># 设定标签，常用被用于筛选，多组 &lt;key&gt;:&lt;value&gt; 形式</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>deploy <span class="token comment">#</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> deploy    <span class="token key atrule">app.kubernetes.io/instance</span><span class="token punctuation">:</span> deploy    <span class="token key atrule">app.kubernetes.io/version</span><span class="token punctuation">:</span> 0.0.1    <span class="token key atrule">app.kubernetes.io/managed-by</span><span class="token punctuation">:</span> qing    <span class="token key atrule">app.kubernetes.io/component</span><span class="token punctuation">:</span> controlle  <span class="token key atrule">annotations</span><span class="token punctuation">:</span> <span class="token comment"># 自定义注解列表，多组 &lt;key&gt;:&lt;value&gt; 形式</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment"># 指定资源类型的规格定义  主要存放的是这个对象独有的定义，来描述其做表达的功能</span>  <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Always <span class="token comment"># 重启策略 默认为：Always 在容器退出后，会立即创建一个相同的容器， 另外还有 OnFailure 和 Never</span>  <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span> <span class="token comment"># 节点选择 选择符合该标签需求的节点调度Pod，需要先给主机打上标签  `kubectl label nodes kube-node1 zone=node1`</span>    <span class="token key atrule">zone</span><span class="token punctuation">:</span> node1  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>    <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span> <span class="token comment"># 节点亲和度配置， 可以更加灵活的配置Pod的分配哪一类节点上</span>      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>        <span class="token key atrule">nodeSelectorTerms</span><span class="token punctuation">:</span> <span class="token comment"># 具体参见 https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes-using-node-affinity/</span>          <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>              <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> disktype                <span class="token key atrule">operator</span><span class="token punctuation">:</span> In                <span class="token key atrule">values</span><span class="token punctuation">:</span>                  <span class="token punctuation">-</span> ssd  <span class="token key atrule">initContainers</span><span class="token punctuation">:</span> <span class="token comment"># 在应用容器启动前（containers中配置的）运行完毕</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> install <span class="token comment"># 参数具体说明 详看 containers</span>      <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox<span class="token punctuation">:</span><span class="token number">1.28</span>      <span class="token key atrule">command</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> wget        <span class="token punctuation">-</span> <span class="token string">"-O"</span>        <span class="token punctuation">-</span> <span class="token string">"/work-dir/index.html"</span>        <span class="token punctuation">-</span> http<span class="token punctuation">:</span>//info.cern.ch  <span class="token key atrule">containers</span><span class="token punctuation">:</span> <span class="token comment"># 容器的配置</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app<span class="token punctuation">-</span>container <span class="token comment"># 容器的名称</span>      <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>latest <span class="token comment"># 要使用的镜像，eg. `busybox`, `busybox:1.28`, `10.192.11.14:5000/qing/busybox:latest`</span>      <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">'sh'</span><span class="token punctuation">,</span> <span class="token string">'-c'</span><span class="token punctuation">,</span> <span class="token string">'echo The app is running! &amp;&amp; sleep 3600'</span> <span class="token punctuation">]</span> <span class="token comment"># 启动容器的运行命令，将会覆盖容器的Dockerfile中定义的 ENTRYPOINT</span>      <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> Never <span class="token comment"># 每次启动是检查和更新images的策略 Never:每次都不检查 不论本地是否存在, Always: 每次都检查, IfNotPresent: 本地有就不检查 没有则拉取</span>      <span class="token key atrule">args</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> aaa <span class="token comment"># 启动容器的命令参数， 对应Dockerfile中CMD参数</span>        <span class="token punctuation">-</span> bbb      <span class="token key atrule">env</span><span class="token punctuation">:</span> <span class="token comment"># 设置容器的环境变量 通过 env 或 envFrom 字段设置的环境变量将覆盖容器镜像中指定的所有环境变量 环境变量可以互相引用 所以请避免产生循环饮用</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> qing <span class="token comment"># 变量的名称</span>          <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"/etc/run.sh"</span> <span class="token comment"># 对应变量的值</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> POD_NAME          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span> <span class="token comment"># 属性参数</span>              <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> metadata.name <span class="token comment"># 属性路径 对应元数据</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> POD_NAMESPACE          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span> <span class="token comment"># 属性参数</span>              <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> metadata.namespace <span class="token comment"># 属性路径 对应元数据</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SPECIAL_LEVEL_KEY <span class="token comment"># 从ConfigMap中获取配置</span>          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span> <span class="token comment"># 从configMap special-config 获取</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config <span class="token comment"># ConfigMap 包含你要赋给 SPECIAL_LEVEL_KEY 的值</span>              <span class="token key atrule">key</span><span class="token punctuation">:</span> special.how <span class="token comment"># 指定与取值相关的键名， 不指定key时获取所有的内容</span>      <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token comment"># 资源管理  如果只有limits配置没有requests配置 pod的requests配置则默认与 limits相同</span>        <span class="token key atrule">requests</span><span class="token punctuation">:</span> <span class="token comment"># 容器运行时，需要的最低配置要求 如果所有的节点都不满足该资源请求 Pod 将无限期处于 PENDING 状态</span>          <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token number">0.1</span> <span class="token comment"># CPU资源（核数）eg. 0.1 , 100m   两种表达方式 0.1 = 100m</span>          <span class="token key atrule">memory</span><span class="token punctuation">:</span> 128Mi <span class="token comment"># 内存使用量</span>        <span class="token key atrule">limits</span><span class="token punctuation">:</span> <span class="token comment"># 资源限制  注意 如果Pod中所有容器使用的资源超过该限制，则会被关闭，同时如果配置了容器的重启机制，则容器可能会处于kill、restart、kill、restart的循环中</span>          <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 500m <span class="token comment"># CPU 请求只能使用绝对数量，而不是相对数量。0.1 在单核、双核或 48 核计算机上的 CPU 数量值是一样的</span>          <span class="token key atrule">memory</span><span class="token punctuation">:</span> 1024Mi <span class="token comment"># 内存单位 基本单位为byte,也是不指定单位时候的默认值 其他单位有 ： E、P、T、G、M、K、Ei、Pi、Ti、Gi、Mi、Ki</span>          <span class="token comment"># 除此之外，还可以分派扩展资源，详情看 https://kubernetes.io/docs/tasks/configure-pod-container/extended-resource/</span>      <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span> <span class="token comment"># 容器对外的端口</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> http<span class="token punctuation">-</span>name <span class="token comment"># 名称</span>          <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP <span class="token comment"># 协议</span>      <span class="token comment"># 配置连接页面 : https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/</span>      <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span> <span class="token comment"># pod存活的探针    一共有4中方式</span>        <span class="token key atrule">httpGet</span><span class="token punctuation">:</span> <span class="token comment"># 通过httpGet检查健康度，返回在 200——399之间，认为容器正常</span>          <span class="token key atrule">path</span><span class="token punctuation">:</span> /heath <span class="token comment"># URL地址</span>          <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span> <span class="token comment"># 检查用端口</span>          <span class="token comment"># host: 127.0.0.1 # 主机地址</span>          <span class="token key atrule">scheme</span><span class="token punctuation">:</span> HTTP <span class="token comment"># 连接主机的方式，另一种为  HTTPS</span>          <span class="token key atrule">httpHeaders</span><span class="token punctuation">:</span> <span class="token comment">#请求中自定义的 HTTP 头。HTTP 头字段允许重复</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Accept              <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">""</span>        <span class="token comment"># tcpSocket:</span>        <span class="token comment">#  port: 8080</span>        <span class="token comment"># exec: # 在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。</span>        <span class="token comment">#   command:</span>        <span class="token comment">#     - cat</span>        <span class="token comment">#     - /tmp/health</span>        <span class="token comment"># grpc: # 使用 gRPC 执行一个远程过程调用。 目标应该实现 gRPC健康检查。 如果响应的状态是 "SERVING"，则认为诊断成功。 gRPC 探针是一个 alpha 特性，只有在你启用了 "GRPCContainerProbe" 特性门控时才能使用。</span>        <span class="token comment"># tcpSocket: # 对容器的 IP 地址上的指定端口执行 TCP 检查。如果端口打开，则诊断被认为是成功的。 如果远程系统（容器）在打开连接后立即将其关闭，这算作是健康的。</span>        <span class="token comment">#   port:</span>        <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">5</span> <span class="token comment"># 当探测失败时，Kubernetes 的重试次数。 对存活探测而言，放弃就意味着重新启动容器</span>        <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">10</span> <span class="token comment"># 在容器启动10秒后进行第一次检测</span>        <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span> <span class="token comment"># 检查间隔时间为 10秒</span>        <span class="token key atrule">successThreshold</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment"># 探测器在失败后，被视为成功的最小连续成功数</span>        <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment"># 检测的超时时间</span>      <span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span> <span class="token comment"># 就绪探测器  配置与存活探针相同  就绪探测器在容器的整个生命周期中保持运行状态</span>        <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">5</span>        <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>          <span class="token key atrule">path</span><span class="token punctuation">:</span> /healthz          <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10254</span>          <span class="token key atrule">scheme</span><span class="token punctuation">:</span> HTTP        <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>        <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>        <span class="token key atrule">successThreshold</span><span class="token punctuation">:</span> <span class="token number">1</span>        <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">1</span>      <span class="token key atrule">lifecycle</span><span class="token punctuation">:</span> <span class="token comment"># 生命周期</span>        <span class="token key atrule">postStart</span><span class="token punctuation">:</span> <span class="token comment">#  启动容器运行之前运行的命令 , k8s在容器创建后立即发送postStart事件，但是对其调用不保证在容器的入口点[entrypoint]之前执行，其与容器代码异步执行，但是容器会一直阻塞等待postStart执行完毕状态才会改变为RUNNING</span>          <span class="token key atrule">exec</span><span class="token punctuation">:</span>            <span class="token key atrule">command</span><span class="token punctuation">:</span>              <span class="token punctuation">-</span> <span class="token string">'sh'</span>              <span class="token punctuation">-</span> <span class="token string">'yum upgrade -y'</span>        <span class="token key atrule">preStop</span><span class="token punctuation">:</span>  <span class="token comment"># 停止容器前运行的命令, 在容器结束前立即发送 preStop 事件。除非 Pod 宽限期限超时，Kubernetes 的容器管理逻辑 会一直阻塞等待 preStop 处理函数执行完毕</span>          <span class="token key atrule">exec</span><span class="token punctuation">:</span>            <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span><span class="token string">"-c"</span><span class="token punctuation">,</span><span class="token string">"nginx -s quit; while killall -0 nginx; do sleep 1; done"</span><span class="token punctuation">]</span>      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span> <span class="token comment"># 挂载持久卷</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>storage1 <span class="token comment"># 挂载设备的名称，与volumes[*].name 需要对应</span>          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data/nginx/data1 <span class="token comment"># 容器内部的目录</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>storage2          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data/nginx/data2        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>storage3          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data/nginx/data3        <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /redis<span class="token punctuation">-</span>master <span class="token comment"># 容器内的配置目录 挂载方式在下方定义  配置的时使用配置集</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> config  <span class="token key atrule">volumes</span><span class="token punctuation">:</span> <span class="token comment"># 定义宿主机上对应的挂载目录    支持多种类型 详见 ：https://kubernetes.io/docs/concepts/storage/volumes/</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>storage1      <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment"># 由k8s自动安排一个空目录</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>storage1      <span class="token key atrule">hostPath</span><span class="token punctuation">:</span> <span class="token comment">#</span>        <span class="token key atrule">path</span><span class="token punctuation">:</span> /data/data2  <span class="token comment"># 宿主机目录</span>        <span class="token key atrule">type</span><span class="token punctuation">:</span> Directory <span class="token comment"># 字段可选  其他类型 : DirectoryOrCreate 不存在则创建空目录 权限为 0755, Directory, FileOrCreate 不存在则创建空文件 权限为 0644, File, Socket, CharDevice, BlockDevice .  没有OrCreate的则需要目标提前存在</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>storage3      <span class="token key atrule">nfs</span><span class="token punctuation">:</span> <span class="token comment"># nfs存储类型挂载 还支持其他类型文件系统</span>        <span class="token key atrule">server</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>节点IP<span class="token punctuation">}</span><span class="token punctuation">}</span>        <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data <span class="token comment"># 节点上的目录</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pvc<span class="token punctuation">-</span>storage      <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span> <span class="token comment"># 使用持久卷声明去申请持久卷</span>        <span class="token key atrule">claimName</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pvc    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config      <span class="token key atrule">configMap</span><span class="token punctuation">:</span>  <span class="token comment"># 配置文件是从配置集中获取</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>conf <span class="token comment"># 要使用的配置集名称</span>        <span class="token key atrule">items</span><span class="token punctuation">:</span> <span class="token comment"># 获取配置集中 data的那些项</span>          <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> redis.conf <span class="token comment"># 引入 redis-conf 配置集中 data 下 key为 redis.conf的配置</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> redis.conf <span class="token comment"># 指定上方通过key获取到的配置 放到什么目录下,在容器的/redis-master创建redis.conf</span>  <span class="token key atrule">securityContext</span><span class="token punctuation">:</span> <span class="token comment"># 设置Pod安全上下文 该配置也可以添加到containers https://kubernetes.io/docs/tasks/configure-pod-container/security-context/</span>    <span class="token key atrule">runAsUsr</span><span class="token punctuation">:</span> <span class="token number">100</span> <span class="token comment"># 指定 Pod 中的所有容器内的进程都使用用户 ID 100 来运行</span>    <span class="token key atrule">runAsGroup</span><span class="token punctuation">:</span> <span class="token number">3000</span> <span class="token comment"># 指定Pod 中所有容器中的进程都以主组 ID 3000 来运行  默认为 root(0)</span>    <span class="token key atrule">fsGroup</span><span class="token punctuation">:</span> <span class="token number">2000</span> <span class="token comment"># 卷 data/nginx/data1, data2, data3 及在该卷中创建的任何文件的属主都会是组 ID 2000</span>  <span class="token key atrule">imagePullSecrets</span><span class="token punctuation">:</span> <span class="token comment"># 如果从需要认证的镜像仓库下载镜像，可以配置Pod访问Secret中创建的密钥，前提是recred已经存在</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> recred  <span class="token comment"># https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/</span>  <span class="token key atrule">dnsPolicy</span><span class="token punctuation">:</span> ClusterFirst <span class="token comment"># Pod的DNS策略， Default/ClusterFirst/ClusterFirstWithHostNet/None  详情查看 ： https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/</span>  <span class="token key atrule">dnsConfig</span><span class="token punctuation">:</span> <span class="token comment"># 非必填 填写时与dnsPolicy一起使用，dnsPolicy 为 none 时必须指定</span>    <span class="token key atrule">nameservers</span><span class="token punctuation">:</span> <span class="token comment"># 非必填 Pod的DNS服务器的 IP 地址列表，最多指定3个IP地址，当 nsPolicy 为 none 时 必须包含一个Ip地址</span>      <span class="token punctuation">-</span> 1.2.3.4    <span class="token key atrule">searches</span><span class="token punctuation">:</span> <span class="token comment"># 非必填 用于在Pod中查找主机名的DNS搜索域的列表</span>      <span class="token punctuation">-</span> ns1.svc.cluster<span class="token punctuation">-</span>domain.example      <span class="token punctuation">-</span> my.dns.search.suffix    <span class="token key atrule">options</span><span class="token punctuation">:</span> <span class="token comment"># 非必填  此属性中的内容将合并到从指定的 DNS 策略生成的选项</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> ndots        <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"2"</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> edns0  <span class="token key atrule">terminationGracePeriodSeconds</span><span class="token punctuation">:</span> <span class="token number">30</span> <span class="token comment"># 终止活跃探测器或启动探测器的宽限时间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> cs-dev-ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Linux系统安装OpenSSL</title>
      <link href="/2023/04/16/cs-dev-ops/linux-install-openssl/"/>
      <url>/2023/04/16/cs-dev-ops/linux-install-openssl/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Linux系统安装OpenSSL"><a href="#基于Linux系统安装OpenSSL" class="headerlink" title="基于Linux系统安装OpenSSL"></a>基于Linux系统安装OpenSSL</h1><blockquote><p>说明：基于 Rocky Linux 系统安装 OpenSSL。</p></blockquote><p>分两种安装方式：</p><ul><li>使用系统的包管理器来安装 OpenSSL 或者查找可靠的第三方二进制包</li><li>基于源代码进行编译和安装</li></ul><h2 id="使用系统包管理器安装"><a href="#使用系统包管理器安装" class="headerlink" title="使用系统包管理器安装"></a>使用系统包管理器安装</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root]$ yum search openssl# 列出所有可用的 OpenSSL 包及其版本信息[root]$ yum install openssl # 直接安装最新版[root]$ openssl version# 查看版本来验证是否安装成功# Ubuntu/Debian 系统中执行如下命令安装# apt-get install openssl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基于源代码编译安装"><a href="#基于源代码编译安装" class="headerlink" title="基于源代码编译安装"></a>基于源代码编译安装</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root]$ wget -c https://www.openssl.org/source/openssl-3.0.1.tar.gz -P /data/downloads# 下载 openssl 地址 https://www.openssl.org/source/openssl-3.0.1.tar.gz[root]$ tar -xvf openssl-3.0.1.tar.gz[root]$ mv openssl-3.0.1 openssl# 解压文件[root]$ cd openssl-3.0.1[root]$ ./config shared --openssldir=/usr/local/openssl --prefix=/usr/local/openssl# 修改安装相关的配置# shared 表示编译 OpenSSL 为共享库的形式，及生成动态链接库(DDL)# --openssldir=/usr/local/openssl 表示指定 OpenSSL 的安装目录为 "/usr/local/openssl"。在这个目录下，会生成一个名为 "openssl" 的子目录，用于存放 OpenSSL 库的头文件、静态库和共享库等文件# --prefix=/usr/local/openssl 表示指定 OpenSSL 库的安装路径为 "/usr/local/openssl"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果编译中如下错误：</p><img src="/2023/04/16/cs-dev-ops/linux-install-openssl/image_00.png" class="" title="image_00"><p>表明安装中需要使用到 <code>Perl</code> 模块 <code>FindBin.pm</code> ，因此需要重新安装下</p><p>执行如下命令安装：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># CentOS/RHEL 系统中，使用以下命令来安装[root]$ yum install perl-FindBin# FindBin.pm 是 Perl 标准库中的一个模块，用于定位正在运行的 Perl 脚本所在的目录。它通常用于查找脚本所在目录下的其他文件或子目录。# Ubuntu/Debian 系统中执行如下命令安装[root]$ apt-get install libfindbin-libs-perl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装 <code>FindBin.pm</code> 完成后 ，继续重新运行 <code>openssl 3.0</code> 的安装命令，需要注意的是如果还有其他 <code>Perl</code> 模块缺失，可能也需要类似的方法进行安装，确保系统中包含必要的 <code>Perl</code> 模块。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root]$ yum install perl-lib# lib.pm 是 Perl 标准库中的一个模块，用于处理 Perl 模块和库文件的路径。它通常用于在 Perl 脚本中加载外部模块或库文件。# apt-get install libmodule-lib-perl[root]$ yum install perl-IPC-Cmd# IPC::Cmd.pm 是 Perl 标准库中的一个模块，用于执行命令并捕获其输出和错误信息。它通常用于在 Perl 脚本中调用系统命令并获取其输出。# apt-get install libipc-cmd-perl[root]$ yum install perl-File-Copy# File::Copy.pm 是 Perl 标准库中的一个模块，用于复制和移动文件。它通常用于在 Perl 脚本中进行文件操作# apt-get install libfile-copy-perl[root]$ yum install perl-File-Compare# File::Compare 模块是 Perl 标准库的一部分，用于比较文件内容[root]$ yum install perl-Pod-Html# 模块是用于将 POD 格式的文档转换为 HTML 格式的工具<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>出现以下输出为安装成功（因安装版本不一样，可能略有不同）：</p><img src="/2023/04/16/cs-dev-ops/linux-install-openssl/image_01.png" class="" title="image_01"><p>之后将安装的 <code>openssl</code> 添加到系统的动态链接库搜索路径中</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root]$ make &amp;&amp; make install# 编译 openssl[root]$ echo "/usr/local/lib64/" &gt;&gt; /etc/ld.so.conf# 将 "/usr/local/lib64/" 目录添加到系统的动态链接库搜索路径中# 动态链接库 (shared library) 被用于在程序运行时共享代码和数据。为了让系统能够找到需要的动态链接库，需要将它们所在的目录添加到系统的动态链接库搜索路径中。[root]$ ldconfig# 更新系统的动态链接库缓存，以使新的目录生效[root]$ mv /usr/bin/openssl /usr/bin/openssl.old[root]$ ln -s /usr/local/openssl/bin/openssl /usr/bin/openssl[root]$ ln -s /usr/local/openssl/include/openssl /usr/include/openssl[root]$ echo "/usr/local/openssl/lib" &gt;&gt; /etc/ld.so.conf# 将OpenSSL 库的软件包添加到系统的动态链接库搜索路径中，确保它们的动态链接库能够被正确地加载和使用。需要注意的是，添加新的目录时需要确保路径正确，否则可能会导致系统无法正确地加载动态链接库而出现错误。[root]$ ldconfig -v# -v 显示详细的动态链接库更新信息。会列出所有被更新的动态链接库文件和它们的路径，以及动态链接库版本等信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> cs-dev-ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> linux </tag>
            
            <tag> openssl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux目录配置详解</title>
      <link href="/2023/04/15/cs-dev-ops/linux-file-system-stand/"/>
      <url>/2023/04/15/cs-dev-ops/linux-file-system-stand/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux目录配置详解"><a href="#Linux目录配置详解" class="headerlink" title="Linux目录配置详解"></a>Linux目录配置详解</h1><h2 id="Linux目录配置的依据——FHS"><a href="#Linux目录配置的依据——FHS" class="headerlink" title="Linux目录配置的依据——FHS"></a>Linux目录配置的依据——FHS</h2><p><code>Filesystem Hierarchy Standard</code>（<code>FHS</code>），主要目的是希望<font color="blue">让使用者可以了解到已安装软件通常放置于 那个目录下</font>,也就是说，FHS 的重点在于规范每个特定的目录下应该要放置什么样子的数据 而已。</p><h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><p><code>FHS</code> 依据文件系统使用的频繁与否与是否允 许使用者随意更动， 而将目录定义成为四种交互作用的形态：</p><table><thead><tr><th></th><th>可分享的（<code>shareable</code>）</th><th>不可分享的（<code>unshareable</code>）</th></tr></thead><tbody><tr><td>不变（<code>static</code>）</td><td><code>/usr</code>（软件存放处）</td><td><code>/etc</code>（配置文件）</td></tr><tr><td></td><td><code>/opt</code>（第三方辅助软件）</td><td><code>/boot</code>（启动与内核文件）</td></tr><tr><td>可变动（<code>variable</code>）</td><td><code>/var/mail</code>（用户邮箱）</td><td>/var/run（程序相关）</td></tr><tr><td></td><td><code>/var/spool/news</code>（新闻组）</td><td>/var/lock（程序相关）</td></tr></tbody></table><ul><li>可分享的<ul><li>可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给 网络上其他主机挂载用的目录；</li></ul></li><li>不可分享的<ul><li>自己机器上面运作的装置文件或者是与程序有关的 <code>socket</code> 文件等， 由于仅与自身机器有关， 所以当然就不适合分享给其他主机了。</li></ul></li><li>不变的<ul><li>有些数据是不会经常变动的，跟随着发行版而不变动。 例如函式库、文件说明文件、系统管 理员所管理的主机服务配置文件等等；</li></ul></li><li>可变动的<ul><li>经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等</li></ul></li></ul><p>事实上，<code>FHS</code> 针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录 的定义： </p><ul><li><code>/</code> (<code>root</code>, 根目录)：与开机系统有关；</li><li><code>/usr</code> (<code>unix software resource</code>)：与软件安装/执行有关；</li><li><code>/var</code> (<code>variable</code>)：与系统运作过程有关。</li></ul><blockquote><p>如果 以『账号』的角度来看，所谓的 <code>root</code> 指的是『系统管理员！』的身份， 如果以『目录』的角度来看，所谓的 <code>root</code> 意 即指的是根目录，就是 <code>/</code> 。</p></blockquote><h3 id="根目录的意义和内容"><a href="#根目录的意义和内容" class="headerlink" title="根目录的意义和内容"></a>根目录的意义和内容</h3><p>根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，同时<font color="blue"><strong>根目录也 与开机/还原/系统修复等动作有关</strong></font>。由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在 <code>FHS</code> 的要求方面，他希望根目录不要放在非常大的分区槽内， 因为越大的分区槽妳会放入越多的数据，如此一来根目录所在分区槽就可能会有较多发生错误的机会。</p><p>因此 <code>FHS</code> 标准建议：<font color="blue">根目录(<code>/</code>)所在分区槽应该越小越好， 且应用程序所安装的软件最好不要与根目 录放在同一个分区槽内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不 容易发生问题。</font></p><h2 id="目录具体说明"><a href="#目录具体说明" class="headerlink" title="目录具体说明"></a>目录具体说明</h2><h3 id="FHS要求必须要存在的目录"><a href="#FHS要求必须要存在的目录" class="headerlink" title="FHS要求必须要存在的目录"></a>FHS要求必须要存在的目录</h3><table><thead><tr><th>目录</th><th>应放置文件内容</th></tr></thead><tbody><tr><td><code>/bin</code></td><td>系统有很多<strong>放置执行文件的目录</strong>，但<code>/bin</code> 比较特殊。因为<code>/bin</code> <font color="blue">放置的是在单人维护模式下还能够被操作的指令</font>。在<code>/bin</code>底下的指令可以被<code>root</code>与一般账号所使用，主要有：<code>cat, chmod, chown, date, mv, mkdir,  cp, bash</code> 等等常用的指令。</td></tr><tr><td><code>/boot</code></td><td>这个目录主要在<strong>放置开机会使用到的文件</strong>，包括 <code>Linux</code> 核心文件以及开机选单与开机所需配置文件等 等。 <code>Linux</code> 内核常用的档名为：<code>vmlinuz</code>，如果使用的是 grub2 这个开机管理程序， 则还会存在 <code>/boot/grub2/</code>这个目录。</td></tr><tr><td><code>/dev</code></td><td>在 <code>Linux</code> 系统上，<strong>任何装置与接口设备都是以文件的型态存在于这个目录当中</strong>的。 你只要透过存取这 个目录底下的某个文件，就等于存取某个装置啰～ 比要重要的文件有<code>/dev/null, /dev/zero, /dev/tty,  /dev/loop*, /dev/sd*</code>等等。</td></tr><tr><td><code>/etc</code></td><td><strong>系统主要的配置文件几乎都放置在这个目录内</strong>，例如人员的账号密码文件、 各种服务的启始档等等。 一般来说，这个目录下的各文件属性是可以让一般使用者查阅的， 但是只有 <code>root</code> 有权力修改。<br> <font color="blue"><code>FHS</code> 建议不要放置可执行文件(<code>binary</code>)在这个目录中</font>。比较重要的文件有：<code>/etc/modprobe.d/, /etc/passwd,  /etc/fstab, /etc/issue</code> 等等。<br>另外 <code>FHS</code> 还规范几个重要的目录最好要存在 <code>/etc/</code> 目录下：<br>        •    <code>/etc/opt</code>(必要)：这个目录在放置第三方协力软件 <code>/opt</code> 的相关配置文件<br>        •    <code>/etc/X11/</code>(建议)：与 X <code>Window</code> 有关的各种配置文件都在这里，尤其是 <code>xorg.conf</code> 这个 <code>X Server</code>  的配置文件。<br>        •    <code>/etc/sgml/</code>(建议)：与 <code>SGML</code> 格式有关的各项配置文件<br>        •    <code>/etc/xml/</code>(建议)：与 <code>XML</code> 格式有关的各项配置文件</td></tr><tr><td><code>/lib</code></td><td>系统的函式库非常的多，而<code>/lib</code> <strong>放置的则是在开机时会用到的函式库， 以及在<code>/bin</code> 或<code>/sbin</code> 底下的指令会呼叫的函式库而已</strong>。 什么是函式库呢？可以将他想成是『外挂』，某些指令必须要有这些『外挂』 才能够顺利完成程序的执行之意。 另外 <code>FSH</code> 还要求底下的目录必须要存在：<br>        •    <code>/lib/modules/</code>：这个目录主要放置可抽换式的核心相关模块(驱动程序)。</td></tr><tr><td><code>/media</code></td><td><code>media</code> 是『媒体』的英文，顾名思义，这个<code>/media</code> 底下<strong>放置的就是可移除的装置</strong>！包括软盘、光盘、 DVD 等等装置都暂时挂载于此。常见的档名有：<code>/media/floppy, /media/cdrom</code> 等等。<font color="blue">可以理解为相对持久的用来挂载的目录</font>。</td></tr><tr><td><code>/mnt</code></td><td>如果想要<strong>暂时挂载某些额外的装置</strong>，一般建议可以放置到这个目录中。 在古早时候，这个目录的 用途与<code>/media</code> 相同，只是有了<code>/media</code> 之后，这个目录就用来暂时挂载用了。<font color="blue">可以理解为临时的用来挂载的目录，用完即取消挂载的</font>。</td></tr><tr><td><code>/opt</code></td><td>这个是<strong>给第三方协力软件放置的目录</strong>。 举例来说，<code>KDE</code> 这个桌面管理系统 是一个独立的计划，不过他可以安装到 <code>Linux</code> 系统中，因此 <code>KDE</code> 的软件就建议放置到此目录下了。 另 外，如果想要自行安装额外的软件(非原本的 <code>distribution</code> 提供的)，那么也能够将你的软件安装到这 里来。 不过，以前的 <code>Linux</code> 系统中，我们还是习惯放置在<code>/usr/local</code> 目录下。</td></tr><tr><td><code>/run</code></td><td>早期的 <code>FHS</code> 规定<strong>系统开机后所产生的各项信息</strong>应该要放置到 <code>/var/run</code> 目录下，新版的 <code>FHS</code> 则规范到 <code>/run</code> 底下。 由于 <code>/run</code> 可以使用内存来仿真，因此效能上会好很多！</td></tr><tr><td><code>/sbin</code></td><td><code>Linux</code> 有非常多指令是用来设定系统环境的，这些指令只有 <code>root</code> 才能够利用来『设定』系统，其他用户 最多只能用来『查询』而已。放在<code>/sbin</code> 底下的为<strong>开机过程中所需要的，里面包括了开机、修复、还原 系统所需要的指令</strong>。 至于某些服务器软件程序，一般则放置到<code>/usr/sbin/</code>当中。至于本机自行安装的软 件所产生的系统执行文件(<code>system binary</code>)，则放置到<code>/usr/local/sbin/</code>当中了。常见的指令包括：<code>fdisk, fsck,  ifconfig, mkfs</code> 等等</td></tr><tr><td><code>/srv</code></td><td><code>srv</code> 可以视为『<code>service</code>』的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见 的服务例如 <code>WWW, FTP</code> 等等。举例来说，<code>WWW</code> 服务器需要的网页资料就可以放置在<code>/srv/www/</code>里面。 不过，系统的服务数据如果尚未要提供给因特网任何人浏览的话，预设还是建议放置到 <code>/var/lib</code> 底下 即可。</td></tr><tr><td><code>/tmp</code></td><td>这是让<strong>一般用户或者是正在执行的程序暂时放置文件的地方</strong>。 这个目录是任何人都能够存取的，所以 你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为 <code>FHS</code> 甚至建议在开机时，应该要 将<code>/tmp</code> 下的数据都删除。</td></tr><tr><td><code>/usr</code></td><td>第二层 FHS 设定，后续介绍。</td></tr><tr><td><code>/var</code></td><td>第二曾 FHS 设定，主要为放置变动性的数据，后续介绍。</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="FHS建议可以存在的目录"><a href="#FHS建议可以存在的目录" class="headerlink" title="FHS建议可以存在的目录"></a>FHS建议可以存在的目录</h3><p>事实上 <code>FHS</code> 针对根目录所定义的标准就仅有上面的目录示例，不过我们的 <code>Linux</code> 底下还有许多目录你也 需要了解一下的。 底下是几个在 <code>Linux</code> 当中也是非常重要的：</p><table><thead><tr><th>目录</th><th>应放置文件内容</th></tr></thead><tbody><tr><td><code>/lost+found</code></td><td>这个目录是<strong>使用标准的 <code>ext2/ext3/ext4</code> 文件系统格式才会产生的一个目录</strong>，目的在于当文件系统发生 错误时， 将一些遗失的片段放置到这个目录下。不过如果使用的是 <code>xfs</code> 文件系统的话，就不会存在 这个目录了！</td></tr><tr><td><code>/proc</code></td><td>这个目录本身是一个『虚拟文件系统(<code>virtual filesystem</code>)』喔！他放置的数据都是在内存当中， 例如系 统核心、行程信息(<code>process</code>)、周边装置的状态及网络状态等等。因为这个目录下的数据都是在内存当 中， 所以本身不占任何硬盘空间啊！比较重要的文件例如：<code>/proc/cpuinfo, /proc/dma, /proc/interrupts,  /proc/ioports, /proc/net/*</code> 等等。</td></tr><tr><td><code>/sys</code></td><td>这个目录其实跟<code>/proc</code> 非常类似，也是一个虚拟的文件系统，主要也是记录核心与系统硬件信息较相 关的信息。 包括目前已加载的核心模块与核心侦测到的硬件装置信息等等。这个目录同样不占硬盘容量。</td></tr></tbody></table><p>早期 <code>Linux</code> 在设计的时候，若发生问题时，<strong>恢复模式通常仅挂载根目录</strong>而已，因此有五个重要的目录被要求一定要与根目录放置在一起， 那就是 <code>/etc, /bin, /dev, /lib, /sbin</code> 这五个重要目录。现在许多 的 <code>Linux</code> 发行版本由于已经将许多非必要的文件移出 <code>/usr</code> 之外了， 所以 <code>/usr</code> 也是越来越精简， 同时因为 <code>/usr</code> 被建议为『<strong>即使挂载成为只读，系统还是可以正常运作</strong>』的模样，所以恢复模式也能 同时挂载 <code>/usr</code> ！ 所以目前部分较新的系统将 <code>/sbin, /bin, /lib</code> 通通移动到 <code>/usr</code> 底下了。</p><h3 id="usr的意义与内容"><a href="#usr的意义与内容" class="headerlink" title="/usr的意义与内容"></a><code>/usr</code>的意义与内容</h3><p><code>/usr</code> 里面放置的数据属于可分享的与不可变动的(<strong>shareable, static</strong>)</p><p>很多人都会误会<code>/usr</code>为 <code>user</code> 的缩写，其实 <code>usr</code> 是 <code>Unix Software Resource</code> 的缩写， 也就是『<code>Unix</code> 操 作系统软件资源』所放置的目录，而不是用户的数据！这点要注意。 <code>FHS</code> 建议所有软件开发者， 应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。</p><p>因为是所有系统默认的软件(<code>distribution</code> 发布者提供的软件)都会放置到<code>/usr</code>底下，因此这个目录有点 类似 <code>Windows</code> 系统的『<code>C:\Windows\</code> (当中的一部份) + <code>C:\Program files\</code>』这两个目录的综合体，系统 刚安装完毕时，这个目录会占用最多的硬盘容量。一般来说，<code>/usr</code> 的次目录建议有底下这些：</p><h3 id="usr目录下FHS建议可以存在的目录"><a href="#usr目录下FHS建议可以存在的目录" class="headerlink" title="/usr目录下FHS建议可以存在的目录"></a><code>/usr</code>目录下FHS建议可以存在的目录</h3><table><thead><tr><th>目录</th><th>应放置文件内容</th></tr></thead><tbody><tr><td><code>/usr/bin/</code></td><td><strong>所有一般用户能够使用的指令都放在这里</strong>！目前新的 <code>CentOS 7</code> 已经将全部的用户指令放置于此， 而使用连结档的方式将 <code>/bin</code> 链接至此！ 也就是说， <code>/usr/bin</code> 与 <code>/bin</code> 是一模一样了！另外，<code>FHS</code>  要求在此目录下不应该有子目录！</td></tr><tr><td><code>/usr/lib/</code></td><td>基本上，<strong>与 <code>/lib</code> 功能相同，所以 <code>/lib</code> 就是链接到此目录中的！</strong></td></tr><tr><td><code>/usr/local/</code></td><td><strong>系统管理员在本机自行安装自己下载的软件</strong>(非发行版默认提供者)，建议安装到此目录， 这 样会比较便于管理。该目录下也是具有 <code>bin, etc, include, lib...</code>的子目录！</td></tr><tr><td><code>/usr/sbin/</code></td><td><strong>非系统正常运作所需要的系统指令</strong>。最常见的就是某些网络服务器软件的服务指令(<code>daemon</code>)！ 不过基本功能与 <code>/sbin</code> 也差不多， 因此目前 <code>/sbin</code> 就是链接到此目录中的。</td></tr><tr><td><code>/usr/share/</code></td><td>主要<strong>放置只读架构的数据文件，当然也包括共享文件</strong>。在这个目录下放置的数据几乎是不分硬件 架构均可读取的数据， 因为几乎都是文本文件。在此目录下常见的还有这些次目录：<br>        •    <code>/usr/share/man</code>：联机帮助文件<br>        •    <code>/usr/share/doc</code>：软件杂项的文件说明<br>        •    <code>/usr/share/zoneinfo</code>：与时区有关的时区文件</td></tr></tbody></table><h3 id="usr目录下FHS建议可以存在的目录-1"><a href="#usr目录下FHS建议可以存在的目录-1" class="headerlink" title="/usr目录下FHS建议可以存在的目录"></a><code>/usr</code>目录下FHS建议可以存在的目录</h3><table><thead><tr><th>目录</th><th>应放置文件内容</th></tr></thead><tbody><tr><td><code>/usr/games/</code></td><td>与游戏相关的数据放置处</td></tr><tr><td><code>/usr/include/</code></td><td><code>c/c++</code>等程序语言的档头(<code>header</code>)与包含档(<code>include</code>)放置处，当我们以 <code>tarball</code> 方式 (<code>*.tar.gz</code> 的方式安 装软件)安装某些数据时，会使用到里头的许多包含档！</td></tr><tr><td><code>/usr/libexec/</code></td><td>某些<strong>不被一般使用者惯用的执行档或脚本</strong>(<code>script</code>)等等，都会放置在此目录中。例如大部分的 <code>X</code> 窗 口底下的操作指令， 很多都是放在此目录下的。</td></tr><tr><td><code>/usr/lib\&lt;qual&gt;/</code></td><td>与 <code>/lib/</code>功能相同，因此目前 <code>/lib64</code> 就是链接到<code>/usr/lib64</code></td></tr><tr><td><code>/usr/src/</code></td><td>一般原始码建议放置到这里，<code>src</code> 有 <code>source</code> 的意思。至于核心原始码则建议放置到<code>/usr/src/linux/</code>目录下。</td></tr></tbody></table><h3 id="var的意义与内容"><a href="#var的意义与内容" class="headerlink" title="/var的意义与内容"></a><code>/var</code>的意义与内容</h3><p>如果<code>/usr</code> 是安装时会占用较大硬盘容量的目录，那么<code>/var</code> 就是<strong>在系统运作后才会渐渐占用硬盘容量的目录</strong>。 因为<code>/var</code>目录<strong>主要针对常态性变动的文件</strong>，包括快取(<code>cache</code>)、登录档(<code>log file</code>)以及某些软件运作所产生的文件， 包括程序文件(<code>lock file, run file</code>)，或者例如 <code>MySQL</code> 数据库的文件等等。</p><h3 id="var目录下FHS建议可以存在的目录"><a href="#var目录下FHS建议可以存在的目录" class="headerlink" title="/var目录下FHS建议可以存在的目录"></a><code>/var</code>目录下FHS建议可以存在的目录</h3><table><thead><tr><th>目录</th><th>应放置文件内容</th></tr></thead><tbody><tr><td><code>/var/cache/</code></td><td>应用程序本身运作过程中会产生的一些暂缓存</td></tr><tr><td><code>/var/lib/</code></td><td>程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的 目录。 举例来说，<code>MySQL</code> 的数据库放置到<code>/var/lib/mysql/</code>而 <code>rpm</code> 的数据库则放到<code>/var/lib/rpm</code>种</td></tr><tr><td><code>/var/lock/</code></td><td>某<strong>些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就 可能产生一些错误的状况，因此就得要将该装置上锁(<code>lock</code>)，以确保该装置只会给单一软件所使用</strong>。举 例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果 两个人同时刻录，那片子写入的是谁的资料？所以当第一个人在刻录时该刻录机就会被上锁， 第二 个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用。目前此目录也已经挪到 <code>/run/lock</code> 中</td></tr><tr><td><code>/var/log/</code></td><td>重要到不行！这是<strong>日志文件放置的目录</strong>！里面比较重要的文件如<code>/var/log/messages, /var/log/wtmp</code>(记录登入者的信息)等</td></tr><tr><td><code>/var/mail/</code></td><td>放置个人电子邮件信箱的目录，不过这个目录也被放置到<code>/var/spool/mail/</code>目录中！ 通常这两个目录 是互为链接文件</td></tr><tr><td><code>/var/run/</code></td><td><strong>某些程序或者是服务启动后，会将他们的 <code>PID</code> 放置在这个目录下</strong>！与 /<code>run</code> 相同，这个目录链接到 <code>/run</code> 去了</td></tr><tr><td><code>/var/spool/</code></td><td>这个目录通常放置一些队列数据，所谓的『队列』就是排队等待其他程序使用的数据！这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到<code>/var/spool/mail/</code>中， 但使用者收下该信 件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到<code>/var/spool/mqueue/</code>中， 等到被送出 后就被删除。如果是工作排程数据(<code>crontab</code>)，就会被放置到<code>/var/spool/cron/</code>目录中！</td></tr></tbody></table><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><code>FHS</code> 仅是定义出最上层(<code>/</code>)及次层(<code>/usr, /var</code>)的目录内容应该要放置的文件或目录数据， 因此，在其他子目录层级内，就可以随开发者自行来配置了。</p><p>以<code>Rocky Linux 9.1</code>为例，将原本很多 <code>/</code> 里的目录链接到了 <code>/usr</code> 中：</p><ul><li><code>/bin --------&gt; /usr/bin</code></li><li><code>/sbin --------&gt; /usr/sbin</code></li><li><code>/lib --------&gt; /usr/lib</code></li><li><code>/lib64 --------&gt; /usr/lib64</code></li><li><code>/var/lock --------&gt; /usr/lock</code></li><li><code>/var/run --------&gt; /run</code></li></ul><p>系统目录截图示例：</p><img src="/2023/04/15/cs-dev-ops/linux-file-system-stand/image_00.png" class="" title="image_00"><img src="/2023/04/15/cs-dev-ops/linux-file-system-stand/image_01.png" class="" title="image_01"><h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h2><p>在 <code>Linux</code> 下，所有的文件与目录都是由根目录开始的！那是所有目录与文件的源头，然后再一个一个的分支下来，有点像是树枝状，因此，也称这种目录配置方式为：『<strong>目录树</strong>(<code>directory  tree</code>)』 ，主要的特性有：</p><ul><li><strong>目录树的启始点为根目录 (<code>/, root</code>)。</strong></li><li><strong>每一个目录不止能使用本地分区的文件系统，也可以使用网络上的文件系统 。举例来说， 可 以利用 <code>Network File System (NFS)</code> 服务器挂载某特定目录等。</strong></li><li><strong>每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。</strong></li></ul><h2 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h2><p>根据文件名写法的不同，以可将所谓的路径（<code>path</code>）定义为绝对路径（<code>absolute</code>）与相对路径（<code>relative</code>）。</p><ul><li>绝对路径<ul><li>由根目录（<code>/</code>）开始写起的文件名或目录名称，例如 <code>/home/dmtsai/.bashrc</code></li></ul></li><li>相对路径<ul><li>相对于目前路径的文件名写法，例如 <code>./home/dmtsai</code> 或 <code>../../home/dmtsai</code> 等，反正开头不是 <code>/</code> 就属于相对路径的写法。</li></ul></li><li><code>.</code> <ul><li>代表当前的目录，也可以使用 <code>./</code> 来表示</li></ul></li><li><code>..</code><ul><li>代码上一层目录，也可以 <code>../</code> 来代表</li></ul></li></ul><h2 id="目录树架构示意图"><a href="#目录树架构示意图" class="headerlink" title="目录树架构示意图"></a>目录树架构示意图</h2><img src="/2023/04/15/cs-dev-ops/linux-file-system-stand/image_02.png" class="" title="image_02"><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>《鸟哥的Linux私房菜》</p>]]></content>
      
      
      <categories>
          
          <category> cs-dev-ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本博客文章分类规则</title>
      <link href="/2023/04/13/hello-world/blog-categorization-rules/"/>
      <url>/2023/04/13/hello-world/blog-categorization-rules/</url>
      
        <content type="html"><![CDATA[<h1 id="本博客文章分类规则"><a href="#本博客文章分类规则" class="headerlink" title="本博客文章分类规则"></a>本博客文章分类规则</h1><table><thead><tr><th>分类</th><th>说明</th></tr></thead><tbody><tr><td><code>cs</code></td><td>计算机方向文章的默认类别。</td></tr><tr><td><code>cs-frameworks-tools</code></td><td>技术框架和工具类别； <code>Spring</code>、<code>Spring boot</code>、<code>Git</code>、<code>Vue</code>等。</td></tr><tr><td><code>cs-languages</code></td><td>编程语言类别；<code>Java</code>、<code>Python</code>、<code>JavaScript</code>、<code>Shell</code>等。</td></tr><tr><td><code>cs-dev-ops</code></td><td>系统运维类别；<code>Linux</code>、<code>Docker</code>、<code>Kubernetes</code>、<code>CI/CD</code> 等。</td></tr><tr><td><code>cs-program-design</code></td><td>程序设计类别；算法、数据结构、设计模式、架构设计等。</td></tr><tr><td><code>cs-data</code></td><td>数据类别；<code>Mysql</code>、<code>Oracle</code>、<code>PostgreSql</code>、<code>Kafka</code>、<code>Redis</code>等</td></tr><tr><td><code>hello-world</code></td><td>默认类别；生活感悟、随言碎语等</td></tr><tr><td><code>notes</code></td><td>其他工具类别</td></tr></tbody></table><h1 id="本博客文章标签说明"><a href="#本博客文章标签说明" class="headerlink" title="本博客文章标签说明"></a>本博客文章标签说明</h1><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td><strong>原创</strong></td><td>标记本文章为原创文章</td></tr><tr><td><strong>转载</strong></td><td>标记本文章为转载文章</td></tr><tr><td><strong>部分原创</strong></td><td>标记本文章部分为转载部分为原创修改</td></tr><tr><td><strong>待续</strong></td><td>标记本文章时持续更新类型，后续会进行扩充</td></tr></tbody></table><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> hello-world </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello-world </tag>
            
            <tag> rules </tag>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Linux系统安装Mysql</title>
      <link href="/2023/04/13/cs-data/linux-install-mysql/"/>
      <url>/2023/04/13/cs-data/linux-install-mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Linux系统安装Mysql"><a href="#基于Linux系统安装Mysql" class="headerlink" title="基于Linux系统安装Mysql"></a>基于Linux系统安装Mysql</h1><blockquote><p>说明：基于 Rocky Linux 系统安装 Mysql。Mysql 是一个关系型数据库管理系统。</p><p>这里基于 Rocky Linux 9.1 系统，安装 Mysql 版本 8.0.32。</p></blockquote><h2 id="安装简介"><a href="#安装简介" class="headerlink" title="安装简介"></a>安装简介</h2><p>在 Linux 下可以使用如下 3 种方式来安装：</p><ul><li>RPM（RedHat Package Manage）<ul><li>安装简单，适合初学者学习使用，一台服务器只能安装一个。</li></ul></li><li>二进制（Binary Package）<ul><li>安装简单，可以按照到任何路径下，灵活性好，一台服务器可以安装多个。</li></ul></li><li>源码（Source Package）<ul><li>在实际安装的操作系统进行可根据需要做定制编译，灵活性最高，性能最好，一台服务器可以安装多个。</li></ul></li></ul><h2 id="使用-RPM-包安装"><a href="#使用-RPM-包安装" class="headerlink" title="使用 RPM 包安装"></a>使用 RPM 包安装</h2><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p>这里有两种方式下载：</p><ul><li>通过网页下载rpm安装包然后上传到需要安装数据库的服务器。</li><li>直接在服务器上下载安装包，使用 <code>wget</code> 来下载。</li></ul><h4 id="直接下载"><a href="#直接下载" class="headerlink" title="直接下载"></a>直接下载</h4><p><a href="https://dev.mysql.com/downloads/mysql/">官网下载地址</a>：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p><img src="/2023/04/13/cs-data/linux-install-mysql/image_00.png" class="" title="image_00"><h4 id="使用-wget-下载"><a href="#使用-wget-下载" class="headerlink" title="使用 wget 下载"></a>使用 wget 下载</h4><h5 id="安装-wgrt"><a href="#安装-wgrt" class="headerlink" title="安装 wgrt"></a>安装 wgrt</h5><p>使用如下的命令快速安装，如果，服务器上已经安装过该工具后，可跳过这一步。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ yum -y install wget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="下载mysql安装包"><a href="#下载mysql安装包" class="headerlink" title="下载mysql安装包"></a>下载mysql安装包</h5><p>在点击图片 images_00 中对应版本的 Download 按钮后，在跳转的页面上使用鼠标右键点击下方的 “No thanks， just start my download” 来拷贝下载链接。</p><img src="/2023/04/13/cs-data/linux-install-mysql/image_01.png" class="" title="image_01"><p>然后使用以下命令在服务器上下载文件</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ wget -c https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.32-1.el9.x86_64.rpm-bundle.tar -P /data/downloads# -P 指定下载目录# -c --continue 如果首次下载中断，可用使用该参数进行续点下载<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>等待片刻即可完成下载</p><img src="/2023/04/13/cs-data/linux-install-mysql/image_02.png" class="" title="image_02"><h3 id="yum安装依赖包"><a href="#yum安装依赖包" class="headerlink" title="yum安装依赖包"></a>yum安装依赖包</h3><p>使用以下命令，安装相关的依赖</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ yum -y install lrzsz wget perl-Digest-MD5$ yum -y install numactl$ yum -y install ncurses ncurses-devel openssl-devel bison gcc gcc-c++ make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加用户及组"><a href="#添加用户及组" class="headerlink" title="添加用户及组"></a>添加用户及组</h3><p>为了方便管理和维护mysql的应用，这里建议创建一个单独的用户组和用户用来管理mysql进程。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root]$ groupadd mysql# 创建用户组# groupdel mysql 删除用户组的命令[root]$ useradd -g mysql -d /home/mysql mysql# -g 指定用户组# -d 指定该用户的家目录# userdel mysql_user 删除用户的命令[root]$ passwd mysqlNew password:Retype new password: passwd: all authentication tokens updated successfully.# 设置用户的密码[root@rhel76 ~]$ cat /etc/group | grep mysqlmysql:x:1000:# 查看是否存在名为 mysql 的组[root@rhel76 ~]$ cat /etc/passwd | grep '^mysql:'mysql:x:1000:1000::/home/mysql:/bin/bash# 查看用户信息,这个命令会查找用户名以 mysql: 开头的行# 给 mysql 添加 sudo 权限[root@rhel76 ~]$ su# 切换为 root 账户[root@rhel76 ~]$ visudo# 编辑 sudoers 文件, 找到 root 账户的地方添加文本 mysql   ALL=(ALL)       ALL# 然后保存退出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/13/cs-data/linux-install-mysql/image_12.png" class="" title="image_12"><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root]$ md5sum mysmd5sum mysql-8.0.32-1.el9.x86_64.rpm-bundle.tarea9a1d7491ba797951f2b542ac76f2e7  mysql-8.0.32-1.el9.x86_64.rpm-bundle.tar# 使用 md5sum 计算下载的安装包的MD5值，与官网上的值做对比来验证下载的安装包的完整性[root]$ tar -xvf mysql-8.0.32-1.el9.x86_64.rpm-bundle.tar -C /home/mysql# -x 表示解压缩 tar 归档文件# -v 表示在解压缩过程中显示详细的进度信息。# -f 表示指定要解压缩的 tar 归档文件。# -C 表示指定要解压缩到的目录# 解压安装包，这里主要时注意必须安装以下四个文件# mysql-community-common-8.0.32-1.el9.x86_64.rpm# mysql-community-libs-8.0.32-1.el9.x86_64.rpm# mysql-community-client-8.0.32-1.el9.x86_64.rpm # 是客户端的安装包# mysql-community-server-8.0.32-1.el9.x86_64.rpm # 是服务端的安装包[root]$ ls -l /home/drwx------ 2 mysql mysql 4096 Apr 16 01:27 mysql# 查看解压后文件的权限[root] chown -R mysql:mysql /home/mysql/# -R 是应用 /home/mysql/ 所有子目录和文件# mysql:mysql 为 owner/group 格式，分别是该目录的新的所有者(mysql)，和新的组(mysql)# 由于使用了root来解压文件，所以输出文件权限不属于上一步创建的用户和组 mysql mysql 所以需要更改它们的权限[root]$ cd /home/mysql# 开始准备安装# 包之间相互依赖，所以必须注意安装顺序# 先装 common # 再装 libs# 如果之前安装了 mariadb，请确保 mariadb 已卸载，centos7 默认支持 mariadb，不支持 mysql，不卸载会出现冲突# 再装 client# 最后装 server# 命令如下[root]$ rpm -ivh mysql-community-common-8.0.32-1.el9.x86_64.rpm# -i 表示安装 RPM 安装包# -v 表示在安装的过程中显示详细的进度信息# -h 表示在安装过程中显示 # 字符来标识进度[root]$ su mysql# 切换为 mysql 用户去安装[mysql]$ rpm -ivh --force --nodeps mysql-community-libs-8.0.32-1.el9.x86_64.rpm# --force 表示强制安装软件包，即使存在依赖关系或冲突# --nodeps 表示忽略依赖关系检查，即使缺少其他软件包的依赖，也会强制安装# 需要注意，使用 "--force" 和 "--nodeps" 选项可能会导致系统不稳定或产生意外的行为，因为它们可能会引入软件包之间的不一致性或安全漏洞，所以在安装其他不确定应用时请谨慎使用[mysql]$ rpm -ivh --force --nodeps mysql-community-client-8.0.32-1.el9.x86_64.rpm[mysql]$ rpm -ivh --force --nodeps mysql-community-server-8.0.32-1.el9.x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[mysql]$ chown -R mysql:mysql /var/lib/mysql# 将 mysql 要使用的函数库和数据文件放置地址，的属主和组修改为之前创建的用户和组[mysql]$ mysqld --initialize# 初始化 mysql 数据库服务器的数据目录、创建系统表和其他必要的文件，只需要在安装的时候执行一次# 如果出现问题请看 其他问题中的描述[mysql]$ systemctl start mysqld# 启动mysql服务# 如果出现问题请看 其他问题中的描述[mysql]$ systemctl status mysqld[mysql]$ sudo systemctl enable mysqld# 于设置 mysqld 服务在系统启动时自动启动# 执行这个命令后，系统会将 mysqld.service 文件链接到 `/etc/systemd/system/multi-user.target.wants/` 目录下，以确保 MySQL 服务在系统启动时自动启动[mysql]$ sudo systemctl is-enabled mysqld# 验证 MySQL 服务是否已经设置为开机自启：使用以下命令可以验证 MySQL 服务是否已经设置为开机自启[root]$ cat /var/log/mysqld.log | grep password# 获得mysql临时密码# MySQL 安装成功后会有一个临时密码，我们可以使用`grep`命令查看临时密码先登录进去MySQL，然后修改MySQL密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建用户与修改临时密码"><a href="#创建用户与修改临时密码" class="headerlink" title="创建用户与修改临时密码"></a>创建用户与修改临时密码</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root]$ cat /var/log/mysqld.log | grep password# 获得mysql临时密码# MySQL 安装成功后会有一个临时密码，我们可以使用`grep`命令查看临时密码先登录进去MySQL，然后修改MySQL密码[root]$ mysql -uroot -p{password}# 使用临时密码登录mysql&gt; set global validate_password.policy=LOW;# 把mysql密码校验强度改为低风险 这条视自己实际情况配置# mysql5.7 中为 validate_password_policymysql&gt; set global validate_password.length=6;# 修改mysql的密码长度 这条视自己实际情况配置# mysql5.7 中为 validate_password_lengthmysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';# 修改mysql密码 这条视自己实际情况配置mysql&gt; show plugins;# 查看相关设置，密码验证规则在最下面mysql&gt; SHOW VARIABLES LIKE 'vali%';# 直接查看密码验证规则<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="远程登录配置"><a href="#远程登录配置" class="headerlink" title="远程登录配置"></a>远程登录配置</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; create user root@'%' identified with mysql_native_password by 'root';-- 创建一个用户名为 root，主机为任意主机（即 %），密码为 root 的用户，并使用 mysql_native_password 插件进行身份验证mysql&gt; grant all on *.* to root@'%' with grant option;-- 授予 root 用户在 MySQL 服务器上拥有所有数据库和所有表的所有权限，并且允许该用户授予其他用户相同的权限mysql&gt; flush privileges;-- 刷新权限mysql&gt; select Host, User from mysql.user;mysql&gt; status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/13/cs-data/linux-install-mysql/image_09.png" class="" title="image_09"><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root]$ firewall-cmd --zone=public --add-port=3306/tcp --permanent# 防火墙放行3306端口# --zone 作用域# --add-port=80/tcp  添加端口，格式为：端口/通讯协议# --permanent  永久生效，没有此参数重启后失效[root]$ firewall-cmd --reload# systemctl restart firewalld.service# 重启防火墙[root]$ firewall-cmd --zone=public --query-port=8080/tcp# 查看端口是否暴露[root]$ systemctl start firewalld.service# 启动防火墙[root]$ systemctl enable firewalld.service# 设置开机自启[root]$ firewall-cmd --state# 检查防火墙状态是否打开[root]$ systemctl disable firewalld# 关闭防火墙[root]$ systemctl is-enabled firewalld.service;echo $?# 检查防火墙开机启动是否生效[root]$ firewall-cmd --list-all# 查看防火墙信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="账号密码相关设置附录"><a href="#账号密码相关设置附录" class="headerlink" title="账号密码相关设置附录"></a>账号密码相关设置附录</h3><p>在数据库的配置文件中添加<code>skip-grant-tables</code>可以跳过密码验证</p><p>查看密码策略：</p><p>​<code>show variables like 'password%';</code></p><p>​<code>SHOW VARIABLES LIKE 'validate_password%';</code></p><p>刷新权限设置：</p><p>​<code>flush privileges;</code></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- mysql5mysql&gt; create database springcloud_dev DEFAULT CHARACTER SET utf8;-- 创建数据库mysql&gt; create user 'springcloud' identified by '123456';-- 创建新用户：mysql&gt; grant all on springcloud_dev.* to 'springcloud';flush privileges;-- 赋予该用户对该数据库的所有权限，并刷新-- 新建数据库并直接赋予权限：-- grant all on springcloud_dev.* TO 'springcloud'@'%' IDENTIFIED BY '123456'; flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">## mysql8create user 'root'@'%' identified by  'password';-- 创建账户(% 代表所有IP)grant all privileges on *.* to 'root'@'%' with grant option;-- 赋予权限，with grant option这个选项表示该用户可以将自己拥有的权限授权给别人flush privileges;-- 改密码&amp;授权超用户，flush privileges 命令本质上的作用是将当前user和privilige表中的用户信息/权限设置从mysql库(MySQL数据库的内置库)中提取到内存里ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'new_password';-- 修改指定用户的密码-- mysql_native_password 插件是 MySQL 8.0 默认的密码插件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="shared-libraries缺失问题"><a href="#shared-libraries缺失问题" class="headerlink" title="shared libraries缺失问题"></a>shared libraries缺失问题</h4><p>如果在启动服务的时候出现如下错误：</p><img src="/2023/04/13/cs-data/linux-install-mysql/image_03.png" class="" title="image_03"><p>或者</p><img src="/2023/04/13/cs-data/linux-install-mysql/image_07.png" class="" title="image_07"><p>执行提示中的命令：</p><img src="/2023/04/13/cs-data/linux-install-mysql/image_04.png" class="" title="image_04"><img src="/2023/04/13/cs-data/linux-install-mysql/image_06.png" class="" title="image_06"><p>提示动态链接库(<code>shared libraries</code>) 缺失，参考以下步骤执行</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root]$ ls -l /lib*/libaio.so.1# 验证 libaio.so.1 动态链接库是否存在# 如果不存在使用[root]$ yum install libaio# 安装 libaio 通过安装完成后自动配置环境，所以可用使用 mysqld --initialize 验证环境# 如果已经存在，使用如下命令将 libaio 所在目录添加到系统的动态链接库搜索路径中[root]$ echo "/usr/lib64" | sudo tee -a /etc/ld.so.conf.d/mysql.conf# 添加到系统的动态链接库搜索路径中[root]$ ldconfig# 更新系统的动态链接库缓存，以使新的目录生效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>确认 OpenSSL 是否安装</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root]$ openssl version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可参考本站文章 <a href="">基于Linux系统安装OpenSSL</a> 来安装该库。</p><h4 id="其他错误排查方式"><a href="#其他错误排查方式" class="headerlink" title="其他错误排查方式"></a>其他错误排查方式</h4><ol><li><p>检查 mysql 的配置文件是否正确，如果有错误则进行修复，并重启 mysql 服务。</p><ol><li>配置文件 <code>/etc/my.cnf</code>或 <code>/etc/mysql/my.cnf</code></li></ol></li><li><p>确保 mysql 数据目录和日志文件所在的目录对 mysql 用户有充足的读写权限，可以使用以下命令来更改文件权限：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root]$ chown -R mysql:mysql /var/lib/mysql/[root]$ chmod -R 755 /var/lib/mysql/[root]$ chown mysql:mysql /var/log/mysqld.log[root]$ chmod 644 /var/log/mysqld.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>检查系统中是否缺失 mysql 的依赖库，如果缺失则进行安装</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root]$ ldd /usr/sbin/mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>检查系统的内存和磁盘空间是否充足，如果不足则进行清理或者扩容</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root]$ df -h --total[root]$ free -h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>在执行任何操作之前，你可以查看 MySQL 的错误日志文件，通常在 <code>/var/log/mysqld.log</code> 中，以查看 MySQL 启动过程中遇到的具体错误信息</p></li></ol><h2 id="二进制包安装"><a href="#二进制包安装" class="headerlink" title="二进制包安装"></a>二进制包安装</h2><h3 id="下载安装包-1"><a href="#下载安装包-1" class="headerlink" title="下载安装包"></a>下载安装包</h3><p>这里有两种方式下载：</p><ul><li>通过网页下载rpm安装包然后上传到需要安装数据库的服务器。</li><li>直接在服务器上下载安装包，使用 <code>wget</code> 来下载。</li></ul><p>具体说明参考  [使用 RPM 包安装](###使用 RPM 包安装)</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ wget -c https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.32-linux-glibc2.12-x86_64.tar.xz -P /tmp# -P 指定下载目录4# -c --continue 如果首次下载中断，可用使用该参数进行续点下载5​<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2023/04/13/cs-data/linux-install-mysql/image_10.png" class="" title="image_10"><h3 id="yum安装依赖包-1"><a href="#yum安装依赖包-1" class="headerlink" title="yum安装依赖包"></a>yum安装依赖包</h3><p>使用以下命令，安装相关的依赖</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ yum -y install lrzsz wget perl-Digest-MD5$ yum -y install numactl$ yum -y install ncurses ncurses-devel openssl-devel bison gcc gcc-c++ make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加用户及组-1"><a href="#添加用户及组-1" class="headerlink" title="添加用户及组"></a>添加用户及组</h3><p>参考上文<a href="###%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%8F%8A%E7%BB%84">添加用户及组</a></p><h3 id="安装mysql-1"><a href="#安装mysql-1" class="headerlink" title="安装mysql"></a>安装mysql</h3><p>安装前如果已经按照过 MariaDB，请先卸载</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root]$ rpm -qa |grep mariadbmariadb-libs-5.5.60-1.el7_5.x86_64[root]$ rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>正式安装</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root]$ su mysql# 切换永固## 用户及目录创建注：可以部署多个实例，通过端口区分root 用户操作：mkdir -p /opt/qing/mysql/mysql3306/data/mkdir -p /opt/qing/mysql/mysql3306/data/datamkdir -p /opt/qing/mysql/mysql3306/app/mkdir -p /opt/qing/mysql/mysql3306/conf/mkdir -p /opt/qing/mysql/mysql3306/data/pid/mkdir -p /opt/qing/mysql/mysql3306/data/socket/mkdir -p /opt/qing/mysql/mysql3306/data/log/mkdir -p /opt/qing/mysql/mysql3306/data/binlog/mkdir -p /opt/qing/mysql/mysql3306/data/errlogmkdir -p /opt/qing/mysql/mysql3306/data/relaylog/mkdir -p /opt/qing/mysql/mysql3306/data/slowlog/mkdir -p /opt/qing/mysql/mysql3306/data/tmp/[mysql]$ cp /tmp/mysql-8.0.32-linux-glibc2.12-x86_64.tar.xz /opt/qing/mysql/mysql3306/app/# 拷贝安装包[mysql]$ ls -l-rw-r--r--. 1 mysql mysql 610315332  4月 16 23:07 mysql-8.0.32-linux-glibc2.12-x86_64.tar.xz[mysql]$ md5sum mysql-8.0.32-linux-glibc2.12-x86_64.tar.xz# 验证，如果可确保包没问题，可用跳过这步[mysql]$ tar xvf mysql-8.0.32-linux-glibc2.12-x86_64.tar.xz# 解压[mysql]$ mv mysql-8.0.32-linux-glibc2.12-x86_64 mysql_8.0.32# 重命名[mysql]$sudo cat &gt;&gt; /home/mysql/.bash_profile &lt;&lt; "EOF"MYSQL_HOME=/opt/qing/mysql/mysql3306/app/mysql_8.0.32PATH=$PATH:$HOME/.local/bin:$HOME/bin:$MYSQL_HOME/binEOF# 修改环境变量，注意这里配置的目录和你自己mysql的地址一致[mysql]$ source ~/.bash_profile# 重新加载当前用户的 Bash 配置文件 ~/.bash_profile[mysql]$ which mysql/opt/qing/mysql/mysql3306/app/mysql_8.0.32/bin/mysql# 查找系统中是否安装了 MySQL 命令行客户端，并返回 MySQL 命令在系统中的安装路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建参数文件"><a href="#创建参数文件" class="headerlink" title="创建参数文件"></a>创建参数文件</h3><p>由于是二进制文件安装，所以数据库参数文件需要自己配置</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[mysql]$ cat &gt;&gt; /opt/qing/mysql/mysql3306/conf/my3306.cnf &lt;&lt; "EOF"[mysqld]server_id = 80273306default-storage-engine= InnoDBbasedir=/opt/qing/mysql/mysql3306/app/mysql_8.0.32datadir=/opt/qing/mysql/mysql3306/data/datasocket=/opt/qing/mysql/mysql3306/data/socket/mysql.socklog-error=//opt/qing/mysql/mysql3306/data/log/mysqld.logpid-file=/opt/qing/mysql/mysql3306/data/pid/mysqld.pidport=3306default-time_zone='+8:00'default_authentication_plugin=mysql_native_password # 加此参数可远程登陆transaction_isolation=READ-COMMITTEDmax_connections=1500back_log=500wait_timeout=1800max_user_connections=800innodb_buffer_pool_size=1024Minnodb_log_file_size=512Minnodb_log_buffer_size=40Mslow_query_log=ONlong_query_time=5# log settings #slow_query_log = ONslow_query_log_file = /opt/qing/mysql/mysql3306/data/slowlog/slow3306.loglog_error = /opt/qing/mysql/mysql3306/data/errlog/err3306.loglog_error_verbosity = 3log_bin = /opt/qing/mysql/mysql3306/data/binlog/mysql_binlog_bin_index = /opt/qing/mysql/mysql3306/data/binlog/mysql_binlog.indexgeneral_log_file = /opt/qing/mysql/mysql3306/data/generallog/general.loglog_queries_not_using_indexes = 1log_slow_admin_statements = 1expire_logs_days = 90binlog_expire_logs_seconds = 2592000      #30dlong_query_time = 2min_examined_row_limit = 100log_throttle_queries_not_using_indexes = 1000innodb_flush_log_at_trx_commit=1EOF# 注意要写入的文件地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据库初始化"><a href="#数据库初始化" class="headerlink" title="数据库初始化"></a>数据库初始化</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[mysql]$ cd ~# 到自己的主目录[mysql]$ mysqld --defaults-file=/opt/qing/mysql/mysql3306/conf/my3306.cnf --initialize --user=mysql --basedir=/opt/qing/mysql/mysql3306/app/mysql_8.0.32 --datadir=/opt/qing/mysql/mysql3306/data/data/# mysqld mysql 服务器的主程序# --defaults-file 配置文件路径，my3306.cnf 是一个自定义的 mysql 配置文件# --initialize 表示需要执行 mysql 的初始化操作，主要是创建系统数据表、设置 root 用户密码等# --basedir 指定了 mysql 的安装目录# --datadir 指定了 mysql 数据库文件的存储目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="启动数据库"><a href="#启动数据库" class="headerlink" title="启动数据库"></a>启动数据库</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[mysql]$ mysqld_safe --defaults-file=/opt/qing/mysql/mysql3306/conf/my3306.cnf --user=mysql &amp;# mysqld_safe mysql 服务器启动脚本，它会以安全模式启动 mysql 服务器，同时还提供了一些额外的安全检查和日志记录功能# --defaults-file 配置文件路径，my3306.cnf 是一个自定义的 mysql 配置文件# --user mysql 服务器进程运行的用户账户# &amp; 表示将命令放在后台运行，即使关闭终端或者退出登录，MySQL 服务器仍然会继续运行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/04/13/cs-data/linux-install-mysql/image_11.png" class="" title="image_11"><h3 id="创建用户与修改临时密码-1"><a href="#创建用户与修改临时密码-1" class="headerlink" title="创建用户与修改临时密码"></a>创建用户与修改临时密码</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[mysql]$ cat /opt/qing/mysql/mysql3306/data/errlog/err3306.log | grep password# 获得mysql临时密码# MySQL 安装成功后会有一个临时密码，我们可以使用`grep`命令查看临时密码先登录进去MySQL，然后修改MySQL密码# 注意这里查看的日志地址，和默认安装不一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其他参考上一个章节的<a href="###%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E4%B8%8E%E4%BF%AE%E6%94%B9%E4%B8%B4%E6%97%B6%E5%AF%86%E7%A0%81">创建用户与修改临时密码</a></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 当然也可以通过 sock 登录[mysql]$ mysql -uroot -p  -P 3306 -S /opt/qing/mysql/mysql3306/data/socket/mysql.sock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果出现如下错误</p><img src="/2023/04/13/cs-data/linux-install-mysql/image_13.png" class="" title="image_13"><p>就需要安装这个缺失的依赖库</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[mysql]$ sudo dnf install ncurses.x86_64# 安装该依赖库会 安装 libtinfo# 如果还是不行检查下是否 libtinfo 有其他版本[mysql]$ ls /usr/lib64/ | grep libtinfolrwxrwxrwx.  1 root root       15  5月 26  2022 libtinfo.so.6 -&gt; libtinfo.so.6.2-rwxr-xr-x.  1 root root   191616  5月 26  2022 libtinfo.so.6.2# 如上所示，已经有6.2的版本存在# 所以来通过创建软链接其到 libtinfo.so.5[mysql]$ sudo ln -s  /usr/lib64/libtinfo.so.6.2 /usr/lib64/libtinfo.so.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="远程登录配置-1"><a href="#远程登录配置-1" class="headerlink" title="远程登录配置"></a>远程登录配置</h3><p>参考上一个章节的<a href="###%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E9%85%8D%E7%BD%AE">远程登录配置</a></p><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><h3 id="下载安装包-2"><a href="#下载安装包-2" class="headerlink" title="下载安装包"></a>下载安装包</h3><p>这里有两种方式下载：</p><ul><li>通过网页下载rpm安装包然后上传到需要安装数据库的服务器。</li><li>直接在服务器上下载安装包，使用 <code>wget</code> 来下载。</li></ul><p>具体说明参考  [使用 RPM 包安装](###使用 RPM 包安装)</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ wget -c https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-boost-8.0.32.tar.gz -P /tmp# -P 指定下载目录4# -c --continue 如果首次下载中断，可用使用该参数进行续点下载5​<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2023/04/13/cs-data/linux-install-mysql/image_14.png" class="" title="image_14"><h3 id="yum安装依赖包-2"><a href="#yum安装依赖包-2" class="headerlink" title="yum安装依赖包"></a>yum安装依赖包</h3><p>使用以下命令，安装相关的依赖</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ yum -y install lrzsz wget perl-Digest-MD5$ yum -y install numactl$ yum -y install cmake gcc gcc-c++$ yum -y install ncurses-devel libaio-devel$ yum install –y openssl openssl-devel ncurses ncurses-devel$ yum -y install ncurses ncurses-devel openssl-devel bison gcc gcc-c++ make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加用户及组-2"><a href="#添加用户及组-2" class="headerlink" title="添加用户及组"></a>添加用户及组</h3><p>参考上文<a href="###%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%8F%8A%E7%BB%84">添加用户及组</a></p><h3 id="安装及配置"><a href="#安装及配置" class="headerlink" title="安装及配置"></a>安装及配置</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[mysql]$ mkdir -p /opt/qing/mysql/mysql3306/app/[mysql]$ mkdir -p /opt/qing/mysql/mysql3306/source/# 创建目录[mysql]$ cp /tmp/mysql-8.0.32-linux-glibc2.12-x86_64.tar.xz /opt/qing/mysql/mysql3306/source/[mysql]$ cd /opt/qing/mysql/mysql3306/source/# 移动源码包[mysql]$ tar -Jxf mysql-8.0.32-linux-glibc2.12-x86_64.tar.xz# 解压[mysql]$ lldrwxrwxr-x. 9 mysql mysql       129  4月 17 01:13 mysql-8.0.32-linux-glibc2.12-x86_64-rw-r--r--. 1 mysql mysql 610315332  4月 17 01:09 mysql-8.0.32-linux-glibc2.12-x86_64.tar.xz[mysql]$ mv mysql-8.0.32-linux-glibc2.12-x86_64 mysql_8.0.32[mysql]$ cd mysql_8.0.32# 进入源码文件中[mysql]$ cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \-DMYSQL_DATADIR=/usr/local/mysql/data \-DSYSCONFDIR=/etc \-DWITH_INNOBASE_STORAGE_ENGINE=1 \-DWITH_PARTITION_STORAGE_ENGINE=1 \-DWITH_FEDERATED_STORAGE_ENGINE=1 \-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \-DWITH_MYISAM_STORAGE_ENGINE=1 \-DENABLED_LOCAL_INFILE=1 \-DENABLE_DTRACE=0 \-DDEFAULT_CHARSET=utf8mb4 \-DDEFAULT_COLLATION=utf8mb4_general_ci \-DWITH_EMBEDDED_SERVER=1 \-DDOWNLOAD_BOOST=1 \-DWITH_BOOST=/opt/qing/mysql/mysql3306/source/mysql_8.0.32/boost/boost_1_73_0 \-DFORCE_INSOURCE_BUILD=1# 使用 CMake 生成 mysql 的安装文件时指定了安装路径# -DCMAKE_INSTALL_PREFIX 参数指定了安装路径为 /usr/local/mysql# -DMYSQL_DATADIR 参数指定了 MySQL 的数据目录为 /usr/local/mysql/data# -DWITH_BOOST 参数指定了 Boost 库的路径为 /opt/qing/mysql/mysql3306/source/mysql_8.0.32/boost/boost_1_73_0[mysql]$ make -j4  # 此处编译需要1个小时，一定要耐心等待[mysql]$ make install# 安装[mysql]$ chown -R mysql:mysql /usr/local/mysql# 修改权限给mysql用户和组[mysql]$ cat &gt; /etc/my.cnf &lt;&lt;"EOF"[mysqld]basedir=/usr/local/mysqldatadir=/usr/local/mysql/dataport=3306server_id=80273306log-binskip-name-resolvecharacter_set_server=utf8mb4default-time-zone = '+8:00'log_timestamps = SYSTEMEOF# 修改环境变量，注意这里配置的目录和你自己mysql的相关地址一致## 初始化[mysql]$ /usr/local/mysql/bin/mysqld --initialize-insecure --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --user=mysql# --initialize-insecure 指定以不安全的方式初始化 mysql 数据库，这意味着 root 用户没有密码。如果需要设置 root 密码，请使用 --initialize 参数。# --basedir 指定 mysql 安装目录的路径。# --datadir 指定 mysql 数据目录的路径。# --user 指定 mysql 服务器进程的运行用户。[mysql]$ echo "export PATH=$PATH:/usr/local/mysql/bin" &gt;&gt; /root/.bashrc# 将 mysql 的可执行文件路径添加到 root 用户的 Bash Shell 环境变量中[mysql]$ source /root/.bashrc# 重新加载 root 的配置文件[mysql]$ mysqld_safe &amp;# 启动 mysql 服务器的一种方式。这个命令会启动一个后台进程，该进程会自动重启 MySQL 服务器进程，如果服务器进程异常退出[mysql]$ mysql -uroot -p# 登录 mysql， 默认密码是空[mysql]$ mysqladmin -uroot -p shutdown# 关闭 mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_41645135/article/details/121882971">参考连接</a>：<a href="https://blog.csdn.net/weixin_41645135/article/details/121882971">https://blog.csdn.net/weixin_41645135/article/details/121882971</a></p>]]></content>
      
      
      <categories>
          
          <category> cs-data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> linux </tag>
            
            <tag> database </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于VMware安装Rocky linux</title>
      <link href="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/"/>
      <url>/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/</url>
      
        <content type="html"><![CDATA[<h1 id="基于VMware安装Rocky-linux"><a href="#基于VMware安装Rocky-linux" class="headerlink" title="基于VMware安装Rocky linux"></a>基于VMware安装Rocky linux</h1><blockquote><p>Rocky linux 是一个开源、社区拥有和管理、免费的企业级Linux发行版，它是由 CentOS 创始人 Gregory Kurtzer 发起的一个社区项目，旨在提供一个免费的、开源的、稳定的、安全的替代品，以取代Centos停止维护（改为滚动更新的Stream版）后，RHEL的下游Linux操作系统的替代方案，并继承了原CentOS的开源免费特点。</p><p><a href="https://rockylinux.org/">官方网址</a>：<a href="https://rockylinux.org/">https://rockylinux.org/</a></p><p><a href="https://www.rockylinux.cn/">中文网址</a>：<a href="https://www.rockylinux.cn/">https://www.rockylinux.cn/</a></p><p><a href="https://mirrors.aliyun.com/rockylinux/">阿里云镜像站</a>：<a href="https://mirrors.aliyun.com/rockylinux/">https://mirrors.aliyun.com/rockylinux/</a></p></blockquote><p>本文基于 <code>VMware Workstation 17 Player</code> 安装，不同版本的VM有不同的配置顺序，但是大致模块和带配置内容都一致，所以按照自己实际情况参考进行配置安装。</p><h2 id="虚拟机基础环境配置"><a href="#虚拟机基础环境配置" class="headerlink" title="虚拟机基础环境配置"></a>虚拟机基础环境配置</h2><h3 id="打开VMware新建虚拟机"><a href="#打开VMware新建虚拟机" class="headerlink" title="打开VMware新建虚拟机"></a>打开VMware新建虚拟机</h3><p>选择创建新虚拟机</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_00.png" class="" title="image_00"><h3 id="选择镜像文件地址"><a href="#选择镜像文件地址" class="headerlink" title="选择镜像文件地址"></a>选择镜像文件地址</h3><p>这里是要选择安装的是哪个来源媒介，包括直接从程序光盘安装和光盘映像文件。我峨嵋你这里选择第二个从光盘映像文件安装：</p><p>选择 安装程序光盘映像文件（<code>ISO</code>）-&gt; 浏览，选择之前下载的 <code>rocky linux</code> 镜像文件</p><p>然后下一步。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_01.png" class="" title="image_01"><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_02.png" class="" title="image_02"><h3 id="选择客户机操作系统"><a href="#选择客户机操作系统" class="headerlink" title="选择客户机操作系统"></a>选择客户机操作系统</h3><p>由于列表中没有<code>Rocky linux</code>的选项，我们选择 <code>Red Hat Enterprise Linux 9 64位</code></p><p>然后下一步。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_03.png" class="" title="image_03"><h3 id="配置虚拟机名称"><a href="#配置虚拟机名称" class="headerlink" title="配置虚拟机名称"></a>配置虚拟机名称</h3><p>这里是配置虚拟机的名称，以及选择虚拟机的保存地址，最终虚拟机的相关文件都会保存到这里选择的地址目录中</p><p>这里设置名称为 <code>Rocky_Linux_GPT</code>，根据自己的需求进行设置。</p><p>然后下一步。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_04.png" class="" title="image_04"><h3 id="为虚拟机设置磁盘容量"><a href="#为虚拟机设置磁盘容量" class="headerlink" title="为虚拟机设置磁盘容量"></a>为虚拟机设置磁盘容量</h3><p>这里的磁盘大小根据自己的需求进行选择，推荐40G即可。如果后期需要增加磁盘容量，可以通过linux的挂载磁盘等其他方式进行扩容。</p><p>并选择将磁盘拆分成多个文件，这样方便与在不同计算机之间直接移动虚拟机的文件来达到移动虚拟机。</p><p>然后下一步。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_05.png" class="" title="image_05"><h3 id="为虚拟机自定义硬件"><a href="#为虚拟机自定义硬件" class="headerlink" title="为虚拟机自定义硬件"></a>为虚拟机自定义硬件</h3><p>可以选择在这里进行自定义硬件，也可以在完成创建之后点击编辑虚拟机设置来进行修改。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_06.png" class="" title="image_06"><h4 id="为虚拟机配置内存"><a href="#为虚拟机配置内存" class="headerlink" title="为虚拟机配置内存"></a>为虚拟机配置内存</h4><p>系统一般推荐是2048MB，根据个人需求进行配置，不过其配置不可用高过宿主机的处理器配置。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_07.png" class="" title="image_07"><h4 id="为虚拟机配置处理器"><a href="#为虚拟机配置处理器" class="headerlink" title="为虚拟机配置处理器"></a>为虚拟机配置处理器</h4><p>这里可以自行选择，不过其配置不可用高过宿主机的处理器配置。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_08.png" class="" title="image_08"><h4 id="为虚拟机配置网络连接"><a href="#为虚拟机配置网络连接" class="headerlink" title="为虚拟机配置网络连接"></a>为虚拟机配置网络连接</h4><p>推荐选择桥接网络，这个也可以在后期进行自定义的修改，也可以配置多网络连接。当然如果没有自定义IP的需求直接选择 NAT 模式最为简单。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_09.png" class="" title="image_09"><ul><li><p>桥接网络</p><ul><li>简单来说虚拟机相当于在宿主机所在局域网内的一个单独的主机，他的行为和宿主机是同等地位的，没有依存关系。该模式下虚拟机和宿主机地位均等，通过各自独立的<code>IP</code>链接网络，相当于虚拟机直接连接网络。通过网络连接中的 <code>Vmnet0</code> 与外界联系。</li></ul></li><li><p>网络地址转换（<code>NET</code>）</p><ul><li>简单来说虚拟系统借助NAT(网络地址转换)功能，通过宿主机所在的网络来访问公网，依赖于宿主机，如果是在公司内网中，推荐使用该模式，不需要再申请内网中的独立<code>IP</code>便可以接入网络。通过网络连接中的 <code>Vmnet8</code> 与外界联系。</li></ul></li><li><p>仅主机模式网络</p><ul><li>简单来说，就是把虚拟机与公网进行了隔离，建立了一个与其他机器相隔离的系统不可以访问外网，仅可以与宿主机进行通信，相当于将虚拟机与宿主机通过双绞线进行了链接。通过网络连接中的 <code>Vmnet1</code> 与外界联系</li></ul></li></ul><blockquote><p>具体可参考如下两篇文章中的解析：</p><p><a href="https://blog.csdn.net/pursuing0my0dream/article/details/50286481">https://blog.csdn.net/pursuing0my0dream/article/details/50286481</a></p><p><a href="https://blog.csdn.net/weixin_34418883/article/details/92515092">https://blog.csdn.net/weixin_34418883/article/details/92515092</a></p></blockquote><p>这里的三种网络链接，可以查看自己的网络适配器，其中会有两个<code>VMware</code>的网络配置，</p><ul><li><p><code>VMware Network Adapter VMnet1</code></p><ul><li>宿主机用于与Host-Only虚拟网络进行通信的宿主机使用的虚拟网卡；即用于<strong>仅主机模式类型的网络</strong>。</li></ul></li><li><p><code>VMware Network Adapter VMnet8</code></p><ul><li>宿主机用于与NAT虚拟网络进行通信的宿主机使用的虚拟网卡；即用于<strong>网络地址转换类型的网络</strong>。</li></ul></li></ul><p>同时在<code>VMware</code>的编辑中还有虚拟网络编辑器选项，在其中可以看到这两个网络配置进行修改，<code>VMnet1</code>，<code>VMnet8</code>，在点击更改设置的时候还可以看到<code>VMnet0</code>(是用于桥接网络)，剩下的<code>VMnet2- VMnet7</code>可以进行自定义<code>custom</code>网络下的虚拟交换机。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>其他配置根据自己的需求进行设置，这里不做过多介绍，如果有兴趣可以自己查询。</p><h4 id="VMware-Workstation中的配置"><a href="#VMware-Workstation中的配置" class="headerlink" title="VMware Workstation中的配置"></a><code>VMware Workstation</code>中的配置</h4><p>如果使用<code>VMware Workstation</code>来创建虚拟机可以在配置机器的过程中也可以选择配置处理器数量和内核数量。当然在<code>VMware Workstation</code>中也可以子啊自定义硬件中配置。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_50.png" class="" title="image_50"><h3 id="完成基础配置"><a href="#完成基础配置" class="headerlink" title="完成基础配置"></a>完成基础配置</h3><p>完成所有的基础配置后，点击完成按钮即可。</p><h3 id="再次修改配置"><a href="#再次修改配置" class="headerlink" title="再次修改配置"></a>再次修改配置</h3><p>如果还有再次修改虚拟机基础硬件环境的配置，可以在初始页面选择需要修改的虚拟机，然后点击编辑虚拟机设置</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_10.png" class="" title="image_10"><h2 id="安装Rocky-Linux系统"><a href="#安装Rocky-Linux系统" class="headerlink" title="安装Rocky Linux系统"></a>安装<code>Rocky Linux</code>系统</h2><h3 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h3><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_11.png" class="" title="image_11"><p>等待片刻即可进入虚拟机安装页面</p><h3 id="选择安装模式与启动-inst-gpt"><a href="#选择安装模式与启动-inst-gpt" class="headerlink" title="选择安装模式与启动(inst.gpt)"></a>选择安装模式与启动(inst.gpt)</h3><h4 id="基础步骤"><a href="#基础步骤" class="headerlink" title="基础步骤"></a>基础步骤</h4><p>从上至下分别是：</p><ul><li>正常安装 <code>Rocky Linux 9.1</code></li><li>测试此光盘后再进入 <code>Rocky Linux 9.1</code> 安装步骤</li><li>进入除错模式。选择此模式会出现更多的选项，分别是：<ul><li>以基本图形用户界面模式安装 <code>Rocky Linux 9.1</code> （使用标准显卡来设置安装步骤图示）</li><li>恢复 <code>Rocky Linux</code> 系统</li><li>运行内存测试程序</li><li>由本地磁盘正常启动，不由光盘启动。</li><li>返回主菜单</li></ul></li></ul><p>基本上，除非硬件系统有问题，包括有用比较特别的显卡外，否则使用“正常安装 <code>Rocky Linux 9.1</code>”的步骤即可。如果怀疑光盘由问题，就可以选择测试光盘后在进入<code>Rocky Linux 9.1</code> 安装的程序。如果确信此光盘没问题，就不要测试了。如果不在乎花费一两分钟的时间去测试看看光盘有没有问题，就使用测试后安装的步骤。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_12.png" class="" title="image_12"><p><strong>可以直接选中第一个选项 Install Rocky Linux 9.1来安装系统</strong></p><h4 id="额外配置"><a href="#额外配置" class="headerlink" title="额外配置"></a>额外配置</h4><p>该步骤并不是必要步骤，只是为了强制使用 <code>GPT</code> 分区表的安装参数。</p><p>因为，如果磁盘容量小于<code>2TB</code>的话，系统默认会使用<code>MBR</code>分区表来安装。因为我们配置的默认磁盘容量是 <code>40GB</code>，所以默认肯定会用<code>MBR</code>分区表来安装。那如果想要强制使用<code>GPT</code>分区表的话，就需要使用以下步骤：</p><ol><li><p>使用箭头键，将图<code>image_12</code>的光标移动到 <code>Install Rocky Linux 9.1</code> 选项</p></li><li><p>按下键盘的 <code>Tab</code> 按键，让光标移动到界面最下方输入额外的内核参数</p></li><li><p>再出现的界面中，输入以下参数</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=Rocky-9-1-x86_64-dvd quiet inst.gpt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中按下<code>tab</code>键后会自动出现如图 <code>image_14</code> 所示的基本参数，在后面添加上 <code>inst.gpt</code> 即可。</p><p>这里的重点参数就是输入的 “<code>inst.gpt</code>”。之后回车运行。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_13.png" class="" title="image_13"></li></ol><p>参数基本格式解析如下“</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">inst.ks=hd:LABEL=&lt;LABEL NAME&gt;:&lt;KS FILENAME&gt; inst.gpt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，<code>&lt;LABEL NAME&gt;</code> 是安装介质的标签名称，<code>&lt;KS FILENAME&gt;</code> 是包含 Kickstart 文件的文件名。使用此内核参数将强制在安装过程中使用 <code>GPT</code> 分区表。</p><p>请注意，在使用此内核参数之前，请确保系统支持 <code>GPT</code> 分区表。如果系统使用 <code>BIOS</code> 引导，则需要使用 <code>MBR</code> 分区表。如果系统使用 <code>UEFI</code> 引导，则可以使用 <code>GPT</code> 分区表。</p><p>此外，如果使用 <code>UEFI</code> 引导，还需要在启动时选择 <code>UEFI</code> 模式。如果使用 <code>BIOS</code> 引导，则应选择 <code>Legacy</code> 模式。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_14.png" class="" title="image_14"><h4 id="启动安装后"><a href="#启动安装后" class="headerlink" title="启动安装后"></a>启动安装后</h4><p>输入合适参数，启动安装之后，系统会运行一段检测的画面，这段检测的流程依据光驱速度、硬件复杂度而有不同，等待个几秒种到一两分钟就可以了。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_15.png" class="" title="image_15"><h3 id="选择基础语言和配置"><a href="#选择基础语言和配置" class="headerlink" title="选择基础语言和配置"></a>选择基础语言和配置</h3><p>选择合适的语言，点击继续。</p><p>这个选择还挺重要的，因为将来的默认语言，默认用户环境等，都跟这里有关，当然在安装好之后可以进行修改。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_16.png" class="" title="image_16"><p>在 <code>Rocky Linux 9.1</code> 的安装步骤中，已经将所有的可选步骤以按钮形式统统集中在了第一页，如下图 <code>images_17</code> 所示，可以在同一个界面种卡完所有的设置，也可以跳着修改各个设置，不用被约束一项一项处理。可以根据需求进行设置，下面将简单介绍下每个项目的设置方式。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_17.png" class="" title="image_17"><h3 id="设置时区、语言与键盘布局"><a href="#设置时区、语言与键盘布局" class="headerlink" title="设置时区、语言与键盘布局"></a>设置时区、语言与键盘布局</h3><h4 id="时区设置"><a href="#时区设置" class="headerlink" title="时区设置"></a>时区设置</h4><p>选择图 <code>images_17</code> 种的 <strong>本地化</strong> 类别种的 <strong>日期和时间</strong> 后，会出现世界地图。</p><p>可以直接在地图上面选择需要的失去位置，也可以在图中 <strong>地区、城市</strong> 的下拉种列表选择需要的城市即可。如果日期与时间不对，可以在相应处分别修改。虽然在有有网络时，可以打开自动校准时间功能，不过如果因为网络尚未设置好，所以 <strong>网络时间</strong> 按钮无法顺利开始。如果网络已经配置好了，就可以选择该按钮。操作完毕后按下 <strong>完成</strong> 按钮。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_18.png" class="" title="image_18"><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_19.png" class="" title="image_19"><h4 id="语言和键盘布局"><a href="#语言和键盘布局" class="headerlink" title="语言和键盘布局"></a>语言和键盘布局</h4><p>选择 <strong>键盘</strong> 按钮。</p><p>这个很重要，因为通常我们需要输入中文，所以常常打字会在中/英文之间切换。过去常常使用的键盘布局时 <strong>Ctrl + 空格</strong> 按钮，或是 <strong>Ctrl + Shift</strong> 按钮，不过这个系统，默认并没有提供任何的切换按钮，所以这里预先来设置一下比较妥当。如图中的顺序去调整，选择合适自己习惯的组合键，我这里选择了 <strong>Ctil + Shift</strong> 组合键，确认后可以按完成按钮即可。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_20.png" class="" title="image_20"><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_21.png" class="" title="image-20230411000145336"><p>当然如果需要其他输入法，选择下面的 <strong>+</strong> 号添加新的语言即可</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_22.png" class="" title="image_22"><h3 id="安装源设置和软件选择"><a href="#安装源设置和软件选择" class="headerlink" title="安装源设置和软件选择"></a>安装源设置和软件选择</h3><p>按下 <strong>安装源</strong> 按钮之后，会看到如下界面</p><p>因为使用的时光盘启动，同时还没有设置网络，因此默认就会选择光盘（<code>sr0</code> 所在的设备）。如果你的主机系统当中还有其他安装程序可以识别的磁盘文件系统，镜像文件也可以放在这些文件系统中，通过镜像文件也能够提供软件的安装，因此就有入宫下图的 <code>ISO</code>文件 的选项。最后，如果安装程序已经预先设置好了网络，那么就可以选择 <strong>在网络上</strong> 的选项，并且填写正确的网址（<code>URL</code>），那么安装程序就可以直接从网络中下载安装。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_23.png" class="" title="image_23"><p>按下完成并返回最开始的设置页面后，等待检测完成后，就得要选择 <strong>软件选择</strong> 的界面了，如下图所示：</p><p>这里可以安装需求选择，默认时 <strong>最小安装</strong> 的模式，这种模式只安装最简单的功能，适合于高手慢慢搭建自己的环境只用。如果时初学者，没有图形用户界面模式看起来确实怪，所以建议可以选择如下的选项：</p><ul><li>带 <code>GUI</code> 的服务器（<code>GUI</code> 就是用户图形用户界面模式，默认搭载 <code>GNOME</code>）；</li><li><code>GNOME</code> 桌面：<code>Linux</code> 常见的图形用户界面软件；</li><li><code>KDE Plasma Workspaces</code>：另一个常见的图形用户界面软件。</li></ul><p>选择完毕之后按下完成，安装程序会开始检查光盘里面有没有选择的软件，而且解决软件依赖性的检查（就是将所选择的大分类下面的其他支持软件统统加载），之后就会再次回到同一配置页面。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_24.png" class="" title="image_24"><h3 id="磁盘分区与文件系统设置"><a href="#磁盘分区与文件系统设置" class="headerlink" title="磁盘分区与文件系统设置"></a>磁盘分区与文件系统设置</h3><h4 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h4><p>这里就是重头戏了，<strong>磁盘分区</strong>，点击 <strong>系统</strong> 分类下的 <strong>安装目的地</strong>，点选之后会进入如下所示界面。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_25.png" class="" title="image_25"><p>选择1号所指，点选之后就会出现打勾的符号。（因为我们时虚拟机虚拟了一块硬盘，所以这里和i能看到一块磁盘，如果机器上有多个磁盘，这里就需要选择下了）之后可以选择下面的自动分区也可以选择自定义分区，按照自己的需求来配置，一般可以选择自动分区。</p><h4 id="自定义分区"><a href="#自定义分区" class="headerlink" title="自定义分区"></a>自定义分区</h4><p>如果选择 <strong>自定义</strong> 之后点击 <strong>完成</strong> 按钮会进入如下的界面</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_26.png" class="" title="image_26"><p>如果之前已经安装了其他系统，就会发现在 <strong>新 Rocky Linux 9.1 安装</strong>下面还有个操作系统名称，点选该名称（系统可能不会有这个选项，也有可能时其他选项。不过，如果时全新硬盘，就可以略过这部分），它就会出现该系统的分区，依序分别点下面的 <code>/boot</code>，<code>/</code>，<code>swap</code>（交换分区）三个项目，然后点选下面的减号 **-**，就可以删除掉该分区了，删除的时候可能会出现警告窗口。会特别询问你哟啊不要同时删除其他的分区，原本是有多个分区的，按下 <strong>删除</strong> 按钮后，三个分区全部会被删除干净，之后就会回到 <code>images_26</code>的界面中，之后就可以建立文件系统了。</p><p>下面先来制作第一个<code>GPT</code> 分区表最好要有的 <code>BIOS boot</code> 分区，如下图</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_27.png" class="" title="image_27"><p>先点选 1 号处的选项，不要使用默认的 <code>LVM</code>。选择 <strong>标准分区</strong> 选项，并按下 2 号处的按钮 <strong>+</strong> 符号，就会出现中间的弹出窗口，在该窗口中 3 号 位置选择图片中的 <strong>biosboot</strong> （不要手动输入界面的问题，请使用既有的选项来选择），同时输入大约 <code>2M</code> 的容量，按下 <strong>添加挂载点</strong> 后，就会显示该分区的详细数据。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_28.png" class="" title="image_28"><p>如上图所示，界面的右边就是 <code>biosboot</code> 分区的详细数据。由于是 <code>BIOS</code> 使用，因此没有挂载点，同时文件系统的部分也是会变成 <code>BIOS Boot</code> 的关键词，并不会是<code>Linux</code>的文件系统，接下来，要来设置其他的分区。继续点击下面的 <strong>+</strong> 号。</p><p>另外，图中的 <strong>设备类型</strong> 其实有3种，这里只使用了标准分区和<code>LVM</code>。三种设备类型的意义分别如下：</p><ul><li>标准分区：类似 <code>/dev/vda1</code> 之类的分区。</li><li><code>LVM</code>：这是一种可以弹性增加或减小文件系统容量的分区，之后或许会在我总结的 《鸟哥的linux私房菜 》中说明。</li><li><code>LVM</code>精简配置（<code>Thin Provisioning</code>）：这个是<code>LVM</code>的高级版。与传统LVM直接分配固定的容量不同，这个 <strong>LVM精简配置</strong> 的选项，可以在使用多少容量才分配磁盘多少容量给你，所以如果LVM设备内的数据量较少，那么你的磁盘其实还可以做更多的数据存储，而不会被平白无故的占有。</li></ul><p>另外，图中的文件系统就是实际 <strong>格式化</strong> 的时候，我们可以格式化成什么文件系统的意思。下面简略分别说下各个文件系统的选项：</p><ul><li><code>ext2/ext3/ext4</code>：这是 <code>Linux</code> 早期使用的文件系统类型。由于 <code>ext3/ext4</code> 文件系统多了日志功能，对于系统的恢复比较快速，不过由于磁盘容量越来越大，<code>ext</code> 系列似乎有点挡不住了，所以除非有特殊设置需求，否则进来比较少使用 <code>ext4</code>。</li><li><code>swap</code>：就是磁盘模拟为内存的交换分区，由于交换分区并不会使用到目录树的挂载，所以用交换分区就不需要指定挂载点。</li><li><code>BIOS Boot</code>：就是 <code>GPT</code> 分区表可能会使用到的东西，若使用的是 <code>MBR</code>，就不需要这个东西了。</li><li><code>xfs</code>：这个是目前 <code>CentOS 7</code> 默认的文件系统，最早是为大型服务器所开发。它对于大容量的磁盘管理非常好，而且格式化的时候速度相当快，很适合当今动不动就是好几个 <code>TB</code> 的磁盘的环境，因此主要使用这个。</li><li><code>vfat</code>：同时被 <code>Linux</code> 与 <code>Windows</code> 所支持的文件系统类型。如果主机硬盘内同时存在 <code>Windows</code>与<code>Linux</code>系统，为了数据交换，确实可以创建一个 <code>vfat</code> 的文件系统。</li></ul><p>接下来是建立 <code>/boot</code> 挂载点的文件系统，容量部分可以输入 <code>1G</code> 或是 <code>1024M</code> 都可以，然后按下 <strong>新增</strong> ，就会回到同一配置页面。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_29.png" class="" title="image_29"><p>接下来依序建立另外所需要的根目录 <code>/</code> 分区，建议给与 <code>10GB</code> 的容量，我们的 <code>/</code> 、 <code>/home</code> 、 交换分区都使用<code>LVM</code>磁盘管理模式即可。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_30.png" class="" title="image_30"><p>选择分区 <code>/</code> 然后点击<strong>设备类型</strong>选择为 <code>LVM</code> ， 由于 <code>LVM</code> 会取一个默认名字的 <code>LVM</code> 设备，如果需要修改，按下 修改 按钮即可，接下来会出现下面的界面，处理 <code>LVM</code> 的相关设置</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_31.png" class="" title="image_31"><p>这里大小根据需求选择即可，在大小策略部分选择 固定容量，大小根据需求设置。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_32.png" class="" title="image_32"><p>之后创建 <code>/home</code> 挂载点，同样设置为 <code>LVM</code> 类型，之后确定卷组部分还有剩余容量即可。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_33.png" class="" title="image_32"><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_34.png" class="" title="image_34"><p>然后设置 <code>swap</code> 分区（交换分区）是当物理内存容量不够时，可以拿这部分来存放内存中较少被使用的数据，以前都建议交换分区需要时内存的2倍最佳。现在的内存都比较大，但是还是最好保持有，不过也不需要太大，<code>1——2GB</code>就好。同样设置为 <code>LVM</code> 类型，之后确定卷组部分还有剩余容量即可。</p><blockquote><p>内存交换分区的功能是：当有数据被存放在物理内存里面，但是这些数据又不是长被<code>CPU</code>所使用时，那么这些不常被使用的数据将会被扔到硬盘的交换分区当中，而将速度较快的物理内存空间释放出来给真正需要的程序使用，所以，如果你的系统不很忙，而内存又很大，自然不需要交换分区。</p></blockquote><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_35.png" class="" title="image_35"><p>完成这些分区配置后，如下</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_36.png" class="" title="image_36"><p>最后点击按钮 <strong>完成</strong> ，系统会出现一个警告窗口，提醒你是否要真的进行这样的分区与格式化的操作。</p><p>之后可以特别观察一下分区表的类型，可以发现方框圈起来的地方，删除了 <code>MSDOS</code>（<code>MBR</code>）而建立了<code>GPT</code>。这就是之前初始化的时候执行的内核参数的效果。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_37.png" class="" title="image_37"><h3 id="内核管理与网络设置"><a href="#内核管理与网络设置" class="headerlink" title="内核管理与网络设置"></a>内核管理与网络设置</h3><h4 id="KDUMP"><a href="#KDUMP" class="headerlink" title="KDUMP"></a>KDUMP</h4><p>点选 <strong>系统</strong> 分类下的 <strong>KDUMP</strong> ，这个选项主要时处理当 <code>Linux</code> 系统，因为内核问题导致的宕机事件会将该当即事件的内存中的数据保存的一项功能。不过，这个功能似乎比较偏向于内核开发者在除错之用，如果又需要可以启动。不需要的话，也能关闭，对系统的影响撕毁并不太大。</p><h4 id="网络和主机名"><a href="#网络和主机名" class="headerlink" title="网络和主机名"></a>网络和主机名</h4><p>之后点选 <strong>系统</strong> 分类下的 <strong>网络和主机名</strong> 的设置。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_38.png" class="" title="image_38"><p>按照顺序，选择正确的网卡之后，然后点击 2 号的 <strong>开启</strong>，之后到 3 号位置开始 <strong>配置</strong> 。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_39.png" class="" title="image_39"><p>进入配置之后就可以配置一个自定义的<code>IP</code>。</p><p>配置 <strong>常规</strong> 选项</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_40.png" class="" title="image_40"><p>然后选择 <strong>IPv4配置</strong> ，然后调整为 <strong>手动</strong>，配置所需要的<code>IP</code>地址与子网掩码，其他选项不用修改，然后 <strong>保存</strong> 即可。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_41.png" class="" title="image_41"><p>然后可在左下角选择配置自己的主机名，配置完毕后就可以 <strong>完成</strong> 了</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_42.png" class="" title="image_42"><h3 id="开始安装、设置root密码与新增可切换身份之一般用户"><a href="#开始安装、设置root密码与新增可切换身份之一般用户" class="headerlink" title="开始安装、设置root密码与新增可切换身份之一般用户"></a>开始安装、设置<code>root</code>密码与新增可切换身份之一般用户</h3><h4 id="root密码"><a href="#root密码" class="headerlink" title="root密码"></a><code>root</code>密码</h4><p>按下 <strong>root密码</strong> ，可以看到下面的界面来修改系统管理员的密码。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_43.png" class="" title="image_43"><p>设置好密码后，按下两次 <strong>完成</strong>，安装程序才会真的帮你设置该密码。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_44.png" class="" title="image_44"><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>接下来建立一个日常登录系统的常用账号，建议将管理员直接登录的权限拿掉，有需要时才用特殊命令（如 <code>su</code>，<code>sudo</code>等命令）切换成管理员身份，所以这里创建一个一般账号</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_45.png" class="" title="image_45"><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_46.png" class="" title="image_46"><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><p>点击 <strong>开始安装</strong> 按钮，进行安装。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_47.png" class="" title="image_47"><p>安装完成之后，点击 重启系统 按钮</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_48.png" class="" title="image_48"><h3 id="准备使用系统前的授权同意"><a href="#准备使用系统前的授权同意" class="headerlink" title="准备使用系统前的授权同意"></a>准备使用系统前的授权同意</h3><p>重新启动完毕后，就会进入下图的页面，等待登录，就此安装完成。（其他系统可能会进入第一次使用的许可证接受界面，选择同意协议后，再次确认后，就可以进入登录页面）</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_49.png" class="" title="image_49"><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="桥接模式下无法联网问题"><a href="#桥接模式下无法联网问题" class="headerlink" title="桥接模式下无法联网问题"></a>桥接模式下无法联网问题</h3><p>桥接模式下，是通过网络适配器 <code>VMware Network Adapter VMnet0</code> 来连接网络，可以先打开 <strong>控制面板</strong> -&gt; <strong>网络和Internet</strong> -&gt; <strong>网络连接</strong> 中来查看网络适配器设置。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_51.png" class="" title="image_51"><p>如果没有找到 <code>VMnet0</code> 的网络适配器就需要手动添加下。</p><p>打开 <code>VMware</code> <strong>编辑</strong> -&gt; <strong>虚拟网络编辑器</strong> 来配置网络</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_52.png" class="" title="imag_52"><p>点击<strong>更改设置</strong>来添加网络适配器。点击后会提示需要管理员权限启动，确认下<code>VMnet0</code>的配置</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_53.png" class="" title="image_53"><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_54.png" class="" title="image_54"><p>打开虚拟机的 配置 -&gt; 网络适配器 -&gt; 将桥接模式下的复制物理网络连接状态勾选。</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_55.png" class="" title="image_55"><p>查看宿主机的网络连接配置，即 <strong>默认网关</strong>、<strong>DNS服务器</strong></p><ol><li><p>通过<strong>设置</strong> -&gt; <strong>网络和 Internet</strong> -&gt; <strong>状态</strong> -&gt; <strong>查看硬件和连接属性</strong>， 找到连接性是已连接的配置即可查看</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_56.png" class="" title="image_56"><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_57.png" class="" title="image_57"></li><li><p>通过<strong>设置</strong> -&gt; <strong>网络和 Internet</strong> -&gt; <strong>状态</strong> -&gt; <strong>更改适配器选项</strong>，双击接入了网络的适配器，点击<strong>详情信息</strong>查看配置</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_58.png" class="" title="image_58"></li></ol><p>打开虚拟机，进入网络配置页面</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_59.png" class="" title="image_59"><p>点击 <strong>设置</strong></p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_60.png" class="" title="image_60"><p>选择 <code>IPv4</code> 选项，将其中的<strong>子网掩码</strong>、<strong>网关</strong>、<strong>DNS配置</strong>与宿主机一致（DNS可以只用配置一个）</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_61.png" class="" title="image_61"><p>保存之后，测试网络连接</p><img src="/2023/03/26/cs-dev-ops/vmware-install-rocky-linux/images_62.png" class="" title="image_62"><hr><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>另附 <a href="https://github.com/RobertSunq/data/blob/master/qing/blog/hexo/VMware%E5%AE%89%E8%A3%85CentOS7.docx">基于VMware Workstation安装Centos 7 教程</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>主要参考于《鸟哥的Linux私房菜》。</p>]]></content>
      
      
      <categories>
          
          <category> cs-dev-ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> linux </tag>
            
            <tag> rocky linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UltralSO制作U盘启动盘</title>
      <link href="/2023/03/26/notes/ultralso-make-startup-disk/"/>
      <url>/2023/03/26/notes/ultralso-make-startup-disk/</url>
      
        <content type="html"><![CDATA[<h1 id="UltralSO制作U盘启动盘"><a href="#UltralSO制作U盘启动盘" class="headerlink" title="UltralSO制作U盘启动盘"></a>UltralSO制作U盘启动盘</h1><blockquote><p>说明：使用<code>UltralSO</code>（软碟通）制作<code>U</code>盘启动盘</p><p>软件<a href="https://cn.ultraiso.net/">下载链接</a>：<a href="https://cn.ultraiso.net/%EF%BC%8C">https://cn.ultraiso.net/，</a>  <a href="https://www.ultraiso.com/">https://www.ultraiso.com/</a></p></blockquote><ol><li><p>格式化需要使用的<code>U</code>盘。</p></li><li><p>打开<code>UltralSO</code>，然后点击  文件 -&gt; 打开，选择需要刻录到<code>U</code>盘的<code>ISO</code>镜像文件。</p><img src="/2023/03/26/notes/ultralso-make-startup-disk/images_00.png" class="" title="images_00"><p>如果右上角显示的镜像容量，大于预设的磁盘大小，可以点击大小设置部分，修改为合适的容量</p><img src="/2023/03/26/notes/ultralso-make-startup-disk/images_04.png" class="" title="images_04"></li><li><p>再左下角区域选择需要刻录的<code>U</code>盘</p><img src="/2023/03/26/notes/ultralso-make-startup-disk/images_01.png" class="" title="images_01"></li><li><p>点击 启动 -&gt; 写入硬盘映像。</p><img src="/2023/03/26/notes/ultralso-make-startup-disk/images_02.png" class="" title="images_02"></li><li><p>在弹出框中进行配置</p><ol><li><p>写入方式选择“<code>USB-HDD+</code>”</p><img src="/2023/03/26/notes/ultralso-make-startup-disk/images_03.png" class="" title="images_03"></li><li><p>点击“写入”按钮</p><img src="/2023/03/26/notes/ultralso-make-startup-disk/images_05.png" class="" title="images_05"><p>如果写入过程中提示 “磁盘/映像空间太小！” 可以尝试去官网下载最新版的<code>UltralSO</code>，这个是老版软件的问题。（在确定自己的U盘容量足够且大于要写入的系统文件大小时）</p></li></ol></li><li><p>最后等待刻录成功</p><img src="/2023/03/26/notes/ultralso-make-startup-disk/images_06.png" class="" title="images_06"></li></ol><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> note </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Microsoft 365 E5订阅 office 与自动续订</title>
      <link href="/2023/03/25/notes/keep-alive-e5/"/>
      <url>/2023/03/25/notes/keep-alive-e5/</url>
      
        <content type="html"><![CDATA[<h1 id="Microsoft-365-E5-订阅-office-与自动续订"><a href="#Microsoft-365-E5-订阅-office-与自动续订" class="headerlink" title="Microsoft 365 E5 订阅 office 与自动续订"></a><code>Microsoft 365 E5</code> 订阅 <code>office</code> 与自动续订</h1><blockquote><p>说明：使用<code>Microsoft 365 E5</code>免费订阅<code>office</code>以及通过<code>github</code>的<code>KeepAliveE5</code>项目定时续期</p></blockquote><h2 id="注册与激活E5账号"><a href="#注册与激活E5账号" class="headerlink" title="注册与激活E5账号"></a>注册与激活<code>E5</code>账号</h2><blockquote><p>注意：下述操作涉及到登录微软官方地址，中途需要使用到谷歌的人机验证，请自行准备好网络环境来访问这些官网。同时需要准备一个微软账号，且安装的时候确保电脑当中没有 <code>office</code>产品，以免安装 <code>microsoft 365</code>失败</p></blockquote><ol><li><p>首先来到<code>microsoft 365</code> 开发人员中心的<a href="https://developer.microsoft.com/en-us/microsoft-365/dev-program">官网</a>：<a href="https://developer.microsoft.com/en-us/microsoft-365/dev-program%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%8C%E9%80%89%E6%8B%A9%E7%AB%8B%E5%8D%B3%E5%8A%A0%E5%85%A5">https://developer.microsoft.com/en-us/microsoft-365/dev-program，如下图，选择立即加入</a></p><img src="/2023/03/25/notes/keep-alive-e5/join_e5.png" class="" title="join_e5"></li><li><p>之后会跳转到需要登陆<code>microsoft</code>账号页面，选择登录账号.</p><img src="/2023/03/25/notes/keep-alive-e5/sign_in_microsoft_account.png" class="" title="sign_in_microsoft_account"></li><li><p>再登录账号之后，会出现页面填写加入计划的详细信息，这里根据自己的实际情况填写即可。（公司部分可以虚拟，此处不会验证公司配置）。</p><img src="/2023/03/25/notes/keep-alive-e5/setting_01.png" class="" title="setting_01"></li><li><p>之后作为开发人员最关注的是什么，根据实际情况随意选择一个</p><img src="/2023/03/25/notes/keep-alive-e5/setting_02.png" class="" title="setting_02"></li><li><p>感兴趣的开发领域也随意选择即可</p><img src="/2023/03/25/notes/keep-alive-e5/setting_03.png" class="" title="setting_03"></li><li><p>之后就会跳转到设置<code>E5</code>订阅</p><img src="/2023/03/25/notes/keep-alive-e5/setting_04.png" class="" title="setting_04"></li><li><p>之后开始填写表单中的信息，<strong>注意这里设置的用户名和创建域会影响到图片中红色圈圈部分的注册的E5账户号名和二级域名</strong>。</p><img src="/2023/03/25/notes/keep-alive-e5/setting_00.png" class="" title="setting_00"></li><li><p>之后，就是设置电话号码。可选择填写国内手机号（<code>China(+86)</code>，<strong>此处就需要谷歌认证了请自行准备好网络环境</strong>）。</p><img src="/2023/03/25/notes/keep-alive-e5/setting_05.png" class="" title="setting_05"></li><li><p>之后就正常登录到开发人员页面了，随后来到<code>admin.microsoft.com</code>来到管理面板。这个时候需要登录刚刚注册的<code>microsoft</code>账号（也就是刚刚配置的<code>E5</code>开发者账号，也就是第八步中红框设定好的域名账号）。</p></li><li><p>登录完成后，选择左边菜单栏中的用户下的活跃用户选项</p><img src="/2023/03/25/notes/keep-alive-e5/setting_06.png" class="" title="setting_06"></li><li><p>勾选自己的账号，然后选择上方的“管理产品许可证”，在弹出的右侧菜单栏中出现的所有许可证都选上然后保存更改</p><img src="/2023/03/25/notes/keep-alive-e5/setting_07.png" class="" title="setting_07"></li></ol><h2 id="下载与激活office"><a href="#下载与激活office" class="headerlink" title="下载与激活office"></a>下载与激活<code>office</code></h2><ol><li><p>来到微软的<a href="https://www.office.com/">官网</a> <a href="https://www.office.com/">https://www.office.com/</a></p><p>登录刚刚注册的E5账号（注意是刚刚注册的E5账号，而不是最开始的微软账号）。</p><img src="/2023/03/25/notes/keep-alive-e5/setting_08.png" class="" title="setting_08"></li><li><p>之后选择右上角的选择，安装<code>office</code>，然后选择 <code>office 365</code> 应用</p><img src="/2023/03/25/notes/keep-alive-e5/setting_09.png" class="" title="setting_09"></li><li><p>之后就下载一个安装软件，下载完成后点击安装运行，会自动安装office 365，再等待安装完成之后，登录之前注册的E5账号即可完成自动激活。</p><img src="/2023/03/25/notes/keep-alive-e5/setting_10.png" class="" title="setting_10"></li></ol><h2 id="使用github-action来自动续订E5"><a href="#使用github-action来自动续订E5" class="headerlink" title="使用github action来自动续订E5"></a>使用<code>github action</code>来自动续订<code>E5</code></h2><ol><li><p>登录<code>github</code>官网，选择账号下面的<code>settings</code>选项。</p><img src="/2023/03/25/notes/keep-alive-e5/active_setting_00.png" class="" title="active_setting_00"></li><li><p>然后点击最下面的<code>Developer settings</code>选项。</p><img src="/2023/03/25/notes/keep-alive-e5/active_setting_01.png" class="" title="active_setting_01"></li><li><p>然后选择 <code>personal accsee tokens</code>，点击 <code>Generate new token</code> 新建 <code>token</code>。保存好新生成的<code>token</code>。</p><img src="/2023/03/25/notes/keep-alive-e5/active_setting_02.png" class="" title="active_setting_02"><img src="/2023/03/25/notes/keep-alive-e5/active_setting_03.png" class="" title="active_setting_03"><img src="/2023/03/25/notes/keep-alive-e5/active_setting_04.png" class="" title="active_setting_04"></li><li><p>搜索<a href="https://github.com/vcheckzen/KeepAliveE5"><code>KeepAliveE5</code></a>项目，并导入到自己的存储库。导入完成后跳转到自己的仓库。</p><img src="/2023/03/25/notes/keep-alive-e5/active_setting_05.png" class="" title="active_setting_05"><p>复制项目的 <code>code</code> ，选择头像旁边的+号导入自己的仓库。</p><img src="/2023/03/25/notes/keep-alive-e5/active_setting_06.png" class="" title="active_setting_06"><img src="/2023/03/25/notes/keep-alive-e5/active_setting_07.png" class="" title="active_setting_07"><img src="/2023/03/25/notes/keep-alive-e5/active_setting_08.png" class="" title="active_setting_08"><p>导入完成后，可以点击跳转到自己项目</p><img src="/2023/03/25/notes/keep-alive-e5/active_setting_09.png" class="" title="active_setting_09"></li><li><p>开启<code>Action</code>功能。进入到项目的<code>settings</code>选项，选择<code>Actions</code>选项中的 <code>General</code>，将Actions permissions 选项设置为第一个 <code>Allow all actions and reusable workflows</code>选项，然后点击<strong>保存</strong>。</p><img src="/2023/03/25/notes/keep-alive-e5/active_setting_10.png" class="" title="active_setting_10"></li><li><p>之后继续在<code>Settings</code>里选择 <code>Secrets and variables</code>选项，点击 <code>Actions</code>，点击 <code>new repository secret</code> 选项。之后配置三个密钥，<code>PAT</code>就是上一步第三步生成的<code>token</code>，<code>USER</code>就是你的<code>E5</code>账号，<code>PASSWD</code>就是你的<code>E5</code>账号的密码，然后<code>Add secret</code>分别设置添加这三个密钥。</p><img src="/2023/03/25/notes/keep-alive-e5/active_setting_11.png" class="" title="active_setting_11"><img src="/2023/03/25/notes/keep-alive-e5/active_setting_13.png" class="" title="active_setting_13"><p>上述三个配置在项目的<code>README</code>中也可以看到</p><img src="/2023/03/25/notes/keep-alive-e5/active_setting_12.png" class="" title="active_setting_12"></li><li><p>之后根据<a href="https://learn.microsoft.com/zh-cn/azure/active-directory/fundamentals/concept-fundamentals-security-defaults#disabling-security-defaults">微软禁用安全默认值教程</a>禁用安全默认值</p><ol><li><p>以安全管理员、条件访问管理员或全局管理员身份登录到 <a href="https://azure.microsoft.com/zh-cn/">Azure</a></p><img src="/2023/03/25/notes/keep-alive-e5/active_setting_14.png" class="" title="active_setting_14"></li><li><p>点击 <code>Azure active directoty</code> 选择 <strong>属性</strong></p></li><li><p>选择 <strong>管理安全默认值</strong></p></li><li><p>将 <strong>启用安全默认值</strong> 切换为 <strong>否</strong></p></li><li><p>选择 保存</p><img src="/2023/03/25/notes/keep-alive-e5/active_setting_15.png" class="" title="active_setting_15"></li></ol></li><li><p>启用<code>Action</code>的注册<code>APP</code>工作流，进入到<code>Action</code>点击 <code>Register APP</code>，点击右侧的<code>Run workflow</code>，分支就选择当前项目的主分支，然后点击 <code>Run workflow</code> 运行注册流程。</p><img src="/2023/03/25/notes/keep-alive-e5/active_setting_16.png" class="" title="active_setting_16"></li><li><p>然后等待一会，等待期间可以点击进去看运行的日志，运行到什么步骤了，完成后点击日志中的 <code>Register app</code> 那一步。 如果最后显示是注册成功就可以了。</p><img src="/2023/03/25/notes/keep-alive-e5/active_setting_17.png" class="" title="active_setting_17"><img src="/2023/03/25/notes/keep-alive-e5/active_setting_18.png" class="" title="active_setting_18"><img src="/2023/03/25/notes/keep-alive-e5/active_setting_20.png" class="" title="active_setting_20"></li><li><p>启用 <code>Action</code> 的调用 <code>API</code> 工作流。进入到 <code>Action</code> 点击 <code>invoke API</code>，点击右侧 <code>Run workflow</code>， 分支就选择当前项目的主分支，点击 <code>Run workflow</code> 运行调用流程。</p><img src="/2023/03/25/notes/keep-alive-e5/active_setting_19.png" class="" title="active_setting_19"></li><li><p>然后等待一会，等待期间可以点击进去看运行的日志，运行到什么步骤了，完成后点击日志中的 <code>Test Api</code> 那一步。可以看到最后已经成功了。</p><img src="/2023/03/25/notes/keep-alive-e5/active_setting_21.png" class="" title="active_setting_21"><img src="/2023/03/25/notes/keep-alive-e5/active_setting_22.png" class="" title="active_setting_22"></li><li><p>后面之歌工作流就会每天自动调用<code>API</code>，保证账号是使用的，从而得到微软的自动续期。</p></li></ol><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> note </tag>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java核心技术——卷1</title>
      <link href="/2022/06/28/cs-languages/core-java-volume-0/"/>
      <url>/2022/06/28/cs-languages/core-java-volume-0/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA核心技术——卷1"><a href="#JAVA核心技术——卷1" class="headerlink" title="JAVA核心技术——卷1"></a>JAVA核心技术——卷1</h1><blockquote><p>说明：java核心技术 —— 卷Ⅰ</p><p>当然这本书很厚，讲解的也很详细。所有呢，我没有准备将所有的知识点在我的这份文章中书写记录，在这里只记录部分我觉得需要备忘的知识。</p><p><a href="https://github.com/RobertSunq/data/tree/master/qing/blog/hexo/corejava/book/api">书中涉及到的java基础类和接口的解析链接</a></p><p><a href="https://github.com/RobertSunq/data/tree/master/qing/blog/hexo/corejava/book/code">书中涉及到的示例代码链接</a> 拷贝自 <a href="http://horstmann.com/corejava">http://horstmann.com/corejava</a></p></blockquote><h2 id="Java程序设置环境"><a href="#Java程序设置环境" class="headerlink" title="Java程序设置环境"></a>Java程序设置环境</h2><h3 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h3><blockquote><p><a href="https://www.oracle.com/java/technologies/downloads/">download-link</a></p><p>以下以 <code>jdk_path</code> 代表 <code>java</code> 安装目录</p></blockquote><table><thead><tr><th>术语</th><th>缩写</th><th>解释</th></tr></thead><tbody><tr><td>Java Development Kit (Java开发工具包)</td><td>JDK</td><td>编写Java程序的程序员使用的软件</td></tr><tr><td>Java Runtime Enviroment (Java运行时环境)</td><td>JRE</td><td>运行Java程序的用户使用的软件</td></tr><tr><td>Server JRE (服务器JRE)</td><td>——</td><td>在服务器上运行Java程序的软件</td></tr><tr><td>Standard Edition (标准版)</td><td>SE</td><td>用于桌面或简单服务器应用的Java平台</td></tr><tr><td>Enterprise Edition (企业版)</td><td>EE</td><td>用于复杂服务器应用的Java平台</td></tr><tr><td>Micro Edition (微型版)</td><td>ME</td><td>用于小型设备的Java平台</td></tr><tr><td>Java FX</td><td>——</td><td>用于图形化用户界面的一个备选工具包，在Java 11之前的某些Java SE发布版本中提供</td></tr><tr><td>OpenJDK</td><td>——</td><td>Java SE的一个免费开源实现</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="设置JDK"><a href="#设置JDK" class="headerlink" title="设置JDK"></a>设置JDK</h3><h4 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a>安装目录</h4><ul><li><p>在Windows中，设置自定义的安装目录，配置好环境变量即可。(最好路径中不要存在空格和中文)</p><ul><li>环境变量的配置略</li></ul></li><li><p>在Mac中，运行安装程序。会把软件安装到 <code>/Library/Java/JavaVirtualMachines/jdk-11.0.x.jdk/Contents/Home</code>。 通过 <code>which java</code> 查找</p></li><li><p>在Linux中</p><ul><li>使用 <code>.tar.gz</code>文件解压到选择的目录即可。 eg. <code>/opt</code></li><li>使用 <code>RPM</code> 文件安装， 需要检查是否安装在  <code>/usr/java/jdk-11.0.x</code> 目录</li><li>环境变量的配置：在 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code> 文件的最后一行添加 export <code>PATH=/usr/java/jdk-11.0.x/bin:$PATH</code></li></ul></li></ul><h4 id="安装库源文件和文档"><a href="#安装库源文件和文档" class="headerlink" title="安装库源文件和文档"></a>安装库源文件和文档</h4><p><strong>库源文件</strong></p><ol><li><p>确保JDK已经安装，而且<code>jdk_path/bin</code> 目录在可执行路径中</p></li><li><p>在主目录(<code>jdk_path</code>)中建立一个目录 <code>javasrc</code> 。 </p></li><li><p>将 <code>jdk_path/lib/zip</code> 解压到 <code>javasrc</code> 目录中 </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> jdk_path<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> javasrc<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> javasrc<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ jar xvf jdk_path/lib/zip<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> <span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p>src.zip 文件中包含了所有公共类库的源代码。获取更多的源代码（编译器、虚拟机、原生方法、私有辅助类）, 访问 <a href="https://openjdk.org/">https://openjdk.org/</a></p></blockquote><p> <strong>文档</strong> </p><ol><li>文档包含在一个压缩文件中，独立于JDK，可以直接从 <a href="https://www.oracle.com/java/technologies/downloads">https://www.oracle.com/java/technologies/downloads</a> 中下载对应版本的文档</li><li>解压压缩包并重命名</li><li>在浏览器中导航到 jdk_path/javadoc/index.html</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> jdk_path<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ jar xvf jdk-11.0.15.1_doc-all.zip<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mv</span> docs javadoc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="运行一个程序"><a href="#运行一个程序" class="headerlink" title="运行一个程序"></a>运行一个程序</h3><ol><li>编写如下 Welcome.java 文件</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">book<span class="token punctuation">.</span>v1ch02</span><span class="token punctuation">;</span><span class="token comment">/** * @author: Robert Sunq * @date: 2022-06-29 0:03 * @since: JDK-11 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Welcome</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> greeting <span class="token operator">=</span> <span class="token string">"Welcome to Core Java!"</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> greeting<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>shell 中键入 <code>javac .\book\v1ch02\Welcome.java</code> <ol><li>如果你的代码中没有添加 <code>package</code> 则去掉命令中的路径，并在文件所在的目录下运行该命令</li><li>注意需要包含文件类型<code>.java</code></li></ol></li><li>键入  <code> java book.v1ch02.Welcome</code>  <ol><li>如果你的代码中没有添加 <code>package</code> 则不需要键入全路径来运行程序</li><li>出现错误<code>java.lang.ClassNotFoundException: ImageViewer</code> 则有可能是时引入<code>package</code>的原因，导致找不到 <code>.class</code> 文件来运行</li><li>注意 不要包含编译后的文件名 <code>.class</code></li></ol></li></ol><h3 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h3><p>Java 9引入了另一种使用Java的方法。<strong>JShell</strong>程序提供一个“读取-计算-打印循环”（Read-Evaluate-Print Loop, REPL）。键入一个Java表达式；JShell会自动评估输入，打印结果，等待下一个输入。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 键入在配置后java的全局环境后，键入 jshell 进入，之后会显示问候符</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ jshell<span class="token operator">|</span>  欢迎使用 JShell -- 版本 <span class="token number">11.0</span>.15.1<span class="token operator">|</span>  要大致了解该版本, 请键入: /help intro<span class="token comment"># 键入表达式，将还会输入结果，即使没有键入 System.out.println</span>jshell<span class="token operator">&gt;</span> <span class="token string">"core java"</span>.length<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token variable">$1</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">9</span><span class="token comment"># 之后可使用输出的变量名 $1 来使用于之后的计算</span>jshell<span class="token operator">&gt;</span> <span class="token number">5</span> * <span class="token variable">$1</span> - <span class="token number">3</span><span class="token variable">$2</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">42</span><span class="token comment"># 当然也可以自定义变量</span>jshell<span class="token operator">&gt;</span> int a <span class="token operator">=</span> <span class="token number">4</span>a <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">4</span>jshell<span class="token operator">&gt;</span> aa <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">4</span><span class="token comment"># 键入部分名称后，可与使用  `tab` 来进行补全</span>jshell<span class="token operator">&gt;</span> MathMath          MathContext签名:java.lang.Math<span class="token operator">&lt;</span>再次按 Tab 可查看文档<span class="token operator">&gt;</span>jshell<span class="token operator">&gt;</span> Math.E                 IEEEremainder<span class="token punctuation">(</span>    PI                abs<span class="token punctuation">(</span>              acos<span class="token punctuation">(</span>             addExact<span class="token punctuation">(</span>         asin<span class="token punctuation">(</span>             atan<span class="token punctuation">(</span>             atan2<span class="token punctuation">(</span>            cbrt<span class="token punctuation">(</span>             ceil<span class="token punctuation">(</span>             classcopySign<span class="token punctuation">(</span>         cos<span class="token punctuation">(</span>              cosh<span class="token punctuation">(</span>             decrementExact<span class="token punctuation">(</span>   exp<span class="token punctuation">(</span>              expm1<span class="token punctuation">(</span>            floor<span class="token punctuation">(</span>            floorDiv<span class="token punctuation">(</span>         floorMod<span class="token punctuation">(</span>         fma<span class="token punctuation">(</span>              getExponent<span class="token punctuation">(</span>      hypot<span class="token punctuation">(</span>incrementExact<span class="token punctuation">(</span>   log<span class="token punctuation">(</span>              log10<span class="token punctuation">(</span>            log1p<span class="token punctuation">(</span>            max<span class="token punctuation">(</span>              min<span class="token punctuation">(</span>              multiplyExact<span class="token punctuation">(</span>    multiplyFull<span class="token punctuation">(</span>     multiplyHigh<span class="token punctuation">(</span>     negateExact<span class="token punctuation">(</span>      nextAfter<span class="token punctuation">(</span>        nextDown<span class="token punctuation">(</span>nextUp<span class="token punctuation">(</span>           pow<span class="token punctuation">(</span>              random<span class="token punctuation">(</span><span class="token punctuation">)</span>          rint<span class="token punctuation">(</span>             round<span class="token punctuation">(</span>            scalb<span class="token punctuation">(</span>            signum<span class="token punctuation">(</span>           sin<span class="token punctuation">(</span>              sinh<span class="token punctuation">(</span>             sqrt<span class="token punctuation">(</span>             subtractExact<span class="token punctuation">(</span>    tan<span class="token punctuation">(</span>tanh<span class="token punctuation">(</span>             toDegrees<span class="token punctuation">(</span>        toIntExact<span class="token punctuation">(</span>       toRadians<span class="token punctuation">(</span>        ulp<span class="token punctuation">(</span>jshell<span class="token operator">&gt;</span> Math.llog<span class="token punctuation">(</span>     log10<span class="token punctuation">(</span>   log1p<span class="token punctuation">(</span><span class="token comment"># 当然和常用的 shell 窗口一样 可与使用方向键来调整光标和查看历史命令</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Java的基本程序设计结构"><a href="#Java的基本程序设计结构" class="headerlink" title="Java的基本程序设计结构"></a>Java的基本程序设计结构</h2><h3 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h3><ul><li><strong>Java中区分大小写</strong></li><li>类的命名请遵循 <strong>驼峰法</strong></li><li>java虚拟机总是从 <strong>main</strong> 方法的代码作为类的执行入口</li><li>java中的注释有两种形式 <code>\\</code> 和 <code>\*  *\</code></li><li>Java 时一种 <strong>强类型语言</strong>，所以必须为每个变量声明一种类型</li></ul><h4 id="类型说明"><a href="#类型说明" class="headerlink" title="类型说明"></a>类型说明</h4><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th><th>包装类型</th></tr></thead><tbody><tr><td><code>int</code></td><td>4(字节)</td><td>-2147483648 — 2147483647</td><td><code>Integer</code></td></tr><tr><td><code>short</code></td><td>2</td><td>-32768 — 32767</td><td><code>Short</code></td></tr><tr><td><code>long</code></td><td>8</td><td>-9223372036854775808 — 9223372036854775807</td><td><code>Long</code></td></tr><tr><td><code>byte</code></td><td>1</td><td>-128 — 127</td><td><code>Byte</code></td></tr><tr><td><code>float</code></td><td>4</td><td>+- 3.40282347E+23F(有效位数 6~7 位)</td><td><code>Float</code></td></tr><tr><td><code>double</code></td><td>8</td><td>+- 1.79769313486231570E+308(有效位数 15位)</td><td><code>Double</code></td></tr><tr><td><code>char</code></td><td>1</td><td></td><td><code>Char</code></td></tr><tr><td><code>boolean</code></td><td>1</td><td><code>false</code>  <code>true</code></td><td><code>Boolean</code></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li><p><strong><code>String</code></strong></p><ul><li>字符串，使用<code> ""</code> 包含起来的字符。 </li><li><strong>不可变</strong>，表示该对象中的值时不能修改的。<code>String greeting = "hello"; greeting = greeting.substring(0,3) + "p!";</code>注意这里字符串 <code>"hello"</code>是永远包含这几个代码单元序列的，并不能修改。第二步中只是使 <code>greeting </code> 引用向了另一个字符串而已。如同原本存放<code>3</code>数值变量的地方存放上了<code>4</code>.</li><li>不可变字符串的优点：<strong>编译器可以让字符串共享</strong>，字符串存放在公共的存储池中。</li><li>注意检测相等时用 :  <code>s.equals(t)</code> 比较字符串字面量上的相等； 如果使用 <code>==</code> 运算符则会检测两个字符串是否存放再同一个位置上，即是否引用向同一个内存地址，如果两个字符串再同一个位置必然相等，但是也有可能将内容相等的多个字符串副本放置到不同的位置上，所以<strong>千万不要</strong>使用 <code>== </code>来测试字符串的相等。</li></ul></li><li><p><code>Long</code></p><ul><li>长整型数值有一个后缀<code>L</code>或<code>l</code>（<code>40000000L</code>）。</li><li>十六进制数值有一个前缀<code>0x</code>或<code>0X</code>（<code>0xFFE</code>）。</li><li>八进制数值有一个前缀<code>0</code>（<code>010</code>）。</li><li>二进制数值有一个前缀<code>0b</code>或<code>0B</code>（<code>0b1001</code>）。Java7之后</li><li>还可以在数字字面量加下划线，<code>1_000_000</code>(或 `0b1111_0100_0010_0100_0000)表示100万。当然Java编译器在编译后会去除这些下划线。</li><li>注意：Java 没有任何无符号（<code>unsigned</code>）形式的<code>int long short byte</code>类型。</li></ul></li><li><p><code>Double</code>和<code>Float</code></p><ul><li><code>float</code>类型的数值只有一个后缀<code>F</code>或<code>f</code>（<code>3.14</code>）。通常都是使用<strong>双精度数值</strong><code>double</code>类型。只有少数情况会使用<code>float</code>，比如：需要<strong>单精度</strong>的库或者大量存储数据。</li><li>没有后缀的浮点数值（3.14）默认为<code>double</code>类型。当然也可以添加后缀<code>D</code>或<code>d</code>（<code>3.14D</code>）</li><li>也可以使用十六进制表示浮点数。<code>0.125 = 0x1.0p-3</code>，在十六进制表示中 <code>p</code>表示指数，而不是<code>e</code>。注意，尾数采用十六进制，指数采用十进制。指数的基数是<code>2</code>，而不是<code>10</code>。</li></ul></li><li><p><code>Unicode</code>和<code>Char</code></p><ul><li><code>... ...</code></li></ul></li></ul><h4 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h4><ol><li><p>变量</p><ul><li><p>声明与定义</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">double</span> salary<span class="token punctuation">;</span><span class="token keyword">int</span> vacationDays<span class="token punctuation">;</span>vacationDays <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>从 <code>Java 10 </code>开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不需要在声明类型了，只需要使用关键字 <code>var</code> 而无需指定类型</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> vacationDays <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span><span class="token keyword">var</span> greeting <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li><p>常量</p><ul><li>使用关键字 <code>final</code>来指示常量。</li><li>关键字 <code>final</code>表示这个变量只能被赋值一次。</li><li>使用关键字 <code>static final</code>设置一个<strong>类常量</strong>，可以在一个类的多个方法中使用。如果被声明为 <code>public</code> 那么其他类也可以使用这个常量。</li></ul></li><li><p>枚举</p><ul><li><p>自定义<strong>枚举类型</strong>。<strong>枚举类型</strong>包括<strong>有限</strong>个命名的值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">enum</span> <span class="token class-name">Size</span> <span class="token punctuation">{</span>SMALL<span class="token punctuation">,</span> MEDIUM<span class="token punctuation">,</span> LARGE<span class="token punctuation">,</span> EXTRA_LARGE<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Size</span> s <span class="token operator">=</span> <span class="token class-name">Size</span><span class="token punctuation">.</span>MEDIUM<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><code>+</code> 加 、<code>-</code> 减、 <code>*</code> 乘、 <code>%</code>  取余</li><li><code>/</code> 除<ul><li>使用关键字 <code>strictfp</code> 修饰类或者方法，表示类或者方法中将采用<strong>严格的浮点运算</strong>，即所有中的中间计算都进行截断为64位计算。<code>double x * y / z;</code> <code>x*y</code>将计算结果截取保存在64位寄存器中， 之后在除以<code>z</code> 将计算结果截取保存到64位寄存器中</li></ul></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><code>int n = 123456; long m = n;</code></p><img src="/2022/06/28/cs-languages/core-java-volume-0/convert.png" class="" title="类型转换"><p><strong>强制类型转换</strong></p><p>符合上图的类型转换会走到那个进行转换，如果进行反方向的就需要进行<strong>强制类型转换</strong>（cast）来完成，当然会有可能损失信息。</p><p><code>double x = 9.997; int nx = (int) x; // nx = 9</code></p><h4 id="关系比较符"><a href="#关系比较符" class="headerlink" title="关系比较符"></a>关系比较符</h4><p><code>&lt;</code> 、<code>&gt;</code>、<code>=</code>、<code>&lt;=</code>、<code>&gt;=</code></p><h4 id="逻辑比较符"><a href="#逻辑比较符" class="headerlink" title="逻辑比较符"></a>逻辑比较符</h4><p><code>&amp;&amp;</code>、<code>||</code>、<code>!</code></p><p>三元表达试： <code>condition ? expression1 : expression2</code></p><p>注意：在逻辑运算中，是按照<strong>短路</strong>方式来求值的。</p><ul><li><code>2 != 1 &amp;&amp; 3 != 2</code> 第一个表达式已经是<code> false</code>时 不会再计算第二个表达式</li><li><code>1 == 1 || 3 != 2</code> 第一个表达式已经是<code> true</code>时 不会再计算第二个表达式</li></ul><p><strong>位运算符</strong></p><p>处理整型类型时，可以直接对成组整数的各个位完成操作。可以使用掩码技术得到整数中的各个位。</p><p><code>&amp;</code> 与、<code>|</code> 或、<code>^</code> 同或 、<code>~</code> 按位取反、</p><p><code>&gt;&gt;</code> 右移，包含移动符号位，使用符号位填充高位</p><p><code>&lt;&lt;</code>左移，低位补 0</p><p><code>&gt;&gt;&gt;</code>无符号右移，高位填充 0</p><h4 id="联机文档"><a href="#联机文档" class="headerlink" title="联机文档"></a>联机文档</h4><blockquote><p>link : <a href="https://docs.oracle.com/en/java/javase/11/docs/api/index.html">https://docs.oracle.com/en/java/javase/11/docs/api/index.html</a></p></blockquote><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>读取“标准输入流” <code>System.in</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InputTest</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * @see book.api.ScannerApi     * @see book.api.SystemApi     * @see book.api.ConsoleApi     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 读取下一行，以回车作为分隔符，中断读入 (输入行中包括空格，也不会中断读入)</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你的名字是: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> name <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 读取一个单词， 空白符作为分隔符，中断读入</span>        <span class="token comment">//  String next = scanner.next();</span>        <span class="token comment">// 读取一个整数</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你多大了: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> age <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你好， "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">". 明年，你将 "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>age <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Java6 之后引入 console 从控制台读取隐形的密码输入。 IDEA 运行 System.console() 返回null时 用命令 javac 编译后  命令java 运行</span><span class="token comment">//        Console console = System.console();</span><span class="token comment">//        String username = console.readLine("用户名： ");</span><span class="token comment">//        char[] passwd = console.readPassword("密码: ");</span><span class="token comment">//        System.out.println("username : " + username + "密码 : "+ String.valueOf(passwd));</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><ul><li><code>System.out.println(x)</code><ul><li>将数值 <code>x</code>输出到控制台</li></ul></li><li><code>System.out.println(“Hello, %s. Next year, you'll be %d", name, age)</code><ul><li>以 <code>%</code> 字符开始的 **格式说明符 **都用后面相应的参数替换</li></ul></li></ul><p><strong>用于<code>printf</code>转换符</strong></p><table><thead><tr><th>转换符</th><th>类型</th><th>示例</th></tr></thead><tbody><tr><td><code>d</code></td><td>十进制整数</td><td>100</td></tr><tr><td><code>x</code></td><td>十六进制整数</td><td>9f</td></tr><tr><td><code>o</code></td><td>八进制整数</td><td>200</td></tr><tr><td><code>f</code></td><td>定点浮点数</td><td>10.9</td></tr><tr><td><code>e</code></td><td>指数浮点数</td><td>1.59e+01</td></tr><tr><td><code>g</code></td><td>通用浮点数(<code>e </code>和<code>f</code>中较短的一个)</td><td>—–</td></tr><tr><td><code>a</code></td><td>十六进制浮点数</td><td>0x1.fccdp3</td></tr><tr><td><code>s</code></td><td>字符串</td><td>Hello</td></tr><tr><td><code>c</code></td><td>字符</td><td>H</td></tr><tr><td><code>b</code></td><td>布尔</td><td><code>true</code></td></tr><tr><td><code>h</code></td><td>散列码</td><td>43423</td></tr><tr><td><code>%</code></td><td>百分号</td><td>%</td></tr><tr><td><code>n</code></td><td>行分隔符</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><strong>用于<code>printf</code>的标志</strong></p><table><thead><tr><th>转换符</th><th>类型</th><th>示例</th></tr></thead><tbody><tr><td><code>+</code></td><td>打印正数和负数的符号</td><td>+2333.333</td></tr><tr><td><code>空格</code></td><td>在正数之前添加空格</td><td>|  2333.33|</td></tr><tr><td><code>0</code></td><td>数字前面补 0</td><td>002333.33</td></tr><tr><td><code>-</code></td><td>左对齐</td><td>|233.33  |</td></tr><tr><td><code>(</code></td><td>将负号括在括号内</td><td>(2333.33)</td></tr><tr><td><code>,</code></td><td>添加分组分隔符</td><td>2,333,33</td></tr><tr><td><code>#</code>(对于 <code>f</code> 格式)</td><td>包含小数点</td><td>3,333.</td></tr><tr><td><code>#</code>(对于 <code>x</code> 或 <code>0</code> 格式)</td><td>添加前缀 <code>0x</code> 或 <code>0</code></td><td>0xcafc</td></tr><tr><td><code>$</code></td><td>指定要格式化的参数索引。<br>eg. <code>%1$d %1$x</code>将以十进制和十六进制格式打印第一个参数<br><strong>注意 参数索引从 <code>1</code> 开始而不是 <code>0</code></strong></td><td>159 9F</td></tr><tr><td><code>&lt;</code></td><td>格式化前面加说明的数值。<br>eg. <code>%d%&lt;x</code>将以十进制和十六进制格式打印同一个数值</td><td>159 9F</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><blockquote><p>可以使用 <code>s</code> 转换符格式化任意的对象。对于实现了 <code>formattable</code> 接口的任意对象，将调用这个对象的 <code>formatTo</code> 方法；否则将对这个对象转换位字符串。即调用 <code>toString</code>方法。</p></blockquote><ul><li>对于上述的格式化字符串，也可以使用静态的 <code>String.format</code> 方法创建一个格式化的字符串</li></ul><p><strong>日期和时间的转换符</strong></p><p><code>printf</code>中的日期和时间格式化选项，已经过时，所以暂时不总结。替换方案 <code>java.time</code></p><table><thead><tr><th>转换符</th><th>类型</th><th>示例</th></tr></thead><tbody><tr><td><code>tx</code> 或 <code>tx</code></td><td>时间日期(<code>T</code>强制大写)</td><td>—-</td></tr><tr><td><code>tc</code></td><td>完整的日期和时间</td><td>周五 7月 15 00:15:46 CST 2022</td></tr><tr><td>—-</td><td>—-</td><td>—-</td></tr></tbody></table><img src="/2022/06/28/cs-languages/core-java-volume-0/printf_format.png" class="" title="格式化输出"><h4 id="文件输入和输出"><a href="#文件输入和输出" class="headerlink" title="文件输入和输出"></a>文件输入和输出</h4><p>读取文件，也是构造一个<code>Scanner</code>对象，如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Scanner</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">Path</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"myfile.txt"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 如果文件名中包含反斜杠符号，需要使用双反斜杠："c:\\mydirectory\\myfile.txt"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出文件，需要构造一个<code>PrintWriter</code>对象，在构造器中需要提供文件名和字符编码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token string">"myfile.txt"</span><span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>当指定一个相对文件名时，eg. “dir/myfile.txt” or “../myfile.txt”，文件位置时相对于<strong>Java</strong></p><p><strong>虚拟机</strong>启动目录的位置。</p><p>如果在命令行方式下执行 <code>java MyProg</code> 启动目录就是命令解释器的房前目录。</p><p>如果是集成开发环境，那么启动目录由IDE控制，使用 <code>String dir = System.getProperty("user.dir");</code>获取到调用的目录。</p><p>当然也可以使用据对路径。</p></blockquote><h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><h4 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/* 块作用域 */</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> k<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment">// k 的作用域只在 块作用域内</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/* 条件语句 */</span>    <span class="token comment">// if (confition) statement</span>    <span class="token comment">// if (confition) statement_1 else statement_2</span>    <span class="token comment">// if (confition_1) statement_1 else if (confition_2) statement_2 else confition_3</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>yourSales <span class="token operator">&gt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1</span>    <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>yourSales <span class="token operator">&gt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// 2</span>    <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>yourSales <span class="token operator">&gt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>yourSales1 <span class="token operator">&gt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 2</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// 3</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/* 循环 */</span>    <span class="token comment">// while (condition) statement</span>    <span class="token comment">// do statement while (confition)</span><span class="token keyword">while</span> <span class="token punctuation">(</span>balance <span class="token operator">&lt;</span> goal<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1</span>    <span class="token punctuation">}</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token comment">// 2</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>balance <span class="token operator">&lt;</span> goal<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="确定循环"><a href="#确定循环" class="headerlink" title="确定循环"></a>确定循环</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">/* 确定循环 */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// i</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/* 多重循环：switch 语句 */</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>choice<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> case 的标签可以是： </p><ul><li>char、byte、short、int的常量表达式；</li><li>枚举常量 <ul><li>可以不必再每个标签中指明枚举名，可以由switch表达式推导出来</li></ul></li><li>字符串字面量</li></ul><blockquote><p>警告：在<code>switch</code>结构中，如果条件可能触发多个<code>case</code>分支，如果在<code>case</code>分支语句的末尾没有<code>break</code>语句，那么就会接着执行下一个<code>case</code>分支语句。这种方式会引发错误。</p><p>如果使用了 <code>switch</code> 语句，在编译代码时可以考虑加上 <code>-Xlint:fallthrough</code> 选项，eg. <code>javac -Xlint:fallthrough Test.java</code>，这样如果某个分支最后缺少一个 <code>break</code> 语句，编译器就会给出一个警告信息。</p><p>如果正好想要使用这种 “直通式” 行为，可以在外围方法上加上一个注解 <code>@SuppressWarnings("fallthrough") </code>，这样就不会针对这个方法产生告警了。</p></blockquote><h4 id="中断控制流程的语句"><a href="#中断控制流程的语句" class="headerlink" title="中断控制流程的语句"></a>中断控制流程的语句</h4><ul><li><code>break</code>：用于退出循环和判断</li><li><code>continue</code>： 将控制转移到最内存循环的首部，即跳出当前循环体的剩余部分，立刻跳转到循环的首部。</li></ul><p>同时，Java 也提供了一种带**标签的<code>break</code>**，用于跳出多重嵌套的循环语句。有时候，在嵌套很深的循环语句中会发生一些不可预料的事情。此时可能更加希望完全跳出所有的嵌套循环之外。</p><p>下面有个示例说明<code>break</code>语句的工作状态。注意：标签必须放在希望跳出的最外层循环之前，并且必须紧跟着一个冒号。</p><blockquote><p>执行带标签的<code>break</code> 会跳转到带标签的语句块的末尾。</p><p>同样在<code>if</code>语句中也可以使用该方式跳出语句块。</p><p>同样也可以用带标签的<code>continue</code>，将跳到与标签匹配的循环首部。</p><p>注意：这里只能跳出语句块，不能跳入语句块。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Scanner</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token comment">// 注意该标签</span>read_data<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 这个循环代码块中由标签标记</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 这个内循环中没有被标记</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" 输入数字 &gt;= 0:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        n <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> n <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span> read_data<span class="token punctuation">;</span>            <span class="token comment">// 中断该标签的循环</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 此语句在标记的break之后立即执行</span><span class="token keyword">if</span> <span class="token punctuation">(</span> n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 检查错误情况</span>    <span class="token comment">// 处理错误情况</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment">// 进行正常处理</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h3><p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用<code>java.math</code>包中的两个类：<code>BigInteger</code> 和 <code>BigDecimal</code>。这两个类可以处理包含任意长度数字序列的数值。</p><p>在使用大数类之后，就不能使用常用的算数运算符(eg. <code>+</code> 和 <code>*</code>)处理大数，而需要使用大数类中的 <code>add</code> 和 <code>multiply</code> 方法</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>存储相同类型值的序列</p></blockquote><h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h4><p>一种数据结构，用来存储同一类型值的集合，通过一个整数下标(<code>index</code>，或称索引)可以访问数组中的每一个值。</p><p>在声明数组变量时，需要指出数组类型（数组元素类型紧跟 <code>[]</code>）和数组变量的名字。</p><blockquote><p>注意：一旦创建了数组，就不能再改变它的长度。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 声明整型数组 a  并未创建</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span><span class="token comment">// or int a[];</span><span class="token comment">// 声明整型数组 a 并创建数组</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 声明并初始化，这个语法中不需要使用 new。 最后一个值后面允许使用逗号</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> small <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 也可以使用 使用 new 初始化</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> anonymous <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// java 中 允许创建有长度为 0 的数组</span><span class="token keyword">new</span> elementType<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h4><p>使用数组下标访问数组 <code>a[n]</code></p><p>在创建：</p><ul><li>数字数组，所有元素都初始化为 <code>0 </code></li><li><code>boolean</code> 数组， 所有元素都初始化 <code>false</code></li><li>对象数组，所有元素都初始化为 <code>null</code></li></ul><h4 id="for-each-循环"><a href="#for-each-循环" class="headerlink" title="for each 循环"></a><code>for each</code> 循环</h4><p><code>java</code> 中也可以使用语法糖来遍历数组中的每个元素</p><p><code>for (variable : collection) statement</code></p><p>当然<code>collection</code> 这以及和表达式必须是一个数组或者是一个实现了 <code>Iterable</code> 接口的类对象(eg. <code>ArrayList</code>)</p><blockquote><p><code>for each</code>循环语句的驯化变量将会遍历数组中的每个元素，而不是下标值。</p></blockquote><h4 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 允许将一个数组变量拷贝到另一个数组变量中，这时，</span><span class="token comment">// 两个变量将引用同一个数组， 因为这里是指向同一块内存空间。</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> smallPrimes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> luckyNumers <span class="token operator">=</span> smallPrimes<span class="token punctuation">;</span><span class="token comment">// 如果希望将一个数组的所有值拷贝到一个新的的胡祖中，要使用 Arrays 类的 copyOf 方法</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> copiedLuckyNumbers <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>luckyNumbers<span class="token punctuation">,</span> luckyNumbers<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 也可以使用这种方法来增大数组的大小</span>luckyNumbers <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>luckyNumbers<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> luckyNumbers<span class="token punctuation">.</span>length<span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><blockquote><p>每一个 <code>Java</code> 应用程序都有一个带 <code>String arg[]</code> 参数的 <code>main</code> 方法。 这个参数表明 <code>mian</code> 方法将接收一个字符串数组，也就是命令行上指定的参数。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Message</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"-h"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello,"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"-g"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Goodbye,"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" "</span> <span class="token operator">+</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果使用下面的形式调用这个程序</p><p><code>java Message -g cruel world</code></p><p><code>args</code> 数组将包含以下内容 ：<code>args[0] = "-g", args[0] = "cruel", args[0] = "world"</code></p><p>这个程序会显示下面的消息：</p><p><code>Goodbye, cruel world!</code></p><blockquote><p>再 <code>Java</code> 应用程序的<code>main</code>方法中，程序名并没有存储再 <code>args</code> 数组中。例如，当从命令行使用下面的命令运行程序时 ： <code>java Message -h world</code>  <code>args[0]</code> 是 <code>"-h"</code>, 而不是 <code>Message</code> 或 <code>java</code></p></blockquote><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><p>相对数值类型数组进行排序，可以使用 <code>Arrays</code> 类中的 <code>sort</code> 方法： <code>Arrays.sort(new int[1000]{...})</code> 这个方法使用了<strong>优化的快速排序</strong>(QuickSort)算法</p><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> magicSquare <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>for each</code> 循环语句不能自动处理二维数组的每一个元素。它会循环处理行，而这些行本身是一个一维数组。访问所有元素，需要使用两个嵌套的循环：</p><p>for (double[] row : a)</p><p>​for (double value : row)</p><p>​do something with value</p></blockquote><blockquote><p>想要快速打印一个二维数组的数据元素列表，可以调用 <code>System.out.println(Arrays.deepToString(a));</code></p></blockquote><h4 id="不规则数组"><a href="#不规则数组" class="headerlink" title="不规则数组"></a>不规则数组</h4><p><strong><code>Java</code>实际上没有多维数组</strong>，只有一维数组，多维数组又被解释为”数组的数组“</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> odds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>N_MAX <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;=</span> N_MAX<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    odds<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 生成一个三角形数据结构</span><span class="token comment">// 0</span><span class="token comment">// 0 0</span><span class="token comment">// 0 0 0</span><span class="token comment">// 0 0 0 0</span><span class="token comment">// 0 0 0 0 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h2><img src="/2022/06/28/cs-languages/core-java-volume-0/opp.png" class="" title="面向对象"><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><strong>类</strong><ul><li>构造对象的模板或蓝图</li><li>由类<strong>构造</strong>对象的过程称之为创建类的<strong>实例</strong></li></ul></li><li><strong>封装</strong><ul><li>处理对象的一个重要改变，将数据和行为组合在一个包中。</li><li>对象中的数据称为<strong>实例字段</strong>，操作数据的过程称为<strong>方法</strong>。</li></ul></li></ul><h3 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h3><ul><li><p><strong>结构示意</strong></p><blockquote><p>在一个源文件中，只能由一个公共类，但可以由任意数目的非公共类。 </p></blockquote><ul><li>构造器与类名相同</li><li>每个类可以由一个及以上的构造器</li><li>构造器可以由0个，1个或多个参数</li><li>构造器没有返回值</li><li>构造器总是伴随着<code>new</code>操作符调用</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ClassName</span> <span class="token punctuation">{</span>    field1<span class="token punctuation">;</span>    field2<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>        constructor1<span class="token punctuation">;</span>    contructor2<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>        method1<span class="token punctuation">;</span>    method2<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="var关键词"><a href="#var关键词" class="headerlink" title="var关键词"></a><code>var</code>关键词</h4><p>Java 10 之后，如果可以从变量的初始值推导出它们的类型，那么可以用 <code>var</code> 关键字声明<strong>局部变量</strong>，而无须指定类型。注意：<code>var</code> 关键字只能用于方法中的<strong>局部变量</strong>。参数和字段的类型必须声明。</p><h4 id="null引用"><a href="#null引用" class="headerlink" title="null引用"></a><code>null</code>引用</h4><p>如果对<code>null</code>值应用一个方法，会产生一个 <code>NullPointerException</code>异常。</p><p>在 <code>Java 9</code>中，Object类提供了一个判断<code>null</code>的方法：</p><ul><li><p>“宽容型”处理<code>null</code>参数，将其转为一个默认值</p><p><code>String name = Objects.requireNonNullElse(n, "defuale");</code></p></li><li><p>“严格型”直接拒绝<code>null</code>参数</p><p><code>Objects.requireNonNull(n, "The name cannot be null");</code></p><p>会产生一个 <code>NullPointerException</code>异常</p></li></ul><h4 id="基于类的访问权限"><a href="#基于类的访问权限" class="headerlink" title="基于类的访问权限"></a>基于类的访问权限</h4><p>一个方法可以访问<strong>所属类的所有对象</strong>的私有数据。</p><h4 id="final实例字段"><a href="#final实例字段" class="headerlink" title="final实例字段"></a>final实例字段</h4><ul><li>修饰实例字段<ul><li>这样的字段必须在构造对象时初始化，在设置之后，就不能再进行修改。但是如果修饰是一个对象变量，对对象的引用不可以修改，不过这个对象的属性可以更改。</li></ul></li></ul><h3 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h3><ul><li><p>静态变量</p><ul><li>使用<code>static</code>修饰实例字段，这个类所有的实例将共享这个字段，如果被一个实例修改，其他所有实例获取到的也是修改的值。</li></ul></li><li><p>静态常量</p><ul><li>使用<code>static final</code>，类的所有实例共享且不允许被修改。</li></ul></li><li><p>静态方法</p><ul><li>使用<code>static</code>修改方法，只能访问类的静态字段，不能访问类的其他非静态属性</li><li>所需要的参数都需要显式的提供</li></ul></li><li><p>工厂方法</p><ul><li><p>使用静态<strong>工厂方法</strong>来构造对象，代理使用构造方法。例如 ： <code>LocalDate.now</code> 、<code>LocalDate.of</code> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">NumberFormat</span> currencyFormatter <span class="token operator">=</span> <span class="token class-name">NumberFormat</span><span class="token punctuation">.</span><span class="token function">getCurrencyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">NumberFormat</span> percentFormatter <span class="token operator">=</span> <span class="token class-name">NumberFormat</span><span class="token punctuation">.</span><span class="token function">getPercentInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 为什么不使用 NumberFormat 的构造器方法去创建实例呢？这样使用的原因如下：</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>无法命名构造器</p><ul><li>构造器的名字必须与类名相同。但是，这里希望由两个不同的名字，分别得到货币实例和百分比实例。</li></ul></li><li><p>使用构造器时，无法改变所构造对象的类型。</p><ul><li>工厂方法是实际上返回的<code>DecimalFormat</code>类的对象，这是<code>NumberFormat</code>的一个子类（继承内容后续说明）。</li></ul></li></ul></li></ul><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><blockquote><p>Java对对象采用的不是按照引用调用，实际上，<strong>对象引用是按照值传递的</strong></p><p>在传递对象类型的数据时，<strong>方法内获取的是对传递的对象引用的一个副本</strong>，而不是传递的原始对象引用。所以在方法内对这个对象引用改变为新的引用的时候，并不会影响到调用处的对象引用；方法结束后，方法内的引用副本就会被丢弃。</p></blockquote><ul><li>方法不能修改基本数据类型的参数（即数值型或布尔型）</li><li>方法可以改变对象参数的状态</li><li>方法不能让一个对象参数参数引用一个新的对象</li></ul><h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><h4 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h4><p>java中由三种初始化数据字段的方法：</p><ul><li><p>在构造器中设置值</p></li><li><p>在声明中赋值</p></li><li><p>初始化块</p><ul><li><p>在一个类的声明中，可以包含任意多个代码块。只要构造这个类的对象，这些块就会被执行。如下示例中：首先运行初始化块，然后才运行构造器的主体部分</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Employee</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> nextId<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> salary<span class="token punctuation">;</span>        <span class="token comment">// 初始化块</span>    <span class="token punctuation">{</span>        id <span class="token operator">=</span> nextId<span class="token punctuation">;</span>        nextId<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        name <span class="token operator">=</span> n<span class="token punctuation">;</span>        salary <span class="token operator">=</span> s<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        name <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        salary <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h4 id="构造器的执行步骤"><a href="#构造器的执行步骤" class="headerlink" title="构造器的执行步骤"></a>构造器的执行步骤</h4><ol><li>如果构造器的第一行调用了另一个构造器，则基于所提供得参数执行第二个构造器。</li><li>否则<ol><li>所有数据字段初始为其默认值（0，false或null）。</li><li>按照在类声明中出现的顺序，执行所有字段初始化方法和初始化块。</li></ol></li><li>执行构造器主体代码。</li></ol><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><h4 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h4><p>使用<strong>包</strong>将类组织在一个集合中，借助包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。</p><p>只用包的主要原因是确保<strong>类名的唯一性</strong>。</p><blockquote><p>在对据有包名且按照包路径放置的类进行编译或运行时，需要加上包路径（完全限定名），例如：</p><p>javac cn/qing/PayrollApp.java</p><p>java cn.qing.PayrollApp</p></blockquote><h4 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h4><p>为了使类能够被多个程序共享，需要做到以下几点：</p><ol><li><p>把类文件放到一个目录中，例如 <code>/home/user/classdir</code>。 需要注意，这个目录是包树状结构的<strong>基目录</strong>。如果希望增加 <code>com.qing.corejava.Employee</code>类，那么<code>Employee.class</code>类文件就必须位于子目录 <code>/home/user/classir/com/qing/corejava</code>中。</p></li><li><p>将<code>JAR</code>文件放在一个目录中，例如：<code>/home/user/archives</code>。</p></li><li><p>设置**类路径(class path)**。类路径是所有包含类文件的路径的集合。</p><p>在UNIX环境中，类路径中的各项之间用（:）分割：</p><p><code>/home/user/classdir:.:/home/user/archives/archive.jar</code></p><p>而在Windows环境中，则以分号（;）分割：</p><p><code>c:\classdir;.;c:\archives\archive.jar</code></p><p>不论是UNIX还是Windows，都用句点（.）表示当前目录。</p><p>类路径包括：</p><ul><li>基目录 <code>/home/user/classdir</code>或<code>c:\clases</code>；</li><li>当前目录（<code>.</code>）；</li><li><code>JAR</code>文件<code>/home/user/archives/archive.jar</code>或<code>c:\archives\archive.jar</code></li></ul><p>从Java 6 开始，可以在JAR文件目录中指定通配符，如下：</p><p><code>/home/user/classdir:.:/home/user/archives/'*'</code> 或者 <code>c:\classdir;.;c:\archives\*</code></p><p>在UNIX中，<code>*</code> 必须转义以放置<code>shell</code>扩展 。</p><p>archives目录中所有JAR文件（但不包括<code>.class</code>文件）都包含在这个类路径中。</p><p>类路径所列出的目录和归档文件是搜索类的<strong>起始点</strong>。</p><h4 id="设置类路径"><a href="#设置类路径" class="headerlink" title="设置类路径"></a>设置类路径</h4><p>最好使用 <code>-classpath</code>（或 <code>-cp</code>，或者Java 9中的 <code>--class-path</code>）选择指定类路径：</p><p><code>java -classpath /home/user/classdir:.:/home/user/archives/archive.jar MyProg</code>或</p><p><code>java -classpath c:\classdir;.;c:\archives\archive.jar MyProy</code></p><p>整个指令必须写在一行中。可以将这样一个长的命令行放在一个shell脚本或一个批处理文件中。</p><p>利用<code>-classpath</code>选项设置类路径是首选的方法，也可以通过设置<code>CLASSPATH</code>环境变量来指定。具体细节依赖于所使用的shell。在Bourne Again shell(bash)中，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">CLASSPATH</span><span class="token operator">=</span>/home/user/classdir:.:/home/user/archives/archive.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在Windows中，命令如下:</p><pre class="line-numbers language-bat" data-language="bat"><code class="language-bat">set CLASSPATH=c:\classdir;.;c:\archives\archive.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>知道退出shell为止，类路径设置均有效。</p></li></ol><h3 id="JAR文件"><a href="#JAR文件" class="headerlink" title="JAR文件"></a><code>JAR</code>文件</h3><p><code>Java</code>归档(<code>JAR</code>)文件是一个压缩文件，使用了<code>ZIP</code>压缩格式，可以包含类文件，也可以包含图像和声音等其他类型文件。</p><h4 id="创建JAR文件"><a href="#创建JAR文件" class="headerlink" title="创建JAR文件"></a>创建<code>JAR</code>文件</h4><p>使用<code>jar</code>工具制作<code>JAR</code>文件（在默认的<code>JDK</code>安装中，这个工具位于<code>jdk/bin</code>目录下）。创建一个新的<code>JAR</code>文件常用命令如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">jar cvf jarFileName file1 file2 *.class <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用格式为 <code>jar options file1 file2 ...</code>   </p><p><code>options</code>具体参数说明如下</p><table><thead><tr><th>option</th><th>说明</th></tr></thead><tbody><tr><td><code>c</code></td><td>创建一个新的或者空的归档文件并加入文件。<br>如果指定的文件名是目录，<code>jar</code>程序将会对他们进行递归处理。</td></tr><tr><td><code>C</code></td><td>临时改变目录，例如：<br>    <code>jar cvf jarFileName.jar -C classes *.class</code><br>切换到<code>classes</code>子目录以便于增加类文件</td></tr><tr><td><code>e</code></td><td>在清单文件中创建一个入口点（请参看<a href="#%E5%8F%AF%E6%89%A7%E8%A1%8Cjar%E6%96%87%E4%BB%B6">可执行JAR文件</a>）</td></tr><tr><td><code>f</code></td><td>指定<code>JAR</code>文件名作为第二个命令行参数。如果没有这个参数，<code>jar</code>命令会将结果写至标准输出（在创建JAR文件时）或者从标准输出读取（在解压或者列出<code>JAR</code>文件内容时）</td></tr><tr><td><code>i</code></td><td>建立索引文件（用于加快大型归档中的查找）</td></tr><tr><td><code>m</code></td><td>将一个<font color="blue">清单文件</font>添加到一个<code>JAR</code>文件中。清单是对归档内容和来源的一个说明。每个归档有一个默认的清单文件。但是，如果想验证归档文件的内容，可以提供自己的清单文件。</td></tr><tr><td><code>M</code></td><td>不为条目创建清单文件</td></tr><tr><td><code>t</code></td><td>显示内容表</td></tr><tr><td><code>u</code></td><td>更新一个已有的<code>JAR</code>文件</td></tr><tr><td><code>v</code></td><td>生成详细的输出结果</td></tr><tr><td><code>x</code></td><td>解压文件。如果提供一个或多个文件名，之解压这些文件；否则，解压所有文件</td></tr><tr><td><code>0</code></td><td>存储，但不进行<code>ZIP</code>压缩</td></tr></tbody></table><h4 id="清单文件"><a href="#清单文件" class="headerlink" title="清单文件"></a>清单文件</h4><p>除了类文件、图像和其他资源外，每个<code>JAR</code>文件还包含一个<strong>清单文件</strong>（<code>manifest</code>），用于描述归档文件的特殊特性。</p><p>清单文件被命名为<code>MANIFEST.MF</code>，位于<code>JAR</code>的一个特殊的<code>MATE_INFO</code>子目录中，最小清单文件示例如下</p><img src="/2022/06/28/cs-languages/core-java-volume-0/MANIFEST.png" class="" title="MANIFEST"><pre class="line-numbers language-none"><code class="language-none">Manifest-Version: 1.0lines describing this archiveName: Woozle.classlines describing this fileName: com/qing/mypkg/lines describing this package<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>详细格式和信息参看： <a href="https://docs.oracle.com/javase/10/docs/specs/jar/jar.html">https://docs.oracle.com/javase/10/docs/specs/jar/jar.html</a></p></blockquote><h4 id="可执行JAR文件"><a href="#可执行JAR文件" class="headerlink" title="可执行JAR文件"></a>可执行<code>JAR</code>文件</h4><p>使用<code>jar</code>命令中的<code>e</code>选项来指定程序的<strong>入口点</strong>，即通常需要在调用<code>java</code>程序启动器时指定的类：</p><p><code>jar cvfe MyProgram.jar cn.qing.mypkg.MainApplication files to add</code></p><p>或者，可以在清单文件中指定程序的主类，例如：</p><p><code>Main-Class: cn.qing.mypkg.MainApplication</code></p><p><strong>注意，不要为主类名增加扩展名。 即 .class</strong></p><blockquote><p>清单文件的最后一行必须以换行符结束。否则，清单文件将无法被正确地读取。</p><p>常见的一个错误是创建了一个只包含Main-Class行而没有行结束符的文本文件</p></blockquote><p>之后就可以使用已下命令来快速的启动程序：</p><p><code>java -jar MyProgam.jar</code></p><h4 id="多版本JAR文件"><a href="#多版本JAR文件" class="headerlink" title="多版本JAR文件"></a>多版本<code>JAR</code>文件</h4><p>在<code>Java 9</code>之后引入**多版本<code>JAR</code>**，其中可以包含面对不同<code>Java</code>版本的类文件，用来解决一个强封装的包在不同版本的<code>Java</code>环境上的运行。</p><p>为了保证向后兼容，额外的类文件放在<code>META-INF/versions</code>目录中：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">Application.classBuidingBlocks.classUtil.classMETA-INF |- MANIFEST.MF (with line Multi-Release: true) |- versions |- 9 |  |- Application.class |  |- BuildingBlocks.class |- 10    |- BuildingBlocks.class<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Java 9</code>之后的版本就可以根据所需，从<code>version</code>中加载自己版本对应的类文件，而<code>Java 8</code>完全不知道<code>META_INF/versions</code>目录的存在，只会去加载最外层遗留的类</p><p>要增加不同版本的类文件，可以使用<code>--release</code>标志：</p><p><code>jar uf MyProgram.jar --release 9 Application.class</code></p><p>要从头构建一个多版本的<code>JAR</code>文件，就可以使用<code>-C</code>选项，对应每个版本要切换到一个不同的类文件目录：</p><p><code>jar cf MyProgram.jar -C bin/8 . --release 9 -C bin/9 Application.class</code></p><p>面向不同版本编译时，使用<code>--release</code>和<code>-d</code>来指定输出目录：</p><p><code>javac -d bin/8 --release 8 .....</code></p><p>在<code>Java 9</code> 中，<code>-d</code>选项会创建这个目录。</p><blockquote><p><code>--release</code>标志是<code>Java 9</code>之后新增的。在之前的版本中，许哟啊使用 <code>-source</code>、<code>-target</code>和<code>-boot-classpath</code>标志。</p></blockquote><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p><code>javadoc</code>工具，可以由源文件中的注释生成一个<code>HTML</code>文件。</p><p><code>java</code>中的注释分两种 <code>\\</code>和<code>\*  *\</code> 两种方式。</p><p>第二种注释中可以添加<strong>自由格式文本</strong>，自由格式文本的<strong>第一句应该是一个概要性的句子</strong>。<code>javadoc</code>工具自动会将这些句子抽取出来形成文档。同时在自由文本中，可以使用<code>HTML</code>修饰符。</p><h4 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h4><p>类注释必须放在<code>import</code>语句之后，类定义之前。</p><h4 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h4><p>每一个方法注释必须放在所描述的方法之前。除了通用标记之外，还可以使用下面的标记，还可以使用下面的标记：</p><ul><li><code>@param variable description</code></li><li><code>@return description</code></li><li><code>@throws class description</code></li></ul><h4 id="字段注释"><a href="#字段注释" class="headerlink" title="字段注释"></a>字段注释</h4><p>只需要对公共字段（通常指的是静态常量）建立稳定。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * The "Hearts" card suit */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> HEARTS <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="通用注释"><a href="#通用注释" class="headerlink" title="通用注释"></a>通用注释</h4><ul><li><p><code>@since text</code></p></li><li><p><code>@author name</code></p></li><li><p><code>@version text</code></p></li><li><p><code>@see</code>  <code>@link</code></p><p>这两个注释可以使用超链接，连接到<code>javadoc</code>文档中插入一个超链接，示例如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">\<span class="token operator">*</span><span class="token operator">*</span>    <span class="token annotation punctuation">@see</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>qing<span class="token punctuation">.</span>corejava<span class="token punctuation">.</span></span>Employee</span>#<span class="token function">raiseSalary</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> 连接到一个具体的方法上    <span class="token annotation punctuation">@see</span> <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"www.qing.cn/corejava.html"</span><span class="token class-name">The</span> <span class="token class-name">Core</span> <span class="token class-name">Java</span> home page<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">&gt;</span>     <span class="token annotation punctuation">@see</span> <span class="token string">"Core Java 2 volume 2"</span><span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> <span class="token keyword">package</span><span class="token punctuation">.</span><span class="token keyword">class</span>#feature label<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token annotation punctuation">@index</span> enrty<span class="token punctuation">}</span> java9 之后添加，标记为搜索框增加一个条目 <span class="token operator">*</span>\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="包注释"><a href="#包注释" class="headerlink" title="包注释"></a>包注释</h4><p>包注释需要在每一个包目录中添加一个单独的文件。有如下两种选择</p><ol><li>提供一个名为<code>package-info.java</code>的文件，这个文件必须包含一个初始的以<code>/**</code>和<code>*/</code>界定的注释，后面是一个<code>package</code>语句。它不能包含更多的代码和注释。</li><li>提供一个名为<code>package.html</code>的<code>HTML</code>文件。会抽取标记<code>&lt;body&gt; ... &lt;/body</code>之间的所有文本。</li></ol><h4 id="注释抽取"><a href="#注释抽取" class="headerlink" title="注释抽取"></a>注释抽取</h4><p>假设希望<code>HTML</code>文件将放在名为<code>docDir</code>的目录下，执行以下步骤</p><ol><li><p>切换到包含想要生成文档的源文件的目录。如果有<strong>嵌套的包</strong>要生成文档，例如<code>com.qing.corejava</code>，就必须切换到包含子目录<code>com</code>的目录（如果提供了<code>overview.html</code>文件的话，就是这个文件所在的目录）</p></li><li><p>运行如下命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 如果是一个包</span>$ javadoc -d docDir nameOfPackage<span class="token comment"># 如果要为多个包生成文档</span>$ javadoc -d docDir nameOfPackage1 nameOfPackage2<span class="token comment"># 如果文件在无名的包中</span>$ javadoc -d docDir *.java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p>更多参考见 <a href="https://docs.oracle.com/javase/9/javadoc/javadoc.htm">https://docs.oracle.com/javase/9/javadoc/javadoc.htm</a></p></blockquote><h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><ol><li><p><strong>一定要保证数据私有</strong></p></li><li><p><strong>一定要对数据进行初始化</strong></p><p><code>java</code>不会初始化局部变量，但是会对对象的实例字段进行初始化。</p></li><li><p><strong>不要在类中使用过多的基本类型</strong></p></li><li><p><strong>不是所有的字段都需要单独的字段访问器和字段更改器</strong></p></li><li><p><strong>分解有过多职责的类</strong></p></li><li><p><strong>类名和方法名要能够体现它们的职责</strong></p></li><li><p><strong>优先使用不可变的类</strong></p></li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>基于已有的类创建新的类。继承已存在的类就是复用（继承）这些类的方法。而且可以增加一些新的方法和字段，使新类能够适应新的情况。</p><h3 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h3><h4 id="定义子类"><a href="#定义子类" class="headerlink" title="定义子类"></a>定义子类</h4><p><code>Java</code>中使用关键字<code>extends</code>来表示继承关系。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>    <span class="token comment">// ....</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>关键词 <code>extends</code>表明正在构造一个新类，它派生于一个已存在的类。这个已存在的类称为<strong>超类（<code>superclass</code>）</strong>、<strong>基类（<code>base class</code>）</strong>、或<strong>父类（<code>parent class</code>）</strong>；新的类称为<strong>子类（<code>subclass</code>）</strong>、<strong>派生类（<code>derived class</code>)<strong>或</strong>孩子类（<code>child class</code>）</strong></p><h4 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h4><p>超类中的有些方法对于子类并不一定适用。为此，需要提供一个新的方法来<strong>覆盖（<code>override</code>）</strong>超类中的这个方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> getSalary <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>    <span class="token comment">// 覆盖 超类 中的方法</span>     <span class="token keyword">public</span> <span class="token keyword">int</span> getSalary <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而如果想在子类中访问父类中的某个方法或者变量时，可以使用特殊的关键字<code>super</code>:。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>    <span class="token comment">// 覆盖 超类 中的方法</span>     <span class="token keyword">public</span> <span class="token keyword">int</span> getSalary <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，这里的<code>super</code>不是一个对象的引用，例如，不能将值<code>super</code>赋给另一个对象变量。</p></blockquote><h4 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h4><p>由于子类的构造器不能访问超类中的私有字段，所以必须通过调用超类的构造器来初始化这些私有字段，同样这里利用的是<code>super</code>的特殊语法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Manager</span> <span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> salary<span class="token punctuation">,</span> <span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> salary<span class="token punctuation">,</span> year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> year<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>bonus <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以简单对比下<code>this</code>和<code>super</code>的含义：</p><ul><li><code>this</code><ul><li>指示隐式参数的引用。</li><li>调用该类的其他构造器。</li></ul></li><li><code>super</code><ul><li>调用超类的方法。</li><li>调用超类的其他构造器。</li></ul></li></ul><p>这里简单引入下<strong>多态</strong>和<strong>动态绑定</strong>:</p><p>如下面的代码块中所示，变量 e 可以指示多种实际类型的，这种现象就是<strong>多态</strong>。在运行时能自动地选择适当的方法，就被称为<strong>动态绑定（<code>dynamic binding</code>）</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>staff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>staff<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span> e <span class="token operator">:</span> staff<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="继承层次"><a href="#继承层次" class="headerlink" title="继承层次"></a>继承层次</h4><p>由一个公共的超类派生出来的所有类的集合称为<strong>继承层次（<code>inheritance hierarchy</code>）</strong>，如下图所示，从某个特定的类到其祖先的路径称为类的<strong>继承链（<code>inheritance chain</code>）</strong>。</p><img src="/2022/06/28/cs-languages/core-java-volume-0/inheritance_hierarchy.png" class="" title="继承层次"><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p><code>"is - a"</code>规则的另一种表达是**替换原则（<code>substitution principle</code>）。它指出程序中出现超类对象的任何地方都可以使用子类对象替换。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Employee</span> e<span class="token punctuation">;</span>e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Employ object expected</span>e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK, Manager can be used as wll</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在<code>Java</code>程序语言中，对象变量是多态的（**<code>polymorphic</code>**）。</p><h4 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h4><p>简单概述下方法调用的过程， 下面以调用<code>x.f(args)</code>，隐式参数<code>x</code>声明为类<code>C</code>的一个对象。</p><ol><li><p>编译器查看对象的声明类型和方法名。</p><ul><li>编译器将会一一列举<code>C</code>类中所有名为f的方法和其超类中所有名为f而且可以访问的方法（超类的私有方法不可访问）。</li><li>此时，编译器已经知道所有可能被调用的候选方法。</li></ul></li><li><p>编译器确定方法调用中提供的参数类型。</p><ul><li><p>编译器根据方法名和具体的参数类型，选择一个与所提供参数类型完全匹配的方法。这个过程称为<strong>重载解析（<code>overloading resolution</code>）</strong>。</p><blockquote><p>方法的名字和参数列表称为方法的<strong>签名</strong>。</p></blockquote></li></ul></li><li><p>如果是<code>private</code>方法、<code>static</code>方法、<code>final</code>方法或者构造器，那么编译器将可以准确地直到应该调用哪个方法。这个称为<strong>静态绑定（<code>static binding</code>）</strong>。</p></li><li><p>程序运行并且采用<strong>动态绑定</strong>调用方法时，虚拟机必须调用与x所引用对象的实际类型对应的那个方法。</p><ul><li><p>由于每次调用方法都需要完成搜索去找到对应的方法，这样开销比较大。因此，虚拟机预先为每个类计算了一个<strong>方法表（<code>method table</code>）</strong>，其中列出了所有方法的签名和要调用的实际方法。这样在真正调用的时候只需要查找这张表就可以了。</p><blockquote><p>在覆盖一个方法的时候，子类方法<strong>不能低于</strong>超类方法的<strong>可见性</strong>。特别是超类方法是<code>public</code>，子类方法也必须声明为<code>public</code>。</p></blockquote></li></ul></li></ol><h4 id="阻止继承：final类和方法"><a href="#阻止继承：final类和方法" class="headerlink" title="阻止继承：final类和方法"></a>阻止继承：<code>final</code>类和方法</h4><p>不允许扩展的类被称为<code>final</code>类。</p><blockquote><p>对于<code>final</code>字段来说，构造对象之后就不允许改变其值了，但是如果将一个类声明为<code>final</code>，只有其中的方法自动的称为<code>final</code>，而不包括字段。</p></blockquote><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>在继承链上进行向下的强制类型转换，并且”谎报”对象宝航的内容，就有可能产生错误。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>staff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>staff<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Manager</span> boss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span> staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Java</code>运行到第七行的时候，将会注意到所给的实例与转换类型不匹配，就会产生一个<code>ClassCastException</code>异常。如果没有进程捕获处理这个异常，程序就会退出。所以可以通过下述方式，使用<code>instanceof</code>在转换之前检查能否转换。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Manager</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    boss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span> staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是如果使用一个超出<strong>继承链</strong>的强制转换就会编译错误。例如：<code>String c = (String) staff[1]</code></p><p>故，强制类型转换：</p><ul><li><p>只能在继承层次内进行强制类型转换。</p></li><li><p>在将超类强制转换成子类之前，应该使用<code>instanceof</code>进行检查</p><blockquote><p>如果 <code>x</code> 为 <code>null</code>， 测试 <code>x instanceof C</code> 。 不会产生异常，只是会返回 <code>false</code>。 这样是因为 <code>null</code>没有引用任何对象，当然也不会引用<code>C</code>类型的对象。</p></blockquote></li></ul><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>主要用于在超类中定义，但是将实现交给子类去实现；同时，抽象方法在子类中必须被重写。由关键字**<code>abstract</code>**修饰。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// no implementation required</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须声明为抽象类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"student"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时即使不含抽象方法的类，也可以定义为抽象类。</p><p>注意：<strong>抽象类不能实例化</strong>，即不能创建这个类的对象，但是可以定义一个抽象类的<strong>对象变量</strong>，就是定义成变量去引用菲抽象子类的对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">Preson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span><span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// success</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="受保护访问"><a href="#受保护访问" class="headerlink" title="受保护访问"></a>受保护访问</h4><p>使用关键字<code>protected</code>修饰，被其修饰的字段和方法只能由同一个包中的类访问，不能通过派生子类来访问受保护的字段。</p><blockquote><p>事实上，<code>Java</code>中的受保护部分对所有子类及同一个包中的所有其他类都可见。与<code>C++</code>中的保护机制不同，<code>Java</code>中的<code>protected</code>概念要比<code>C++</code>中的安全性差。</p></blockquote><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><ol><li><code>private</code>：仅对本类可见。</li><li><code>public</code>：仅对外部完全可见。</li><li><code>protected</code>：仅对本包和所有子类可见。</li><li>默认：不需要修饰符，对本包可见。</li></ol><h3 id="Object：所有类的超类"><a href="#Object：所有类的超类" class="headerlink" title="Object：所有类的超类"></a><code>Object</code>：所有类的超类</h3><p><code>Object</code>类是<code>Java</code>中所有类的始祖，在<code>Java</code>中每个类都扩展了<code>Object</code>，但是并不需要在类的定义中显式的去继承它。</p><h4 id="Object类型的变量"><a href="#Object类型的变量" class="headerlink" title="Object类型的变量"></a><code>Object</code>类型的变量</h4><ol><li>可以使用<code>Object</code>类去引用任何类型的对象，<code>Object obj = new Employee();</code>。</li><li>在<code>Java</code>中只有<strong>基本类型（<code>primitive type</code>）</strong>不是对象。</li><li>所有的数组类型，不管是对象数组还是基本类型的数组都扩展了<code>Object</code>类。</li></ol><h4 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a><code>equals</code>方法</h4><p><code>Object</code>类中实现的<code>equals</code>方法将确定两个对象引用是否相等。</p><p>但是对于一些状态检测的对象的相等性，更多的是去比较其包含的属性之间的相等状态，而不能只是简单的比较两个引用必须是一个对象。这里就需要对<code>equals</code>的方法进行重写。</p><p>同时子类中定义<code>equals</code>方法时，首先要调用超类的<code>euqals</code>方法。</p><p>如下示例来展示对<code>equals</code>方法的重写：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> salary<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">LocalDate</span> hireDay<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">double</span> salary<span class="token punctuation">,</span> <span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> salary<span class="token punctuation">;</span>        hireDay <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> otherObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// a quick test to see if the objects are identical</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> otherObject<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// must return false if the explicit parameter is null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>otherObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">// if the classes don't match, they can't be equal</span>        <span class="token comment">// getClass() 方法将会返回这个对象所属的类</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> otherObject<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">// now we know otherObject is a non-null Employee</span>        <span class="token keyword">var</span> other <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span><span class="token punctuation">)</span> otherObject<span class="token punctuation">;</span>        <span class="token comment">// test whether the fields have identical values</span>        <span class="token comment">// 这里为了防止 对象属性 name 和 hireDay 为null导致错误，所有推荐使用 Objects.equals()方法来进行比较，而不是使用 name.equals(other.name)</span>        <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> other<span class="token punctuation">.</span>name<span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span> salary <span class="token operator">==</span> other<span class="token punctuation">.</span>salary <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>hireDay<span class="token punctuation">,</span> other<span class="token punctuation">.</span>hireDay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="相等测试与继承"><a href="#相等测试与继承" class="headerlink" title="相等测试与继承"></a>相等测试与继承</h4><p><code>equals</code>方法要具有下面的特性：</p><ol><li><strong>自反性</strong></li><li><strong>对称性</strong></li><li><strong>传递性</strong></li><li><strong>一致性</strong></li><li>对于任意非空引用<code>x</code>，<code>x.equals(null)</code></li></ol><p>以下时任何编写一个相对完美的<code>equals</code>方法的建议：</p><ol><li><p>显式参数命名为<code>otherObject</code>，稍后需要将它强制转换成另一个名为other的变量。</p></li><li><p>检测<code>this</code>与<code>otherObject</code>是否相等：<code>if (this == otherObject) return true;</code>这属于一种优化。</p></li><li><p>检查<code>otherObject</code>是否为<code>null</code>，如果<code>null</code>，返回<code>false</code>。</p></li><li><p>比较<code>this</code>与<code>otherObject</code>的类。</p><ul><li><p>如果<code>equals</code>的语句可以在子类中改变，就使用<code>getClass</code>检测：</p><p><code>if (getClass() != otherObject.getClass()) return false;</code></p></li><li><p>如果<strong>所有的子类</strong>都由相等的相等性语义，就可以使用<code>instanceof</code>检测：</p><p><code>if (!(otherObject instanceof ClassName)) return false;</code></p></li></ul></li><li><p>将<code>otherObject</code>强制转换为相应类类型的变量：</p><p><code>ClassName other = (ClassName) otherObject;</code></p></li><li><p>根据相等性概念的要求来比较具体的属性字段。</p><ul><li>使用<code>==</code>比较基本类型字段</li><li>使用<code>Objects.equals</code>比较对象字段</li><li>对于数组类型的字段，可以使用静态的<code>Arrays.equals</code>方法来检测</li></ul><p>所有字段都匹配，返回<code>true</code>，否则返回<code>false</code></p></li></ol><blockquote><p>如下的实现<code>equals</code>方法的一种常见的错误，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Employee</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法声明的显示参数类型是<code>Employee</code>。因此，它没有覆盖<code>Object</code>类的<code>equals</code>方法，而是定义了一个完全无关的方法。</p><p>为了避免这种错误，可以使用<code>@Override</code>标记要覆盖超类方法的那些子类方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> otherObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a><code>hashCode</code>方法</h4><p>散列码（<code>hash code</code>）是由对象导出的一个整形值，是没有规律的。</p><blockquote><p>相同的字符串由相同的散列码，这是因为字符串的散列码是由<strong>内容</strong>导出的。</p><p><code>equals</code>与<code>hashCode</code>的定义必须相容</p></blockquote><h4 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a><code>toString</code>方法</h4><p>返回表示对象值的一个字符串。例如：<code>Point</code>类的<code>toString</code>方法将返回下面的字符串<code>java.awt.Point[x=10,y=20]</code>。</p><p><code>Object</code>类定义了<code>toString</code>方法，会打印对象的类名和散列码。例如，<code>System.out.println(System.out)</code>将生成<code>java.io.PrintStream@23f434</code>。原因在于<code>System.out</code>没有覆盖超类<code>Object</code>中的<code>toString</code>方法。</p><blockquote><ol><li><p>建议为自定义的每一个类都添加重写<code>toString</code>方法，方便与在日志中对数据的输出。</p></li><li><p>对于数组类型的数组，可以调用<code>Arrays.toString(new int[]{1, 2, 3, 4})</code>来生成字符串。</p></li></ol></blockquote><h3 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h3><p>所有的基本类型都有一个与之对应的类，这些类称为<strong>包装器（<code>wrapper</code>）</strong>。</p><table><thead><tr><th>基本类型</th><th>包装类型</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>Integer</code></td></tr><tr><td><code>long</code></td><td><code>Long</code></td></tr><tr><td><code>float</code></td><td><code>Float</code></td></tr><tr><td><code>double</code></td><td><code>Double</code></td></tr><tr><td><code>short</code></td><td><code>Short</code></td></tr><tr><td><code>byte</code></td><td><code>Byte</code></td></tr><tr><td><code>char</code></td><td><code>Character</code></td></tr><tr><td><code>bool</code></td><td><code>Boolean</code></td></tr></tbody></table><p>方便在一些必须使用类的地方来使用，例如：<code>ArrayList&lt;Integer&gt;</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 在添加 int 类型时，下面的调用</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将自动变换为</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面所述的这个过程称为<strong>自动装箱（<code>autoboxing</code>）</strong>。</p><p>相反的将一个<code>Integer</code>对象赋给一个<code>int</code>值时，也会自动的拆箱，编译器将<code>int n = list.get(3)</code>自动的转换成<code>int n = list.get(3).intValue();</code>。</p><blockquote><ol><li>自动装箱规范要求<code>boolean</code>、<code>byte</code>、<code>char&lt;=127</code>、介于<code>-128和127</code>之间的<code>short</code>和<code>int</code>被包装到固定的对象中。</li><li><strong>装箱和拆箱时编译器做的工作，而不是虚拟机</strong>。</li></ol></blockquote><p>介于<code>-128和127</code>之间的<code>short</code>和<code>int</code>被包装到固定的对象中。所以两个<code>Integer</code>对象会有时候会相等。如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">prinln</span><span class="token punctuation">(</span> a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出为true</span><span class="token comment">/* * 因为介于`-128 ~ 127`之间的`short`和`int`被包装到固定的对象中， 所以这时候比较的时同一块地址中保存的数据* 所以在超过`-128 ~ 127`范围之内的两个 Integer 对象则不相等*/</span><span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> d <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">prinln</span><span class="token punctuation">(</span> a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出为false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2022/06/28/cs-languages/core-java-volume-0/integer.png" class="" title="integer"><h3 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h3><p>可以提供参数数量可变的方法，又被称为<strong>变参（<code>varargs</code>）方法</strong>。例如下面的方法</p><p><code>System.out.printf("%d", n);  System.out.printf("%d %s", n, "widghts");  </code></p><p>上面的两个语句都是调用同一个方法，不过是一个为两个参数，一个为三个参数。<code>printf</code>方法是如下这样定义的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintStream</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">PrintStream</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token class-name">String</span> fmt<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">format</span><span class="token punctuation">(</span>fmt<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的省略号<code>...</code>是<code>Java</code>代码的一部分，它表明这个方法可以接收任意数量的对象（除fmt参数之外）。这里<code>printf</code>方法接收了两个参数，一个是格式字符串，<strong>另一个数量可变的参数实际上是一个<code>Object[]</code>数组</strong>。</p><p><code>Object... </code>参数类型与<code>Object[]</code>完全一样。</p><blockquote><p>所以上面的示例调用也可以写作：</p><p><code>System.out.printf("%d %s", new Object[] { new Integer(1), "widghts");</code></p></blockquote><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>所有的枚举类型都是<code>Enum</code>类的子类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">enum</span> <span class="token class-name">Size</span> <span class="token punctuation">{</span>    <span class="token function">SMALL</span><span class="token punctuation">(</span><span class="token string">"S"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">MEDIUM</span><span class="token punctuation">(</span><span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">LARGE</span><span class="token punctuation">(</span><span class="token string">"L"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EXTRA_LARGE</span><span class="token punctuation">(</span><span class="token string">"XL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 枚举的构造器总是私有的</span>    <span class="token keyword">private</span> <span class="token class-name">Size</span><span class="token punctuation">(</span><span class="token class-name">String</span> abbreviation<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>abbreviation <span class="token operator">=</span> abbreviation<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getAbbreviation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> abbreviation<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> abbreviation<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><strong>反射库（<code>reflection library</code>）</strong>提供了一个丰富且精巧的工具集，可以用来编写能够动态操纵<code>Java</code>代码的程序。</p><p>能够分析类能力的程序称为<strong>反射（<code>reflective</code>）</strong>，用于</p><ul><li>在运行时分析类的能力</li><li>在运行时检查对象，例如，编写一个适用与所有类的<code>toString</code>方法</li><li>实现泛型数组造作代码</li><li>利用<code>Method</code>对象， 这个对象很像C++中的函数指针</li></ul><h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a><code>Class</code>类</h4><p> <code>Java</code>运行时系统始终为所有对象维护的一个<strong>运行时类型标识</strong>。</p><ul><li><p><code>Object</code>类中的<code>getClass()</code>方法将会返回一个<code>Class</code>类型的实例。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Employee</span> e<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token class-name">Class</span> cl <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>静态方法<code>forName</code>获得类名对应的<code>Class</code>对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> className <span class="token operator">=</span> <span class="token string">"java.util.Random"</span><span class="token punctuation">;</span><span class="token class-name">Class</span> cl <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><blockquote><p><strong>注意</strong>：一个<code>Class</code>对象实际上表示的是一个<strong>类型</strong>，可能是类，也可能不是类，例如，<code>int</code>不是类，但是int.class是一个<code>Class</code>类型的对象。</p></blockquote><p><strong>虚拟机为每个类型管理一个唯一的Class对象</strong>。因此可以使用==运算符实现两个类对象的比较。</p><p>在有一个Class对象的时候，可以用它构造类的实例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> className <span class="token operator">=</span> <span class="token string">"java.util.Random"</span><span class="token punctuation">;</span> <span class="token comment">// or any other name of a class with a no-arg constructor</span><span class="token class-name">Class</span> cl <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Object</span> obj <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="声明异常入门"><a href="#声明异常入门" class="headerlink" title="声明异常入门"></a>声明异常入门</h4><ul><li><p>非检查型异常 （unchecked）</p></li><li><p>检查型异常 （checked）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">api</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> classParam<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">NoSuchMethodException</span> <span class="token punctuation">{</span>      <span class="token comment">// 返回一个Class对象， 表示名为className的类。 throws ClassNotFoundException</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> aClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"book.api.ClassApi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 生成一个对象，描述有指定参数类型的构造器。 throws NoSuchMethodException</span>    <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> classParam<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token class-name">ClassApi</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>在<code>Java</code>中，关联的文件被称为资源（<code>resource</code>）</p><p><code>Class</code>类提供了一个很有用的服务可以查找资源文件：</p><ol><li>获取拥有资源的类的<code>Class</code>对象，例如，ResourceTest.class</li><li>接受描述资源位置的<code>URL</code>， <code>URL url = cl.getResource("about.gif");</code></li><li>使用<code>getResourceAsStream</code>方法获得一个输入流来读取文件中中的数据。</li></ol><h4 id="利用反射分析类的能力"><a href="#利用反射分析类的能力" class="headerlink" title="利用反射分析类的能力"></a>利用反射分析类的能力</h4><p>主要是通过 <code>java.lang.reflect</code>包中三个类<code>Field</code>、<code>Method</code>、<code>Constructor</code>分别来描述类的字段、方法和构造器，进而来分析类的能力。</p><p><strong><code>Class</code>类的<code>getDeclareFields</code>、<code>getDeclareMethods</code>、<code>getDeclaredConstructors</code>方法将分别而返回类中声明的全部字段、方法和构造器的数组，其中包括私有成员、包成员和受保护成员，但不包括超类的成员。</strong></p><h4 id="使用反射在运行时分析对象"><a href="#使用反射在运行时分析对象" class="headerlink" title="使用反射在运行时分析对象"></a>使用反射在运行时分析对象</h4><ul><li>反射机制的默认行为受限于<code>Java</code>的访问限制，但是，可以调用<code>Field</code>、<code>Method</code>和<code>Constructor</code>对象的<code>setAccessible</code>方法覆盖Java的访问控制。<ul><li>·该方法是<code>AccessibleObject</code>类中的一个方法，是上述三个类的公共超类。这个特性是为调试、持久存储和类似机制提供的。</li><li>如果类中存在循环引用，在用反射获取其中属性时可能存在无限递归的问题，因此，可以使用<code>ObjectAnalyzer</code>来跟踪已访问过的对象避免无限递归。</li></ul></li></ul><h3 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h3><ol><li><strong>将公共操作和字段放在超类中</strong></li><li><strong>不要使用受保护的字段</strong></li><li><strong>使用继承实现“is-a”关系</strong></li><li><strong>除非所有继承的方法都有意义，否则不要使用继承</strong></li><li><strong>再覆盖方法时，不要改变预期的行为</strong></li><li><strong>使用多态，而不要使用类型信息</strong></li><li><strong>不要滥用反射</strong><ul><li>反射机制使人们可以在运行时查看字段和方法，从而能编写出更具有通用性的程序。这种功能对于编写系统程序及其有用，但是通常不适于编写应用程序。</li><li>反射是很脆弱的，如果使用反射，编译器将无法帮助你查找编程错误，因此只有在运行时才会发现错误并导致异常</li></ul></li></ol><h2 id="接口、lambda表达式和内部类"><a href="#接口、lambda表达式和内部类" class="headerlink" title="接口、lambda表达式和内部类"></a>接口、<code>lambda</code>表达式和内部类</h2><h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（<code>interface</code>）</h3><p>用来描述类应该做什么，而不指定它们具体应该怎么做。一个类可以实现（<code>implement</code>）一个或多个接口。</p><h4 id="接口概念"><a href="#接口概念" class="headerlink" title="接口概念"></a>接口概念</h4><p>接口不是类，而是对希望符合这个接口的类的一组需求。使用关键字 <code>interface</code> 定义方式如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparable</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>在接口声明中，没有将 <code>compareTo</code> 方法声明为 <code>public</code> ，这是因为在接口中的所有方法都自动时 <code>public</code>。不过，在实现接口是，必须将方法声明为 <code>public</code>；否则，编译器将认为这个方法的访问属性时包可见性，这个类的默认访问属性。</p></blockquote><p>为了让类实现一个接口，通过如下步骤定义：</p><ol><li>将类声明为实现给定的接口。</li><li>对接口中的所有方法提供定义。</li></ol><p>使用关键字 <code>implments</code> ：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="接口的属性"><a href="#接口的属性" class="headerlink" title="接口的属性"></a>接口的属性</h4><p>接口不是类。具体来说，<strong>不能使用<code>new</code>运算符实例化一个接口</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ERROR</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过<strong>可以声明接口的变量</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Comparable</span> x<span class="token punctuation">;</span> <span class="token comment">// ok</span>x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Exployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可以引用一个实现了这个接口的类对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用  <code>instanceof</code> 检查一个对象是否实现了某个特定的接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span> anObject <span class="token keyword">instanceof</span> <span class="token class-name">Comparable</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以建立与类的继承层次一样的扩展接口，即 接口继承接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Moveable</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Powered</span> <span class="token keyword">extends</span> <span class="token class-name">Moveable</span> <span class="token punctuation">{</span>    <span class="token keyword">double</span> <span class="token function">milesPerGallon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接口中不能包含实例字段，但是可以包含常量，接口中的字段总是 <code>public static final</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Powered</span> <span class="token keyword">extends</span> <span class="token class-name">Moveable</span> <span class="token punctuation">{</span>    <span class="token keyword">double</span> <span class="token function">milesPerGallon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> SPEED_LIMIT <span class="token operator">=</span> <span class="token number">95</span><span class="token punctuation">;</span> <span class="token comment">// a public static finla constant</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h4><p>一个类可以实现多个接口，但是只能继承一个类，Java不支持多重继承。所以在抽象类之外有引入了接口的概念。</p><h4 id="静态和私有方法"><a href="#静态和私有方法" class="headerlink" title="静态和私有方法"></a>静态和私有方法</h4><p>在<code>Java8</code>中，允许在接口中增加静态方法。目前为止，通常的做法都是将静态方法放在伴随类中。在标准库中，你会看到成对出现的接口和实用工具类，如<code>Collection/Collections</code>或<code>Path/Paths</code>.</p><p>在Java9中，接口中的方法可以是private。private方法可以是静态方法或实例方法。由于私有方法只能在接口本身的方法中使用，所以用法很有限，只能作为接口中其他方法的辅助方法。</p><h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>可以为接口方法提供一个<strong>默认实现</strong>，必须用<code>default</code>修饰符标记这样一个方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CompareTo</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">default</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">T</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// by default, all elements are the same</span>    <span class="token punctuation">}</span>        <span class="token comment">// 同时默认方法可以调用其他方法</span>    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// an abstract method</span>    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认方法的一个重要用法就是“<strong>接口演化</strong>”（interface evolution）。即对老接口增加新方法，那么历史的已经实现的类要怎么处理呢，这时候通过对新加的方法提供默认实现，即可保证历史的实现也可以正常编译和使用。</p><h4 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h4><ol><li><p>超类优先。</p><p>如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法都会被忽略。</p></li><li><p>接口冲突。</p><p>如果一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突，</p></li></ol><h4 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h4><img src="/2022/06/28/cs-languages/core-java-volume-0/copy_clone.png" class="" title="image-copy_clone"><img src="/2022/06/28/cs-languages/core-java-volume-0/light_copy.png" class="" title="image-light_copy"><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a><code>lambda</code>表达式</h3><p> 用于处理代码块</p><h4 id="lambda表达式的语法"><a href="#lambda表达式的语法" class="headerlink" title="lambda表达式的语法"></a><code>lambda</code>表达式的语法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如上就是一个简单的**<code>lambda</code>表达式**，<code>lambda</code>表达式就是一个代码块，以及必须传入代码的变量规范。</p><p>这是一种表达方式：<strong>参数，箭头（-&gt;）以及一个表达式</strong>。示例：</p><ol><li><p>如果代码要完成多个计算，可以将代码卸载<code>{}</code>中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>即使lambda表达式没有参数，仍然需要提供空括号，就像无参数方法一样：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> comp <span class="token operator">=</span>     <span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span>  <span class="token comment">// same as (String first, String second)</span>    <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>如果方法只有一个参数，而且这个参数的类型可以推导出来，那么甚至可以省略小括号</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The time is "</span>                       <span class="token operator">+</span> <span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">ofEpochMilli</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getWhen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p>无须指定<code>lambda</code>表达式的返回类型。<code>lambda</code>表达式的返回类型总是会由上下文推导得出。</p><blockquote><p>如果一个lambda表达式只在某些分支返回一个值，而另外一个分支不返回值，这是不合法的。例如，(int x) -&gt; { if (x &gt;= 0) return 1;} 就不合法。</p></blockquote><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为<strong>函数式接口</strong>（<code>functional interface</code>）。</p><p>最好把<code>lambda</code>表达式看作是一个函数，而不是一个对象，另外要接受<code>lambda</code>表达式可以传递到函数式接口。</p><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> event <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 也可以改为</span><span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TImer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>表达式<strong>System.out::println</strong>是一个<strong>方法引用</strong>（<code>method reference</code>），它指示编译器生成一<strong>个函数式接口</strong>的实例，覆盖这个接口的抽象方法来调用给定的方法。</p><p>要用::运算符分割方法名与对象或类名，主要由下面三种情况：</p><ol><li><p><strong><code>object::instanceMethod</code></strong></p><p>方法引用等价于向方法传递参数的<code>lambda</code>表达式。</p><p>对于<code>System.out::println</code>，对象是 <code>System.out</code>， 所以方法表达式等价于<code> x -&gt; System.out,println(x)</code></p></li><li><p><strong><code>Class::instanceMethod</code></strong></p><p>第一个参数会成为方法的隐式参数</p><p><code>String::compareToIgnoreCase</code> 等同于<code> (x, y) -&gt; x.compareToIgnoreCase(y)</code></p></li><li><p><strong><code>Class::staticMethod</code></strong></p><p>所有的参数都传递到静态方法：<code>Math::pow</code> 等价于<code> (x, y) -&gt; Math.pow(x, y)</code>。</p></li></ol><p><strong>方法引用示例</strong></p><table><thead><tr><th>方法引用</th><th>等价的lambda表达式</th><th>说明</th></tr></thead><tbody><tr><td><code>separator::equals</code></td><td><code>x -&gt; separator.equals(x)</code></td><td>这是包含一个对象和一个实例方法的方法表达式。<code>lambda</code>参数作为这个方法的显示参数传入</td></tr><tr><td><code>String::trim</code></td><td><code>x -&gt; x.trim()</code></td><td>这是一个包含一个类和一个实例方法的方法表达式。<code>lambda</code>表达式会成为隐式参数</td></tr><tr><td><code>String::concat</code></td><td><code>(x, y) -&gt; x.concat(y)</code></td><td>同样，这里有一个实例方法，不过这次由一个显示参数。与前面一样，第一个<code>lambda</code>参数会称为隐式参数，其余的参数会传递到方法</td></tr><tr><td><code>Integer::valueOf</code></td><td><code>x -&gt; Integer::valueOf(x)</code></td><td>这是包含一个静态方法的方法表达式。<code>lambda</code>参数会传递到这个静态方法</td></tr><tr><td><code>Integer::sum</code></td><td><code>(x, y) -&gt; Integer::sum(x, y)</code></td><td>这是另一个静态方法，不过这一次有两个参数。两个<code>lambda</code>参数都传递到这个静态方法。<code>Integer.sum</code>方法专门创建为作为一个方法引用。对于lambda表达式，可以只写作<code>(x, y) -&gt; x+y</code></td></tr><tr><td><code>Integer::new</code></td><td><code>x -&gt; new Integer(x)</code></td><td>这是一个构造器引用，<code>lambda</code>参数传递到这个构造器，详见<a href="####%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8">构造器引用</a></td></tr><tr><td><code>Integer[]::new</code></td><td><code>n -&gt; new Integer[n]</code></td><td>这是一个数组构造器引用，<code>lambda</code>参数是数组长度</td></tr></tbody></table><blockquote><p>注意：只有当<code>lambda</code>表达式的体只调用一个方法而不做其他操作时，才能把lambda表达式重写为方法引用。例如：<code>s -&gt; s.length() == 0</code>，这里有一个方法调用。但是还有一个比较，所以这里不能使用方法引用。</p></blockquote><blockquote><p>包含对象的方法引用与等价的<code>lambda</code>表达式还有一个细微的差别。考虑一个方法引用，如<code>separator::equals</code>。如果<code>separator</code>为<code>null</code>，构造<code>separator::equals</code>时就会立即抛出一个<code>NullPointerException</code>异常。<code>lambda</code>表达式<code> x-&gt; sparator.equals(x)</code>只在调用时才会抛出<code>NullPointerException</code>异常。</p></blockquote><p>同样也可以使用：<code>this::instanceMethod</code>和 <code>super::instanceMethod</code></p><h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span> people <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>toArray</code>方法调用这个构造器来得到一个有正确类型的数组，这里的<code>Person[]::new</code>就是一个构造器引用。</p><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">repeatMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">,</span> <span class="token keyword">int</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultToolkit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，里面的<code>lambda</code>表达式有一个自由变量<code>text</code>，表示<code>lambda</code>表达式的数据接口必须存储自由变量的值。</p><blockquote><p>关于代码块以及自由变量值有一个术语：闭包（<code>closure</code>）</p></blockquote><p>可以看到lambda表达式可以捕获外围作用域中变量的值，<strong>但是这里有一个重要的限制，在lambda表达之中，只能引用值不会改变的变量</strong>，主要原因在于：如果lambda表达式中更改变量，<strong>并发执行多个动作时就会不安全</strong>。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">countDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        start<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// ERROR: Can't mutate captured variable</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，如果lambda表达式中引用一个变量，而这个变量可能在外面改变，这个也是不合法的。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ERROR: Cannot refer to changing i</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有一条规则：<font color="blue"><code>lambda</code>表达式中捕获的变量必须实际上是事实最终变量（<code>effectively final</code>）。事实最终变量是指，这个变量初始化之后就不会再为它赋新值</font>。</p><p><code>lambda</code>表达式的体与嵌套快有相同的作用域。在一个<code>lambda</code>表达式中使用<code>this</code>关键字时，是指创建这个lambda表达式的方法的<code>this</code>参数。</p><h4 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理<code>lambda</code>表达式</h4><p>使用<code>lambda</code>表达式的重点是延迟执行（<code>deferred execution</code>）。毕竟，如果想要立即执行代码，完全可以直接执行，而无需把他包装在一个<code>lambda</code>表达式中。</p><p><strong>常用函数式接口</strong></p><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>抽象方法</th><th>描述</th><th>其他方法</th></tr></thead><tbody><tr><td><code>Runnable</code></td><td><code>无</code></td><td><code>void</code></td><td><code>run</code></td><td><code>作为无参数或返回值的动作执行</code></td><td></td></tr><tr><td><code>Supplier&lt;T&gt;</code></td><td><code>无</code></td><td><code>T</code></td><td><code>get</code></td><td><code>提供一个T类型的值</code></td><td></td></tr><tr><td><code>Consumer&lt;T&gt;</code></td><td><code>T</code></td><td><code>void</code></td><td><code>accept</code></td><td><code>提供一个T类型的值</code></td><td><code>andThen</code></td></tr><tr><td><code>BiConsumer&lt;T, U&gt;</code></td><td><code>T, U</code></td><td><code>void</code></td><td><code>accept</code></td><td><code>处理T和U类型的值</code></td><td><code>andThen</code></td></tr><tr><td><code>Function&lt;T, R&gt;</code></td><td><code>T</code></td><td><code>R</code></td><td><code>apply</code></td><td><code>有一个T类型参数的函数</code></td><td><code>compose, andThen, identity</code></td></tr><tr><td><code>BiFunction&lt;T, U, R&gt;</code></td><td><code>T, U</code></td><td><code>R</code></td><td><code>apply</code></td><td><code>有T和U类型参数的函数</code></td><td><code>andThen</code></td></tr><tr><td><code>UnaryOperator&lt;T&gt;</code></td><td><code>T</code></td><td><code>T</code></td><td><code>apply</code></td><td><code>类型T上的一元操作符</code></td><td><code>compose, andThen, identity</code></td></tr><tr><td><code>BinaryOperator&lt;T&gt;</code></td><td><code>T, T</code></td><td><code>T</code></td><td><code>apply</code></td><td><code>类型T上的二元操作符</code></td><td><code>andThen, maxBy, minBy</code></td></tr><tr><td><code>Predicate&lt;T&gt;</code></td><td><code>T</code></td><td><code>boolean</code></td><td><code>test</code></td><td><code>布尔值函数</code></td><td><code>and, or, negate, isEqual</code></td></tr><tr><td><code>Bipredicate&lt;T, U&gt;</code></td><td><code>T, U</code></td><td><code>boolean</code></td><td><code>test</code></td><td><code>有两个参数的布尔值函数</code></td><td><code>and, or, negate</code></td></tr></tbody></table><p>基本类型的函数式接口</p><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>抽象方法名</th></tr></thead><tbody><tr><td><code>BooleanSupplier</code></td><td>无</td><td><code>boolean</code></td><td><code>getAsBoolean</code></td></tr><tr><td><em><code>P</code></em><code>Supplier</code></td><td>无</td><td><em><code>p</code></em></td><td><code>getAs</code><em><code>P</code></em></td></tr><tr><td><em><code>P</code></em><code>ConSumer</code></td><td><em><code>p</code></em></td><td><code>void</code></td><td><code>accept</code></td></tr><tr><td><em><code>ObjP</code></em><code>Consumer&lt;T&gt;</code></td><td><em><code>T</code><em>、</em><code>p</code></em></td><td><code>void</code></td><td><code>accept</code></td></tr><tr><td><em><code>P</code></em><code>Function&lt;T&gt;</code></td><td><em><code>p</code></em></td><td><em><code>T</code></em></td><td><code>apply</code></td></tr><tr><td><em><code>P</code></em><code>To</code><em><code>Q</code></em><code>Function</code></td><td><em><code>p</code></em></td><td><em><code>q</code></em></td><td><code>applyAs</code><em><code>Q</code></em></td></tr><tr><td><code>To</code><em><code>P</code></em><code>Function&lt;T&gt;</code></td><td><em><code>T</code></em></td><td><em><code>p</code></em></td><td><code>applyAs</code><em><code>P</code></em></td></tr><tr><td><code>To</code><em><code>P</code></em><code>Bifunction&lt;T, U&gt;</code></td><td><em><code>T</code><em>、</em><code>U</code></em></td><td><em><code>p</code></em></td><td><code>applyAs</code><em><code>P</code></em></td></tr><tr><td><em><code>P</code></em><code>UnaryOperator</code></td><td><em><code>p</code></em></td><td><em><code>p</code></em></td><td><code>applyAs</code><em><code>P</code></em></td></tr><tr><td><em><code>P</code></em><code>BinaryOperator</code></td><td><em><code>p</code><em>、</em><code>p</code></em></td><td><em><code>p</code></em></td><td><code>applyAs</code><em><code>P</code></em></td></tr><tr><td><em><code>P</code></em><code>Predicate</code></td><td><em><code>p</code></em></td><td><code>boolean</code></td><td><code>test</code></td></tr></tbody></table><p><strong>注 <em><code>p</code><em>、</em><code>q</code></em> 是<code>int</code>、<code>long</code>、<code>double</code>；*<code>P</code><em>、</em><code>Q</code>*是<code>Int</code>、<code>Long</code>、<code>Double</code></strong></p><blockquote><p>如果设计你自己的接口，其中只有一个抽象方法，可以用<code>@FunctionalInterface</code>注解来标记这个接口。</p></blockquote><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><strong>内部类</strong>（<code>inner class</code>）是定义在另一个类中的类。</p><ul><li>内部类可以对同一个包中的其他类隐藏。</li><li>内部类方法可以访问定义这个类的作用域中的数据，包括原本私有的数据。</li></ul><h4 id="使用内部类访问对象状态"><a href="#使用内部类访问对象状态" class="headerlink" title="使用内部类访问对象状态"></a>使用内部类访问对象状态</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TalkingClock</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> interval<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> beep<span class="token punctuation">;</span> <span class="token comment">// 注意这个变量，在内部类中被访问了</span>        <span class="token keyword">public</span> <span class="token class-name">TalkingClock</span><span class="token punctuation">(</span><span class="token keyword">int</span> interval<span class="token punctuation">,</span> <span class="token keyword">boolean</span> beep<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimePrinter</span> impements <span class="token class-name">ActinListener</span> <span class="token punctuation">{</span> <span class="token comment">// 这是一个内部类</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 注意这里的 if(beep)中 beep 是外部类的变量</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>beep<span class="token punctuation">)</span> <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultTooklit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个内部类方法可以访问自己的数据字段，以可以访问创建它的外围类对象的数据字段。为此，内部类的对象总有一个隐式引用，指向创建它的外部类对象。</p><img src="/2022/06/28/cs-languages/core-java-volume-0/inner_class_0.png" class="" title="inner_class_0"><p>这个引用在内部类的定义中是不可见的。外围类的引用在构造器中设置。编译器会修改所有的内部类构造器，添加一个对应外围类引用的参数。</p><h4 id="内部类的特殊语法规则"><a href="#内部类的特殊语法规则" class="headerlink" title="内部类的特殊语法规则"></a>内部类的特殊语法规则</h4><p>当然使用外部类的引用，有一个更专业的语法：<code>OuterClass.this</code>，表示对外围类的引用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimePrinter</span> impements <span class="token class-name">ActinListener</span> <span class="token punctuation">{</span> <span class="token comment">// 这是一个内部类</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 注意这里的 if(beep)中 beep 是外部类的变量</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">TalkingClock</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>beep<span class="token punctuation">)</span> <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultTooklit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="内部类的编译文件"><a href="#内部类的编译文件" class="headerlink" title="内部类的编译文件"></a>内部类的编译文件</h4><p><strong>内部类</strong>是一个<strong>编译器现象</strong>，与虚拟机无关。编译器将会把内部类转换为常规的类文件，用<code>$</code>分割外部类名与内部类名，而虚拟机则对此一无所知。</p><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>可以在一个方法中局部地定义一个类，这样就可以只限定于在方法块中使用这个类，这样局部类有一个很大的优势，即对外部世界完全隐藏。</p><p>声明局部类时不能有访问说明符。</p><p>局部类还有一个优点，它们不仅能够访问外部类的字段，还可以访问局部变量！不过，那些局部变量必须是<strong>事实最终变量</strong>（<code>effectively final</code>）。和<code>lambda</code>表达式中的相同限定。</p><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>如果只想创建这个类的一个对象，甚至不需要为类指定名字，这样的一个类被称为<strong>匿名内部类</strong>（<code>anonymous inner class</code>）</p><p>大致的结构如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span>construction parameters<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// inner class methods and data</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>其中SuperType可以时接口，如ActionListener，这样就是实现了这个接口；</li><li>也可以时一个类，这样就是扩展这个类，相当于内部类继承这个类。</li></ol><p><strong>匿名内部类不能有构造器</strong>，实际上，构造参数要传递给超类构造器。</p><blockquote><p>尽管匿名类不能有构造器，但可以提供一个对象初始化块：</p><p>var count = new Person(“Dracula”) {</p><p>​{initialization}</p><p>}</p></blockquote><blockquote><p>下面有个技巧为“双括号初始化”（double brace initialization），利用内部类的语法创建并初始化一个数组列表并传递给一个方法：</p><p><code>invite(new ArrayList&lt;String&gt;() {{ add("Harry"); add("Tony"); }})</code></p><p>这里外层括号建立了<code>ArrayList</code>的一个匿名子类。内层括号则是一个对象初始化块。</p></blockquote><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>有时候使用内部类只是为了把一个类隐藏在另一个类的内部，并不需要内部类有外围类对象的一个引用。为此，可以将内部类声明为<code>static</code>，这样就不会生成那个引用了，如果将访问权限设置为public，同时也可以提供给其他类访问。静态内部类类似于其他内部类，只是没有对外部类的引用。</p><blockquote><p>与常规内部类不同，静态内部类可以有静态字段和方法。</p><p>在接口中声明的内部类自动是<code>static</code>和<code>public</code></p></blockquote><h2 id="异常、断言和日志"><a href="#异常、断言和日志" class="headerlink" title="异常、断言和日志"></a>异常、断言和日志</h2><h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p>异常对象都是派生于<code>Throwable</code>类的一个类实例。</p><p>Java语言规范将派生于Error类或RuntimeException类的所有异常称为非检查型（<code>unchecked</code>）异常，所有其他的异常称为检查型（<code>checked</code>）异常。</p><img src="/2022/06/28/cs-languages/core-java-volume-0/throwable.png" class="" title="throwable"><h4 id="声明检查型异常"><a href="#声明检查型异常" class="headerlink" title="声明检查型异常"></a>声明检查型异常</h4><blockquote><p>如果在子类中覆盖了超累的一个方法，子类方法中声明的检查型异常不能比超类方法中声明的异常更通用（子类方法可以抛出更特定的异常，或者根本不抛出任何异常）。</p><p>如果超类方法没有抛出任何检查型异常，子类已不能抛出任何检查型异常。</p></blockquote><h4 id="如何抛出异常"><a href="#如何抛出异常" class="headerlink" title="如何抛出异常"></a>如何抛出异常</h4><p>下面是抛出这个异常的语句：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EOFException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h4><p>只需要定义一个派生于<code>Exception</code>的类，或者派生于<code>Exception</code>的某个子类。</p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><h4 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>捕获异常需要使用到，<code>try/catch</code>语句块：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// code</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExceptionType</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// handler for this type</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果<code>try</code>语句块中的任何代码抛出了<code>catch</code>子句中指定的一个异常类，那么：</p><ol><li>程序将跳过<code>try</code>语句块的其他代码</li><li>程序将执行catch子句中的处理器代码</li></ol><h4 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// code that might throw exceptions</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundExcption</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// code</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnknownHostExcption</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// code</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IoExcption</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// code</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在java7之后，同一个catch子句中可以捕获多个异常类型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// code that might throw exceptions</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundExcption</span> <span class="token operator">|</span> <span class="token class-name">UnknownHostExcptione</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// code</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IoExcption</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// code</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>捕获多个异常时，异常变量隐含为final变量，例如，在以下子句体中不能为 e 赋予不同的值：</p><p><code>catch (FileNotFoundExcption | UnknownHostExcptione e) { ... }</code></p></blockquote><h4 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// access the database</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> original<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServletException</span><span class="token punctuation">(</span><span class="token string">"database error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span><span class="token function">initCause</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a><code>finally</code>子句</h4><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">var in = new FileInputStream(...);try {    // code that might throw exceptions} catch (IOException e) {    // show error message} finally {    in.close()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，不管是否有异常被捕获，<code>finally</code>子句中的代码都会执行。<code>finally</code>在块（<code>try</code> 或者 <code>catch </code>部分）的“<strong>跳出</strong>”之前执行其中的代码。</p><p>同时，<code>try</code>语句可以只有<code>finally</code>子句，而没有<code>catch</code>子句：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// code that might throw exceptions</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当<code>finally</code>子句包含<code>return</code>语句时，可能会产生意想不到的结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// ERROR</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上所示，在方法返回前，会执行<code>finally</code>子句块，如果<code>finally</code>块也有一个<code>return</code>语句，这个返回值将会遮蔽原来的返回值。如果执行 <code>parseInt("42")</code> ，真正返回前会执行<code>finally</code>子句，使得方法最后返回一个0，而忽略原来的返回值。</p><p>更糟糕的是，如果 <code>parseInt("zero")</code> ，会抛出异常，return甚至会“吞掉”这个异常。</p><p><code>finally</code>子句的主要用于清理资源。不要把改变控制流的语句（<code>return，throw，break，continue</code>）放在<code>finally</code>子句中。</p></blockquote><h4 id="try-with-Resources语句"><a href="#try-with-Resources语句" class="headerlink" title="try-with-Resources语句"></a><code>try-with-Resources</code>语句</h4><p>最简格式为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span> <span class="token class-name">Resource</span> res <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// work with res</span><span class="token punctuation">}</span><span class="token comment">// 同时这里还可以定义多个资源</span><span class="token keyword">try</span> <span class="token punctuation">(</span> <span class="token class-name">Resource</span> in <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token class-name">Resource</span> out <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// work with res</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，<code>try</code>块退出时，会自动调用<code>res.close()</code>。不论这个块如何退出，异常或者正常退出，都会执行<code>res.close()</code>。</p><p>在<code>Java9</code>中，可以在try首部中提供之前声明的事实最终变量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printAll</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lines<span class="token punctuation">,</span> <span class="token class-name">PrintWriter</span> out<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>out<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// effectively final variable</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> line <span class="token operator">:</span> lines<span class="token punctuation">)</span> <span class="token punctuation">{</span>            out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token comment">// out.close() called here</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果try块抛出一个异常，而且<code>close</code>方法也抛出一个异常，这样就会带来一个难题。<code>try-with-resources</code>语句可以很好地处理这种情况。<strong>原来的异常会重新抛出，而<code>close</code>方法抛出的异常会“被抑制”。这些异常将自动捕获，并由<code>addSuppressed</code>方法增加到原来的异常</strong>。如果对这些异常感兴趣，可以调用<code>getSuppressed</code>方法，它会生成从<code>close</code>方法抛出并被抑制的异常数组。</p><blockquote><p><code>try -with-resources</code>语句自身也可以有catch子句，甚至还可以有一个finally子句。这些子句会在关闭资源后执行。<strong>注意是在关闭资源后执行</strong>。</p></blockquote><h4 id="分析堆栈轨迹元素"><a href="#分析堆栈轨迹元素" class="headerlink" title="分析堆栈轨迹元素"></a>分析堆栈轨迹元素</h4><p><strong>堆栈轨迹</strong>（<code>stack trace</code>）是程序执行过程中某个特定点上所欲哦挂起的方法调用的一个列表。可以调用<code>Throwable</code>类的<code>printStackTrace</code>方法访问堆栈轨迹。</p><h3 id="使用异常的技巧"><a href="#使用异常的技巧" class="headerlink" title="使用异常的技巧"></a>使用异常的技巧</h3><ol><li><p><strong>异常处理不能代替简单的测试</strong></p></li><li><p><strong>不要过分地细化异常</strong></p><p>将正常处理与错误处理分开</p></li><li><p><strong>充分利用异常层次结构</strong></p><p>不要只抛出RuntimeException异常，应该寻找一个合适的子类或创建自己的异常类。</p><p>不要只捕获Throwable异常，否则，这会使你的代码更难读、更难维护。</p></li><li><p><strong>不要压制异常</strong></p></li><li><p><strong>在检测错误时，“苛刻”要比放任更好</strong></p></li><li><p><strong>不要羞于传递异常</strong></p></li></ol><h3 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h3><h4 id="断言的概念"><a href="#断言的概念" class="headerlink" title="断言的概念"></a>断言的概念</h4><p>断言机制允许在测试期间向代码中插入一些检查，而在产生代码中会自动删除这些检查。</p><p>Java语言引入了关键字 assert。这个关键字有两种形式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">assert</span> condition<span class="token punctuation">;</span><span class="token keyword">assert</span> condition <span class="token operator">:</span> expression<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="启用和禁用断言"><a href="#启用和禁用断言" class="headerlink" title="启用和禁用断言"></a>启用和禁用断言</h4><p>在默认情况下，断言时禁用的。可以在运行时用-enableassertions或-ea选项启用断言：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ java -enableassertions MyApp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要注意的是，不必重新编译程序来启用或禁用断言。启用或禁用断言是<strong>类加载器</strong>（<code>class loader</code>）的功能。禁用断言时，类加载器会去除断言代码。</p><p>也可以在某个类或整个包中启用断言，例如：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ java -ea:MyClass -ea:com.mycompany.mylib MyApp<span class="token comment"># 在MyClass类以及com.mycompany.mylib包和它的子包</span><span class="token comment"># 使用 -disableassertions 或 -da</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不过，启用和禁用所有断言的<code>-ea</code>和<code>-da</code>开关不能应用到那些没有类加载器的“系统类”上。对于这些系统类，需要使用<code>-enablesystemassertions/-esa</code>开关启用断言。</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>暂略</p><h2 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h2><h3 id="为什么要使用泛型程序设计"><a href="#为什么要使用泛型程序设计" class="headerlink" title="为什么要使用泛型程序设计"></a>为什么要使用泛型程序设计</h3><p><strong>反省程序设计</strong>（<code>generic programming</code>）意味着编写的代码可以对多种不同类型的对象重用。</p><p>这种设计可以让程序更易读，也更安全。</p><h3 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h3><p><strong>泛型类</strong>（<code>generic class</code>）就是有一个或多个类型变量的类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">T</span> first<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">T</span> second<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> first <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> second <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token class-name">T</span> first<span class="token punctuation">,</span> <span class="token class-name">T</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> first<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirst</span><span class="token punctuation">(</span><span class="token class-name">T</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecond</span><span class="token punctuation">(</span><span class="token class-name">T</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Pair</code> 类引入了一个类型变量T，用尖括号（<code>&lt;&gt;</code>）括起来，放在类名的后面。当然也可以定义多个类型变量：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>Java</code>库使用变量<code>E</code>表示集合的元素类型，<code>K</code>和<code>V</code>分别表示表的键和值的类型。<code>T</code>（必要时还可以用相邻的字母<code>U</code>和<code>S</code>）表示“任意类型”</p></blockquote><p>可以使用具体的类型替换类型变量来实例化（<code>instantiate</code>）泛型类型，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>除了可以定义泛型类之外，还可以定义一个带有类型参数的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ArrayAlg</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">getMiddle</span><span class="token punctuation">(</span><span class="token class-name">T</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token punctuation">[</span>a<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法实在普通类中定于的，而不是在泛型类中。注意，类型变量放在修饰符（这里的修饰符就是public static）的后面，并在返回类型的前面。</p><p>泛型方法可以再普通类中定义，也可以在泛型类中定义。</p><p>当调用一个泛型方法时，可以把具体类型包围在尖括号中：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> middle <span class="token operator">=</span> <span class="token class-name">ArrayAlg</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token function">getMiddle</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token string">"Q."</span><span class="token punctuation">,</span> <span class="token string">"Public"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样，在方法调用中可以省略<code>&lt;String&gt;</code>类型参数。编译器可以将参数的类型和泛型类型<code>T</code>进行匹配，推断出T一定是<code>String</code>。</p><h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><p>有时候类或方法需要对类型变量加以约束，这时候就可以通过对类型变量<code>T</code>设置一个限定（<code>bound</code>）来实现这一点：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里表示T应该时限定类型（<code>bounding type</code>）的子类型（<code>subtype</code>）。<code>T</code>和限定类型可以是类，也可以时接口。选择关键词<code>extends</code>的原因是它更接近于子类型的概念。同样一个类型变量或通配符可以有多个限定，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Compatable</span> <span class="token operator">&amp;</span> <span class="token class-name">Serializable</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>限定类型用“<code>&amp;</code>”分割，而逗号用来分隔类型变量。</p><p><strong>在<code>Java</code>的继承中，可以根据需要拥有多个接口超类型，但最多有一个限定可以是类。如果有一个类作为限定，它必须是限定列表中的第一个限定。</strong></p><h3 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h3><p>虚拟机没有泛型类型对象——所有对象都属于普通类。在泛型实现的早期版本中，甚至能够将使用泛型的程序编译为1.0虚拟机上运行的类文件！在下面的小结中可以看到编译器如何“擦除”类型参数。</p><h4 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h4><p>无论何时定义一个泛型类型，都会自动提供一个相应的<strong>原始类型</strong>（<code>raw type</code>）。这个原始类型的名字就是去掉类型参数后的泛型类型名。类型变量会被<strong>擦除</strong>（<code>erased</code>），并替换为其限定类型（或者，对于无限定的变量则替换为<code>Object</code>）。</p><p>例如，<code>Pair&lt;T&gt;</code>的原始类型如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> first<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> second<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> first <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> second <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token class-name">Object</span> first<span class="token punctuation">,</span> <span class="token class-name">Object</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> first<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirst</span><span class="token punctuation">(</span><span class="token class-name">Object</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecond</span><span class="token punctuation">(</span><span class="token class-name">Object</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为<code>T</code>是一个无限定的变量，所以直接用<code>Object</code>替代。</p><p><strong>原始类型用第一个限定来替换类型变量，或者，如果没有给定限定，就替换为<code>Object</code>。</strong>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Interval</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span> <span class="token operator">&amp;</span> <span class="token class-name">Serializable</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">T</span> first<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">T</span> second<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token class-name">T</span> first<span class="token punctuation">,</span> <span class="token class-name">T</span> second<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类型擦除后，原始类型<code>Interval</code>如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Interval</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Comparable</span> first<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Comparable</span> second<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span> first<span class="token punctuation">,</span> <span class="token class-name">Comparable</span> second<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果将限定切换为<code>Class Interval&lt;T extends Serializable &amp; Comparable&gt;</code>会发生什么。如果这样操作，原始类型会用<code>Serializable</code>替换<code>T</code>，而编译器在必要时要向<code>Comparable</code>插入强制类型转换。<strong>为了提高效率，应该将标签（<code>tagging</code>）接口（即没有方法的接口）放在限定列表的末尾。</strong></p></blockquote><h4 id="转换泛型表达式"><a href="#转换泛型表达式" class="headerlink" title="转换泛型表达式"></a>转换泛型表达式</h4><p>编写一个泛型方法调用时，如果擦除了返回类型，编译器会插入强制类型转换。例如，对于下面的语序：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> buddies <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token class-name">Employee</span> buddy <span class="token operator">=</span> buddies<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>getFirst</code>擦除类型后的返回类型时<code>Object</code>。编译器自动插入转换到<code>Employee</code>的强制类型转换。</p><h4 id="转换泛型方法"><a href="#转换泛型方法" class="headerlink" title="转换泛型方法"></a>转换泛型方法</h4><p>对于<code>Java</code>泛型转换，需要记住以下几个事实：</p><ul><li>虚拟机中没有泛型，只有普通的类和方法。</li><li>所有的类型参数都会替换它们的限定类型。</li><li>会合成<strong>桥方法</strong>来保持多态。</li><li>为保持类型安全性，必要时会插入强制类型转换。</li></ul><h3 id="限制和局限性"><a href="#限制和局限性" class="headerlink" title="限制和局限性"></a>限制和局限性</h3><p><strong>这些限定和局限性的主要造成原因就是<font color="blue">类型擦除</font></strong></p><h4 id="不能用基本类型实例化类型参数"><a href="#不能用基本类型实例化类型参数" class="headerlink" title="不能用基本类型实例化类型参数"></a>不能用基本类型实例化类型参数</h4><p>不能用基本类型代替类型参数。因此没有<code>Pair&lt;double&gt;</code>，只有<code>Pair&lt;Double&gt;</code>。其原因就在于类型擦除。擦除之后，<code>Pair</code>类含有<code>Object</code>类型的字段，而<code>Object</code>不能存储<code>double</code>值。</p><h4 id="运行时类型查询值适用于原始类型"><a href="#运行时类型查询值适用于原始类型" class="headerlink" title="运行时类型查询值适用于原始类型"></a>运行时类型查询值适用于原始类型</h4><p>虚拟机中的对象总有一个特定的非泛型类型。因此，所有的类型查询只产生原始类型。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// ERROR</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// ERROR</span><span class="token comment">// 或者强制类型转换</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> a<span class="token punctuation">;</span> <span class="token comment">// warning can only test that a is a Pair</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的道理，getClass方法总是<strong>返回原始类型并不是泛型</strong>，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stringPair <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> employeePair <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>stringPair<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> employeePair<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// they are equal</span><span class="token comment">// getClass() 返回 Pair.class    </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h4><p>不能实例化参数化类型的数据，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// ERROR</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为，擦除之后，<code>table</code>的类型时Pair[]. 可以把它转换为<code>Object[]</code>：<code>Object[] objarray = table;</code></p><p>如果试图存储其他类型的元素，就会抛出一个<code>ArrayStoreException</code>异常：<code>objarray[0] = "Hello";</code></p><p>不过对于泛型类型，擦除会使这种机制无效。赋值语句：<code>objarray[0] = new Pair&lt;Employee&gt;();</code>，尽管能够通过数组存储的检查，仍然会导致一个类型错误。由于这个原因，不允许创建参数化类型的数组。</p><p>需要说明的是，指示不允许创建这个数组，而声明类型为<code>Pair&lt;String&gt;[]</code>的变量仍是合法的。不过不能用<code>new Pair&lt;String&gt;[10]</code>初始化这个变量。</p><blockquote><p>可以声明通配类型的数组，然后进行强制类型转换：（不过是不安全的初始化）</p><p><code>var table = (Pair&lt;String&gt;[]) new Pair&lt;?&gt;[10];</code></p></blockquote><h4 id="Varargs警告"><a href="#Varargs警告" class="headerlink" title="Varargs警告"></a><code>Varargs</code>警告</h4><p>向参数个数可变的方法传递一个泛型类型的实例。</p><p>下面的简单方法，它的参数个数是可变的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> coll<span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ts<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 存在警告但是还可以使用</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">T</span> t <span class="token operator">:</span> ts<span class="token punctuation">)</span> <span class="token punctuation">{</span>        coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>考虑下面的调用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pair</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> table <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> pair1 <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> pair2 <span class="token operator">-</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token function">addAll</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> pair1<span class="token punctuation">,</span> pair2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为了调用这个方法，Java虚拟机必须建立一个Pair<strintg>数组，这违反了<a href="####%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E7%BB%84">上面的规则</a>。</strintg></p><blockquote><p>这里可以使用两个注解来抑制这个警告：<code>@SuppressWarnings("unchecked")</code> 和 <code>@SafeVarargs</code></p></blockquote><h4 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h4><p>不能在类似 new T(…) 的表达式中使用类型变量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> first <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> second <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// ERROR</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型擦除将T变成Object，这样就变成调用 new Object()，不是所期望的。</p><p>在Java 8 之后，最好的解决办法是让调用者提供一个构造器表达式。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token class-name">Pair</span><span class="token punctuation">.</span><span class="token function">makePair</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">makePair</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> constr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>constr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> constr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="不能构造泛型数组"><a href="#不能构造泛型数组" class="headerlink" title="不能构造泛型数组"></a>不能构造泛型数组</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">minmax</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//Error</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>因为<strong>类型擦除</strong>的原因，这里会使得这个方法总是构造<code>Comparable[2]</code>数组。</p><p>所以这种情况下最好是让用户提供一个数组构造器表达式：</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">String[] names = ArrayAlg.minmax(String[]::new, "Tom", "Dick", "Harry");public static &lt;T extends Comparable&gt; T[] minman(IntFunction&lt;T[]&gt; constr, T... a) {    T[] result = constr.apply(2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型类的静态上下文中类型变量无效"><a href="#泛型类的静态上下文中类型变量无效" class="headerlink" title="泛型类的静态上下文中类型变量无效"></a>泛型类的静态上下文中类型变量无效</h4><p>不能在静态字段或方法中引用类型变量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singletion</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">T</span> singleInstance<span class="token punctuation">;</span> <span class="token comment">// ERROR</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">T</span> <span class="token function">getSingleInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ERROR</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> singleInstance<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上所示，类型擦除之后，只剩下Singleton类，它只包含一个singleInstance字段。因此，禁止使用带有类型变量的静态字段和方法。</p><h4 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h4><p>既不能抛出也不能捕获泛型类的对象。实际上，泛型类扩展<code>Throwable</code>甚至都是不合法的。例如，以下定义就不合法 <code>public class Problem&lt;T&gt; extends Exception {}</code>，不过，在异常规范中使用类型变量是允许的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// do work </span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> realCause<span class="token punctuation">)</span> <span class="token punctuation">{</span>        t<span class="token punctuation">.</span><span class="token function">initCause</span><span class="token punctuation">(</span>realCause<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="可以取消对检查型异常的检查"><a href="#可以取消对检查型异常的检查" class="headerlink" title="可以取消对检查型异常的检查"></a>可以取消对检查型异常的检查</h4><p>Java异常处理的一个基本原则是，必须为所有检查型异常提供一个处理器。不过可以利用泛型取消这个机制。关键方法在于：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">throwAs</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意擦除后的冲突"><a href="#注意擦除后的冲突" class="headerlink" title="注意擦除后的冲突"></a>注意擦除后的冲突</h4><p>为了支持擦除转换，倘若两个接口类型是同一个接口的不同参数化，一个类或类型变量就不能同时作为这个两个接口类型的子类。例如，下面的代码时非法的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Manager</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span class="token comment">// ERROR</span><span class="token comment">// Manager 会实现Comparable&lt;Employee&gt; 和 Comparable&lt;Manager&gt; ， 这是同一个接口的不同参数化.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3><img src="/2022/06/28/cs-languages/core-java-volume-0/pair.png" class="" title="pair"><h3 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h3><h4 id="通配符概念"><a href="#通配符概念" class="headerlink" title="通配符概念"></a>通配符概念</h4><p>在通配符类型中，允许类型参数发生变化。例如，通配符类型：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示任何泛型<code>Pair</code>类型，它的类型参数时<code>Employee</code>的子类，如<code>Pair&lt;Manager&gt;</code>，但不是<code>Pair&lt;String&gt;</code>。</p><h4 id="通配符的超类型限定"><a href="#通配符的超类型限定" class="headerlink" title="通配符的超类型限定"></a>通配符的超类型限定</h4><p>除了继承限定外，还可以指定<strong>超类型限定</strong>：<code>? super Manager</code>。这个通配符限制为<code>Manager</code>的所有超类型。</p><p>直白的来说，带有超类型限定的通配符（<code>&lt;? super Manager&gt;</code>）允许你写入一个泛型对象，而带有子类型限定的通配符（<code>? extends Employee</code>）允许你读取一个泛型对象。</p><blockquote><p>超类型限定（<code>&lt;? super Manager&gt;</code>）： 可以明确的通过Manager知道其继承的超类，所以方便于写入一个泛型对象。</p><p>子类型限定（<code>? extends Employee</code>）：可以明确的知道返回的类型都是Employee的子类，所以方便于读取一个泛型对象。</p></blockquote><p>超类限定和子类限定同时使用：<code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; T min(T[] a)</code></p><h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><p>还可以使用根本无限定的通配符，例如，<code>Pair&lt;?&gt;</code>。初看起来，这好像与原始的Pair类型一样。实际上，这两种类型有很大的不同。类型Pair&lt;?&gt;有以下方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">?</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">setFirst</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>getFirst</code>的返回值只能赋给一个<code>Object</code>。<code>setFirst</code>方法不能被调用，甚至不能用<code>Object</code>调用（可以调用<code>setFirst&lt;null&gt;</code>）。<code>Pair&lt;?&gt;</code>和<code>Pair</code>本质的不同在于：可以用任意<code>Object</code>对象调用原始<code>Pair</code>类的<code>setFirst</code>方法。</p><p>为什么要使用这样一个脆弱的类型？它对于很多简单操作非常有用。例如，下面这个方法可用来测试一个对组是否包含一个<code>null</code>引用，它不需要实际的类型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">hasNulls</span><span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> p<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> p<span class="token punctuation">.</span><span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过将<code>hasNulls</code>转换成泛型方法，可以避免使用通配符类型：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">boolean</span> <span class="token function">hasNulls</span><span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是 ，带有通配符的版本可读性更好。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a><code>Java</code>集合框架</h3><h4 id="集合接口与实现分类"><a href="#集合接口与实现分类" class="headerlink" title="集合接口与实现分类"></a>集合接口与实现分类</h4><p><code>Java</code>集合类库也将接口（<code>interface</code>）与实现（<code>implementation</code>）分离。</p><h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a><code>Collection</code>接口</h4><p>在<code>Java</code>类库中，集合类的基本接口时<code>Collection</code>接口。这个接口有两个基本方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 向集合中添加元素</span>    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 迭代器</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p><code>Iterator</code>接口包含4个方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">forEachRemaining</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过反复调用<code>next</code>方法，可以逐个访问及各种的每个元素。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> iter <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> element <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// do something with element</span><span class="token punctuation">}</span><span class="token comment">// 这样的循环可以用“ for each ”， 编译器简单的将其转换为带有迭代器的循环。</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> element <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// do something with element</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>“<code>for each</code>”循环可以处理任何实现了Iterable接口的对象，这个接口只包含一个抽象方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也可以不写循环，而是调用<code>forEachRemaining</code>方法并提供一个<code>lambda</code>表达式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">iterator<span class="token punctuation">.</span><span class="token function">forEachRemaining</span><span class="token punctuation">(</span>element <span class="token operator">-&gt;</span> <span class="token keyword">do</span> something <span class="token keyword">with</span> <span class="token namespace">element</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>Java</code>的迭代器，查找操作和位置变更十分紧密耦合。查找一个元素的唯一方法时调用<code>next</code>，而在执行查找操作的同时，迭代器的位置就会随之向前移动。因此，<strong>可以认为<code>Java</code>迭代器位于两个元素之间，当调用<code>next</code>时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用</strong>。如下图：</p><img src="/2022/06/28/cs-languages/core-java-volume-0/iterator_0.png" class="" title="iterator_0"><p><code>Iterator</code>接口的<code>remove</code>方法将会<strong>删除上次调用</strong><code>next</code>方法时返回的对象。如果想要删除指定位置上的元素，仍然需要越过这个元素。例如，可以如下删除一个字符串集合中的第一个元素：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// skip over the first element</span>it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// now remove it</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>跟重要的时，<code>next</code>方法调用之间存在依赖性。如果调用<code>remove</code>之前没有调用<code>next</code>，将时不合法的。如果这样做，将会抛出一个<code>IllegalStateException</code>异常</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ERROR</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上，必须先调用<code>next</code>越过将要删除的元素</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h3><img src="/2022/06/28/cs-languages/core-java-volume-0/collection_0.png" class="" title="collection_0"><p><code>List</code>是一个有序集合（<code>ordered collection</code>）。元素会增加到容器中的特定位置。可以采用两种方式访问元素</p><ul><li>使用迭代器访问</li><li>使用一个整数索引来访问<ul><li>又称为<strong>随机访问</strong>（<code>random access</code>）</li></ul></li></ul><h3 id="具体集合"><a href="#具体集合" class="headerlink" title="具体集合"></a>具体集合</h3><blockquote><p><strong>线程安全</strong>的集合在后续介绍</p></blockquote><table><thead><tr><th>集合类型</th><th>描述</th><th>参见</th></tr></thead><tbody><tr><td><code>ArrayList</code></td><td>可以动态增长和缩减的一个索引序列</td><td></td></tr><tr><td><code>LinkedList</code></td><td>可以在任何位置高效插入和删除的一个有序序列</td><td><a href="####%E9%93%BE%E8%A1%A8">链表</a></td></tr><tr><td><code>ArrayDeque</code></td><td>实现为循环数组的一个双端队列</td><td></td></tr><tr><td><code>HashSet</code></td><td>没有重复元素的一个无序集合</td><td></td></tr><tr><td><code>TreeSet</code></td><td>一个有序集</td><td></td></tr><tr><td><code>LinkedHashSet</code></td><td>一个包含枚举值的集</td><td></td></tr><tr><td><code>PriorityQueue</code></td><td>允许高效删除最小元素的一个集合</td><td></td></tr><tr><td><code>HashMap</code></td><td>存储键/值关联的一个数据结构</td><td></td></tr><tr><td><code>TreeMap</code></td><td>键有序的一个映射</td><td></td></tr><tr><td><code>EnumMap</code></td><td>键属于枚举类型的一个映射</td><td></td></tr><tr><td><code>LinkedHashMap</code></td><td>可以记住键/值项添加次序的一个映射</td><td></td></tr><tr><td><code>WeakHashMap</code></td><td>值不会在别处使用时就可以被垃圾回收的一个映射</td><td></td></tr><tr><td><code>IdentityHashMap</code></td><td>用<code>==</code>而不是用<code>equals</code>比较键的一个映射</td><td></td></tr></tbody></table><img src="/2022/06/28/cs-languages/core-java-volume-0/collection_1.png" class="" title="collection_0"><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表是一个有序集合，每个对象的位置十分重要。</p><p>在<code>Java</code>程序设计语言中，所有链表实际上都是<strong>双向链表</strong>（<code>doubly linked</code>）</p><p>如果需要对集合进行随机访问，就是用数组或<code>ArrayList</code>。</p><img src="/2022/06/28/cs-languages/core-java-volume-0/linkedlist.png" class="" title="linkedlist"><h4 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h4><p><code>List</code>是一个有序集合（<code>ordered collection</code>）。元素会增加到容器中的特定位置。可以采用两种方式访问元素</p><ul><li>使用迭代器访问</li><li>使用一个整数索引来访问<ul><li>又称为随机访问（<code>random access</code>），这种访问方式不适用于链表，更适用于数组。</li></ul></li></ul><blockquote><p>这里的动态数组，还涉及到<code>Vector</code>类，为什么要用<code>ArrayList</code>而不是<code>Vector</code>呢？原因在于：<code>Vector</code>类的所有方法都是同步的，可以安全地从两个线程访问一个<code>Vector</code>对象。但是，如果只从一个线程访问<code>Vector</code>，代码就会在同步操作上白白浪费大量时间。而与之不同，<code>ArrayList</code>方法不是同步的，因此，建议在不需要同步时使用<code>ArrayList</code>，而不要使用<code>Vector</code>。</p></blockquote><h4 id="散列集"><a href="#散列集" class="headerlink" title="散列集"></a>散列集</h4><p><strong>散列表</strong>（<code>hash table</code>），可以用于快速地查找对象。</p><p>散列表为每个对象计算一个整数，称为<strong>散列码</strong>（<code>hash code</code>）。散列码是由对象的实例字段得出的一个整数，有不同数据的对象将产生一个不同的散列码。</p><p>在<code>Java</code>中，散列表用链表数组实现。每个列表被称为<strong>桶</strong>（<code>bucket</code>）。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。在桶中没有其他元素，此时将元素直接插入到桶中就可以了。当然，有时候会遇到桶已经被填充的情况。这种现象被称为<strong>散列冲突</strong>（<code>hash collision</code>）。这时，需要将新对象与桶中的所有对象比较，查看这个对象是否存在。</p><blockquote><p>在Java8中，桶满时会从链表变为平衡二叉树</p></blockquote><p>散列集迭代器将依次访问所有的桶，由于散列将元素分散在表中，所以会以一种看起来随机的顺序访问元素。这就是<strong>散列集无序</strong>的原因。</p><p>如果散列表太满，就需要<strong>再散列</strong>（<code>rehashed</code>）。创建一个桶数更多的表，插入数据后丢弃掉原来的表。<strong>装填因子</strong>（<code>load factor</code>）可以确定何时对散列表进行再散列。</p><img src="/2022/06/28/cs-languages/core-java-volume-0/hash_table.png" class="" title="hash_table"><h4 id="树集"><a href="#树集" class="headerlink" title="树集"></a>树集</h4><p><code>TreeSet</code>类与散列集十分类型，不过，相对于散列集有所改进。树集是一个<strong>有序集合</strong>（<code>sorted collection</code>）。树集的排序是用一个<strong>树</strong>数据结构完成的（目前实现使用的是<strong>红黑树</strong>（<code>red-black tree</code>））</p><blockquote><p>要使用树集，必须能够比较元素，这些元素必须实现<code>Comparable</code>接口，或者构造集必须提供一个<code>Comparator</code>。</p></blockquote><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p><strong>优先队列</strong>（<code>priority queue</code>）中的元素可以按照任意的顺序插入，但会按照有序的顺序进行检索。也就是说，无论何时调用<code>remove</code>方法，总会获得优先队列中最小的元素。这里优先队列并没有对所有元素进行排序，是因为优先队列使用了一个精巧且高效的数据结构，称为堆（<code>heap</code>）。堆是一个 可以自组织的二叉树，其添加（<code>add</code>）和删除（<code>remove</code>）操作可以让最小的元素移动到根，而不必花费时间对元素进行排序。</p><p>优先队列的典型用法是<strong>任务调度</strong>。</p><blockquote><p>和树集一样，要使用优先队列，必须能够比较元素，这些元素必须实现<code>Comparable</code>接口，或者构造集必须提供一个<code>Comparator</code>。</p></blockquote><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>映射用来存放键/值对，如果提供了键，就能够查找到值。</p><h4 id="基本映射操作"><a href="#基本映射操作" class="headerlink" title="基本映射操作"></a>基本映射操作</h4><p><code>Java</code>类库为映射提供了两个通用的实现：<code>HashMap</code>和<code>TreeMap</code>。这两个类都实现了<code>Map</code>接口。</p><p>散列映射对键进行散列，树映射根据键的顺序将元素组织为一个搜索树。散列或比较函数只应用于键，与键关联的值不进行散列或比较。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// HashMap implements Map</span><span class="token keyword">var</span> harry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>staff<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"23"</span><span class="token punctuation">,</span> harry<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// put() 保存值，只保存最近存储的值</span><span class="token class-name">Employee</span> e <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"23"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// gets harry</span><span class="token comment">// 迭代处理映射的键和值， 使用方法 forEach</span>staff<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"key"</span> <span class="token operator">+</span> k <span class="token operator">+</span> <span class="token string">", value="</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="映射试图"><a href="#映射试图" class="headerlink" title="映射试图"></a>映射试图</h4><p>集合框架不认为映射本身是一个集合。（其他数据结构框架认为映射是一个键/值对集合，或者是按键索引的值集合）不过，可以得到映射的<strong>视图</strong>（<code>view</code>）——这是实现了Collection接口或某个子接口的对象。</p><p>有3种视图：键集、值集合（不是一个集）以及键/值对集。键和键/值对可以构成一个集，应为映射中一个键值能有一个副本：</p><ul><li><code>Set&lt;K&gt; keySet()</code> <strong>键集</strong></li><li><code>Collection&lt;V&gt; values()</code> <strong>值集</strong></li><li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> <strong>键/值对集</strong></li></ul><p>会分别返回这3个视图。（映射条目集的元素是实现了<code>Map.Entry</code>接口的类的对象）</p><h4 id="链接散列集与映射"><a href="#链接散列集与映射" class="headerlink" title="链接散列集与映射"></a>链接散列集与映射</h4><p><code>LinkedHashSet</code>和<code>LinkedHashMap</code>类会记住插入元素项的顺序。这样就可以避免散列表中的项看起来顺序是随机的。在表中插入元素项时，就会并入到双向列表中，如下图：</p><img src="/2022/06/28/cs-languages/core-java-volume-0/linked_set_map.png" class="" title="linked_set_map"><p>链表散列映射可以使用<strong>访问顺序</strong>而不是插入顺序来迭代处理映射条目。每次调用<code>get</code>或<code>put</code>时，收到影响的项将从当前的位置删除，并放到项链表的尾部（只影响项在链表中的位置，而散列表的桶不会受影响。映射条目总是在键散列码对应的桶中）。要构造这样一个散列映射，需要调用：</p><p><code>LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, true)</code></p><p>访问顺序对于实现缓存的“<strong>最近最少使用</strong>”原则十分重要。</p><h4 id="枚举集与映射"><a href="#枚举集与映射" class="headerlink" title="枚举集与映射"></a>枚举集与映射</h4><p><code>EnumSet</code>是一个枚举类型元素集的高效实现。由于枚举类型只有有限个实例，所以<code>EnumSet</code>内部用位序列实现。如果对应的值在集中，则相应的位被置为<code>1</code>。</p><p><code>EnumSet</code>类没有公共的构造器。要使用静态工厂方法构造这个集：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">enum</span> <span class="token class-name">Weekday</span> <span class="token punctuation">{</span> MONDAY<span class="token punctuation">,</span> TUESDAY<span class="token punctuation">,</span> WEDNESDAY<span class="token punctuation">,</span> THUSDAY<span class="token punctuation">,</span> FRIDAY<span class="token punctuation">,</span> SATURDAY<span class="token punctuation">,</span> SUNDAY<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Weekday</span><span class="token punctuation">&gt;</span></span> always <span class="token operator">=</span> <span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span><span class="token class-name">Weekday</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Weekday</span><span class="token punctuation">&gt;</span></span> never <span class="token operator">=</span> <span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">noneOf</span><span class="token punctuation">(</span><span class="token class-name">Weekday</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Weekday</span><span class="token punctuation">&gt;</span></span> workday <span class="token operator">=</span> <span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token class-name">Weekday</span><span class="token punctuation">.</span>MONDAY<span class="token punctuation">,</span> <span class="token class-name">Weekday</span><span class="token punctuation">.</span>FRIDAY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Weekday</span><span class="token punctuation">&gt;</span></span> mwf <span class="token operator">=</span> <span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token class-name">Weekday</span><span class="token punctuation">.</span>MONDAY<span class="token punctuation">,</span> <span class="token class-name">Weekday</span><span class="token punctuation">.</span>WEDNESDAY<span class="token punctuation">,</span> <span class="token class-name">Weekday</span><span class="token punctuation">.</span>FRIDAY<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用<code>Set</code>接口的常用方法来修饰<code>EnumSet</code>。</p><p><code>EnumMap</code>是一个<strong>键类型</strong>为枚举类型的映射。可以高效地实现为一个值数组。</p><h4 id="标识散列映射"><a href="#标识散列映射" class="headerlink" title="标识散列映射"></a>标识散列映射</h4><p>类<code>IdentityHashMap</code>，键的散列值不是用<code>hashCode</code>函数计算的，而是用<code>System.identityHashCode</code>方法计算的。这是<code>Object.hashCode</code>根据对象的内存地址计算散列码时所使用的方法。而且，**在对两个对象进行比较时，<code>IdentityHashMap</code>类使用<code>==</code>**，而不使用<code>equals</code>。</p><blockquote><p>即，保存的键值即使内容相同，但是不是同一个对象（即内存地址相同）会被视为两个不同的键值。两个值相同但是不是同一个对象的键再添加时，不会相互产生值的覆盖。</p></blockquote><p>也就是说，<strong>不同的键对象即使内容相同，也被视为不同的对象</strong>。在实现对象遍历算法（如对象串行化）时，这个类非常有用，可以用来跟踪哪些对象已经遍历过。</p><h4 id="属性映射"><a href="#属性映射" class="headerlink" title="属性映射"></a>属性映射</h4><p> 属性映射（property map）是一个特殊类型的映射结构，有2个特性：</p><ul><li>键与值都是字符串。</li><li>这个映射可以很容地保存到文件以及从文件加载。</li><li>有一个二级表存放默认值。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> settings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>settings<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"width"</span><span class="token punctuation">,</span> <span class="token string">"600.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>settings<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"filename"</span><span class="token punctuation">,</span> <span class="token string">"/home/qing/books/core_java/code/raven.html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以使用store方法将属性映射列表保存到一个文件中：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"program.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 第二个参数是包含在这个文件中的注释</span><span class="token class-name">Settings</span><span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"Program Properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例如下：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#Program Properties</span><span class="token comment">#Sun Mar 12 17:47:54 CST 2023</span><span class="token attr-name">top</span><span class="token punctuation">=</span><span class="token attr-value">227.0</span><span class="token attr-name">left</span><span class="token punctuation">=</span><span class="token attr-value">1286.0</span><span class="token attr-name">width</span><span class="token punctuation">=</span><span class="token attr-value">423.0</span><span class="token attr-name">height</span><span class="token punctuation">=</span><span class="token attr-value">547.0</span><span class="token attr-name">filename</span><span class="token punctuation">=</span><span class="token attr-value">/home/qing/books/core_java/code/raven.html</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要从文件加载属性，可以使用以下调用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"program.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>settings<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Properties类有两种提供默认值的机制：</p><ol><li><p>查找一个字符串的值，可以指定一个默认值，这样当键不存在时就会自动使用这个默认值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> filename <span class="token operator">=</span> settings<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"filename"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>可以把所有默认值都放在一个二级属性映射中，并在主属性映射的构造器中提供这个二级映射。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> defaultSettings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>defaultSettings<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"width"</span><span class="token punctuation">,</span> <span class="token string">"600"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>defaultSettings<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"height"</span><span class="token punctuation">,</span> <span class="token string">"400"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>defaultSettings<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span>filename<span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用默认值初始化主属性映射</span><span class="token keyword">var</span> settings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span>defaultSettings<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="视图和包装器"><a href="#视图和包装器" class="headerlink" title="视图和包装器"></a>视图和包装器</h3><p><strong>视图</strong>（<code>view</code>）获得其他实现了<code>Collection</code>接口或<code>Map</code>接口的对象。<code>keySet</code>方法就是这样的一个应用例子。<code>keySet</code>方法返回一个实现了Set接口的类对象，由这个类的方法操纵原映射。这种集合称为<strong>视图</strong>。</p><h4 id="小集合"><a href="#小集合" class="headerlink" title="小集合"></a>小集合</h4><p><code>Java9</code>引入了一些静态方法，可以生成给定元素的集和列表，已经给定键/值对的映射：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> names <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Peter"</span><span class="token punctuation">,</span> <span class="token string">"Pual"</span><span class="token punctuation">,</span> <span class="token string">"Mary"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numbers <span class="token operator">=</span> <span class="token class-name">Set</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> scores <span class="token operator">=</span> <span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Peter"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Pual"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Mary"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这些集合对象时<strong>不可修改</strong>的。如果试图修改，会导致一个<code>UnsupportedOperationException</code>异常。</p><blockquote><p><code>Java9</code>之前由一个静态方法<code>Arrays.asList</code>，返回一个可更改但是大小不可变的列表。</p><p>另外还有遗留的方法<code>Collections.emptySet</code>和<code>Collections.singleton</code>。</p><p><code>Collections</code>类包含很多实用方法，这些方法的参数和返回值都是集合。注意与<code>Collection</code>接口区分。</p></blockquote><h4 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h4><p>可以为很多集合建立子范围（<code>subrange</code>）视图。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> group2 <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中第一个索引包含在子列表中，第二个索引不包含在内（<strong>左闭右开</strong>截取）。可以对子范围应用任何操作，而且操作会自动反映到整个列表。</p><h4 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h4><p><code>Collections</code>类可以生成集合的不可修改视图（<code>unmodifiable view</code>）。这些视图对现有集合增加一个运行时检查，如果发现试图对集合进行修改，就会抛出一个异常，集合仍保持不变。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 主要是这8个方法</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableCollection<span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableList<span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableSet<span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableSortedSet<span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableNavigableSet<span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableMap<span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableSortedMap<span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span>unmodifiableNavigableMap<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如，假设想要让某些代码查看但不能修改一个集合的内容，就可以进行以下操作：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">lookAt</span><span class="token punctuation">(</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableList</span><span class="token punctuation">(</span>staff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 之后，在lookAt中对于传递的集合不能进行修改操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h4><p>如果从多个线程访问集合，就必须确保集合不会被意外地破坏。此时，就可以使用试图机制来确保常规集合时线程安全的，对于没有实现线程安全的集合类，就饿可以使用<code>Collections.synchronizedMap</code>方法来将任何一个映射转换成由同步访问方法的Map。</p><h4 id="检查型视图"><a href="#检查型视图" class="headerlink" title="检查型视图"></a>检查型视图</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> safeStrings <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">checkedList</span><span class="token punctuation">(</span>strings<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个视图的<code>add</code>方法将检查插入的对象是否属于给定的类，如果不属于给定的类，就立即抛出一个<code>ClassCastException</code>。</p><blockquote><p>检查型视图受限于虚拟机可以完成的运行时检查。例如，对于<code>ArrayList&lt;Pair&lt;String&gt;&gt;</code>，由于虚拟机有一个“原始”<code>Pair</code>类，所以无法阻止插入<code>Pair&lt;Date&gt;</code>。</p></blockquote><h2 id="图形用户界面程序设计"><a href="#图形用户界面程序设计" class="headerlink" title="图形用户界面程序设计"></a>图形用户界面程序设计</h2><p>暂略</p><h2 id="Swing用户界面组件"><a href="#Swing用户界面组件" class="headerlink" title="Swing用户界面组件"></a><code>Swing</code>用户界面组件</h2><p>暂略</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>每个任务在一个线程（thread）中执行，线程是控制线程的简称。如果一个程序可以同时运行多个线程，则称这个程序是多线程的（multithreaded）。</p><p>多进程与多线程的本质区别在于每个进程都拥有自己的一套变量，而线程则共享数据。共享变量使线程之间的通信比进程之间的通信更有效、更容易。此外，在有些操作系统中，与进程相比较，线程更“轻量级”，创建、撤销一个线程比启动新进程的开销要小得多。</p><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><ol><li><p>将执行这个任务的代码放在一个类的<code>run</code>方法中，这个类要实现<code>Runnable</code>接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token comment">// task code;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>从这个<code>Runnable</code>构造一个<code>Thread</code>对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>启动线程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>这里的<code>Thread</code>就是创建了一个单独的线程去处理任务。线程之间是可以并发运行的。</p><blockquote><p>还可以通过建立<code>Thread</code>类的一个子类来定义线程，如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// task code</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后可以构造这个子类的一个对象，并调用它的<code>start</code>方法。不过，现在不在推荐这种方法。</p></blockquote><blockquote><p><strong>警告</strong>：不要调用<code>Thread</code>类或<code>Runnable</code>对象的run方法。直接调用<code>run</code>方法只会在同一个线程中执行这个任务——而没有启动新的线程。实际上，应当调用<code>Thread.start</code>方法，这会创建一个执行<code>run</code>方法的新线程。</p></blockquote><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>线程有如下6个状态：</p><ul><li><code>New</code>（新建）</li><li><code>Runnable</code>（可运行）</li><li><code>Blocked</code>（阻塞）</li><li><code>Waiting</code>（等待）</li><li><code>Timed waiting</code>（计时等待）</li><li><code>Terminated</code>（终止）</li></ul><p>如果要确定一个线程的当前状态，只需要调用<code>getState</code>方法。</p><h4 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h4><p>当用new操作符创建一个新线程时，如<code>new Thread(r)</code>，这个线程还没有开始运行。这意味着它的状态是新建（<code>new</code>）。当一个线程处于新建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。</p><h4 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h4><p>一旦调用<code>start</code>方法，线程就处于<strong>可运行</strong>（<code>runnable</code>）状态。一个可运行的线程可能长在运行也可能没有运行。要由操作系统为线程提供具体的运行时间。</p><p>一旦<strong>一个线程开始运行，它不一定始终保持运行。事实上，运行中的线程有时需要暂停，让其他线程有机会运行</strong>。线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每个可运行线程一个时间片来执行任务。当时间片用完时，操作系统<strong>剥夺</strong>该线程的运行权，并给另一个线程一个机会来运行。当选择下一个线程时，操作系统会考虑线程的优先级。</p><p>现在所有的桌面以及服务器操作系统都是用<strong>抢占式调度</strong>。但是，想手机这样的小型设备可能使用<strong>协作式调度</strong>。在这样的设备中，一个线程只能在调用<code>yield</code>方法或者被阻塞或等待时才是去控制权。</p><p>在有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当然，如果线程的数目多于处理的数目，调度器还是需要分配时间片的。</p><p><strong>在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行（正是因为这样，这个状态称为“可运行”而不是“运行”）</strong></p><h4 id="阻塞和等待状态"><a href="#阻塞和等待状态" class="headerlink" title="阻塞和等待状态"></a>阻塞和等待状态</h4><p>当线程处于阻塞或等待状态时，它暂时是不活动的。阻塞的造成原因可能如下</p><ul><li>当一个线程试图获取一个内部的对象锁（这里的锁并不是指 <code>java.util.concurrent</code> 库中的<code>Lock</code>），而这个锁目前被其他线程占有，该线程就会被阻塞。当所有其他线程都释放了这个锁，并且线程调度器允许该线程持有这个锁时，它将变成非阻塞状态。</li><li>当线程等待另一个线程通知调度器出现一个条件时，这个线程会进入等待状态。阻塞状态与等待状态并没有太大的区别</li><li>有几个方法有超时参数，调用这些方法会让线程进入计时等待（<code>time waiting</code>）状态。</li></ul><p>线程在获得可运行的“状态”后，根据优先级来判断是否可以抢占正在运行的线程的运行权。</p><img src="/2022/06/28/cs-languages/core-java-volume-0/thread_state.png" class="" title="thread_state"><h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><p>线程会由于以下两个原因之一而终止：</p><ul><li><code>run</code> 方法正常退出，线程自然终止</li><li>因为一个没有捕获的异常终止了<code>run</code>方法，使线程意外终止。</li></ul><h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><h4 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h4><p>当线程的<code>run</code>方法执行方法体中最后一条语句后在执行<code>return</code>语句<strong>返回时</strong>，或者出现了方法中<strong>没有捕获的异常时</strong>，线程将终止。</p><p>还可以通过<code>interrupt</code>方法来<strong>请求终止</strong>一个线程，这时候会设置线程的<strong>中断状态</strong>。这是每个线程都有的<code>boolean</code>标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断。</p><p>如何检查这个中断状态呢？首先调用静态的<code>Thread.currentThread</code>方法获得当前线程，然后调用<code>isInterrupted</code>方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> more work <span class="token keyword">to</span> <span class="token keyword">do</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// do more work</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是，如果线程被阻塞，就无法检查中断状态。这里就需要使用<code>InterruptedException</code>异常。当在一个被<code>sleep</code>或<code>wait</code>调用阻塞的线程上调用<code>interrupt</code>方法时，那个阻塞调用（即<code>sleep</code>或<code>wait</code>调用）将被一个<code>InterruptedException</code>异常中断。（有一些阻塞<code>I/O</code>调用不能被中断，对此应该考虑选择可中断的调用）</p><p><strong>常用的模板思路如下</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// ...</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1. 检查中断标志位</span>             <span class="token comment">// &amp;&amp; more work to do  </span>             <span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 2. 检查中断异常</span>        <span class="token comment">// thread was interrupted during sleep or wait</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment">// cleanup, if required</span>    <span class="token punctuation">}</span>    <span class="token comment">// exiting the run method terminates the thread</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在每次工作迭代之后都调用<code>sleep</code>方法（或者其他可中断方法），<code>isInterrupted</code>检查既没有必要也没有用处。如果设置了中断状态，此时倘若调用<code>sleep</code>方法，它不会休眠。实际上，它会清除中断状态并抛出<code>InterruptedException</code>。因此，使用循环调用了<code>sleep</code>，就不要检测中断状态，而应当捕获<code>InterruptedException</code>异常。如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// ...</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>             <span class="token comment">// &amp;&amp; more work to do  </span>             <span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 检查中断异常</span>        <span class="token comment">// thread was interrupted during sleep or wait</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment">// cleanup, if required</span>    <span class="token punctuation">}</span>    <span class="token comment">// exiting the run method terminates the thread</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在这里有两个非常类似的方法，<code>interrupted</code>和<code>isInterrupted</code>。</p><p><code>interrupted</code>方法时一个静态方法，它检查<strong>当前线程是否被中断</strong>。而且，调用<code>interrupted</code>方法<strong>会清除该线程中的中断状态</strong>。</p><p>另一方面，<code>isInterrupted</code>方法时一个实例方法，可以用来<strong>检查是否有线程被中断</strong>。调用这个方法<strong>不会改变中断状态</strong>。</p></blockquote><p>如果，在处理中想不出在catch子句中可以做什么有意义的工作，可以将其抛出：</p><ul><li>```java<br>void mySubTask() {<br>// …<br>try {<br>    sleep(delay);<br>} catch (InterruptedException e) {<br>    Thread.currentThread().interrupt(); // 设置中断状态，这样一来调用者就可以检测中断状态<br>}<br>// …<br>}<pre class="line-numbers language-none"><code class="language-none">+ ```java  void mySubtask() throws InterruptedException { // 标记抛出异常，提供给调用者去处理      // ...      sleep(delay)       // ...  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将这个线程转换为守护线程（daemon thread）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>守护线程为其他线程提供服务。</p><h4 id="线程名"><a href="#线程名" class="headerlink" title="线程名"></a>线程名</h4><p>默认情况下，线程有容易记的名字，如 Thread-2。同时也可以使用setName方法为线程设置任何名字：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"Web crawler"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在线程转储时可能很有用。</p><h4 id="未捕获异常的处理器"><a href="#未捕获异常的处理器" class="headerlink" title="未捕获异常的处理器"></a>未捕获异常的处理器</h4><p>线程的<code>run</code>方法不能抛出任何检查型异常，但是，非检查型异常可能会导致线程终止。这种情况下，线程会死亡。</p><p>不过，对于可以传播的异常，并没有任何<code>catch</code>子句。实际上，在线程死亡之前，异常会传递到一个用于处理未捕获异常的处理器。</p><p>这个处理器必须属于一个实现了<code>Thread.UncaughtExceptionaHandler</code>接口的类。这个接口只有一个方法 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">uncaughtExctption</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> e<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>单一：可以用<code>setUncaughtExctptionHandler</code>方法为<strong>任何线程安装一个处理器</strong>。</p><p>全局：也可以用<code>Thread</code>类的静态方法<code>setDefaultUncaughtExctptionHandler</code>为<strong>所有线程安装一个默认的处理器</strong>。</p><p>如果没有安装默认处理器，默认处理器则是<code>null</code>。但是，如果没有为单个线程安装处理器，那么处理器就是该线程的<code>ThreadGroup</code>对象。</p><p><code>ThreadGroup</code>类实现了<code>Thread.UncaughtExceptionHandler</code>接口。它的<code>uncaughtException</code>方法执行以下操作：</p><ol><li>如果该线程组有父线程组，那么调用父线程组的<code>uncaughtException</code>方法。</li><li>否则，如果<code>Thread.UncaughtExceptionaHandler</code>方法返回一个非<code>null</code>的处理器，则调用该处理器。</li><li>否则，如果<code>Throwble</code>是<code>ThreadDeath</code>的一个实例，什么都不做。</li><li>否则，将线程的名字以及<code>Throwable</code>的栈轨迹输出到<code>System.err</code>。</li></ol><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>在<code>Java</code>中，每一个线程都有一个优先级。默认一个线程会继承构造它的那个线程的优先级。可以用<code>setPriority</code>方法提高或降低任何一个线程的优先级。可以将优先级设置为<code>MIN_PRIORITY</code>（在<code>Thread</code>类中定义为1）与<code>MAX_PRIORITY</code>（定义为10）之间的任何值。<code>NORM_PRIORITY</code>定义为5、</p><p>线程调度器有机会选择新线程时，首先选择具有较高优先级的线程。但是，<strong>线程优先级高度依赖于系统</strong>。</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>竟态条件（<code>race condition</code>）。主要就是数据同步问题。</p><h4 id="竟态条件的一个例子"><a href="#竟态条件的一个例子" class="headerlink" title="竟态条件的一个例子"></a>竟态条件的一个例子</h4><p>为了避免多线程破坏共享数据，必须学习如何同步存取。使用一个模拟银行交易的例子来说明。</p><p>这里要随机地选择从哪个源账户转账到哪个目标账户：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// CAUTION: unsafe when called from multiple threads</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    accounts<span class="token punctuation">[</span>from<span class="token punctuation">]</span> <span class="token operator">-=</span> amount<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" %10.2f from %d to %d"</span><span class="token punctuation">,</span> amount<span class="token punctuation">,</span> from<span class="token punctuation">,</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    accounts<span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" Total Blance: %10.2f%n"</span><span class="token punctuation">,</span> <span class="token function">getTotalBlance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面时<code>Runnable</code>实例的代码。<code>run</code>方法不断地从一个给定银行账户取钱。在每次迭代中，<code>run</code>方法选择一个随机的目标账户和一个随机金额，调用<code>bank</code>对象的<code>tranfer</code>方法，然后休眠。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> toAccount <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>bank<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">double</span> amount <span class="token operator">=</span> MAX_AMOUNT <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bank<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>fromAccount<span class="token punctuation">,</span> toAccount<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>DELAY <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个模拟程序运行是，不清楚在某一时刻某个银行账户中有多少钱，但是我们知道所有账户的总金额应该保持不变，因为我们所做的只是把钱从一个账户转移到另一个账号。</p><p>每一次交易结束时，<code>transfer</code>方法会重新计算总金额并打印出来。</p><p>这个程序永远不会结束。只能按<code>CTRL+C</code>来终止程序。</p><p>下面时典型的输出：</p><pre class="line-numbers language-log" data-language="log"><code class="language-log">Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span><span class="token number">588.23</span> from <span class="token number">11</span> to <span class="token number">44</span> Total Balance<span class="token operator">:</span><span class="token number">100000.00</span>Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span><span class="token number">684.24</span> from <span class="token number">15</span> to <span class="token number">34</span> Total Balance<span class="token operator">:</span><span class="token number">100000.00</span>Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span><span class="token number">578.73</span> from <span class="token number">21</span> to <span class="token number">51</span> Total Balance<span class="token operator">:</span><span class="token number">100000.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span><span class="token number">288.23</span> from <span class="token number">13</span> to <span class="token number">14</span> Total Balance<span class="token operator">:</span><span class="token number">90200.03</span>Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span><span class="token number">583.23</span> from <span class="token number">31</span> to <span class="token number">24</span> Total Balance<span class="token operator">:</span><span class="token number">90200.03</span>Thread<span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span><span class="token number">988.23</span> from <span class="token number">51</span> to <span class="token number">45</span> Total Balance<span class="token operator">:</span><span class="token number">90200.03</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，这里出现了错误。对于最初的几次交易，银行余额保持在100000，这是正确的，因为共1000个账户，每个账户1000。不过，经过一段时间后，余额有轻微的变化。运行这个程序的时候，可能很快就能发现出错了，有时可能需要很长的时间才能发现余额不对。</p><p>完整的示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token comment">/** * A bank with a number of bank accounts. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bank</span><span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> accounts<span class="token punctuation">;</span>   <span class="token comment">/**    * Constructs the bank.    * @param n the number of accounts    * @param initialBalance the initial balance for each account    */</span>   <span class="token keyword">public</span> <span class="token class-name">Bank</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> initialBalance<span class="token punctuation">)</span>   <span class="token punctuation">{</span>      accounts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>accounts<span class="token punctuation">,</span> initialBalance<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment">/**    * Transfers money from one account to another.    * @param from the account to transfer from    * @param to the account to transfer to    * @param amount the amount to transfer    */</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span>   <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>accounts<span class="token punctuation">[</span>from<span class="token punctuation">]</span> <span class="token operator">&lt;</span> amount<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      accounts<span class="token punctuation">[</span>from<span class="token punctuation">]</span> <span class="token operator">-=</span> amount<span class="token punctuation">;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %10.2f from %d to %d"</span><span class="token punctuation">,</span> amount<span class="token punctuation">,</span> from<span class="token punctuation">,</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      accounts<span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" Total Balance: %10.2f%n"</span><span class="token punctuation">,</span> <span class="token function">getTotalBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment">/**    * Gets the sum of all account balances.    * @return the total balance    */</span>   <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getTotalBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>      <span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">double</span> a <span class="token operator">:</span> accounts<span class="token punctuation">)</span>         sum <span class="token operator">+=</span> a<span class="token punctuation">;</span>      <span class="token keyword">return</span> sum<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment">/**    * Gets the number of accounts in the bank.    * @return the number of accounts    */</span>   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>      <span class="token keyword">return</span> accounts<span class="token punctuation">.</span>length<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * This program shows data corruption when multiple threads access a data structure. * @version 1.32 2018-04-10 * @author Cay Horstmann */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnsynchBankTest</span><span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NACCOUNTS <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">double</span> INITIAL_BALANCE <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">double</span> MAX_AMOUNT <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DELAY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>   <span class="token punctuation">{</span>      <span class="token keyword">var</span> bank <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bank</span><span class="token punctuation">(</span>NACCOUNTS<span class="token punctuation">,</span> INITIAL_BALANCE<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NACCOUNTS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>         <span class="token keyword">int</span> fromAccount <span class="token operator">=</span> i<span class="token punctuation">;</span>         <span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span>            <span class="token punctuation">{</span>               <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>               <span class="token punctuation">{</span>                  <span class="token keyword">int</span> toAccount <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>bank<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">double</span> amount <span class="token operator">=</span> MAX_AMOUNT <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  bank<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>fromAccount<span class="token punctuation">,</span> toAccount<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>DELAY <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span>            <span class="token punctuation">{</span>            <span class="token punctuation">}</span>                     <span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>         t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="竟态条件详解"><a href="#竟态条件详解" class="headerlink" title="竟态条件详解"></a>竟态条件详解</h4><p>上一节运行了一个程序，其中有几个线程会更新银行银行余额。一段时间之后，不知不觉地出现了错误，可能有些钱会丢失，也可能几个账户同时有钱进账。当两个线程试图同时更新同一个账户时，就会出现这个问题。假设两个线程同时执行指令</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">accounts<span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>问题在于这不是原子操作哦。这个指令可能如下处理：</p><ol><li>将<code>accounts[to]</code>加载到寄存器。</li><li>增加<code>amount</code>。</li><li>将结果写回<code>accounts[to]</code>。</li></ol><p>现在，假定第1个线程执行步骤1和步骤2，然后，它的运行权被抢占。在假设第2个线程被唤醒，更新<code>account</code>数组中的同一个元素。然后，第1个线程被唤醒并完成其第3步。</p><p>这个动作会抹除第2个线程所作的更新。这样一来，总金额就不再正确了。如下图</p><img src="/2022/06/28/cs-languages/core-java-volume-0/transfer_thread_00.png" class="" title="transfer_thread_00"><blockquote><p>实际上可以查看执行这个类中每一个语句的虚拟机字节码。运行以下命令</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">javap <span class="token operator">-</span>c <span class="token operator">-</span>v <span class="token class-name">Bank</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对Bank.class文件进行反编译。例如，代码行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">accounts<span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会转换为下面的字节码：</p><pre class="line-numbers language-ABAP" data-language="ABAP"><code class="language-ABAP">aload_0getfield#2 // Field accounts:[Diload_2dup2daloaddload_3dadddastore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些代码的含义无关紧要。重要的是这个增加命令是由多条指令组成的，执行这些指令的线程可以在任何一条指令上被中断。</p></blockquote><p>在一个有多个核心的现代处理器上，出问题的风险相当高。</p><p>如果能够确保线程失去控制之前方法已经运行完成，那么银行账户对象的状态就不会被破坏。</p><h4 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h4><p>有两种机制可以防止并发访问代码块。<code>Java</code>语言提供了一个<code>synchronized</code>关键词来达到这一目的，另外<code>Java 5</code>引入了<code>ReentrantLock</code>类。 <code>synchronized</code>关键字会自动提供一个锁以及相关的“条件”，对于大多数需要显示锁的情况，这种机制功能很强大，也很便利。</p><p>用<code>ReentrantLock</code>保护代码块的基本结构如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">myLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// a ReentrantLock object</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// critical section</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    myLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// make sure the lock is unlocked even if an exception is thrown</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个结构确保<strong>任何时刻只有一个线程进入临界区。一旦一个线程锁定了锁对象，其他任何线程都无法通过<code>lock</code>语句</strong>。当其他线程调用<code>lock</code>时，它们会暂停，知道第一个线程释放这个锁对象。</p><blockquote><p><strong>警告</strong>：<strong>要把unlock操作包括在finally子句中，这一点至关重要</strong>。如果在临界区的代码抛出一个异常，锁必须释放。否则，其他线程将永远阻塞。</p></blockquote><blockquote><p><strong>注意</strong>：<strong>使用锁时，就不能使用<code>try-with-resources</code>语句</strong>。首先，解锁方法名不是<code>close</code>。不过，即使将它重命名，<code>try-with-resources</code>语句也无法正常工作。它的首部希望声明一个新变量。但是如果使用一个锁，你可能想使用多个线程共享那个变量（而不是新变量）。</p></blockquote><p>非同步线程与同步线程的比较</p><img src="/2022/06/28/cs-languages/core-java-volume-0/transfer_thread_01.png" class="" title="transfer_thread_01"><p>注意每个<code>Bank</code>对象都有自己的<code>ReentrantLock</code>对象。如果两个线程试图访问同一个<code>Bank</code>对象，那么锁可以用来保证串行化访问。不过，如果两个线程访问不同的<code>Bank</code>对象，每个线程会得到不同的锁对象，两个线程都不会阻塞。本应该如此，因为线程在操纵不同的<code>Bank</code>实例时，线程之间不会相互影响。</p><p>这个锁称为<strong>重入（<code>reentrant</code>）锁</strong>，因为线程可以反复获得已拥有的锁。锁有一个<strong>持有计数</strong>（<code>hold count</code>）来跟踪对<code>lock</code>方法的嵌套调用。线程每一次调用lock后都要调用<code>unlock</code>来释放锁。由于这个特性，被一个锁保护的代码可以调用另一个使用相同锁的方法。</p><blockquote><p><strong>警告</strong>：要注意确保临界区中的代码不要因为抛出异常而跳出临界区。如果在临界区代码结束之前抛出了异常，<code>finally</code>子句将释放锁，但是对象可能处于被破坏的状态。</p></blockquote><h4 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h4><p>通常，线程进入临界区后却发现只有满足了某个条件之后它才能执行。可以使用一个<strong>条件对象</strong>来管理那些已经获得了一个锁却不能做有用工作的线程。在这一节里，将会介绍Java库中条件对象的实现（由于历史原因，条件对象经常被称为条件变量（<code>confitional variable</code>））。</p><p>如下所示，假定只有当账户中的金额大于要转出的金额时才可以转账。如果某个线程刚刚获得对<code>bankLock</code>的<strong>排他性访问权</strong>，如果此时账户中资金不足，则无法完成转账操作，但是又因为锁的存在，别的线程没有存款的机会，这里就会产生死锁问题，这种情况下就可以引入条件对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Bank</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Confition</span> sufficientFunds<span class="token punctuation">;</span>    <span class="token comment">// ...</span>    <span class="token keyword">public</span> <span class="token class-name">Bank</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// ...</span>        sufficientFunds <span class="token operator">=</span> bankLock<span class="token punctuation">.</span><span class="token function">newConfition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建条件对象来表示“资金充足”条件。</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果transfer方法发现资金不足，就会调用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">sufficientFuns<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>当前线程现在暂停，并放弃锁。这就允许另一个线程执行</strong>，来增加账户余额。</p><p>一旦一个线程调用了await方法，它就会进入这个条件的等待集（wait set）。当锁可用时，该线程并不会变为可运行状态。实际上，它仍保持非活动那个状态，直到另一个线程在同一条件上调用signalAll方法。当另外一个线程完成转账时，它应该调用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">sufficientFunds<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 启动所有的等待线程</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个调用会重新激活等待这个条件的所有线程。当这些线程从等待集中移出时，它们再次成为可运行的线程，调度器最终将再次将它们激活。同时，它们会尝试重新进入该对象。一旦锁可用，它们中的某个线程将从<code>await</code>调用返回，得到这个锁，<strong>并从之前暂停的地方继续执行</strong>。</p><p><code>signalAll</code>方法仅仅时通知等待的线程：现在<strong>有可能</strong>满足条件，值得再次检查条件。</p><blockquote><p><strong>注释</strong>：t通常，await调用应该放在如下形式的循环中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>OK <span class="token keyword">to</span> <span class="token namespace">proceed</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><p>当一个线程调用<code>await</code>时，它没有办法重新自行激活。它寄希望于其他线程。如果没有其他线程来重新激活等待的线程，它就永远不再运行了。这将导致<strong>死锁</strong>（<code>deadlock</code>）现象。如果所有其他线程都被阻塞，最后一个活动线程调用了<code>await</code>方法但没有先解除另外某个线程的阻塞，现在这个线程也会阻塞。此时没有线程可以解除其他线程的阻塞状态，程序会永远挂起<strong>。所以至关重要的一点，最终必须要有某个其他线程调用<code>signalAll</code>方法激活线程</strong>。</p><p>注意<code>signalAll</code>调用<strong>不会立即激活一个等待的线程</strong>。它姿势解除等待线程的阻塞，使这些线程可以在当前线程释放锁之后竞争访问对象。</p><p>当然也可以调用<code>signal</code>只是随机选择等待集中的一个线程解锁，但是如果被解锁的线程仍旧不能运行，它就会被再次阻塞。如果此时没有其他线程再次调用<code>signal</code>，系统就会进入死锁。</p><blockquote><p><strong>警告</strong>：只有当线程拥有一个条件的锁时，它才能在这个条件上调用<code>await</code>、<code>signalAll</code>或<code>signal</code>方法。</p></blockquote><p>当然加入了以上的控制手段之后，整个程序运行起来要慢一些，这是为了实现同步机制所涉及的额外工作付出的代价。</p><h4 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a><code>synchronized</code>关键字</h4><p>在上一个小节，了解了<code>Lock</code>和<code>Condition</code>对象，先对锁和条件的要点做个总结：</p><ul><li>锁用来保护代码片段，一次只能由一个线程执行被保护的代码。</li><li>锁可以管理试图进入被保护代码段的线程。</li><li>一个锁可以有一个或多个相关联的条件对象。</li><li>每个条件对象管理那些已经进入被保护代码段但还不能运行的线程。</li></ul><p><code>Java</code>中的<strong>每个对象都有一个内部锁</strong>。如果一个方法声明时有<code>synchronized</code>关键字，那么对象的锁将保护整个方法，也就是要调用这个方法，线程必须获得内部对象锁。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// method body</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等价于</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>intrinsicLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// method body</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>intrinsicLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注释</strong>：<code>wait</code>、<code>notifyAll</code>以及<code>notify</code>方法是<code>Object</code>类的<code>final</code>方法。<code>Condition</code>方法必须命名为<code>await</code>、<code>signalAll</code>和<code>signal</code>，从而不会与那些方法发生冲突。</p></blockquote><p>经静态方法声明为同步也是合法的。如果调用这样的一个方法，它会获得相关类对象的内部锁。</p><p>内部锁和条件存在一些限制。包括：</p><ul><li>不能中断一个正在尝试获得锁的线程。</li><li>不能指定尝试获得锁时的超时时间。</li><li>每个锁仅有一个条件可能时不够的。</li></ul><p>对<code>Lock</code>和<code>Condition</code>对象的使用建议：</p><ul><li>最好既不使用<code>Lock/Condition</code>也不使用<code>synchronized</code>关键字。使用<code>java.util.concurrent</code>包中的某种机制，它会为你处理所有的锁定。例如，使用阻塞队列来同步完成一个共同任务的线程。</li><li>如果<code>synchronized</code>关键字适合你的程序，那么尽量使用这种做法，这样可以减少编写的代码量，还能减少出错的概率。</li><li>如果特别需要<code>Lock/Condition</code>结构提供的额外能力，则使用<code>Lock/Condition</code></li></ul><h4 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h4><p>每一个<code>Java</code>对象都有一个锁，线程可以通过调用同步方法获得锁。还有另一种机制可以获得锁：即进入一个同步块。当线程进入如下形式的块时：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// this is the syntax for a synchronized block</span>    <span class="token comment">// critical section</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它会获得<code>obj</code>的锁。</p><p>有时我们会发现一些“专用”锁，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bank</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> accounts<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// an ad-hoc lock</span>            accounts<span class="token punctuation">[</span>from<span class="token punctuation">]</span> <span class="token operator">-=</span> amount<span class="token punctuation">;</span>            accounts<span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">]</span> <span class="token operator">+=</span> amount<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，创建<code>lock</code>对象只是为了使用每个<code>Java</code>对象拥有的锁。</p><p>使用一个对象的锁来实现额外的原子操作，这种做法称为<strong>客户端锁定</strong>（<code>client-side locking</code>）</p><p>但是完全依赖于<code>Bank</code>类对自己的所有更改方法使用内部锁，但是如果开发者没有在文档中标注这些限定，那就需要自己去越多源代码，从这个角度看，<strong>客户端锁定是非常脆弱的，通常不推荐使用</strong>。</p><h4 id="监控器"><a href="#监控器" class="headerlink" title="监控器"></a>监控器</h4><p>监控器具有如下特性：</p><ul><li>监视器是只包含私有字段的类。</li><li>监视器类的每个对象有一个关联的锁。</li><li>所有方法由这个锁锁定。换句话说，如果客户端调用<code>obj.method()</code>，那么<code>obj</code>对象的锁在方法调用开始时自动获得，并且当方法返回时自动释放该锁。因此所有的字段是私有的，这样的安排可以确保一个线程处理字段时，没有其他线程能够访问这些字段。</li><li>锁可以由任意多个相关联的条件。</li></ul><h4 id="volatile字段"><a href="#volatile字段" class="headerlink" title="volatile字段"></a><code>volatile</code>字段</h4><p><code>volatile</code>关键字为实例字段的同步访问提供了一种免锁机制。如果声明一个字段为<code>volatile</code>，那么编译器和虚拟机就知道该字段可能被另一个线程并发更新。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> done<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> done<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>编译器会插入适当的代码，以确保如果一个线程对done变量做了修改，这个修改对读取这个变量的所有其他线程都可见。</p><blockquote><p>volatile 变量不能提供原子性。例如，方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">flipDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> done <span class="token operator">=</span> <span class="token operator">!</span>done<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// not atomic</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不能确保翻转字段中的值。不能保证读取、翻转和写入不被中断。</p></blockquote><h4 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a><code>final</code>变量</h4><p>还可以考虑使用final声明：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">var</span> accounts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他线程会在构造器完成构造之后才看到这个<code>accounts</code>变量。</p><p>如果不使用<code>final</code>，就不能保证其他线程看到的是<code>accounts</code>更新后的值，它们可能都只是看到<code>null</code>，而不是新构造的<code>HashMap</code>。</p><p>当然，<strong>对这个映射的操作并不是线程安全的</strong>。如果有多个线程更改和读取这个映射，仍然需要进行同步。</p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>假设对共享变量除了赋值之外并不做其他操作，那么可以将这些共享变量声明为<code>volatile</code>。</p><p><code>java.util.concurrent.atomic</code>包中很多类使用了很高效的机器级指令（而没有使用锁）来保证其他操作的原子性。例如，<code>AtomicInteger</code>类提供了方法<code>incrementAndGet</code>和<code>decrementAndGet</code>，它们分别以原子方式将一个整数进行自增或自减。</p><p>如果有大量线程要访问相同的原子值，性能会大幅下降，因此乐观更新需要太多次重试。</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>锁和条件不能解决多线程中可能出现的所有问题，例如：</p><ol><li>账户1：200</li><li>账户2：300</li><li>线程1：从账户1转300到账户2</li><li>线程2：从账户2转400到账户1</li></ol><p>如果在线程转账时有条件限定，需要大于转账金额才能转账，则两个线程都会因为要等待更多的钱款存入而导致所有的线程进入<strong>阻塞状态</strong>。这样的状态称为<strong>死锁</strong>（<code>deadlock</code>）</p><blockquote><p>当程序挂起时，按下 <code>Ctrl + \</code>，将得到一个线程转储，这会累出所有线程。</p></blockquote><p><strong>遗憾的是，<code>Java</code>编程语言中没有任何东西可以避免或打破这种死锁。必须仔细设计程序，确保不会出现死锁</strong>。</p><h4 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h4><p>线程间共享变量存在风险，有时可能要避免共享变量，使用<code>ThreadLocal</code>辅助类为各个线程提供各自的实例。例如，<code>SimpleDateFormat</code>类不是线程安全的。假设有一个静态变量：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">SimpleDateFormat</span> dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果两个线程都执行以下操作：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> dateStamp <span class="token operator">=</span> dateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果可能很混乱，因为<code>dateFormat</code>使用的内部数据结构可能会被并发的访问所破坏。当然可以使用同步，但开销很大；或者也可以在需要时构造一个局部<code>SimpleDateFormat</code>对象，不过这样很浪费。</p><p>可以考虑为每个线程构造一个实例的方式来避免错误产生：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SimpleDateFormat</span><span class="token punctuation">&gt;</span></span> dateFormat <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用时，使用如下格式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> dateStamp <span class="token operator">=</span> dateFormat<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样在给定线程中首次调用<code>get</code>时，会调用构造器中的<code>lambda</code>表达式。在此之后，<code>get</code>方法会返回属于当前线程的那个实例。</p><h3 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h3><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，<strong>阻塞队列</strong>（<code>blocking queue</code>）将导致线程阻塞。在协调多个线程之间的合作时，阻塞队列是一个有用的工具。</p><p>阻塞队列方法：</p><table><thead><tr><th>方法</th><th>正常动作</th><th>特殊情况下的动作</th></tr></thead><tbody><tr><td><code>add</code></td><td>添加一个元素</td><td>如果队列满，则抛出<code>IllegalStateException</code>异常</td></tr><tr><td><code>element</code></td><td>返回队头元素</td><td>如果队列空，则抛出<code>NoSuchElementException</code>异常</td></tr><tr><td><code>offer</code></td><td>添加一个元素并返回true</td><td>如果队列满，则返回<code>false</code></td></tr><tr><td><code>peek</code></td><td>返回队头元素</td><td>如果队列空，则返回 <code>null</code></td></tr><tr><td><code>poll</code></td><td>移除并返回队头元素</td><td>如果队列空，则返回<code>null</code></td></tr><tr><td><code>put</code></td><td>添加一个元素</td><td>如果队列满，则阻塞</td></tr><tr><td><code>remove</code></td><td>移除并返回队头元素</td><td>如果队列空，则抛出<code>NoSuchElementException</code>异常</td></tr><tr><td><code>take</code></td><td>移除并返回队头元素</td><td>如果队列空，则阻塞</td></tr></tbody></table><blockquote><p><strong>注释</strong>：<code>poll</code>和<code>peek</code>方法返回<code>null</code>来指示失败。因此，向这些队列中插入<code>null</code>值时非法的。</p></blockquote><p><code>java.util.concurrent</code>包提供了阻塞队列的几个变体。默认情况下</p><ul><li><code>LinkedBlockingQueue</code>的容量没有上界，但是也可以选择指定一个最大容量。</li><li><code>LinkedBlockingDeque</code>是一个双端队列。</li><li><code>ArrayBlockingQueue</code>在构造时需要指定容量，并且有一个可选的参数来指定是否需要公平性。若设置了公平参数，那么等待了最长时间的线程会优先得到处理。通常，公平性会降低性能，只有在确实非常需要时才使用公平参数。</li><li><code>PriorityBlockingQueue</code>时一个优先队列，而不是先进先出队列。元素按照它们的优先级顺序移除。这个队列没有容量上限，但是，如果队列时空的，获取元素的操作会阻塞。</li><li><code>TransferQueue</code>接口，允许生产者线程等待，直到消费者准备就绪可以接受元素。如果生产者调用<code>q.transfer(item);</code>这个调用会阻塞，直到另一个线程将元素（<code>item</code>）删除。</li></ul><h4 id="高效的映射、集和队列"><a href="#高效的映射、集和队列" class="headerlink" title="高效的映射、集和队列"></a>高效的映射、集和队列</h4><p><code>java.util.concurrent</code>包提供了映射、有序集和队列的高效实现：<code>ConcurrentHashMap</code>、<code>ConcurrentSkipListMap</code>、<code>ConcurrentSkipListSet</code>和<code>ConcurrentLinkedQueue</code>。</p><p><strong>这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分尽可能减少竞争</strong>。</p><p>与大多数集合不同，这些类的<code>size</code>方法不一定在常量时间内完成操作。确定这些集合的当前大小通常需要遍历。</p><p>并发散列映射可以高效地支持大量阅读器和一定数量的书写器。默认情况下认为可以有至多16个同时运行的书写器线程。当然可以有更多的书写器线程，但是，同一时间如果多于16个，其他线程将暂时阻塞。可以在构造器中指定更大数目，不过，通常都没有这种必要。</p><blockquote><p>散列映射将相同散列码的所有条目放在同一个“桶”中。不过，在较新的<code>Java</code>版本中<strong>，并发散列映射将桶组织为树</strong>，而不是列表，键类型实现<code>Comparable</code>，从而可以保证性能为<code>O(log(n))</code>。</p></blockquote><h4 id="对并发散列映射的批操作"><a href="#对并发散列映射的批操作" class="headerlink" title="对并发散列映射的批操作"></a>对并发散列映射的批操作</h4><p><code>Java API</code>为并发散列映射提供了批操作，即使有其他线程在处理映射，这些操作也能安全地执行。批操作会遍历映射，处理遍历过程中找到的元素。这里不会冻结映射的当前快照。除非恰好直到批操作运行时映射不会被修改，否则就要把结果看作是映射的一个近似。</p><p>有3种不同的操作：</p><ul><li><code>search</code>（搜索）为每个键或值应用一个函数，直到函数生成一个非null的结果。然后搜索终止，返回这个函的结果。</li><li><code>reduce</code>（归约）组合所有键或值，这里要使用所提供的一个累加函数。</li><li><code>forEach</code>为所有键或值应用一个函数。</li></ul><p>每个操作都有4个版本：</p><ul><li><code>operationKeys</code>：处理键</li><li><code>operationValues</code>：处理值</li><li><code>operation</code>：处理键和值</li><li><code>operationEntries</code>：处理<code>Map.Entry</code>对象</li></ul><h4 id="并发集视图"><a href="#并发集视图" class="headerlink" title="并发集视图"></a>并发集视图</h4><p>如果需要一个很大的线程安全的集而不是映射，并没有<code>ConcurrentHashSet</code>类，可以使用<code>ConcurrentHashMap.newKeySet()</code>方法生成一个<code>Set&lt;K&gt;</code>，这实际上是<code>ConcurrentHashMap&lt;K, Boolean&gt;</code>的一个包装器。（所有映射值都为<code>Boolean.TRUE</code>，不过因为只是要把它用作一个集，所以并不关系映射值。）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> words <span class="token operator">=</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token function">newKeySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，如果原先有一个映射，<code>keySet</code>方法可以生成这个映射的键值。这个集是可更改的。</p><h4 id="写数组的拷贝"><a href="#写数组的拷贝" class="headerlink" title="写数组的拷贝"></a>写数组的拷贝</h4><p><code>CopyOnWriteArrayList</code>和<code>CopyOnWeiteArraySet</code>是线程安全的集合，其中所有更改器会建立底层数组的一个副本。如果迭代访问集合的线程数超过更改集合的线程数，这样的安排是很有用的。当构造一个迭代器的时候，它包含当前数组的一个引用。如果这个数组后来被更改了，迭代器仍然引用旧数组，但是，集合的数组已经替换。因而，<strong>原来的迭代器可以访问一致的（但可能过时的）视图</strong>，而且不存在任何同步开销。</p><h4 id="并行数组算法"><a href="#并行数组算法" class="headerlink" title="并行数组算法"></a>并行数组算法</h4><p><code>Arrays</code>类提供了大量并行化操作。静态<code>Arrays.parallelSort</code>方法可以对一个基本类型值或对象数组排序。</p><h4 id="较早的线程安全集合"><a href="#较早的线程安全集合" class="headerlink" title="较早的线程安全集合"></a>较早的线程安全集合</h4><p>从<code>Java</code>的初始版本开始，<code>Vector</code>和<code>Hashtable</code>类就提供了动态数组和散列表的线程安全的实现。现在这些类被认为已经过时，而被<code>ArrayList</code>和<code>HashMap</code>类所取代。不过，那些类不是线程安全的，实际上，集合库中提供了一种不同的机制。任何集合类都可以通过使用<strong>同步包装器</strong>（synchronization wrapper）变成线程安全的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> synchArrayList <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> synchHashMap <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果集合的方法使用锁加以保护，可以提供线程安全的访问。</p><h3 id="任务和线程池"><a href="#任务和线程池" class="headerlink" title="任务和线程池"></a>任务和线程池</h3><p>构造一个新的线程开销有些大，因为这涉及与操作系统的交互。如果你的程序中创建了大量的生命期很短的线程，那么不应该把每个任务映射到一个单独的线程，而应该使用<strong>线程池</strong>（<code>thread pool</code>）。线程池中包含需要准备运行的线程。为线程池提供一个<code>Runnable</code>，就会有一个线程调用<code>run</code>方法。当<code>run</code>方法退出时，这个线程不会死亡，而是留在池中准备给下一个请求提供服务。</p><h4 id="Callable与Future"><a href="#Callable与Future" class="headerlink" title="Callable与Future"></a><code>Callable</code>与<code>Future</code></h4><p><code>Runnable</code>封装一个异步运行的任务，可以把它想象成一个没有参数和返回值的异步任务。<code>Callable</code>与<code>Runnable</code>类似，但是又返回值。<code>Callable</code>接口时一个参数化的类型，只有一个方法<code>call</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token class-name">V</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>Future</code>保存异步计算的<strong>结果</strong>。可以启动一个计算，将<code>Future</code>对象交给某个线程，然后忘掉它。这个<code>Future</code>对象的所有者在结果计算好之后就可以获得结果。</p><p><code>Future&lt;V&gt;</code>接口又下面的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterrupt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个<code>get</code>方法的调用会阻塞，直到计算完成。</p><p>第二个<code>get</code>方法也会阻塞，不过如果在计算完成之前调用超时，会抛出一个<code>TimeoutException</code>。如果计算已经完成，那么<code>get</code>方法立即返回。</p><p>如果计算还在进行，<code>isDone</code>方法返回<code>false</code>；如果已经完成，则返回<code>true</code>。</p><p>可以用<code>cancel</code>方法取消计算。如果计算还没有开始，它会被取消而且不再开始。如果计算正在进行，那么如果<code>mayInterrupt</code>参数为<code>true</code>，它就会被中断。</p><blockquote><p><strong>警告</strong>：取消一个任务涉及两个步骤。必须找到并中断底层线程。另外任务实现（在<code>call</code>方法中）必须感知到中断，并放弃它的工作。如果一个<code>Future</code>对象不知道任务在哪个线程中执行，或者如果任务没有监视执行任务的线程的中断状态，那么取消任务没有任何效果。</p></blockquote><p>执行<code>Callable</code>的一种方法时使用<code>FutureTask</code>，它实现了<code>Future</code>和<code>Runnable</code>接口，所以可以构造一个线程来运行这个任务：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span>integer<span class="token punctuation">&gt;</span></span> task <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token keyword">var</span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// is's a Runnable</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//...</span><span class="token class-name">Integer</span> result <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// it's a Future</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p><strong>执行器</strong>（<code>Executors</code>）类又许多静态工厂方法，用来构造线程池。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>newCachedThreadPool</code></td><td>必要时创建新线程；空闲线程会保留60秒</td></tr><tr><td><code>newFixedThreadPool</code></td><td>池中包含固定数目的线程；空闲线程会一直保留</td></tr><tr><td><code>newWorkStealingPool</code></td><td>一种适合“fork-join”任务的线程池，其中复杂的任务会分解为更简单的任务，空闲线程会“密取”较简单的任务</td></tr><tr><td><code>newSingleThreadExecutor</code></td><td>只有一个线程的“池”，会顺序地执行所提交的任务，适合于性能分析，做对照组</td></tr><tr><td><code>newScheduledThreadPool</code></td><td>用于调度执行的固定线程池</td></tr><tr><td><code>newSingleThreadScheduledExecutor</code></td><td>用于调度执行的单线程“池”，适合于性能分析，做对照组</td></tr></tbody></table><p><code>newCachedThreadPool</code>方法构造一个线程池，会立即执行各个任务，如果又空闲线程可用，就使用现有空闲线程执行任务；如果没有可用的空闲线程，则创建一个新线程。</p><p><code>newFixedThreadPool</code>方法构造一个具有固定大小的线程池。如果提交的任务数多于空闲线程数，就把未得到服务的任务放到队列中。当其他任务完成以后再运行这些排队的任务。</p><p><code>newSingleThreadExecutor</code>是一个退化了的大小为1的线程池：由一个线程顺序地执行所提交的任务。</p><p>以上三个方法返回实现了<code>ExecutorService</code>接口的<code>ThreadPoolExecutor</code>类的对象。</p><p>可以下面的方法之一将<code>Runnable</code>或<code>Callable</code>对象提交给<code>ExecutorService</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">T</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 完成时返回指定的result对象。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>线程池会再方便的时候今早执行提交的任务。</p><p>使用完一个线程池时，调用<code>shutdown</code>。这个方法启动线程池的关闭序列。被关闭的执行器不再接受新的任务。当所有任务都完成时，线程池中的线程死亡。另一种方法是调用<code>shutdownNow</code>。线程池会取消所有尚未开始的任务。</p><ol><li>调用Executors类的静态方法<code>NewCachedThreadPool</code>或<code>newFixedThreadPool</code>。</li><li>调用<code>submit</code>提交<code>Runnable</code>或Callable对象。</li><li>保存好返回的<code>Future</code>对象，以便得到结果或者取消任务。</li><li>当不想再提交任何任务时，调用<code>shutdown</code></li></ol><p><code>ScheduledExecutorService</code>接口为调度执行或重复执行任务提交了一些方法。</p><h4 id="fork-join框架"><a href="#fork-join框架" class="headerlink" title="fork-join框架"></a><code>fork-join</code>框架</h4><p><code>fore-join</code>框架使用了一种有效的只能方法来平衡可用线程的工作负载，这种方法称为<strong>工作密取</strong>（<code>work stealing</code>）。</p><h3 id="异步计算"><a href="#异步计算" class="headerlink" title="异步计算"></a>异步计算</h3><p>无等待或<strong>异步</strong>计算</p><h4 id="可完成Future"><a href="#可完成Future" class="headerlink" title="可完成Future"></a>可完成<code>Future</code></h4><p>当有一个<code>Future</code>对象时，需要调用<code>get</code>来获得值，这个方法会阻塞，直到值可用。<code>CompletableFuture</code>类实现了<code>Future</code>接口，它提供了获得结果的另一种机制。<strong>通过注册一个回调，一旦结果而可用，就会（再某个线程中）利用该结果调用这个回调。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>f<span class="token punctuation">.</span><span class="token function">thenAccept</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> <span class="token comment">// Process the result string s</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过这种方式，无需阻塞就可以再结果可用时对结果进行处理。</p><p>大多数情况下，都需要建立自己的<code>CompletableFuture</code>。要想异步运行任务并得到<code>CompletableFuture</code>，不要把它直接调用给执行器服务，而应该调用静态方法<code>CompletableFuture.supplyAsync</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">readPage</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">openStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UncheckedIOException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> executor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果省略执行器，任务会在一个默认执行器上运行（具体就是<code>ForkJoinPool.commonPoll()</code>返回的执行器）。</p><blockquote><p><strong>警告</strong>：注意<code>supplyAsync</code>方法的第一个参数是一个<code>Supplier&lt;T&gt;</code>，而不是<code>Callable&lt;T&gt;</code>。这两个接口都描述了无参数而且返回值类型为<code>T</code>的函数，不过<code>Supplier</code>函数不能抛出检查型异常。送上面的代码可以看到，这不是一个令人鼓舞的选择。</p></blockquote><p><code>CompletableFuture</code>可以采用两种方式完成：得到一个结果，或者由一个未捕获的异常。要处理这两种情况，可以使用<code>whenComplete</code>方法。要对结果（或者如果没有就为<code>null</code>）和异常（或者如果没有就为<code>null</code>）调用所提供的函数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">f<span class="token punctuation">.</span><span class="token function">whenComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// Process the result s;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// Process the Throwable t;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>CompletableFuture</code>之所以被称为时可完成的，是因为可以手动地设置一个完成值。（在其他并发库中，这样的对象称为承诺（<code>promise</code>）。）当然，用<code>supplyAsync</code>创建一个<code>CompetableFuture</code>时，任务完成时就会隐式地设置完成值。不过，显示地设置结果可以提供更大的灵活性。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>exector<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">workHard</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    f<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">workSmart</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    f<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 要对一个异常完成future，需要调用</span><span class="token class-name">Throwable</span> t <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>f<span class="token punctuation">.</span><span class="token function">completeExceptionally</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以在多个线程中在同一个<code>future</code>上安全地调用complete或<code>completeExceptionally</code>。如果这个<code>future</code>已经完成，这些调用没有任何作用。</p></blockquote><blockquote><p>与普通的<code>Future</code>不同，调用<code>cancel</code>方法时，<code>CompletableFuture</code>的计算不会中断。取消只会把这个<code>Future</code>对象设置为以异常方式完成（有一个<code>CancellationException</code>异常）。</p></blockquote><h4 id="组合可完成Future"><a href="#组合可完成Future" class="headerlink" title="组合可完成Future"></a>组合可完成<code>Future</code></h4><p>为<code>CompletableFuture&lt;T&gt;</code>对象增加一个动作</p><table><thead><tr><th>方法</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>thenApply</code></td><td><code>T -&gt; U</code></td><td>对结果应用一个函数</td></tr><tr><td><code>thenAccept</code></td><td><code>T -&gt; void</code></td><td>类似于<code>thenApply</code>，不过结果为<code>void</code></td></tr><tr><td><code>thenCompose</code></td><td><code>T -&gt; CompletableFuture&lt;U&gt;</code></td><td>对结果调用函数并执行返回的<code>future</code></td></tr><tr><td><code>handle</code></td><td><code>(T, Throwable) -&gt; U</code></td><td>处理结果或错误，生成一个新结果</td></tr><tr><td><code>whenComplete</code></td><td><code>(T, Throwable) -&gt; void</code></td><td>类似于<code>handle</code>，不过结果为<code>void</code></td></tr><tr><td><code>exceptionally</code></td><td><code>Throwable -&gt; T</code></td><td>从错误计算一个结果</td></tr><tr><td><code>completeOnTimeout</code></td><td><code>T, long, TimeUnit</code></td><td>如果超时，生成给定值作为结果</td></tr><tr><td><code>orTimeout</code></td><td><code>long, TimeUnit</code></td><td>如果超时，生成一个<code>TimeoutException</code>异常</td></tr><tr><td><code>thenRun</code></td><td><code>Runnable</code></td><td>执行<code>Runnable</code>，结果为<code>void</code></td></tr></tbody></table><p>组合多个组合对象</p><table><thead><tr><th>方法</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>thenCombine</code></td><td><code>CompletableFuture&lt;U&gt;, (T, U) -&gt; V</code></td><td>执行两个动作并用给定函数组合结果</td></tr><tr><td><code>thenAcceptBoth</code></td><td><code>CompletableFuture&lt;U&gt;, (T, U) -&gt; void</code></td><td>与<code>thenCombine</code>类似，不过结果为<code>void</code></td></tr><tr><td><code>runAfterBoth</code></td><td><code>CompletableFuture&lt;?&gt;, Runnable</code></td><td>两个都完成后执行<code>runnable</code></td></tr><tr><td><code>applyToEither</code></td><td><code>CompletableFuture&lt;T&gt;, T -&gt; V</code></td><td>得到其中一个的结果时，传入给定的函数</td></tr><tr><td><code>acceptEither</code></td><td><code>CompletableFuture&lt;T&gt;, T -&gt; void</code></td><td>与<code>applyToEither</code>类似，不过结果为<code>void</code></td></tr><tr><td><code>runAfterEither</code></td><td><code>CompletableFuture&lt;?&gt;, Runnable</code></td><td>其中一个完成后执行 <code>runnable</code></td></tr><tr><td><code>static allOf</code></td><td><code>CompletableFuture&lt;?&gt; ...</code></td><td>所有给定的<code>future</code>都完成后完成，结果为<code>void</code></td></tr><tr><td><code>static anyOf</code></td><td><code>CompletableFuture&lt;?&gt; ...</code></td><td>任意给定的<code>future</code>完成后则玩抽，结果为<code>void</code></td></tr></tbody></table><ul><li>前三个方法并发运行一个<code>CompletableFuture&lt;T&gt;</code>和一个<code>CompletableFuture&lt;U&gt;</code>动作，并组合结果。</li><li>接下来三个方法并发运行两个<code>CompletableFuture&lt;T&gt;</code>动作。一旦其中一个动作完成，就传递它的结果，并忽略另一个结果。</li><li>最后的静态<code>allOf</code>和<code>allOr</code>方法取一组可完成<code>future</code>（数目可变），并生成一个<code>CompletableFuture&lt;Void&gt;</code>，它会在所有这些future都完成时或者其中任意一个<code>future</code>完成时结束。<code>allOf</code>方法不会生成任何结果。**<code>anyOf</code>方法不会终止其余任务**。</li></ul><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>到目前为止，已经了解了如何在同一个程序的不同线程中执行<code>Java</code>代码。有时候还需要执行另一个程序。为此，可以使用<code>ProcessBuilder</code>和<code>Process</code>类。<code>Process</code>类在一个单独的操作系统进程中执行一个命令，允许我们与标准输入、输出和错误流交互。<code>ProcessBuilder</code>类则允许我们配置<code>Process</code>对象。</p><blockquote><p><code>ProcessBuilder</code>类可以取代<code>Runtime.exec</code>调用，而且更为灵活。</p></blockquote><h4 id="建立一个进程"><a href="#建立一个进程" class="headerlink" title="建立一个进程"></a>建立一个进程</h4><p>首先指定想要执行的命令。可以提供一个<code>List&lt;String&gt;</code>，或者直接提供命令字符串。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"gcc"</span><span class="token punctuation">,</span> <span class="token string">"myapp.c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>警告</strong>：第一个字符串必须是一个可执行的命令，而不是一个<code>shell</code>内置命令。例如，要在<code>Windows</code>中运行<code>dir</code>命令，就需要提供字符串 <code>"cmd.exe" "/C"</code> 和 <code>"dir"</code> 来建立进程。</p></blockquote><p>每个进程都有一个工作目录，用来解析相对目录名。默认情况下，进程的工作目录与虚拟机相同，通常是启动<code>java</code>程序的哪个目录。可以用<code>directory</code>方法改变工作目录：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">builder <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">directory</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">toFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>配置<code>ProcessBuilder</code>的各个方法都返回其自身，所以可以把命令串起来。最终会调用：</p><p><code>Process p = new ProcessBuilder(command).directory(file)......start();</code></p></blockquote><p>接下来，要指定如何处理进程的标准输入、输出和错误流。默认情况下，它们分别是一个管道，可以用以下方法访问：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">OutputStream</span> processIn <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">InputStream</span> processOut <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">InputStream</span> processErr <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getErrorStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意，进程的输入流是<code>JVM</code>的一个输出流！我们会写入这个流，而我们写的内容会成为进程的输入。与之相反，我们会读取进程写入输出和错误流的内容。对我们来说，它们都是输入流。</p><p>可以指定新进程的输入、输出和错误流与<code>JVM</code>相同。如果用户在一个控制台运行<code>JVM</code>，所有用户输入都会转发到进程，而进程的输出将显示在控制台上。可以调用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">builder<span class="token punctuation">.</span><span class="token function">redirectIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为这三个流建立这个设置。如果只想继承某些流，可以把值：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ProcessBuilder<span class="token punctuation">.</span>Redirect</span><span class="token punctuation">.</span>INHERIT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>传入<code>redirectInput</code>、<code>redirectOutput</code>或<code>redirectError</code>方法。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">builder<span class="token punctuation">.</span><span class="token function">redirectOutput</span><span class="token punctuation">(</span><span class="token class-name">ProcessBuilder<span class="token punctuation">.</span>Redirect</span><span class="token punctuation">.</span>INHERIT<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过提供<code>File</code>对象，可以将进程流重定向到文件：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">builder<span class="token punctuation">.</span><span class="token function">redirectInput</span><span class="token punctuation">(</span>inputFile<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">redirectOutput</span><span class="token punctuation">(</span>outputFile<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">redirectError</span><span class="token punctuation">(</span>errorFile<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>进程启动时，会创建或删除输出和错误文件。要追加到现有的文件，可以使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">builder<span class="token punctuation">.</span><span class="token function">redirectOutput</span><span class="token punctuation">(</span><span class="token class-name">ProcessBuilder<span class="token punctuation">.</span>Redirect</span><span class="token punctuation">.</span><span class="token function">appendTo</span><span class="token punctuation">(</span>outputFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>合并输出和错误流通常很有用，这样就能按进程生成这些消息的顺序显示输出和错误消息。可以调用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">builder<span class="token punctuation">.</span><span class="token function">redirectErrorStream</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启用合并。如果这样做，就不能再在<code>ProcessBuilder</code>上调用<code>redirectError</code>，也不能在<code>Process</code>上调用<code>getErrorStream</code>。</p><p>有时可能还需要修改进程的环境变量。在这里，构建器的串联语法就不能用了。需要得到构造器的环境（由运行<code>JVM</code>的那个进程的环境变量初始化），然后加入或删除环境变量条目。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> env <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">environment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>env<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"LANG"</span><span class="token punctuation">,</span> <span class="token string">"fr_ER"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>env<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"JAVA_HOME"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Process</span> p <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果希望利用管道将一个进程的输出作为另一个进程的输入（类似于<code>shell</code>中的 <code>|</code> 操作符），<code>Java 9</code>提供了一个<code>startPipeline</code>方法。可以传入一个进程构建器列表，并从最后一个进程读取结果。这里给出了一个枚举一个目录树中的各个扩展的例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Process</span><span class="token punctuation">&gt;</span></span> processes <span class="token operator">=</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">.</span><span class="token function">startPipeline</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"find"</span><span class="token punctuation">,</span> <span class="token string">"/opt/jdk-9"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"grep"</span><span class="token punctuation">,</span> <span class="token string">"-o"</span><span class="token punctuation">,</span> <span class="token string">"\\.[^./]*$"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"sort"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"uniq"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Process</span> last <span class="token operator">=</span> processes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>processes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>last<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行一个进程"><a href="#运行一个进程" class="headerlink" title="运行一个进程"></a>运行一个进程</h4><p>配置了构建器之后，要调用它的<code>start</code>方法启用进程。如果把输入、输出和错误流配置为管道，现在可以写输入流，并读取输出和错误流。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Process</span> process <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span> <span class="token string">"-l"</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">directory</span><span class="token punctuation">(</span><span class="token class-name">Path</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"/tmp"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token keyword">var</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">hasNextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>警告</strong>：ji进程流的缓冲空间是有限的。不能写入太多输入，而且要及时读取输出。如果由大量输入和输出，可能需要在单独的线程中生产和消费这些输入输出。否则可能会造成阻塞问题。</p></blockquote><p>要等待进程完成，可以调用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> result <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">waitFor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者，如果不想无限期地等待，可以这样做：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> delay <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">waitFor</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">exitValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    process<span class="token punctuation">.</span><span class="token function">destroyForcibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个<code>waitFor</code>调用返回过程的退出值（<code>0</code>表示成功，或者返回一个非0的错误码）。如果进程没有超时，第二个调用返回<code>true</code>。然后需要调用<code>exitValue</code>方法获取退出值。</p><p>如果不会等待进程结束，而只是让它继续运行，不时调用<code>isAlive</code>来查看进程是否仍存活。要杀死这个进程，可以调用<code>destroy</code>或<code>destroyForcibly</code>。这两个调用之间的区别取决于平台。在<code>UNIX</code>上，前者会以<code>SIGTERM</code>终止进程，后者会以<code>SIGKILL</code>终止进程。（如果<code>destory</code>方法可以正常终止进程，<code>supportsNormalTermination</code>方法返回<code>true</code>。）</p><p>最后会在进程完成时接收到一个异步通知。调用<code>process.onExit()</code>会得到一个<code>CompletableFuture&lt;Process&gt;</code>，可以用来调度任何动作。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">process<span class="token punctuation">.</span><span class="token function">onExit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenAccept</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Exit value: "</span> <span class="token operator">+</span> p<span class="token punctuation">.</span><span class="token function">exitValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="进程句柄"><a href="#进程句柄" class="headerlink" title="进程句柄"></a>进程句柄</h4><p>要获得进程启动的一个进程的更多信息，或者想更多地了解你的计算机上正在运行的任何其他进程，可以使用<code>ProcessHandle</code>接口。可以用4种方式得到一个<code>ProcessHandle</code>：</p><ol><li>给定一个<code>Process</code>对象p，<code>p.toHandle()</code>会生成它的<code>ProcessHandle</code></li><li>给定一个<code>long</code>类型的操作进程<code>ID</code>，<code>ProcessHandle.of(id)</code>可以生成这个进程的句柄。</li><li><code>Process.current()</code>时运行这个<code>Java</code>虚拟机的进程的句柄</li><li><code>ProcessHandle.allProcesses()</code> 可以生成对当前进程可见的所有操作系统进程的<code>Stream&lt;ProcessHandle&gt;</code></li></ol><p>给定一个进程句柄，可以得到它的进程<code>ID</code>、父进程、子进程和后代进程。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> pid <span class="token operator">=</span> handle<span class="token punctuation">.</span><span class="token function">pid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProcessHandle</span><span class="token punctuation">&gt;</span></span> parent <span class="token operator">=</span> handle<span class="token punctuation">.</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProcessHandle</span><span class="token punctuation">&gt;</span></span> children <span class="token operator">=</span> handle<span class="token punctuation">.</span><span class="token function">children</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProcessHandle</span><span class="token punctuation">&gt;</span></span> descendants <span class="token operator">=</span> handle<span class="token punctuation">.</span><span class="token function">descendants</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>allProcesses</code>、<code>children</code>和<code>descendants</code>方法返回<code>Stream&lt;ProcessHandle&gt;</code>实例只是当时的快照。流中的任何进程在你看到它们的时候可能已经终止了，而且可能已经启动了其他进程，而那些新启动的进程不在流中。</p></blockquote><p>info方法可以生成一个<code>ProcessHandle.Info</code>对象，它提供了一些方法来获得进程的有关信息。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token function">arguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">command</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">commandLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">startInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">totalCpuDuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有这些方法都返回<code>Optional</code>值，因为可能某个特定的操作系统不能报告这个信息。</p><p>要监视或强制进程终止，于Process类一样，<code>Processhandle</code>接口也有<code>isAlive</code>、<code>supportsNormalTermination</code>、<code>destroy</code>、<code>destroyForcibly</code>和<code>onExit</code>方法。不过，没有对应<code>waitFor</code>的方法。</p><h2 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a><code>Java</code>关键字</h2><p>本附录列出了Java语言的所有关键字。有些关键字是“受限的”，它们只在某些特定场合（例如。在模块声明中）有特殊含义。在其他情况下，它们可以是标识符。</p><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td><code>abstract</code></td><td>抽象类或方法</td></tr><tr><td><code>assert</code></td><td>用来查找内部程序错误</td></tr><tr><td><code>boolean</code></td><td>布尔类型</td></tr><tr><td><code>break</code></td><td>跳出一个选择语句或循环</td></tr><tr><td><code>byte</code></td><td>8位整数类型</td></tr><tr><td><code>case</code></td><td><code>switch</code>的一个分支</td></tr><tr><td><code>catch</code></td><td>捕获异常的<code>try</code>块子句</td></tr><tr><td><code>char</code></td><td><code>Unicode</code>字符类型</td></tr><tr><td><code>class</code></td><td>定义一个类类型</td></tr><tr><td><code>const</code></td><td>未使用</td></tr><tr><td><code>continue</code></td><td>在循环末尾继续</td></tr><tr><td><code>default</code></td><td><code>switch</code>的默认子句，或者接口的默认方法</td></tr><tr><td><code>do</code></td><td><code>do/while</code> 循环最前面的语句</td></tr><tr><td><code>double</code></td><td>双精度浮点数类型</td></tr><tr><td><code>else</code></td><td><code>if</code> 语句的 <code>else</code> 子句</td></tr><tr><td><code>enum</code></td><td>枚举类型</td></tr><tr><td><code>exports</code></td><td>导出一个模块的包（受限）</td></tr><tr><td><code>extends</code></td><td>定义一个类的父类，或者一个通配符的上届</td></tr><tr><td><code>final</code></td><td>一个常量，或一个不能被覆盖的类或方法</td></tr><tr><td><code>finally</code></td><td><code>try</code>块中总会执行的部分</td></tr><tr><td><code>float</code></td><td>单精度浮点数类型</td></tr><tr><td><code>for</code></td><td>一种循环类型</td></tr><tr><td><code>goto</code></td><td>未使用</td></tr><tr><td><code>if</code></td><td>一个条件语句</td></tr><tr><td><code>implements</code></td><td>定义一个类实现的接口</td></tr><tr><td><code>import</code></td><td>导入一个包</td></tr><tr><td><code>instanceof</code></td><td>测试一个对象是否为一个类的实例</td></tr><tr><td><code>int</code></td><td>32位整数类型</td></tr><tr><td><code>interface</code></td><td>一种抽象类型，其中包含可以由类实现的方法</td></tr><tr><td><code>long</code></td><td>64位长整数类型</td></tr><tr><td><code>native</code></td><td>由宿主系统实现的一个方法</td></tr><tr><td><code>new</code></td><td>分配一个新对象或数据</td></tr><tr><td><code>null</code></td><td>一个空引用（需要说明的是，<code>null</code>从技术上讲是一个字面量，而不是关键字）</td></tr><tr><td><code>module</code></td><td>声明一个模块（受限）</td></tr><tr><td><code>open</code></td><td>修改一个<code>module</code>声明（受限）</td></tr><tr><td><code>opens</code></td><td>打开一个模块的包（受限）</td></tr><tr><td><code>package</code></td><td>包含类的一个包</td></tr><tr><td><code>private</code></td><td>这个特性只能由该类的方法访问</td></tr><tr><td><code>protected</code></td><td>这个特性只能由该类、其子类以及同一个包中的其他类的方法访问</td></tr><tr><td><code>provides</code></td><td>只是一个模块使用一个服务（受限）</td></tr><tr><td><code>public</code></td><td>这个特性可以由所有类的方法访问</td></tr><tr><td><code>return</code></td><td>从一个方法返回</td></tr><tr><td><code>short</code></td><td>16位整数类型</td></tr><tr><td><code>static</code></td><td>这个特性是类或接口特有的，而不属于类的实例</td></tr><tr><td><code>strictfp</code></td><td>对浮点数计算使用严格的规则</td></tr><tr><td><code>super</code></td><td>超类对象或构造器，或一个通配符的下界</td></tr><tr><td><code>switch</code></td><td>一个选择语句</td></tr><tr><td><code>synchronized</code></td><td>对线程而言是原子的方法或代码块</td></tr><tr><td><code>this</code></td><td>当前类的一个方法或构造器的隐含参数</td></tr><tr><td><code>throw</code></td><td>抛出一个异常</td></tr><tr><td><code>to</code></td><td><code>exports</code> 或 <code>opens</code> 声明的一部分（受限）</td></tr><tr><td><code>throws</code></td><td>一个方法可能抛出的异常</td></tr><tr><td><code>transient</code></td><td>标记非永久的数据</td></tr><tr><td><code>transitive</code></td><td>修饰一个<code>require</code>声明（受限）</td></tr><tr><td><code>try</code></td><td>捕获异常的代码块</td></tr><tr><td><code>uses</code></td><td>指示一个模块使用一个服务（受限）</td></tr><tr><td><code>var</code></td><td>声明一个变量的类型是推导得出的（受限）</td></tr><tr><td><code>void</code></td><td>指示一个方法不返回任何值</td></tr><tr><td><code>volatile</code></td><td>确保一个字段可以由多个线程访问</td></tr><tr><td><code>with</code></td><td>在一个<code>provides</code>语句中定义服务类（受限）</td></tr><tr><td><code>while</code></td><td>一种循环</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul><li><code>-Xlint:unchecked</code>：编译时使用，可以看到警告的文本信息。</li><li><code>@SuppressWarnings("unchecked")</code>：标识编译器忽略<code>unchecked</code>警告信息，例如：使用<code>List</code>，<code>ArrayList</code>等未进行参数化产生的警告信息。</li></ul><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> cs-languages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> java </tag>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开心最重要</title>
      <link href="/2022/05/22/hello-world/happy-day/"/>
      <url>/2022/05/22/hello-world/happy-day/</url>
      
        <content type="html"><![CDATA[<h1 id="开心最重要"><a href="#开心最重要" class="headerlink" title="开心最重要"></a>开心最重要</h1><blockquote><p>今日感想</p></blockquote><p>不用记住今天发生了什么，只记住以后要自己开心最重要啊！！！</p><p>喜欢就去做呀，开开心心的，把自己搞的那么疲惫干啥，普普通通就行。</p>]]></content>
      
      
      <categories>
          
          <category> hello-world </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 心情 </tag>
            
            <tag> 开心就好 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法与示例</title>
      <link href="/2022/05/15/notes/markdown-notes/"/>
      <url>/2022/05/15/notes/markdown-notes/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown语法与示例"><a href="#markdown语法与示例" class="headerlink" title="markdown语法与示例"></a>markdown语法与示例</h1><blockquote><p>注：所有例子，上面是效果，下面是源码。</p><p>部分效果展示由于hexo渲染网页的原因无法完全展示。</p></blockquote><h2 id="简单概述"><a href="#简单概述" class="headerlink" title="简单概述"></a>简单概述</h2><h3 id="宗旨"><a href="#宗旨" class="headerlink" title="宗旨"></a>宗旨</h3><p>Markdown 的目标是实现「易读易写」。</p><p>可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/">atx</a>、<a href="http://textism.com/tools/textile/">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p><hr><h3 id="兼容HTML"><a href="#兼容HTML" class="headerlink" title="兼容HTML"></a>兼容HTML</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。但是需要注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。</p><p>eg. 这里的双星不在做强调处理。</p><p>这是一个普通段落。</p><table>    <tbody><tr>        <td>*Foo*</td>    </tr></tbody></table><p>这是另一个普通段落。</p><hr><h3 id="特殊字符自动转换"><a href="#特殊字符自动转换" class="headerlink" title="特殊字符自动转换"></a>特殊字符自动转换</h3><p>特殊字符的转义字符，可以自动直接的转换进行展现</p><p>eg.</p><p>&amp;copy;</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token entity named-entity" title="©">&amp;copy;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>A&amp;T</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">AT<span class="token entity named-entity" title="&amp;">&amp;amp;</span>T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&lt;</p><pre class="line-numbers language-none"><code class="language-none">&lt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&gt;</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token entity named-entity" title=">">&amp;gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>"</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token entity named-entity" title="&quot;">&amp;quot;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&amp;nbsp;</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>支持两种标题的语法，类 <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a> 和类 <a href="http://www.aaronsw.com/2002/atx/">atx</a> 形式</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题）<span class="token title important">This is an H1<span class="token punctuation">=============</span></span><span class="token title important">This is an H2<span class="token punctuation">-------------</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶<span class="token title important"><span class="token punctuation">#</span> 这是 H1</span><span class="token title important"><span class="token punctuation">##</span> 这是 H2</span><span class="token title important"><span class="token punctuation">###</span> 这是 H3</span><span class="token title important"><span class="token punctuation">####</span> 这是 H4</span><span class="token title important"><span class="token punctuation">#####</span> 这是 H5</span><span class="token title important"><span class="token punctuation">######</span> 这是 H6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="区块引用-Blockquotes"><a href="#区块引用-Blockquotes" class="headerlink" title="区块引用 Blockquotes"></a>区块引用 Blockquotes</h3><blockquote><p>这是一个区块引用</p></blockquote><blockquote><blockquote><p>也可以使用多个 </p></blockquote></blockquote><blockquote><h6 id="这是一个标题。"><a href="#这是一个标题。" class="headerlink" title="这是一个标题。"></a>这是一个标题。</h6></blockquote><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token blockquote punctuation">&gt;</span> 这是一个区块引用<span class="token blockquote punctuation">&gt; &gt;</span> 也可以使用多个 <span class="token blockquote punctuation">&gt;</span> <span class="token title important"><span class="token punctuation">######</span> 这是一个标题。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><ul><li><p>1</p></li><li><p>2</p><ul><li><p>a</p><ul><li>bb</li></ul><ul><li>aa</li></ul></li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">在无序列表中 使用 { + ， - ， * }三个符号来标识无序列表，三者功能相同，相同层级下的列表表示建议使用相同的标识符，配合四个空白字符缩进，三者的组合则可以搭配出层级效果+ 1+ 2* a* bb- aa&gt; bb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><ol><li>第一</li><li>第二<ul><li>a<br>3. 反斜杠避免被识别为有序列表</li></ul></li><li>第三</li></ol><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">使用数字接着一个英文句点，则是有序列表。可以配合使用缩进配合与无序列表，区块引用等配合使用<span class="token list punctuation">1.</span> 第一<span class="token list punctuation">2.</span> 第二<span class="token list punctuation">+</span> a3\. 反斜杠避免被识别为有序列表<span class="token list punctuation">3.</span> 第三<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">这是一个代码区块<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是<code>一个</code>小段 <code>的</code> 代码 <code>显示</code></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">代码区块可以进行缩进区分，或者使用六个个反引号来进行包围，前三个反引号之后可以跟着指定的代码格式。（这里使用\,是为了展示源码）\```markdown\这是一个代码区块\```小段代码这是``` 一个 ```小段 <span class="token code-snippet code keyword">``的``</span> 代码 <span class="token code-snippet code keyword">`显示`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><hr><hr><hr><hr><hr><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。也可以在星号或是减号中间插入空格<span class="token hr punctuation">* * *</span><span class="token hr punctuation">***</span><span class="token hr punctuation">*****</span><span class="token hr punctuation">- - -</span><span class="token hr punctuation">---------------------------------------</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>两种形式的链接语法： 行内式和参考式两种形式</p><hr><h4 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h4><p><a href="http://www.baidu.com/" title="百度">示例1</a> 链接中的title文字可以使用双引号包裹起来显示。<br><a href="http://www.baidu.com/">示例2</a> 这是一个链接。</p><p><a href="/about/">示例3</a> 相对路径链接.</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">下面为行内式<span class="token url">[<span class="token content">示例1</span>](<span class="token url">http://www.baidu.com/</span> <span class="token string">"百度"</span>)</span> 链接中的title文字可以使用双引号包裹起来显示。<span class="token url">[<span class="token content">示例2</span>](<span class="token url">http://www.baidu.com/</span>)</span> 这是一个链接。要链接到同样主机的资源，可以使用相对路径<span class="token url">[<span class="token content">示例3</span>](<span class="token url">/about/</span>)</span> 相对路径链接.参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h4><p><a href="http://www.baidu.com/" title="百度">参考式</a> 此处引用的链接是参考，id标签中定义的.</p><p><a href="http://www.baidu.com/" title="百度">id</a> 此处第二个标签中不指明使用的参考，默认会寻找与名称相同的标记链接</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记<span class="token url">[<span class="token content">参考式</span>][<span class="token variable">id</span>]</span> 此处引用的链接是参考，id标签中定义的.[id][] 此处第二个标签中不指明使用的参考，默认会寻找与名称相同的标记链接接着，在文件的任意处，你可以把这个标记的链接内容定义出来此处的注释 使用 "" , '' , () 三种标识效果相同，且注意需要 [] 后紧跟 ：<span class="token url-reference url"><span class="token punctuation">[</span><span class="token variable">id</span><span class="token punctuation">]</span><span class="token punctuation">:</span> http://www.baidu.com/  <span class="token string">"百度"</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h4><p>即引用本文章中的其他标题或者另一个文件中的其他标题</p><p><a href="#%E5%AE%97%E6%97%A8">引用到宗旨部分</a></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">引用同一个文件的某个标题<span class="token url">[<span class="token content">title</span>](<span class="token url">#title</span>)</span>使用 # 选中章节。 注意要将大写字母改成小写，并删除特殊字符，空格使用 - 代替, 几级标题就时几个#引用另一个文件<span class="token url">[<span class="token content">title</span>](<span class="token url">./dir/file.md</span>)</span>引用另一个我呢见的某一个标题<span class="token url">[<span class="token content">title</span>](<span class="token url">./dir/file.md#title</span>)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p><em>斜体-星号</em></p><p><em>斜体-下划线</em></p><p><strong>加粗-星号</strong></p><p><strong>加粗-下划线</strong></p><p><del>删除线</del></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token italic"><span class="token punctuation">*</span><span class="token content">斜体-星号</span><span class="token punctuation">*</span></span><span class="token italic"><span class="token punctuation">_</span><span class="token content">斜体-下划线</span><span class="token punctuation">_</span></span><span class="token bold"><span class="token punctuation">**</span><span class="token content">加粗-星号</span><span class="token punctuation">**</span></span><span class="token bold"><span class="token punctuation">__</span><span class="token content">加粗-下划线</span><span class="token punctuation">__</span></span><span class="token strike"><span class="token punctuation">~~</span><span class="token content">删除线</span><span class="token punctuation">~~</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>同样也允许两种样式： <em>行内式</em>和<em>参考式</em></p><hr><h6 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h6><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">与超链接相似，只是在·[]·前添加 !<span class="token url"><span class="token operator">!</span>[<span class="token content">图片</span>](<span class="token url">/path/to/img.jpg</span>)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h6 id="参考式-1"><a href="#参考式-1" class="headerlink" title="参考式"></a>参考式</h6><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">同样与超链接的参考式相同 只是在<span class="token code-snippet code keyword">`[]`</span>前添加 <span class="token code-snippet code keyword">`!`</span>!图片][id]<span class="token url-reference url"><span class="token punctuation">[</span><span class="token variable">id</span><span class="token punctuation">]</span><span class="token punctuation">:</span> url/to/image  <span class="token string">"图片注释"</span></span>注意这里的参考链接 <span class="token code-snippet code keyword">`[]`</span> 前不需要添加 <span class="token code-snippet code keyword">`!`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接</p><hr><p><a href="http://www.baidu.com/">http://www.baidu.com/</a></p><p><a href="mailto:address@example.com">address@example.com</a></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&lt;http://www.baidu.com/&gt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>address@example.com</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，即转义字符，使得其后的字符不被markdown识别处理，方便与插入普通字符。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">\   反斜线`   反引号<span class="token list punctuation">*</span>   星号_   底线{}  花括号[]  方括号()  括弧<span class="token title important"><span class="token punctuation">#</span>   井字号</span><span class="token list punctuation">+</span>   加号<span class="token list punctuation">-</span>   减号.   英文句点!   惊叹号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>基于markdown可以适配html语言，所以我们也可以使用html语言中简单的标签来达到更多的扩展效果</p><hr><h3 id="颜色设置"><a href="#颜色设置" class="headerlink" title="颜色设置"></a>颜色设置</h3><p><font size="3" color="red">红色</font></p><p><font size="2" color="blue">蓝色</font></p><pre class="line-numbers language-none"><code class="language-none">&lt;span style="color: red;"&gt;这段文字会变成红色&lt;/span&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>红色<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>blue<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>红色<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">&gt;</span></span>也可以使用 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span> 标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>这段文字会变成红色<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h3><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">与行内式的超链接相似,只是在<span class="token code-snippet code keyword">`[]`</span>中添加 <span class="token code-snippet code keyword">`^`</span><span class="token url-reference url"><span class="token punctuation">[</span><span class="token variable">^注脚</span><span class="token punctuation">]</span><span class="token punctuation">:</span> https://www.appinn.com/markdown/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h3><p><a href="E:/Study/studyNote/Study/other-notes/git-nodes.md">绝对地址文件</a><br><a href="git-nodes.md">相对地址文件</a></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">链接文件与超链接语法类似，<span class="token url">[<span class="token content">绝对地址文件</span>](<span class="token url">E:/Study/studyNote/Study/other-notes/git-nodes.md</span>)</span><span class="token url">[<span class="token content">相对地址文件</span>](<span class="token url">git-nodes.md</span>)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> LR方<span class="token text string">[方形]</span> <span class="token arrow operator">--&gt;</span>圆<span class="token text string">(圆角)</span>    圆 <span class="token arrow operator">--&gt;</span> A<span class="token text string">{条件a}</span>    A <span class="token arrow operator">--&gt;</span><span class="token label property">|a=1|</span> B<span class="token text string">[结果B]</span>    A <span class="token arrow operator">--&gt;</span><span class="token label property">|a=2|</span> C<span class="token text string">[结果C]</span>    F<span class="token text string">[横向流程图]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TD方<span class="token text string">[方形]</span> <span class="token arrow operator">--&gt;</span>圆<span class="token text string">(圆角)</span>    圆 <span class="token arrow operator">--&gt;</span> A<span class="token text string">{条件a}</span>    A <span class="token arrow operator">--&gt;</span><span class="token label property">|a=1|</span> B<span class="token text string">[结果B]</span>    A <span class="token arrow operator">--&gt;</span><span class="token label property">|a=2|</span> C<span class="token text string">[结果C]</span>    F<span class="token text string">[横向流程图]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">本质上是代码块，不过使用的语言是『mermaid』，详细操作可以查询『mermaid』\ ```mermaidgraph LR方[方形] --&gt;圆(圆角)    圆 --&gt; A{条件a}    A --&gt;|a=1| B[结果B]    A --&gt;|a=2| C[结果C]    F[横向流程图]\ ```\ ```mermaidgraph TD方[方形] --&gt;圆(圆角)    圆 --&gt; A{条件a}    A --&gt;|a=1| B[结果B]    A --&gt;|a=2| C[结果C]    F[横向流程图]\ ```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代办"><a href="#代办" class="headerlink" title="代办"></a>代办</h3><ul><li><input disabled="" type="checkbox"> 这是一个代办</li><li><input checked="" disabled="" type="checkbox"> 这是一个已办</li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">-</span> [ ] 这是一个代办<span class="token list punctuation">-</span> [x] 这是一个已办ps：并不是所有情况下，代办的效果都可以实现<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">[TOC]  # 即插入一个文章目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="lt-span-gt"><a href="#lt-span-gt" class="headerlink" title="<span>"></a><code>&lt;span&gt;</code></h3><p><span class="highlight" onclick="alert('Hello world!')">这段文字会变成加粗，并在点击时弹出消息框</span></p><p><span style="font-size: 18px; color: blue; font-weight: bold; font-style: italic; text-decoration: line-through;">这段文字会变成蓝色、加粗、斜体、带删除线，并且大小为18像素</span></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>highlight<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello world!'</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>这段文字会变成加粗，并在点击时弹出消息框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>highlight 加粗字体<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">font-size</span><span class="token punctuation">:</span> 18px<span class="token punctuation">;</span> <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span> <span class="token property">font-weight</span><span class="token punctuation">:</span> bold<span class="token punctuation">;</span> <span class="token property">font-style</span><span class="token punctuation">:</span> italic<span class="token punctuation">;</span> <span class="token property">text-decoration</span><span class="token punctuation">:</span> line-through<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>这段文字会变成蓝色、加粗、斜体、带删除线，并且大小为18像素<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>标签本身并不对文本大小、颜色、加粗、斜体、删除线等进行设置，而是通过CSS样式来实现这些效果。以下是一些常见的CSS属性和值，可以用于对<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>标签内的文本进行样式设置：字体大小：使用font-size属性设置，例如font-size: 16px;可以将文本大小设置为16像素。文本颜色：使用color属性设置，例如color: red;可以将文本颜色设置为红色。文本加粗：使用font-weight属性设置，例如font-weight: bold;可以将文本设置为加粗字体。文本斜体：使用font-style属性设置，例如font-style: italic;可以将文本设置为斜体字体。文本删除线：使用text-decoration属性设置，例如text-decoration: line-through;可以将文本设置为带有删除线。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="https://www.appinn.com/markdown/">https://www.appinn.com/markdown/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> note </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes yaml配置详解——汇总篇</title>
      <link href="/2022/05/12/cs-dev-ops/kubernetes-yaml/"/>
      <url>/2022/05/12/cs-dev-ops/kubernetes-yaml/</url>
      
        <content type="html"><![CDATA[<h1 id="kubernetes-yaml配置详解——汇总篇"><a href="#kubernetes-yaml配置详解——汇总篇" class="headerlink" title="kubernetes yaml配置详解——汇总篇"></a>kubernetes yaml配置详解——汇总篇</h1><blockquote><p>k8s 集群中对资源管理和资源对象编排部署都可以通过声明样式（YAML）文件来解决，通过使用kubectl 命令直接使用资源清单文件就可以实现对大量的资源对象进行编排部署了。一般情况下，都是通过配置YAML文件来部署集群的。</p><p><a href="https://kubernetes.io/docs/concepts/" title="前往">官网概念文档</a> : <a href="https://kubernetes.io/docs/concepts/">https://kubernetes.io/docs/concepts/</a></p><p><a href="https://kubernetes.io/docs/tasks/" title="前往">官网示例文档</a> : <a href="https://kubernetes.io/docs/tasks/">https://kubernetes.io/docs/tasks/</a></p><p><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/" title="前往">官网API文档</a> : <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/">https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/</a></p><p><font color="red">注意：在k8s应用的yaml文件中不支持使用制表符为缩紧，所以要保证所有缩进都是空格。</font></p><p>汇总篇创建在2022-05-12，但是之后一直未抽时间来总结其他部分，故一直没有发布出去，后续在2023有想法发布分章详解时发现在之前已经有了汇总篇，所以汇总篇的时间便早于了分章讲解。发布分章与汇总篇的原因在于这些都是抽时间总结的，如果等全部总结完成在发布整个流程会拉的很长或者可能一直不会发布（类似于<a href="https://robertsunq.github.io/2022/06/28/cs-languages/core-java-volume-0/">JAVA核心技术——卷1</a>一样从开始写到最后发布持续了一年才最终发文，期间因为各种原因断断续续，因为一直没有发布所以不着急填坑，懒得大半年没学习。嘿嘿 (* ￣︿￣)），所以决定将分章与汇总篇都发布出去，汇总篇改为持续更新状态，也方便自己在网页上看到自己有多少坑没有填。</p></blockquote><h2 id="YAML支持的数据结构"><a href="#YAML支持的数据结构" class="headerlink" title="YAML支持的数据结构"></a>YAML支持的数据结构</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><blockquote><p>键值对的集合，又称为映射/哈希/字典</p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 对象类型：一组键值对，`: ` 来表示对应关系</span><span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">24</span><span class="token comment"># 也允许将所有的键值对写道一个行内</span><span class="token key atrule">hash</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">,</span> <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">24</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>一组对象</p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 数组类型： 一组以`-`开头的行，构成数组，`-` 推荐与上层对象key对齐</span><span class="token key atrule">people</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> qing<span class="token punctuation">-</span> robert<span class="token comment"># 也可以缩写为行内表示</span><span class="token key atrule">people</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>qing<span class="token punctuation">,</span> robert<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Kubernets中各模块的YAML语法"><a href="#Kubernets中各模块的YAML语法" class="headerlink" title="Kubernets中各模块的YAML语法"></a>Kubernets中各模块的YAML语法</h2><p>主要分为两个部分，一部分是控制器的定义，另一部分是被控制对象的定义</p><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><blockquote><p>控制器</p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1 <span class="token comment"># API版本</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment <span class="token comment"># 资源类型</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span> <span class="token comment"># 资源元数据</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span> <span class="token comment"># 标签，列表</span>    <span class="token key atrule">app.kubernetes.io</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx    <span class="token key atrule">name.kubernetes.io</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>tomcat <span class="token comment"># 名称</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>qing <span class="token comment"># 所属命名空间</span><span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment"># 资源规格定义</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span> <span class="token comment"># 副本数量</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span> <span class="token comment"># 标签选择器</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span> <span class="token comment"># 匹配规则为 {key,value}</span>      <span class="token key atrule">app.kubernetes.io</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx       <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><blockquote><p>模版：控制器启动和备份对象使用的模版，也是被控制对象的定义</p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">template</span><span class="token punctuation">:</span> <span class="token comment"># Pod模版</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span> <span class="token comment"># Pod元数据</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app.kubernetes.io</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment"># Pod规格定义</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span> <span class="token comment"># 容器配置</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx <span class="token comment"># 镜像名</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> tomcat<span class="token punctuation">:</span>8.5.68 <span class="token comment"># 镜像名:版本号</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="kubectl-create"><a href="#kubectl-create" class="headerlink" title="kubectl create"></a>kubectl create</h3><blockquote><p>可以使用 kubectl create 来创建基础的yaml配置文件在进行修改</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create deployment qing-nginx --image<span class="token operator">=</span>niginx -oyaml --dry-run<span class="token comment"># create deployment 创建部署</span><span class="token comment"># qing-nginx 名称</span><span class="token comment"># --image=niginx 所用镜像</span><span class="token comment"># -oyaml 以yaml文件格式 输出</span><span class="token comment"># --dry-run 尝试运行，不会创建真实的容器</span><span class="token comment"># 直接到输出到文件中</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create deployment qing-nginx --image<span class="token operator">=</span>niginx -oyaml --dry-run <span class="token operator">&gt;</span> qing-nginx-1.yaml<span class="token comment"># 对呀已经部署的 可以查询出名称然后导出配置到文件</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get deployNAME         READY   UP-TO-DATE   AVAILABLE   AGEqing-nginx   <span class="token number">0</span>/1     <span class="token number">1</span>            <span class="token number">0</span>           8s<span class="token comment"># 输出为配置文件</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get deploy qing-nginx -o<span class="token operator">=</span>yaml <span class="token operator">&gt;</span> qing-nginx-2.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><blockquote><p>运行中的一组容器，<code>Pod</code>是<code>kubernetes</code>中应用的最小单位</p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1 <span class="token comment"># api的版本 需要在命令 `kubectl api-versions` 的查询列表中</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod <span class="token comment"># 资源类型 常用 Pod/Deployment/Service/Ingress/ConfigMap/PersistentVolume/PersistentVolumeClaim/Secret</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span> <span class="token comment"># 指定资源的元数据配置，对于所有的API对象来说这部分基本相同，是用来表示这个对象资源的，从Kubernetes中找到这个对象的主要依</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>pod <span class="token comment"># 名称，在同一个namespace中需要唯一</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>kube <span class="token comment"># 命名空间，需要已经存在</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span> <span class="token comment"># 设定标签，常用被用于筛选，多组 &lt;key&gt;:&lt;value&gt; 形式</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>deploy <span class="token comment">#</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> deploy    <span class="token key atrule">app.kubernetes.io/instance</span><span class="token punctuation">:</span> deploy    <span class="token key atrule">app.kubernetes.io/version</span><span class="token punctuation">:</span> 0.0.1    <span class="token key atrule">app.kubernetes.io/managed-by</span><span class="token punctuation">:</span> qing    <span class="token key atrule">app.kubernetes.io/component</span><span class="token punctuation">:</span> controlle  <span class="token key atrule">annotations</span><span class="token punctuation">:</span> <span class="token comment"># 自定义注解列表，多组 &lt;key&gt;:&lt;value&gt; 形式</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment"># 指定资源类型的规格定义  主要存放的是这个对象独有的定义，来描述其做表达的功能</span>  <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Always <span class="token comment"># 重启策略 默认为：Always 在容器退出后，会立即创建一个相同的容器， 另外还有 OnFailure 和 Never</span>  <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span> <span class="token comment"># 节点选择 选择符合该标签需求的节点调度Pod，需要先给主机打上标签  `kubectl label nodes kube-node1 zone=node1`</span>    <span class="token key atrule">zone</span><span class="token punctuation">:</span> node1  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>    <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span> <span class="token comment"># 节点亲和度配置， 可以更加灵活的配置Pod的分配哪一类节点上</span>      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>        <span class="token key atrule">nodeSelectorTerms</span><span class="token punctuation">:</span> <span class="token comment"># 具体参见 https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes-using-node-affinity/</span>          <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>              <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> disktype                <span class="token key atrule">operator</span><span class="token punctuation">:</span> In                <span class="token key atrule">values</span><span class="token punctuation">:</span>                  <span class="token punctuation">-</span> ssd  <span class="token key atrule">initContainers</span><span class="token punctuation">:</span> <span class="token comment"># 在应用容器启动前（containers中配置的）运行完毕</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> install <span class="token comment"># 参数具体说明 详看 containers</span>      <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox<span class="token punctuation">:</span><span class="token number">1.28</span>      <span class="token key atrule">command</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> wget        <span class="token punctuation">-</span> <span class="token string">"-O"</span>        <span class="token punctuation">-</span> <span class="token string">"/work-dir/index.html"</span>        <span class="token punctuation">-</span> http<span class="token punctuation">:</span>//info.cern.ch  <span class="token key atrule">containers</span><span class="token punctuation">:</span> <span class="token comment"># 容器的配置</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app<span class="token punctuation">-</span>container <span class="token comment"># 容器的名称</span>      <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>latest <span class="token comment"># 要使用的镜像，eg. `busybox`, `busybox:1.28`, `10.192.11.14:5000/qing/busybox:latest`</span>      <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">'sh'</span><span class="token punctuation">,</span> <span class="token string">'-c'</span><span class="token punctuation">,</span> <span class="token string">'echo The app is running! &amp;&amp; sleep 3600'</span> <span class="token punctuation">]</span> <span class="token comment"># 启动容器的运行命令，将会覆盖容器的Dockerfile中定义的 ENTRYPOINT</span>      <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> Never <span class="token comment"># 每次启动是检查和更新images的策略 Never:每次都不检查 不论本地是否存在, Always: 每次都检查, IfNotPresent: 本地有就不检查 没有则拉取</span>      <span class="token key atrule">args</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> aaa <span class="token comment"># 启动容器的命令参数， 对应Dockerfile中CMD参数</span>        <span class="token punctuation">-</span> bbb      <span class="token key atrule">env</span><span class="token punctuation">:</span> <span class="token comment"># 设置容器的环境变量 通过 env 或 envFrom 字段设置的环境变量将覆盖容器镜像中指定的所有环境变量 环境变量可以互相引用 所以请避免产生循环饮用</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> qing <span class="token comment"># 变量的名称</span>          <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"/etc/run.sh"</span> <span class="token comment"># 对应变量的值</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> POD_NAME          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span> <span class="token comment"># 属性参数</span>              <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> metadata.name <span class="token comment"># 属性路径 对应元数据</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> POD_NAMESPACE          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span> <span class="token comment"># 属性参数</span>              <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> metadata.namespace <span class="token comment"># 属性路径 对应元数据</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SPECIAL_LEVEL_KEY <span class="token comment"># 从ConfigMap中获取配置</span>          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span> <span class="token comment"># 从configMap special-config 获取</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config <span class="token comment"># ConfigMap 包含你要赋给 SPECIAL_LEVEL_KEY 的值</span>              <span class="token key atrule">key</span><span class="token punctuation">:</span> special.how <span class="token comment"># 指定与取值相关的键名， 不指定key时获取所有的内容</span>      <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token comment"># 资源管理  如果只有limits配置没有requests配置 pod的requests配置则默认与 limits相同</span>        <span class="token key atrule">requests</span><span class="token punctuation">:</span> <span class="token comment"># 容器运行时，需要的最低配置要求 如果所有的节点都不满足该资源请求 Pod 将无限期处于 PENDING 状态</span>          <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token number">0.1</span> <span class="token comment"># CPU资源（核数）eg. 0.1 , 100m   两种表达方式 0.1 = 100m</span>          <span class="token key atrule">memory</span><span class="token punctuation">:</span> 128Mi <span class="token comment"># 内存使用量</span>        <span class="token key atrule">limits</span><span class="token punctuation">:</span> <span class="token comment"># 资源限制  注意 如果Pod中所有容器使用的资源超过该限制，则会被关闭，同时如果配置了容器的重启机制，则容器可能会处于kill、restart、kill、restart的循环中</span>          <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 500m <span class="token comment"># CPU 请求只能使用绝对数量，而不是相对数量。0.1 在单核、双核或 48 核计算机上的 CPU 数量值是一样的</span>          <span class="token key atrule">memory</span><span class="token punctuation">:</span> 1024Mi <span class="token comment"># 内存单位 基本单位为byte,也是不指定单位时候的默认值 其他单位有 ： E、P、T、G、M、K、Ei、Pi、Ti、Gi、Mi、Ki</span>          <span class="token comment"># 除此之外，还可以分派扩展资源，详情看 https://kubernetes.io/docs/tasks/configure-pod-container/extended-resource/</span>      <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span> <span class="token comment"># 容器对外的端口</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> http<span class="token punctuation">-</span>name <span class="token comment"># 名称</span>          <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP <span class="token comment"># 协议</span>      <span class="token comment"># 配置连接页面 : https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/</span>      <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span> <span class="token comment"># pod存活的探针    一共有4中方式</span>        <span class="token key atrule">httpGet</span><span class="token punctuation">:</span> <span class="token comment"># 通过httpGet检查健康度，返回在 200——399之间，认为容器正常</span>          <span class="token key atrule">path</span><span class="token punctuation">:</span> /heath <span class="token comment"># URL地址</span>          <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span> <span class="token comment"># 检查用端口</span>          <span class="token comment"># host: 127.0.0.1 # 主机地址</span>          <span class="token key atrule">scheme</span><span class="token punctuation">:</span> HTTP <span class="token comment"># 连接主机的方式，另一种为  HTTPS</span>          <span class="token key atrule">httpHeaders</span><span class="token punctuation">:</span> <span class="token comment">#请求中自定义的 HTTP 头。HTTP 头字段允许重复</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Accept              <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">""</span>        <span class="token comment"># tcpSocket:</span>        <span class="token comment">#  port: 8080</span>        <span class="token comment"># exec: # 在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。</span>        <span class="token comment">#   command:</span>        <span class="token comment">#     - cat</span>        <span class="token comment">#     - /tmp/health</span>        <span class="token comment"># grpc: # 使用 gRPC 执行一个远程过程调用。 目标应该实现 gRPC健康检查。 如果响应的状态是 "SERVING"，则认为诊断成功。 gRPC 探针是一个 alpha 特性，只有在你启用了 "GRPCContainerProbe" 特性门控时才能使用。</span>        <span class="token comment"># tcpSocket: # 对容器的 IP 地址上的指定端口执行 TCP 检查。如果端口打开，则诊断被认为是成功的。 如果远程系统（容器）在打开连接后立即将其关闭，这算作是健康的。</span>        <span class="token comment">#   port:</span>        <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">5</span> <span class="token comment"># 当探测失败时，Kubernetes 的重试次数。 对存活探测而言，放弃就意味着重新启动容器</span>        <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">10</span> <span class="token comment"># 在容器启动10秒后进行第一次检测</span>        <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span> <span class="token comment"># 检查间隔时间为 10秒</span>        <span class="token key atrule">successThreshold</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment"># 探测器在失败后，被视为成功的最小连续成功数</span>        <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment"># 检测的超时时间</span>      <span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span> <span class="token comment"># 就绪探测器  配置与存活探针相同  就绪探测器在容器的整个生命周期中保持运行状态</span>        <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">5</span>        <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>          <span class="token key atrule">path</span><span class="token punctuation">:</span> /healthz          <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10254</span>          <span class="token key atrule">scheme</span><span class="token punctuation">:</span> HTTP        <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>        <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>        <span class="token key atrule">successThreshold</span><span class="token punctuation">:</span> <span class="token number">1</span>        <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">1</span>      <span class="token key atrule">lifecycle</span><span class="token punctuation">:</span> <span class="token comment"># 生命周期</span>        <span class="token key atrule">postStart</span><span class="token punctuation">:</span> <span class="token comment">#  启动容器运行之前运行的命令 , k8s在容器创建后立即发送postStart事件，但是对其调用不保证在容器的入口点[entrypoint]之前执行，其与容器代码异步执行，但是容器会一直阻塞等待postStart执行完毕状态才会改变为RUNNING</span>          <span class="token key atrule">exec</span><span class="token punctuation">:</span>            <span class="token key atrule">command</span><span class="token punctuation">:</span>              <span class="token punctuation">-</span> <span class="token string">'sh'</span>              <span class="token punctuation">-</span> <span class="token string">'yum upgrade -y'</span>        <span class="token key atrule">preStop</span><span class="token punctuation">:</span>  <span class="token comment"># 停止容器前运行的命令, 在容器结束前立即发送 preStop 事件。除非 Pod 宽限期限超时，Kubernetes 的容器管理逻辑 会一直阻塞等待 preStop 处理函数执行完毕</span>          <span class="token key atrule">exec</span><span class="token punctuation">:</span>            <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span><span class="token string">"-c"</span><span class="token punctuation">,</span><span class="token string">"nginx -s quit; while killall -0 nginx; do sleep 1; done"</span><span class="token punctuation">]</span>      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span> <span class="token comment"># 挂载持久卷</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>storage1 <span class="token comment"># 挂载设备的名称，与volumes[*].name 需要对应</span>          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data/nginx/data1 <span class="token comment"># 容器内部的目录</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>storage2          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data/nginx/data2        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>storage3          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data/nginx/data3        <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /redis<span class="token punctuation">-</span>master <span class="token comment"># 容器内的配置目录 挂载方式在下方定义  配置的时使用配置集</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> config  <span class="token key atrule">volumes</span><span class="token punctuation">:</span> <span class="token comment"># 定义宿主机上对应的挂载目录    支持多种类型 详见 ：https://kubernetes.io/docs/concepts/storage/volumes/</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>storage1      <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment"># 由k8s自动安排一个空目录</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>storage1      <span class="token key atrule">hostPath</span><span class="token punctuation">:</span> <span class="token comment">#</span>        <span class="token key atrule">path</span><span class="token punctuation">:</span> /data/data2  <span class="token comment"># 宿主机目录</span>        <span class="token key atrule">type</span><span class="token punctuation">:</span> Directory <span class="token comment"># 字段可选  其他类型 : DirectoryOrCreate 不存在则创建空目录 权限为 0755, Directory, FileOrCreate 不存在则创建空文件 权限为 0644, File, Socket, CharDevice, BlockDevice .  没有OrCreate的则需要目标提前存在</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>storage3      <span class="token key atrule">nfs</span><span class="token punctuation">:</span> <span class="token comment"># nfs存储类型挂载 还支持其他类型文件系统</span>        <span class="token key atrule">server</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>节点IP<span class="token punctuation">}</span><span class="token punctuation">}</span>        <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data <span class="token comment"># 节点上的目录</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pvc<span class="token punctuation">-</span>storage      <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span> <span class="token comment"># 使用持久卷声明去申请持久卷</span>        <span class="token key atrule">claimName</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pvc    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config      <span class="token key atrule">configMap</span><span class="token punctuation">:</span>  <span class="token comment"># 配置文件是从配置集中获取</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>conf <span class="token comment"># 要使用的配置集名称</span>        <span class="token key atrule">items</span><span class="token punctuation">:</span> <span class="token comment"># 获取配置集中 data的那些项</span>          <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> redis.conf <span class="token comment"># 引入 redis-conf 配置集中 data 下 key为 redis.conf的配置</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> redis.conf <span class="token comment"># 指定上方通过key获取到的配置 放到什么目录下,在容器的/redis-master创建redis.conf</span>  <span class="token key atrule">securityContext</span><span class="token punctuation">:</span> <span class="token comment"># 设置Pod安全上下文 该配置也可以添加到containers https://kubernetes.io/docs/tasks/configure-pod-container/security-context/</span>    <span class="token key atrule">runAsUsr</span><span class="token punctuation">:</span> <span class="token number">100</span> <span class="token comment"># 指定 Pod 中的所有容器内的进程都使用用户 ID 100 来运行</span>    <span class="token key atrule">runAsGroup</span><span class="token punctuation">:</span> <span class="token number">3000</span> <span class="token comment"># 指定Pod 中所有容器中的进程都以主组 ID 3000 来运行  默认为 root(0)</span>    <span class="token key atrule">fsGroup</span><span class="token punctuation">:</span> <span class="token number">2000</span> <span class="token comment"># 卷 data/nginx/data1, data2, data3 及在该卷中创建的任何文件的属主都会是组 ID 2000</span>  <span class="token key atrule">imagePullSecrets</span><span class="token punctuation">:</span> <span class="token comment"># 如果从需要认证的镜像仓库下载镜像，可以配置Pod访问Secret中创建的密钥，前提是recred已经存在</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> recred  <span class="token comment"># https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/</span>  <span class="token key atrule">dnsPolicy</span><span class="token punctuation">:</span> ClusterFirst <span class="token comment"># Pod的DNS策略， Default/ClusterFirst/ClusterFirstWithHostNet/None  详情查看 ： https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/</span>  <span class="token key atrule">dnsConfig</span><span class="token punctuation">:</span> <span class="token comment"># 非必填 填写时与dnsPolicy一起使用，dnsPolicy 为 none 时必须指定</span>    <span class="token key atrule">nameservers</span><span class="token punctuation">:</span> <span class="token comment"># 非必填 Pod的DNS服务器的 IP 地址列表，最多指定3个IP地址，当 nsPolicy 为 none 时 必须包含一个Ip地址</span>      <span class="token punctuation">-</span> 1.2.3.4    <span class="token key atrule">searches</span><span class="token punctuation">:</span> <span class="token comment"># 非必填 用于在Pod中查找主机名的DNS搜索域的列表</span>      <span class="token punctuation">-</span> ns1.svc.cluster<span class="token punctuation">-</span>domain.example      <span class="token punctuation">-</span> my.dns.search.suffix    <span class="token key atrule">options</span><span class="token punctuation">:</span> <span class="token comment"># 非必填  此属性中的内容将合并到从指定的 DNS 策略生成的选项</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> ndots        <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"2"</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> edns0  <span class="token key atrule">terminationGracePeriodSeconds</span><span class="token punctuation">:</span> <span class="token number">30</span> <span class="token comment"># 终止活跃探测器或启动探测器的宽限时间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><blockquote><p>部署控制<code>Pod</code>，使<code>Pod</code>拥有多个副本、自愈、阔缩容等能力</p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 一些重复 功能相同的配置不在过多赘述，前往Pod的配置部分查看</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment <span class="token comment"># 资源类型 常用 Pod/Deployment/Service/Ingress/ConfigMap/PersistentVolume/PersistentVolumeClaim/Secret</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>deploy <span class="token comment"># 名称，在同一个namespace中需要唯一</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>kube <span class="token comment"># 命名空间，需要已经存在</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>deploy <span class="token comment">#</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> deploy  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment"># 指定资源类型的规格定义 这里的是对 Deployment 对定义</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span> <span class="token comment"># 启动对Pod副本数量</span>  <span class="token key atrule">revisionHistoryLimit</span><span class="token punctuation">:</span> <span class="token number">10</span> <span class="token comment"># 保留历史版本的个数，旧 ReplicaSet 会消耗 etcd 中的资源 默认是10</span>  <span class="token key atrule">paused</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 暂停部署 处于暂定状态的deployment中的template 发生任何修改都不会出发新的上线  默认是false</span>  <span class="token key atrule">progressDeadlineSeconds</span><span class="token punctuation">:</span> <span class="token number">500</span> <span class="token comment"># 部署超时时间 等待 Deployment 取得进展的秒数 此字段需要大于下方的 minReadySeconds ，默认是600</span>  <span class="token key atrule">minReadySeconds</span><span class="token punctuation">:</span> <span class="token number">5</span> <span class="token comment"># 最短就绪时间，指定新创建的 Pod 在没有任意容器崩溃情况下的最小就绪时间 只有超出这个时间 Pod 才被视为可用，默认值为 0</span>  <span class="token key atrule">strategy</span><span class="token punctuation">:</span> <span class="token comment"># 策略</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> RollingUpdate <span class="token comment"># 策略类型 [Recreate 重建，会先kill当前所有的Pods] [RollingUpdate 滚动更新]</span>    <span class="token key atrule">rollingUpdate</span><span class="token punctuation">:</span> <span class="token comment"># 滚动更新策略 通过下面的两个参数控制过程</span>      <span class="token key atrule">maxSurge</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment"># 最大的额外存在副本数量，两种形式 百分比和整数  默认 25%</span>      <span class="token key atrule">maxUnavaliable</span><span class="token punctuation">:</span> <span class="token number">5</span> <span class="token comment"># 最大不可用状态的Pod的数量 两种形式 百分比和整数 默认 25%</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span> <span class="token comment"># 过滤规则的定义，定义的规则是 AND 的逻辑, 这里定义的匹配条件推荐是只匹配下方 template 中定义的pod，如果此时有别的Pod也符合要求，会导致该部署也会管理到别的Pod造成交叉不可预估的问题</span>    <span class="token comment"># matchLabels 与 matchExpressions 具体区别暂未搞懂，等待测试</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span> <span class="token comment"># 查找匹配对标签，对应的是 labels中定义的 &lt;key&gt;:&lt;value&gt; 用来匹配过滤带有这写label的Pod</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx    <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span> <span class="token comment"># Expression匹配规则</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx  <span class="token key atrule">template</span><span class="token punctuation">:</span> <span class="token comment"># Pod的模版配置， 会根据这个模版配置来创建Pod，基本的参数和Pod部分的相同</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx          <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.14.2          <span class="token key atrule">port</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h3><blockquote><p><a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/replicaset/" title="前往">官方文档</a> <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/replicaset/">https://kubernetes.io/zh/docs/concepts/workloads/controllers/replicaset/</a></p></blockquote><ul><li><code>ReplicaSet</code> 的目的是维护一组在任何时候都处于运行状态的 <code>Pod</code> 副本的稳定集合。 通常用来保证给定数量的、完全相同的<code> Pod</code> 的可用性。</li><li><code>Deployment</code> 是一个更高级的概念，管理 <code>ReplicaSet</code>，并向 <code>Pod</code> 提供声明式的更新以及许多其他有用的功能。</li><li>建议直接使用 <code>Deployment</code> ，所以这里不在总结梳理 <code>ReplicaSet</code> 详情查看官方文档</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># loading ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h3><blockquote><p>管理有状态应用的工作负载 <code>API</code> 对象，为<code> Pod</code> 提供持久存储和持久标识符</p><p>适用于：稳定的、唯一的网络标识符；稳定的、持久的存储；有序的、优雅的部署和缩放；有序的、自动的滚动更新；</p></blockquote><ul><li><p><code>StatefulSet</code> 会为每个 <code>Pod</code> 维护了一个有粘性的 <code>ID</code>，这些<code> Pod</code> 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 <code>Pod</code> 都有一个永久不变的 <code>ID</code>。该标识包括顺序标识、稳定的网络标识和稳定的存储。</p><ul><li>有序索引：StatefulSet中的每个Pod将被分配一个整数序号，从0到N-1，该序号在StatefulSet上是唯一的</li><li>文档的网络ID：为每个Pod根据StatefulSet的名称和Pod的序号派生出主机名格式为 $(StatefulSet name)-$(num)</li></ul></li><li><p>给定的Pod的存储卷必须有<code>PV</code>（<code>Persistent Volume</code> 持久卷）的 <code>storage class</code>提供，或者管理员预先创建固定的挂载目录。</p></li><li><p>删除或者收缩 <code>StatefulSet</code> 并<strong>不会</strong>删除它关联的存储卷，为了保证数据安全。</p></li><li><p>需要<code>Headless Services</code> 来负责 <code>Pod</code> 的网络标识时，需要自行负责创建此服务。</p><ul><li>网络ID  <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/statefulset/#stable-network-id">https://kubernetes.io/zh/docs/concepts/workloads/controllers/statefulset/#stable-network-id</a></li><li><code>Headless Services</code>  <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/#headless-services">https://kubernetes.io/zh/docs/concepts/services-networking/service/#headless-services</a></li></ul></li><li><p>当删除 <code>StatefulSets</code> 时，<code>StatefulSet</code> 不提供任何终止 <code>Pod</code> 的保证。 为了实现 <code>StatefulSet</code> 中的 <code>Pod</code> 可以有序地且体面地终止，可以在删除之前将 <code>StatefulSet</code> 缩放为 <code>0</code>。</p></li><li><p>默认使用的 <code>Pod</code> 的 <code>OrderedReady</code> 是 滚动更新，可能需要人工干预才能修复一些损坏状态。</p></li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 一些重复 功能相同的配置不在过多赘述，前往 Pod/Deployment/ 的配置部分查看</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> StatefulSet <span class="token comment"># 资源类型 常用 Pod/Deployment/Service/Ingress/ConfigMap/PersistentVolume/PersistentVolumeClaim/Secret</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>deploy <span class="token comment"># 名称，在同一个namespace中需要唯一</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>kube <span class="token comment"># 命名空间，需要已经存在</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>deploy <span class="token comment">#</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> deploy  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment"># 指定资源类型的规格定义 这里的是对 StatefulSet 对定义</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx <span class="token comment"># 必须匹配 .spec.template.metadata.labels</span>  <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> <span class="token string">"nginx"</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span> <span class="token comment"># 默认值是 1</span>  <span class="token key atrule">minReadySeconds</span><span class="token punctuation">:</span> <span class="token number">10</span> <span class="token comment"># 默认值是 0</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx <span class="token comment"># 必须匹配 .spec.selector.matchLabels</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">terminationGracePeriodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>  <span class="token comment"># 终止活跃探测器或启动探测器的宽限时间</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx          <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/nginx<span class="token punctuation">-</span>slim<span class="token punctuation">:</span><span class="token number">0.8</span>          <span class="token key atrule">ports</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> web          <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span> <span class="token comment"># 指定容器的挂载卷</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> www              <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html  <span class="token key atrule">volumeClaimTemplates</span><span class="token punctuation">:</span> <span class="token comment"># 挂载卷申请的模版 StatefulSet 的卷挂载必须是PV提供 将通过 PersistentVolumes 驱动提供的 PersistentVolumes 来提供稳定的存储</span>    <span class="token punctuation">-</span> <span class="token key atrule">metadata</span><span class="token punctuation">:</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> www      <span class="token key atrule">spec</span><span class="token punctuation">:</span>        <span class="token key atrule">accessModes</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"ReadWriteOnce"</span> <span class="token punctuation">]</span> <span class="token comment"># 权限模式</span>        <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> <span class="token string">"my-storage-class"</span> <span class="token comment">#</span>        <span class="token key atrule">resources</span><span class="token punctuation">:</span>          <span class="token key atrule">requests</span><span class="token punctuation">:</span>            <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi <span class="token comment"># 申请的容量</span>            <span class="token comment"># loading ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> cs-dev-ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 待续 </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubesphere笔记</title>
      <link href="/2022/05/12/cs-dev-ops/kubesphere/"/>
      <url>/2022/05/12/cs-dev-ops/kubesphere/</url>
      
        <content type="html"><![CDATA[<h1 id="kubesphere笔记"><a href="#kubesphere笔记" class="headerlink" title="kubesphere笔记"></a>kubesphere笔记</h1><blockquote><p>KubeSphere是基于Kubernetes构建的分布式、多租户、多集群、企业级开源容器平台，具有强大且完善的网络与存储能力，并通过极简单的人机交互提供完善的多集群管理、CI/CD、为服务治理、应用管理等功能，帮助企业在云、虚拟化及物理机等异构基础设施上快速构建、部署及韵味容器架构，实现应用等敏捷开发与全生命周期管理。</p><p><a href="https://kubesphere.com.cn/" title="前往链接">官网连接</a> ： <a href="https://kubesphere.com.cn/">https://kubesphere.com.cn/</a></p></blockquote><img src="/2022/05/12/cs-dev-ops/kubesphere/0001.png" class="" title="kubesphere"><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>可以直接参考<a href="https://kubesphere.com.cn/docs/quick-start/minimal-kubesphere-on-k8s/" title="前往">官方在Kubernetes安装步骤</a>  <a href="https://kubesphere.com.cn/docs/quick-start/all-in-one-on-linux/" title="前往">官方在Linux直接安装步骤</a>  </p></blockquote><h3 id="前置环境"><a href="#前置环境" class="headerlink" title="前置环境"></a>前置环境</h3><ul><li><p><strong>请参照<a href="https://robertsunq.github.io/2022/04/30/devops/kubernetes/#toc-heading-4" title="前往本站文章">kunernetes</a>文章中的安装步骤，安装docker与kubernetes环境</strong></p></li><li><p><strong>NFS文件系统</strong></p><p><strong>安装nfs-server</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ yum <span class="token function">install</span> -y nfs-utils<span class="token comment"># 所有机器安装 nfs文件管理工具</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ yum <span class="token function">install</span> -y nfs-utils<span class="token comment"># 主节点设置 </span><span class="token comment">############</span><span class="token comment"># 挂载nfs，以下是配置</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"/nfs/data/ *(insecure,rw,sync,no_root_squash)"</span> <span class="token operator">&gt;</span> /etc/exports<span class="token comment"># /nfs/data/ 需要暴露的目录 </span><span class="token comment"># * 所有人可以同步</span><span class="token comment"># insecure,rw,sync,no_root_squash 同步的方式</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p /nfs/data<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> rpcbind --now<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> nfs-server --now<span class="token comment"># 配置生效</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ exportfs -r<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ exportfs/nfs/data<span class="token operator">&lt;</span>world<span class="token operator">&gt;</span><span class="token comment">############</span><span class="token comment"># 从节点设置,挂载主节点的nfs目录  选做</span><span class="token comment">############</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ showmount -e <span class="token punctuation">{</span><span class="token punctuation">{</span>主节点IP<span class="token punctuation">}</span><span class="token punctuation">}</span>Export list <span class="token keyword">for</span> <span class="token number">172.1</span>.1.1/nfs/data *<span class="token comment">#挂载 nfs 服务器上的共享目录到本机路径 /root/nfsmount</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p /nfs/data_bak<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mount</span> -t nfs <span class="token punctuation">{</span><span class="token punctuation">{</span>主节点IP<span class="token punctuation">}</span><span class="token punctuation">}</span>:/nfs/data /nfs/data_bak<span class="token comment"># {{主节点IP}}:/nfs/data 挂载到当前机器的 /nfs/data_bak目录</span><span class="token comment"># 写入一个测试文件</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"hello nfs server"</span> <span class="token operator">&gt;</span> /nfs/data/test.txt<span class="token comment">############</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>配置默认存储</strong></p><blockquote><p>配置动态供应等默认存储类</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 根据下面的yaml配置 创建 storage.yaml 并执行</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl apply -f storage.yaml<span class="token comment">#确认配置是否生效</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get sc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment">## 创建了一个存储类  注意将下方的ip地址修改为自己主节点的地址</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> storage.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> StorageClass<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>storage  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">storageclass.kubernetes.io/is-default-class</span><span class="token punctuation">:</span> <span class="token string">"true"</span><span class="token key atrule">provisioner</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>sigs.io/nfs<span class="token punctuation">-</span>subdir<span class="token punctuation">-</span>external<span class="token punctuation">-</span>provisioner<span class="token key atrule">parameters</span><span class="token punctuation">:</span>  <span class="token comment"># 删除pv的时，pv的内容是否要备份</span>  <span class="token key atrule">archiveOnDelete</span><span class="token punctuation">:</span> <span class="token string">"true"</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token comment"># replace with namespace where provisioner is deployed</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">strategy</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> Recreate  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">serviceAccountName</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner          <span class="token key atrule">image</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>subdir<span class="token punctuation">-</span>external<span class="token punctuation">-</span>provisioner<span class="token punctuation">:</span>v4.0.2          <span class="token comment"># resources:</span>          <span class="token comment">#    limits:</span>          <span class="token comment">#      cpu: 10m</span>          <span class="token comment">#    requests:</span>          <span class="token comment">#      cpu: 10m</span>          <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>root              <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /persistentvolumes          <span class="token key atrule">env</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> PROVISIONER_NAME              <span class="token key atrule">value</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>sigs.io/nfs<span class="token punctuation">-</span>subdir<span class="token punctuation">-</span>external<span class="token punctuation">-</span>provisioner            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> NFS_SERVER              <span class="token key atrule">value</span><span class="token punctuation">:</span> 172.31.0.4 <span class="token comment">## 指定自己nfs服务器地址</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> NFS_PATH                <span class="token key atrule">value</span><span class="token punctuation">:</span> /nfs/data  <span class="token comment">## nfs服务器共享的目录</span>      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>root          <span class="token key atrule">nfs</span><span class="token punctuation">:</span>            <span class="token key atrule">server</span><span class="token punctuation">:</span> 172.31.0.4 <span class="token comment">## 指定自己nfs服务器地址</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data <span class="token comment">## nfs服务器共享的目录</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token comment"># replace with namespace where provisioner is deployed</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner<span class="token punctuation">-</span>runner<span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"nodes"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"persistentvolumes"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"create"</span><span class="token punctuation">,</span> <span class="token string">"delete"</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"persistentvolumeclaims"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"update"</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"storage.k8s.io"</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"storageclasses"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"events"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"create"</span><span class="token punctuation">,</span> <span class="token string">"update"</span><span class="token punctuation">,</span> <span class="token string">"patch"</span><span class="token punctuation">]</span><span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> run<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner<span class="token key atrule">subjects</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount    <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner    <span class="token comment"># replace with namespace where provisioner is deployed</span>    <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner<span class="token punctuation">-</span>runner  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io<span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> Role<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> leader<span class="token punctuation">-</span>locking<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token comment"># replace with namespace where provisioner is deployed</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"endpoints"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"create"</span><span class="token punctuation">,</span> <span class="token string">"update"</span><span class="token punctuation">,</span> <span class="token string">"patch"</span><span class="token punctuation">]</span><span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> leader<span class="token punctuation">-</span>locking<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token comment"># replace with namespace where provisioner is deployed</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">subjects</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount    <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner    <span class="token comment"># replace with namespace where provisioner is deployed</span>    <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">kind</span><span class="token punctuation">:</span> Role  <span class="token key atrule">name</span><span class="token punctuation">:</span> leader<span class="token punctuation">-</span>locking<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>metrics-server</strong></p><blockquote><p>集群指标监控组件</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 根据下面的yaml配置 创建 metrics-server.yaml 并执行</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl apply -f metrics-server.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server  <span class="token key atrule">name</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server    <span class="token key atrule">rbac.authorization.k8s.io/aggregate-to-admin</span><span class="token punctuation">:</span> <span class="token string">"true"</span>    <span class="token key atrule">rbac.authorization.k8s.io/aggregate-to-edit</span><span class="token punctuation">:</span> <span class="token string">"true"</span>    <span class="token key atrule">rbac.authorization.k8s.io/aggregate-to-view</span><span class="token punctuation">:</span> <span class="token string">"true"</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> system<span class="token punctuation">:</span>aggregated<span class="token punctuation">-</span>metrics<span class="token punctuation">-</span>reader<span class="token key atrule">rules</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> metrics.k8s.io  <span class="token key atrule">resources</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> pods  <span class="token punctuation">-</span> nodes  <span class="token key atrule">verbs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> get  <span class="token punctuation">-</span> list  <span class="token punctuation">-</span> watch<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server  <span class="token key atrule">name</span><span class="token punctuation">:</span> system<span class="token punctuation">:</span>metrics<span class="token punctuation">-</span>server<span class="token key atrule">rules</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">""</span>  <span class="token key atrule">resources</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> pods  <span class="token punctuation">-</span> nodes  <span class="token punctuation">-</span> nodes/stats  <span class="token punctuation">-</span> namespaces  <span class="token punctuation">-</span> configmaps  <span class="token key atrule">verbs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> get  <span class="token punctuation">-</span> list  <span class="token punctuation">-</span> watch<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server  <span class="token key atrule">name</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server<span class="token punctuation">-</span>auth<span class="token punctuation">-</span>reader  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io  <span class="token key atrule">kind</span><span class="token punctuation">:</span> Role  <span class="token key atrule">name</span><span class="token punctuation">:</span> extension<span class="token punctuation">-</span>apiserver<span class="token punctuation">-</span>authentication<span class="token punctuation">-</span>reader<span class="token key atrule">subjects</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount  <span class="token key atrule">name</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server  <span class="token key atrule">name</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server<span class="token punctuation">:</span>system<span class="token punctuation">:</span>auth<span class="token punctuation">-</span>delegator<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> system<span class="token punctuation">:</span>auth<span class="token punctuation">-</span>delegator<span class="token key atrule">subjects</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount  <span class="token key atrule">name</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server  <span class="token key atrule">name</span><span class="token punctuation">:</span> system<span class="token punctuation">:</span>metrics<span class="token punctuation">-</span>server<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> system<span class="token punctuation">:</span>metrics<span class="token punctuation">-</span>server<span class="token key atrule">subjects</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount  <span class="token key atrule">name</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server  <span class="token key atrule">name</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> https    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">443</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> https  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server  <span class="token key atrule">name</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server  <span class="token key atrule">strategy</span><span class="token punctuation">:</span>    <span class="token key atrule">rollingUpdate</span><span class="token punctuation">:</span>      <span class="token key atrule">maxUnavailable</span><span class="token punctuation">:</span> <span class="token number">0</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">args</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>cert<span class="token punctuation">-</span>dir=/tmp        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>kubelet<span class="token punctuation">-</span>insecure<span class="token punctuation">-</span>tls        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>secure<span class="token punctuation">-</span>port=4443        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>kubelet<span class="token punctuation">-</span>preferred<span class="token punctuation">-</span>address<span class="token punctuation">-</span>types=InternalIP<span class="token punctuation">,</span>ExternalIP<span class="token punctuation">,</span>Hostname        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>kubelet<span class="token punctuation">-</span>use<span class="token punctuation">-</span>node<span class="token punctuation">-</span>status<span class="token punctuation">-</span>port        <span class="token key atrule">image</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server<span class="token punctuation">:</span>v0.4.3        <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent        <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>          <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">3</span>          <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /livez            <span class="token key atrule">port</span><span class="token punctuation">:</span> https            <span class="token key atrule">scheme</span><span class="token punctuation">:</span> HTTPS          <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">4443</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> https          <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP        <span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span>          <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">3</span>          <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /readyz            <span class="token key atrule">port</span><span class="token punctuation">:</span> https            <span class="token key atrule">scheme</span><span class="token punctuation">:</span> HTTPS          <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>        <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>          <span class="token key atrule">readOnlyRootFilesystem</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>          <span class="token key atrule">runAsNonRoot</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>          <span class="token key atrule">runAsUser</span><span class="token punctuation">:</span> <span class="token number">1000</span>        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /tmp          <span class="token key atrule">name</span><span class="token punctuation">:</span> tmp<span class="token punctuation">-</span>dir      <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span>        <span class="token key atrule">kubernetes.io/os</span><span class="token punctuation">:</span> linux      <span class="token key atrule">priorityClassName</span><span class="token punctuation">:</span> system<span class="token punctuation">-</span>cluster<span class="token punctuation">-</span>critical      <span class="token key atrule">serviceAccountName</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> tmp<span class="token punctuation">-</span>dir<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apiregistration.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> APIService<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server  <span class="token key atrule">name</span><span class="token punctuation">:</span> v1beta1.metrics.k8s.io<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">group</span><span class="token punctuation">:</span> metrics.k8s.io  <span class="token key atrule">groupPriorityMinimum</span><span class="token punctuation">:</span> <span class="token number">100</span>  <span class="token key atrule">insecureSkipTLSVerify</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">service</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> metrics<span class="token punctuation">-</span>server    <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system  <span class="token key atrule">version</span><span class="token punctuation">:</span> v1beta1  <span class="token key atrule">versionPriority</span><span class="token punctuation">:</span> <span class="token number">100</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="安装KubeSphere"><a href="#安装KubeSphere" class="headerlink" title="安装KubeSphere"></a>安装KubeSphere</h3><blockquote><p><a href="https://kubesphere.com.cn/">https://kubesphere.com.cn/</a></p><p>#注意：如果为k8s单节点，需要执行以下命令允许master部署pod，<code>kubectl taint nodes --all node-role.kubernetes.io/master-</code> 不然nfs-client一直在pending状态</p><p><a href="https://kubesphere.com.cn/docs/quick-start/minimal-kubesphere-on-k8s/" title="前往">官方安装步骤</a> ： <a href="https://kubesphere.com.cn/docs/quick-start/minimal-kubesphere-on-k8s/">https://kubesphere.com.cn/docs/quick-start/minimal-kubesphere-on-k8s/</a></p></blockquote><ul><li><p><strong>下载核心文件</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">wget</span> https://github.com/kubesphere/ks-installer/releases/download/v3.1.1/kubesphere-installer.yaml<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">wget</span> https://github.com/kubesphere/ks-installer/releases/download/v3.1.1/cluster-configuration.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>附本人github复制文件内容的下载链接 <a href="https://github.com/RobertSunq/data/blob/master/qing/blog/hexo/kubesphere/kubesphere-installer.yml" title="kubesphere-installer.yml 下载链接 ">kubesphere-installer</a>   <a href="https://github.com/RobertSunq/data/blob/master/qing/blog/hexo/kubesphere/cluster-configuration.yml" title="v2.5.1 cluster-configuration.yml 下载链接 ">cluster-configuration</a></p></blockquote></li><li><p><strong>修改cluster-configuration</strong></p><blockquote><p>在 cluster-configuration.yaml中指定我们需要开启的功能</p><p>参照官网“启用可插拔组件” </p><p><a href="https://kubesphere.com.cn/docs/pluggable-components/overview/">https://kubesphere.com.cn/docs/pluggable-components/overview/</a></p></blockquote></li><li><p><strong>执行安装</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl apply -f kubesphere-installer.yaml<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl apply -f cluster-configuration.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>查看安装的进度</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl logs -n kubesphere-system <span class="token variable"><span class="token variable">$(</span>kubectl get pod -n kubesphere-system -l <span class="token assign-left variable">app</span><span class="token operator">=</span>ks-install -o <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">'{.items[0].metadata.name}'</span><span class="token variable">)</span></span> -f<span class="token comment"># 安装成功后 访问任意机器的 30880端口</span><span class="token comment"># 账号 ： admin</span><span class="token comment"># 密码 ： P@88w0rd</span><span class="token comment"># 如果出现etcd监控证书找不到的问题 这行下面的操作</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl -n kubesphere-monitoring-system create secret generic kube-etcd-client-certs  --from-file<span class="token operator">=</span>etcd-client-ca.crt<span class="token operator">=</span>/etc/kubernetes/pki/etcd/ca.crt  --from-file<span class="token operator">=</span>etcd-client.crt<span class="token operator">=</span>/etc/kubernetes/pki/apiserver-etcd-client.crt  --from-file<span class="token operator">=</span>etcd-client.key<span class="token operator">=</span>/etc/kubernetes/pki/apiserver-etcd-client.key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>附</strong></p><p><strong>Linux单节点部署KubeSphere</strong></p><blockquote><p><a href="https://kubesphere.com.cn/docs/quick-start/all-in-one-on-linux/" title="前往">官方安装步骤</a>： <a href="https://kubesphere.com.cn/docs/quick-start/all-in-one-on-linux/">https://kubesphere.com.cn/docs/quick-start/all-in-one-on-linux/</a></p></blockquote><ol><li><p>防火墙放行  30000~32767 并指定hostname</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ hostnamectl set-hostname node1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>准备KubeKey</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">KKZONE</span><span class="token operator">=</span>cn<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">curl</span> -sfL https://get-kk.kubesphere.io <span class="token operator">|</span> <span class="token assign-left variable">VERSION</span><span class="token operator">=</span>v2.0.0 <span class="token function">sh</span> -<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">chmod</span> +x kk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用KubeKey引导安装集群 </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#可能需要下面命令</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ yum <span class="token function">install</span> -y conntrack<span class="token comment"># 执行安装</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ ./kk create cluster --with-kubernetes v1.21.5 --with-kubesphere v3.2.1<span class="token comment"># 查看安装结果</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl logs -n kubesphere-system <span class="token variable"><span class="token variable">$(</span>kubectl get pod -n kubesphere-system -l <span class="token assign-left variable">app</span><span class="token operator">=</span>ks-install -o <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">'{.items[0].metadata.name}'</span><span class="token variable">)</span></span> -f<span class="token comment">### 由于安装的默认docker镜像的问题，可能会导致部分Pod启动失败</span><span class="token comment">### 此时可以打开另一个命令窗口修改仓库地址</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">vim</span> /etc/docker/daemon.json<span class="token comment">##### 添加下面的仓库配置 #####</span><span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>    <span class="token string">"https://registry.aliyuncs.com"</span>,    <span class="token string">"https://docker.mirrors.ustc.edu.cn"</span>  <span class="token punctuation">]</span><span class="token comment">##### 结束  ######</span><span class="token comment"># 之后重启docker</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ systemctl restart docker<span class="token comment"># 可以等待pod被自动拉起 或者也可以通过从之执行上面的安装命令再次安装</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2022/05/12/cs-dev-ops/kubesphere/0002.png" class="" title="安装成功后截图"></li><li><p>安装后开启功能</p><blockquote><p>其他可插拔功能根据需求安装：<a href="https://kubesphere.com.cn/docs/pluggable-components/">https://kubesphere.com.cn/docs/pluggable-components/</a></p></blockquote></li></ol><p><strong>Linux多节点部署KubeSphere</strong></p><ol><li><p>防火墙放行  30000~32767 并指定hostname</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ hostnamectl set-hostname node1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>准备KubeKey</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">KKZONE</span><span class="token operator">=</span>cn<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">curl</span> -sfL https://get-kk.kubesphere.io <span class="token operator">|</span> <span class="token assign-left variable">VERSION</span><span class="token operator">=</span>v2.0.0 <span class="token function">sh</span> -<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">chmod</span> +x kk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建集群配置文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#可能需要下面命令</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ yum <span class="token function">install</span> -y conntrack<span class="token comment"># 执行安装</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ ./kk create cluster --with-kubernetes v1.21.5 --with-kubesphere v3.2.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建集群</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 在该配置文件中，修改其hosts属性的ip地址为自己集群的地址</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ ./kk create cluster -f config-sample.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>附本人github config-sample.yaml文件内容的下载链接<a href="https://github.com/RobertSunq/data/blob/master/qing/blog/hexo/kubesphere/config-sample.yaml" title="config-sample.yaml 下载链接 ">config-sample.yaml</a></p></blockquote></li><li><p>查看进度</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl logs -n kubesphere-system <span class="token variable"><span class="token variable">$(</span>kubectl get pod -n kubesphere-system -l <span class="token assign-left variable">app</span><span class="token operator">=</span>ks-install -o <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">'{.items[0].metadata.name}'</span><span class="token variable">)</span></span> -f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>loading…</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> cs-dev-ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 待续 </tag>
            
            <tag> command </tag>
            
            <tag> note </tag>
            
            <tag> kubesphere </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-FAQ</title>
      <link href="/2022/05/08/cs-dev-ops/faq-docker/"/>
      <url>/2022/05/08/cs-dev-ops/faq-docker/</url>
      
        <content type="html"><![CDATA[<h1 id="FAQ-docker"><a href="#FAQ-docker" class="headerlink" title="FAQ-docker"></a>FAQ-docker</h1><blockquote><p>自己在使用docker做开发的过程中遇到的一些问题的记录</p></blockquote><h5 id="Q-Dockerfile中COPY-指令的-lt-src-gt-是否支持"><a href="#Q-Dockerfile中COPY-指令的-lt-src-gt-是否支持" class="headerlink" title="Q:Dockerfile中COPY 指令的<src> 是否支持../"></a>Q:<code>Dockerfile</code>中<code>COPY</code> 指令的<code>&lt;src&gt;</code> 是否支持<code>../</code></h5><p><strong>A:</strong></p><blockquote><p><code>COPY</code>的源文件目录不支持使用 <code>../</code>来访问其上册目录，<src>路径必须构建在上下文中，因为docker构建的第一步就是将上下文目录和子目录发送到docker守护进程</src></p></blockquote><h5 id="Q-docker-run-detach-keys-quot-quot-中参数-detach-keys的作用"><a href="#Q-docker-run-detach-keys-quot-quot-中参数-detach-keys的作用" class="headerlink" title="Q: docker run --detach-keys=&quot;&quot;中参数--detach-keys的作用"></a>Q: <code>docker run --detach-keys=""</code>中参数<code>--detach-keys</code>的作用</h5><p> <strong>A：</strong></p><blockquote><p>官网解释为：Override the key sequence for detaching a container</p><p>用于容器的键盘映射键位，在容器被连接到前台时，若宿主机的键盘键位与容器键位冲突，可以使用该指令对容器的键位进行重新映射。</p></blockquote><h5 id="Q：Dockerfile中的COPY指令，拷贝文件夹时只会拷贝文件夹中的内容"><a href="#Q：Dockerfile中的COPY指令，拷贝文件夹时只会拷贝文件夹中的内容" class="headerlink" title="Q：Dockerfile中的COPY指令，拷贝文件夹时只会拷贝文件夹中的内容"></a>Q：<code>Dockerfile中</code>的<code>COPY</code>指令，拷贝文件夹时只会拷贝文件夹中的内容</h5><p><strong>A:</strong></p><blockquote><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">COPY data/ /home/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>data中的目录结构为：</p><p>｜—— data</p><p>｜｜——dir1</p><p>｜｜｜a.txt</p><p>｜｜——dir2</p><p>｜｜｜b.txt</p><p>｜｜c.txt</p><p>拷贝到容器中后目录结构为，也就是并不会拷贝目录本身，只会拷贝目录中的内容文件</p><p>｜—— home</p><p>｜｜——dir1</p><p>｜｜｜a.txt</p><p>｜｜——dir2</p><p>｜｜｜b.txt</p><p>｜｜c.txt</p></blockquote><h5 id="Q：Dockerfile-build过程中出现错误，如何去调试"><a href="#Q：Dockerfile-build过程中出现错误，如何去调试" class="headerlink" title="Q：Dockerfile build过程中出现错误，如何去调试"></a>Q：<code>Dockerfile</code> <code>build</code>过程中出现错误，如何去调试</h5><p><strong>A：</strong></p><blockquote><p>执行 <code>docker build</code> 命令使用<code>Dockerfile</code>构建一个新的镜像的时候，dokcer内部的执行的构建步骤大致为如下几步：</p><ol><li>使用<code>Dockerfile</code> 中定义的基础镜像<code>FROM centos</code>运行一个容器</li><li>依次执行<code>Dockerfile</code> 中后续的指令，来对启动的容器进行修改；<ol><li>每执行完一条指令后，执行一个类似于<code>commit</code>的操作，来生成一个新的镜像层。(<code>build</code> <code>Dockerfile</code>的时候若不关闭使用缓存构建，用的镜像层的缓存就是以此方式构建的)</li><li>基于上一步提交的镜像来运行一个新的容器</li><li>重复1，2步骤来完成对<code>Dockerfile</code>中所有指令的执行</li></ol></li><li>完成镜像的构建</li></ol><p>所以基于上述的构建步骤，可以通过重新启动出错前一步的build出来的容器还原现场，之后再执行出错一行的命令来分析错误的原因。</p><p>eg.</p><p>执行 <code>docker build . -t test:1.0.0</code> 时某一行出现错误：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">Sending build context to Docker daemon  67.37MBStep 1/5 : FROM java:8 ---&gt; d23bdf5b1b1bStep 2/5 : COPY ./target/*.jar /app/app.jarCOPY failed: no source files were specified<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到在执行<em><strong>Step 2/5</strong></em>出现错误，在其上一步<em><strong>Step 1/5</strong></em>会保留一个临时容器<code>d23bdf5b1b1b</code> ，所以就可以启动这个临时容器来达到还原出错前的现场</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ docker container run -it d23bdf5b1b1b /bin/bash# 之后在容器中执行错误命令来排查错误# 注意 这里是使用交互模式启动，使用exit退出后 容器就会关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> cs-dev-ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> docker </tag>
            
            <tag> FAQ </tag>
            
            <tag> 待续 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS安装docker和kubernetes</title>
      <link href="/2022/05/04/cs-dev-ops/docker-k8s-mac-install/"/>
      <url>/2022/05/04/cs-dev-ops/docker-k8s-mac-install/</url>
      
        <content type="html"><![CDATA[<h1 id="MacOS安装docker和kubernetes"><a href="#MacOS安装docker和kubernetes" class="headerlink" title="MacOS安装docker和kubernetes"></a>MacOS安装docker和kubernetes</h1><blockquote><p>在mac电脑上安装 Docker Desktop 以及对应的kubernetes(k8s)</p><p>相关资源下载地址：</p><p><a href="https://docs.docker.com/desktop/mac/install/">Docker Desktop</a></p><p><a href="https://github.com/AliyunContainerService/k8s-for-docker-desktop">k8s-for-docker-desktop</a></p></blockquote><h2 id="Docker-Desktop-安装"><a href="#Docker-Desktop-安装" class="headerlink" title="Docker Desktop 安装"></a>Docker Desktop 安装</h2><ol><li>在docker官网上下载对应芯片版本的<a href="https://docs.docker.com/desktop/mac/install/">Docker Desktop</a> dmg文件</li></ol><img src="/2022/05/04/cs-dev-ops/docker-k8s-mac-install/0001.png" class="" title="下载"><hr><ol start="2"><li>打开下载的dmg文件 安装docker</li></ol><img src="/2022/05/04/cs-dev-ops/docker-k8s-mac-install/0002.png" class="" title="安装"><ol start="3"><li>在启动台找到docker的图标即可启动</li></ol><img src="/2022/05/04/cs-dev-ops/docker-k8s-mac-install/0003.png" class="" title="启动"><h2 id="Kubernetes-安装"><a href="#Kubernetes-安装" class="headerlink" title="Kubernetes 安装"></a>Kubernetes 安装</h2><blockquote><p>这里没有使用docker destop自带的k8s安装按钮安装应用，而是使用阿里云的k8s-for-docker-desktop来进行安装。</p></blockquote><ol><li>在docker desktop中查看关联的k8s版本</li></ol><img src="/2022/05/04/cs-dev-ops/docker-k8s-mac-install/0004.png" class="" title="关联的k8s版本"><ol start="2"><li>访问<a href="https://github.com/AliyunContainerService/k8s-for-docker-desktop">k8s-for-docker-desktop</a>的github项目地址找到对应的版本下载项目</li></ol><img src="/2022/05/04/cs-dev-ops/docker-k8s-mac-install/0005.png" class="" title="下载"><ol start="3"><li><p>解压文件，执行其中的脚本 load_images.sh</p><blockquote><p>如果安装时下载资源比较慢，可以为docker daemon配置国内的镜像加速，阿里云镜像服务或者中科大镜像加速地址：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></p></blockquote><img src="/2022/05/04/cs-dev-ops/docker-k8s-mac-install/0007.png" class="" title="配置镜像加速"></li></ol><img src="/2022/05/04/cs-dev-ops/docker-k8s-mac-install/0006.png" class="" title="执行load_images.sh"><ol start="4"><li>等待执行成功，可以执行命令 kubectl version 查看版本来确定是否安装成功</li></ol><img src="/2022/05/04/cs-dev-ops/docker-k8s-mac-install/0008.png" class="" title="查看安装版本"><ol start="5"><li>打开docker desktop控制面板查看相关信息</li></ol><img src="/2022/05/04/cs-dev-ops/docker-k8s-mac-install/0009.png" class="" title="查看相关信息"><ol start="6"><li><p>配置kubernetes</p><blockquote><p>可选操作：切换kubernetes运行上下文到docker-desktop（之前版本的context为docker-for-desktop）</p></blockquote></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 切换运行上下文[root@qing centos]$ kubectl config use-context docker-desktop# 查看配置[root@qing centos]$ kubectl config view# 验证kubernetes集群状态[root@qing centos]$ kubectl cluster-info[root@qing centos]$ kubectl get nodes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>完</strong></p>]]></content>
      
      
      <categories>
          
          <category> cs-dev-ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> docker </tag>
            
            <tag> kubernetes </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes</title>
      <link href="/2022/04/30/cs-dev-ops/kubernetes/"/>
      <url>/2022/04/30/cs-dev-ops/kubernetes/</url>
      
        <content type="html"><![CDATA[<h1 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h1><blockquote><p>大规模容器编排系统</p></blockquote><p><strong>特性</strong></p><ul><li><strong>服务发现和负载均衡</strong><ul><li>Kubernetes可以使用DNS名称或者IP地址公开容器，如果进入容器的流量很大，Kubernetes可以负载均和冰粉配网络流量，从而使部署稳定</li></ul></li><li><strong>存储编排</strong><ul><li>Kubernetes允许自动挂在所选择的存储系统。eg. 本地存储、公共云提供商</li></ul></li><li><strong>自动部署和回滚</strong><ul><li>使用Kubernetes描述已部署的所需状态，可以将受控的速率将实际状态更改为期望状态。比如可以自动化Kubernetes来部署创建新容器，删除现有容器并将它们的所有资源用于新容器</li></ul></li><li><strong>自动完成装箱计算</strong><ul><li>Kubernetes允许指定每个容器所需的CPU和RAM。当容器指定来资源请求时，Kubernetes可以做出更好的决策来管理容器资源。</li></ul></li><li><strong>自我修复</strong><ul><li>Kubernetes重新启动失败的容器、替换容器、杀死不相应用户定义的运行状态检查的容器，并且在准备好服务之前不将其通告给客户端。</li></ul></li><li><strong>密钥和配置管理</strong><ul><li>Kubernetes可以存储和管理敏感信息，例如密码、OAuth令牌和ssh密钥。可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</li></ul></li></ul><p>Kubernetes提供了一个可弹性运行分布式系统的框架，可以更轻松管理系统的Canary部署。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>Kubernetes Cluster = N Master Node + N Worker Node =&gt; N主节点 + N工作节点；</p><h3 id="平面组件结构"><a href="#平面组件结构" class="headerlink" title="平面组件结构"></a>平面组件结构</h3><img src="/2022/04/30/cs-dev-ops/kubernetes/components-of-kubernetes.svg" class="" title="components-of-kubernetes"><img src="/2022/04/30/cs-dev-ops/kubernetes/0001.png" class="" title="平面结构图-1"><p><strong>控制平面组件</strong>(control plane)</p><ul><li><p><strong>kube-apiserver</strong></p><p>API服务器为K8s集群资源操作提供唯一入口，并提供认证、授权、访问控制、API 注册和发现机制。</p><p>Kubernetes API 服务器验证并配置 API 对象的数据， 这些对象包括 pods、services、replicationcontrollers 等。 API 服务器为 REST 操作提供服务，并为集群的共享状态提供前端， 所有其他组件都通过该前端进行交互。</p></li><li><p><strong>etcd</strong></p><p>兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库(例如 Pod 的数量、状态、命名空间等）、API 对象和服务发现细节。 在生产级k8s中etcd通常会以集群的方式存在，安全原因，它只能从 API 服务器访问。</p></li><li><p><strong>kube-scheduler</strong></p><p>kube-scheduler 负责监视新创建、未指定运行Node的 Pods，决策出一个让pod运行的节点。</p><p>调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。</p></li><li><p><strong>kube-controller-manager</strong></p><p>k8s在后台运行许多不同的控制器进程，当服务配置发生更改时（例如，替换运行 pod 的镜像，或更改配置 yaml 文件中的参数），控制器会发现更改并开始朝着新的期望状态工作。</p><p>控制器包括:</p><ul><li>节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应</li><li>任务控制器（Job controller）: 监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li><li>端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)</li><li>服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌</li></ul></li><li><p><strong>cloud-controller-manager</strong></p><p>云控制器管理器使得你可以将你的集群连接到云提供商的 API 之上， 同时可以将云平台交互组件与本地集群中组件分离。</p><p>下面的控制器都包含对云平台驱动的依赖：</p><ul><li>节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除</li><li>路由控制器（Route Controller）: 用于在底层云基础架构中设置路由</li><li>服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器</li></ul></li></ul><p><strong>Node中组件</strong></p><blockquote><p>节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。</p></blockquote><ul><li><p><strong>kubelet</strong></p><p>一个在集群中每个node上运行的代理。 它保证容器都 运行在 Pod 中。kubelet 定期接收新的或修改过的 pod 规范 PodSpecs（主要通过 kube-apiserver）并确保 pod 及容器健康并以所需状态运行。该组件还向 kube-apiserver 报告运行它的主机的健康状况。</p><p><strong>kubelet 不会管理不是由 Kubernetes 创建的容器。</strong></p></li><li><p><strong>kube-proxy</strong></p><p>kube-proxy是集群中每个节点上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。用于处理单个主机子网划分并向外部世界公开服务。它跨集群中的各种隔离网络将请求转发到正确的 pod/容器。</p><p>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><p>如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。</p></li></ul><blockquote><p>该部分组件说明参考自： <a href="https://zhuanlan.zhihu.com/p/409971135">https://zhuanlan.zhihu.com/p/409971135</a></p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>docker kubelet kebectl kubeadm</p></blockquote><ol><li><strong>docker</strong> : 容器运行环境</li><li><strong>kubelet</strong> : 基本运行环境</li><li>kubectl : 帮助管理员输入相关操作命令， 可以只安装在admin</li><li>kubeadm : 帮助管理人员快速搭建集群环境</li></ol><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><ol><li><strong>配置yum源</strong></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ yum <span class="token function">install</span> -y yum-utils<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ yum-config-manager <span class="token punctuation">\</span>--add-repo <span class="token punctuation">\</span>https://download.docker.com/linux/centos/docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>安装docker</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">sudo</span> yum <span class="token function">install</span> -y docker-ce docker-ce-cli containerd.io<span class="token comment"># 安装指定版本</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">sudo</span> yum <span class="token function">install</span> -y docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io-1.4.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>启动docker</strong></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> docker --now<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>配置镜像加速</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="集群创建"><a href="#集群创建" class="headerlink" title="集群创建"></a>集群创建</h3><blockquote><p>请先保证docker安装完成</p></blockquote><p><strong>安装kebuadm</strong></p><ul><li>一台兼容的Linux主机。Kubernetes项目为基于Debian和Red Hat的Linux发行版以及一些不提供包管理器的发行版提供通用的指令</li><li>每台机器2GB或者更多的内存（较少会影响应用的运行内存）</li><li>2 CPU核或更多</li><li>集群中的所有机器的网络彼此均能相互连接（公网和内网都可以）<ul><li><strong>设置防火墙放行规则</strong></li></ul></li><li>节点之中不可以用重复的主机名、MAC地址和product_uuid<ul><li><strong>设置不同的hostname</strong></li></ul></li><li>开启机器上的某些端口<ul><li><strong>内网通信</strong></li></ul></li><li>禁用交换分区。为了保证kubelet正常工作，<strong>必须禁用交换分区</strong><ul><li><strong>永久关闭</strong></li></ul></li></ul><blockquote><p>设置主机名：hostnamectl set-hostname k8s-master</p><p>查看主机名：hostname</p><p>查看分区：free -m </p></blockquote><img src="/2022/04/30/cs-dev-ops/kubernetes/0003.png" class="" title="集群结构"><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 设置独立域名</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ hostnamectl set-hostname xxxx<span class="token comment"># 将SELinux设置为 permissive模式（相当于禁用）</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ setenforce <span class="token number">0</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">sed</span> -i <span class="token string">'s/^SELINUX=enforcing$/SELINUX=permissive/'</span> /etc/selinux/config<span class="token comment"># 关闭swap</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ swapoff -a<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">sed</span> -ri <span class="token string">'s/.*swap.*/#&amp;/'</span> /etc/fstab<span class="token comment"># 允许 iptables 检查桥接流量</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/modules-load.d/k8s.conf</span>br_netfilterEOF</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/sysctl.d/k8s.conf</span>net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ sysctl --system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="安装kubelet、kubeadm、kubectl"><a href="#安装kubelet、kubeadm、kubectl" class="headerlink" title="安装kubelet、kubeadm、kubectl"></a>安装kubelet、kubeadm、kubectl</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/yum.repos.d/kubernetes.repo</span>[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg   http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgexclude=kubelet kubeadm kubectlEOF</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ yum <span class="token function">install</span> -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes<span class="token operator">=</span>kubernetes<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> --now kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>kubelet 现在每隔几秒就会重启，因为它陷入了一个等待kubeadm指令的死循环在等待指令</p><p>可以使用命令  systemctl status kubelet 查看状态</p></blockquote><h4 id="使用kubeadm引导集群"><a href="#使用kubeadm引导集群" class="headerlink" title="使用kubeadm引导集群"></a>使用kubeadm引导集群</h4><h5 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h5><blockquote><p>下载各个机器需要的镜像</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">tee</span> ./images.sh <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'#!/bin/bashimages=(kube-apiserver:v1.20.9kube-proxy:v1.20.9kube-controller-manager:v1.20.9kube-scheduler:v1.20.9coredns:1.7.0etcd:3.4.13-0pause:3.2)for imageName in ${images[@]} ; dodocker pull $imageNamedoneEOF</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">chmod</span> +x ./images.sh <span class="token operator">&amp;&amp;</span> ./images.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="设置主节点"><a href="#设置主节点" class="headerlink" title="设置主节点"></a>设置主节点</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 所有机器添加master域名映射，以下需要修改为自己的master的内网ip地址</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"10.140.122.4 cluster-endpoint"</span> <span class="token operator">&gt;&gt;</span> /etc/hosts<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"10.140.122.39 node01"</span> <span class="token operator">&gt;&gt;</span> /etc/hosts<span class="token comment"># 在其他节点可以ping通主节点</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">ping</span> cluster-endpoint<span class="token comment"># 主节点运行 注意 --apiserver-advertise-address 映射的ip改成自己的</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubeadm init <span class="token punctuation">\</span>--apiserver-advertise-address<span class="token operator">=</span><span class="token number">10.140</span>.122.4 <span class="token punctuation">\</span>--control-plane-endpoint<span class="token operator">=</span>cluster-endpoint <span class="token punctuation">\</span>--image-repository registry.aliyuncs.com <span class="token punctuation">\</span>--kubernetes-version v1.20.9 <span class="token punctuation">\</span>--service-cidr<span class="token operator">=</span><span class="token number">10.96</span>.0.0/16 <span class="token punctuation">\</span>--pod-network-cidr<span class="token operator">=</span><span class="token number">192.168</span>.0.0/16<span class="token comment">## --apiserver-advertise-address  主节点的ip</span><span class="token comment">## --control-plane-endpoint       主节点的域名</span><span class="token comment">## --image-repository             镜像仓库</span><span class="token comment">## --kubernetes-version           k8s版本</span><span class="token comment">## service-cidr                   k8s内部进行负载均衡使用ip范围  不可与机器的ip有所重叠</span><span class="token comment">## --pod-network-cidr             k8s启动的pod的ip地址的范围   不可与机器的ip有所重叠</span><span class="token comment"># 保证每个配置之间的网络范围不重叠 --apiserver-advertise-address、--service-cidr、--pod-network-cidr</span><span class="token comment"># 如果这里修改了 后两个配置项的ip域，后续的 calico.yaml 文件中要进行对应修改</span><span class="token comment">## 复制保留 Your Kubernetes control-plane has initialized successfully 后面的内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="后续操作"><a href="#后续操作" class="headerlink" title="后续操作"></a>后续操作</h5><blockquote><p>根据安装后的提示选择执行部分</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># To start using your cluster, you need to run the following as a regular user:</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p <span class="token environment constant">$HOME</span>/.kube<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">cp</span> -i /etc/kubernetes/admin.conf <span class="token environment constant">$HOME</span>/.kube/config<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> <span class="token environment constant">$HOME</span>/.kube/config<span class="token comment"># Alternatively, if you are the root user, you cna run:</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">KUBECONFIG</span><span class="token operator">=</span>/etc/kubernetes/admin.conf<span class="token comment"># You should now deploy a pod network to the cluster.</span><span class="token comment"># RUN "kubectl apply -f [podnetwork].yaml" with one of the options # listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="部署网络组件"><a href="#部署网络组件" class="headerlink" title="部署网络组件"></a>部署网络组件</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 官方文档 https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">curl</span> https://docs.projectcalico.org/manifests/calico.yaml -O<span class="token comment">## 如果出现警告（k8s使用高于1.21版本）</span><span class="token comment">## Warning: policy/v1beta1 PodDisruptionBudget is deprecated in v1.21+, unavailable in v1.25+; use policy/v1 PodDisruptionBudget poddisruptionbudget.policy "calico-kube-controllers" deleted</span><span class="token comment">## 1. 原因在于policy/v1beta1 在1.22之后使用 policy/v1, 1.25正式移除，暂不影响使用，</span><span class="token comment">## 2. 如果想去除 可以修改下载的calico.yaml，找到其中的`policy/v1beta1`修改为`policy/v1`即可</span><span class="token comment"># -f 应用文件</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl apply -f calico.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="加入node节点"><a href="#加入node节点" class="headerlink" title="加入node节点"></a>加入node节点</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 根据之前的提示 将node节点加入集群</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubeadm <span class="token function">join</span> cluster-endpoint:6443 --token xxxxxxxxx<span class="token comment"># 上述的令牌只有24小时有效 过期了使用下述命令重新生成</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubeadm token create -print-join-command<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h5><blockquote><p>kubectl 只有在主节点有效</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看集群所有节点</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get nodes<span class="token comment"># 根据配置文件，给集群创建资源</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl apply -f xxx.yaml<span class="token comment"># 查看集群部署了哪些应用</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pods -A<span class="token comment">## === docker ps</span><span class="token comment">## docker中叫做容器 在 k8s中叫做pos</span><span class="token comment">## kubectl get pods -A -w 保留窗口信息监控</span><span class="token comment">## watch -n 1 kubectl get pods -A</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="部署dashboard"><a href="#部署dashboard" class="headerlink" title="部署dashboard"></a>部署dashboard</h4><ol><li><strong>部署</strong></li></ol><blockquote><p>kubernetes官方提供的可视化界面</p><p><a href="https://github.com/kubernetes/dashboard">https://github.com/kubernetes/dashboard</a></p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.5.1/aio/deploy/recommended.yaml<span class="token comment"># 备注: raw.githubusercontent.com 属于外网 由于域名污染的问题 可能直接执行无法访问，可以选择在浏览器中复制上面的链接 在本地创建文件保存内容 (科学上网？)</span><span class="token comment"># 复制保存到本地后 使用命令 kubectl apply -f ./recommended.yaml 执行文件</span><span class="token comment"># 拉取dashboard镜像报CarshLoopBackoff 需要调整yaml文件两处 添加主机名 nodeName   eg. k8s_master</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>附本人github复制文件下载链接：<a href="https://github.com/RobertSunq/data/blob/master/qing/blog/hexo/kubernetes/recommended_v2.5.1.yaml" title="v2.5.1 recommended.yaml 下载链接 ">recommended</a></p></blockquote><ol start="2"><li><strong>设置访问端口</strong></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard<span class="token comment"># 暴露dashboard的端口号</span><span class="token comment">### 1. 打开文件后  </span><span class="token comment">### 2. 输入 `/` </span><span class="token comment">### 3. 之后输入 `type:` ，找到文本 `type: ClusterIP` </span><span class="token comment">### 4. 修改为 NodePort</span><span class="token comment">### 5. 退出并保存</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>NodeIP： node节点的IP地址，即物理网卡的IP地址</p><p>PodIp：Pod的IP地址，即docker容器的IP地址，此为虚拟IP地址</p><p>ClusterIP：Service的IP地址，此为虚拟IP地址</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 通过公网ip访问的话需要在虚拟机或者云服务器中开放端口</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get svc -A <span class="token operator">|</span> <span class="token function">grep</span> kubernetes-dashboard<span class="token comment">## 找到端口，在安全组放行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之后通过:  https://集群任意IP:Port 就可以访问了</p><ol start="3"><li><strong>创建访问账号</strong></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">vim</span> dash_manager.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 创建dash_manager.yaml文件，并键入以下文本，使用kebuctl apply -f dash_manager.yaml 来创建相关账号</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin   <span class="token comment"># 该处为命名空间，注意跟上面安装的dashboard配置中的命名空间相同</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>dashboard<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span> <span class="token punctuation">:</span> cluster<span class="token punctuation">-</span>admin<span class="token key atrule">subjects</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin  <span class="token comment"># 该处为命名空间，注意跟上面安装的dashboard配置中的命名空间相同</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>dashboard<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl apply -f dash_manager.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 如果启动失败通过下面命令查看pod信息</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pods,svc -n kubernetes-dashboard -o wide<span class="token comment"># 找到对应启动失败pod的name 查看详细信息 {{pod-name}}为上一步查出的问题</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl describe pod/<span class="token punctuation">{</span><span class="token punctuation">{</span>pod-name<span class="token punctuation">}</span><span class="token punctuation">}</span> -n kubernetes-dashboard<span class="token comment"># 修改后 可以从master节点重启下pod , 删除后k8s可以自动恢复</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl delete pod/<span class="token punctuation">{</span><span class="token punctuation">{</span>pod-name<span class="token punctuation">}</span><span class="token punctuation">}</span> -n kubernetes-dashboard<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2022/04/30/cs-dev-ops/kubernetes/0004.png" class="" title="错误演示"><ol start="4"><li><strong>令牌访问</strong></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl -n kubernetes-dashboard get secret <span class="token variable"><span class="token variable">$(</span>kubectl -n kubernetes-dashboard get sa/admin -o <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">"{.secrets[0].name}"</span><span class="token variable">)</span></span> -o go-template<span class="token operator">=</span><span class="token string">"{{.data.token | base64decode}}"</span><span class="token comment"># 将输出的密钥复制保留</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="5"><li>mac上通过代理访问</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 启用代理</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl proxy  <span class="token comment"># 访问网址：http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#!/overview?namespace=default</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="核心实战"><a href="#核心实战" class="headerlink" title="核心实战"></a>核心实战</h2><p>资源创建方式主要有两种</p><ul><li>命令行：键入命令</li><li>YAML：编写yaml文件来执行</li></ul><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><blockquote><p>命名空间 ： 用来隔离资源，分组。默认只隔离资源，不隔离网络。</p></blockquote><h4 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查询命名空间</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get namespace<span class="token comment"># [root@qing centos]$ kubectl get ns # ns 为namespace缩写</span><span class="token comment"># ----------------------------------------------------</span>NAME                   STATUS   AGEdefault                Active   6d3hkube-node-lease        Active   6d3hkube-public            Active   6d3hkube-system            Active   6d3hkubernetes-dashboard   Active   4m23s<span class="token comment"># ----------------------------------------------------</span><span class="token comment"># 获取部署的应用</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pods -A <span class="token comment"># -A 获取所有的应用 不添加时获取 namespace=default 下的应用</span><span class="token comment"># -n namespace 查询指定命名空间下面的应用 kubectl get pods -n kubernetes-dashboard</span><span class="token comment"># 创建命名空间</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create ns kube-qing<span class="token comment"># 删除命名空间</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl delete ns kube-qing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">注意：删除命名空间的时候会连带删除该命名空间下的所有资源</font></p><h4 id="YAML操作"><a href="#YAML操作" class="headerlink" title="YAML操作"></a>YAML操作</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">tee</span> ./kube_qing.yaml <span class="token operator">&lt;&lt;-</span><span class="token string">EOFapiVersion: v1 # 版本号kind: Namespace # 指定资源类型  命名空间metadata: # 元数据  name: kube-qingEOF</span><span class="token comment"># 应用该文件创建命名空间</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl apply -f ./kube_qing.yaml<span class="token comment"># 删除时也可以使用配置文件删除</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl delete -f ./kube_qing.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="命令小结-1"><a href="#命令小结-1" class="headerlink" title="命令小结"></a>命令小结</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 获取所有的命令空间</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get namespace<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get ns<span class="token comment"># 获取部署的pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod -A<span class="token comment"># -n {{命名空间}}  指定命名空间</span><span class="token comment"># 创建命名空间</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create ns <span class="token punctuation">{</span><span class="token punctuation">{</span>namespace<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment"># 删除命名空间</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create ns <span class="token punctuation">{</span><span class="token punctuation">{</span>namespace<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><blockquote><p>运行中的一组容器，Pod是kubernetes中应用的最小单位</p></blockquote><p>下图中为一个pod包含两个容器组成一个小应用</p><img src="/2022/04/30/cs-dev-ops/kubernetes/0005.png" class="" title="pod结构"><ol><li>Pod和container都运行在以docker为基础的环境上</li><li>container（容器）为dokcer管理的单位，每个应用包装为一个容器在运行</li><li>Pod为k8s在container的基础上再包装一层用于作为最小单位用于管理，Pod中可以只包含一个容器也可以包含多个容器</li></ol><img src="/2022/04/30/cs-dev-ops/kubernetes/0006.png" class="" title="Pod和container"><h4 id="命令行操作-1"><a href="#命令行操作-1" class="headerlink" title="命令行操作"></a>命令行操作</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 启动一个pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl run qing-nginx --image<span class="token operator">=</span>nginx -n kube-qing<span class="token comment"># --image=nginx  指定镜像为nginx启动容器</span><span class="token comment"># -n 指定命名空间  不指定是为 default 命名空间</span><span class="token comment"># 包装为pod 命名为qing-nginx</span><span class="token comment"># 查看kube-qing命名空间下的pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod -n kube-qing<span class="token comment"># 查看pod的详情  describe 描述pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl describe pod qing-nginx -n kube-qing<span class="token comment"># ------------------------------------------------</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.Events:  <span class="token comment"># 启动pod中的事件过程</span>  Type    Reason     Age   From               Message  ----    ------     ----  ----               -------  Normal  Scheduled  116s  default-scheduler  Successfully assigned kube-qing/qing-nginx to docker-desktop   <span class="token comment"># 116s 前 成功将任务分配给docker-desktop节点</span>  Normal  Pulling    116s  kubelet            Pulling image <span class="token string">"nginx"</span>   <span class="token comment"># 116s 前 kubelet拉取镜像</span>  Normal  Pulled     99s   kubelet            Successfully pulled image <span class="token string">"nginx"</span> <span class="token keyword">in</span> <span class="token number">16</span>.555086628s  Normal  Created    99s   kubelet            Created container qing-nginx   <span class="token comment"># 99s 前 创建容器成功</span>  Normal  Started    99s   kubelet            Started container qing-nginx   <span class="token comment"># 99s 前 启动容器成功</span><span class="token comment"># ------------------------------------------------</span><span class="token comment"># 集群环境下 该容器只会在第一步分配的节点上启动 其他节点上不会启动</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看日志</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl logs qing-nginx -n kube-qing<span class="token comment"># -f 追踪显示日志</span><span class="token comment"># 删除刚刚启动的pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl delete pod qing-nginx -n kube-qing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="YAML操作-1"><a href="#YAML操作-1" class="headerlink" title="YAML操作"></a>YAML操作</h4><ol><li>一个pod包含一个容器</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod <span class="token comment"># 资源类型</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>   <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">run</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx  <span class="token comment"># pod 的名字</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>qing <span class="token comment"># 所在的命名空间</span><span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment"># 所要创建的pod的详细信息</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token comment"># 指定启动的容器， 可以启动多个容器，使用多个 - image 形式</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx <span class="token comment"># 镜像名称</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx <span class="token comment"># 容器的名字， docker ps 可查询</span>  <span class="token comment"># - image: mysql</span>  <span class="token comment">#   name: qing-mysql</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>一个pod包含多个容器</p><blockquote><p>同一个pod中共享网络空间，使用的是同一个ip地址，所以这里可以通过分别访问启动的qing-nginx-tomcat Pod的80和8080端口可以验证启动的两个容器</p><p>可以将pod类比理解为一个小的虚拟机环境，可以启动多个容器，但是容器间不能端口冲突</p></blockquote></li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod <span class="token comment"># 资源类型</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>   <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">run</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>tomcat  <span class="token comment"># pod 的名字</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>qing <span class="token comment"># 所在的命名空间</span><span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment"># 所要创建的pod的详细信息</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token comment"># 指定启动的容器， 可以启动多个容器，使用多个 - image 形式</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx <span class="token comment"># 镜像名称</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>nginx <span class="token comment"># 容器的名字， docker ps 可查询</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> tomcat<span class="token punctuation">:</span>8.5.68 <span class="token comment"># 镜像名+版本</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动成功后</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看命名空间kube-qing下的pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod -n kube-qing -o wideNAME                READY   STATUS    RESTARTS   AGE     IP          NODE             NOMINATED NODE   READINESS GATESqing-nginx          <span class="token number">1</span>/1     Running   <span class="token number">0</span>          2m34s   <span class="token number">192.168</span>.0.57   docker-desktop   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>qing-nginx-tomcat   <span class="token number">2</span>/2     Running   <span class="token number">0</span>          2m22s   <span class="token number">192.168</span>.0.58   docker-desktop   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>           <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span><span class="token comment"># 访问qing-nginx-tomcat中的容器</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token number">192.168</span>.0.58:80<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">curl</span> <span class="token number">192.168</span>.0.58:8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="命令小结-2"><a href="#命令小结-2" class="headerlink" title="命令小结"></a>命令小结</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">## 以下 -n 为可选参数  不指明时为 default 空间</span><span class="token comment">## 每个pod k8s都会分配一个ip</span><span class="token comment">## 集群中的任意一个机器以及任意的应用都能通过pod分配的ip来访问，但是在集群外部不能访问</span><span class="token comment"># 启动pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl run <span class="token punctuation">{</span><span class="token punctuation">{</span>自定义名称<span class="token punctuation">}</span><span class="token punctuation">}</span> --image<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>镜像名<span class="token punctuation">}</span><span class="token punctuation">}</span> -n <span class="token punctuation">{</span><span class="token punctuation">{</span>命名空间<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment"># 查看命名空间中的pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod -n <span class="token punctuation">{</span><span class="token punctuation">{</span>命名空间<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment"># 描述启动中的pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl describe pod <span class="token punctuation">{</span><span class="token punctuation">{</span>pod名称<span class="token punctuation">}</span><span class="token punctuation">}</span> -n <span class="token punctuation">{</span><span class="token punctuation">{</span>命名空间<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment"># 删除命名空间中的pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl delete pod <span class="token punctuation">{</span><span class="token punctuation">{</span>pod名称<span class="token punctuation">}</span><span class="token punctuation">}</span> -n <span class="token punctuation">{</span><span class="token punctuation">{</span>命名空间<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment"># 查看pod的运行日志</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl logs <span class="token punctuation">{</span><span class="token punctuation">{</span>pod名称<span class="token punctuation">}</span><span class="token punctuation">}</span> -n <span class="token punctuation">{</span><span class="token punctuation">{</span>命名空间<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment"># 打印pod更完善的信息</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod -o wide<span class="token comment"># 进入pod中容器的 /bin/bash</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> -it qing-nigin -- /bin/bash<span class="token comment"># 监控pod的操作</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod -w<span class="token comment"># 用,分割获取多种资源</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod,svc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><blockquote><p>部署应用：控制Pod，使Pod拥有多个副本、自愈、阔缩容等能力</p></blockquote><h4 id="命令行操作-2"><a href="#命令行操作-2" class="headerlink" title="命令行操作"></a>命令行操作</h4><ol><li>创建pod</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl run mynginx --image<span class="token operator">=</span>nginx<span class="token comment"># 使用deployment创建pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create deployment mytomcat --image<span class="token operator">=</span>tomcat:8.5.68<span class="token comment">## 但是使用 kubectl delete pod mytomcat-xxxx的时候 会触发自愈 重新启动一个pod </span><span class="token comment">## 想要删除的话 使用命令 kubectl delete deploy mytomcat</span><span class="token comment">## 查询所有的部署  kubectl get deploy</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>启用多副本</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create deployment qing-app --image<span class="token operator">=</span>nginx --replicas<span class="token operator">=</span><span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>阔缩容</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 扩容</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl scale --replicas<span class="token operator">=</span><span class="token number">5</span> deployment/qing-app<span class="token comment"># 缩容 将replicas缩小</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl scale --replicas<span class="token operator">=</span><span class="token number">2</span> deployment/qing-app<span class="token comment"># 也可也直接去修改对应的YAML</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl edit deployment qing-app<span class="token comment"># 修改其中的 replicas 参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="YAML操作-2"><a href="#YAML操作-2" class="headerlink" title="YAML操作"></a>YAML操作</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment <span class="token comment"># 资源类型 </span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span> <span class="token comment"># 副本个数</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app  <span class="token key atrule">template</span><span class="token punctuation">:</span> <span class="token comment"># 副本的模版</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span> <span class="token comment"># 启动的容器</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx <span class="token comment"># 使用的镜像</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="自愈和故障转移"><a href="#自愈和故障转移" class="headerlink" title="自愈和故障转移"></a>自愈和故障转移</h4><p><strong>自愈</strong>：当Pod出现停机、删除Pod、容器崩溃等时，k8s可以自行重启Pod</p><p><strong>故障转移</strong>：集群状态下，如果一台机器因为断电等原因掉线，k8s在监控到这种情况后，会将这台机器上之前运行的所有Pod转移到当前集群中状态正常的节点上。</p><h4 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h4><blockquote><p>灰度发布</p><p>当更新某个pod时：</p><ol><li><p>先启动V2版本的Pod，此时V1版本的Pod依旧接受流量处理任务</p></li><li><p>当V2版本的Pod稳定后，会将流量请求切换到V2版本的Pod，然后关闭掉V1版本的Pod</p></li></ol></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 以Deployment中yaml部署的应用为例</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">set</span> image deployment/qing-app <span class="token assign-left variable">nginx</span><span class="token operator">=</span>nginx:1.16.1  --record<span class="token comment"># set image 设置镜像 </span><span class="token comment"># deployment/qing-app 目标应用的名称  </span><span class="token comment"># nginx=nginx:1.16.1 修改的内容</span><span class="token comment"># --record  </span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl rollout status deployment/qing-app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 历史记录</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl rollout <span class="token function">history</span> deployment/qing-app<span class="token comment"># 查看某个历史详情</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl rollout <span class="token function">history</span> deployment/qing-app --revision<span class="token operator">=</span><span class="token number">2</span><span class="token comment"># 回滚（上个版本）</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl rollout undo deployment/qing-app<span class="token comment"># 回滚（指定版本）</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl rollout undo deployment/qing-app --to-revision<span class="token operator">=</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Deployment-StatefulSet-DaemonSet-Job-CronJob"><a href="#Deployment-StatefulSet-DaemonSet-Job-CronJob" class="headerlink" title="Deployment StatefulSet DaemonSet Job/CronJob"></a><code>Deployment</code> <code>StatefulSet</code> <code>DaemonSet</code> <code>Job/CronJob</code></h4><p><strong>延伸</strong>：</p><p>除了<code>Deployment</code>之外，k8s还有<code>StatefulSet</code>、<code>DaemonSet</code>、<code>Job</code>等类型资源。统称为<font color="blue">工作负载</font>。</p><ul><li><code>Deployment</code>：无状态应用部署，例如微服务，提供多副本等功能</li><li><code>StatefulSet</code>：有状态应用部署，例如redis，提供稳定的存储、网络等功能</li><li><code>DaemonSet</code>：守护型应用部署，例如日志收集组件，在每个机器都运行一份(有且只有一份)</li><li><code>Job</code>/<code>CronJob</code>：定时任务部署，例如垃圾清理组件，可以在指定时间运行</li></ul><p>有状态应用使用  <code>StatefulSet</code>  部署，无状态应用使用 <code>Deployment</code> 部署</p><blockquote><p><a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/">https://kubernetes.io/zh/docs/concepts/workloads/controllers/</a></p></blockquote><p>在dashboard上也有对应管理菜单页</p><img src="/2022/04/30/cs-dev-ops/kubernetes/0007.png" class="" title="dashboard"><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><blockquote><p>将一组Pods公开为网络服务等抽象方法。</p><p>Pod的服务发现与负载均衡</p></blockquote><img src="/2022/04/30/cs-dev-ops/kubernetes/0008.png" class="" title="service"><h4 id="命令行操作-3"><a href="#命令行操作-3" class="headerlink" title="命令行操作"></a>命令行操作</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 暴露Deploy 默认在集群内有效</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl expose deployment qing-app --port<span class="token operator">=</span><span class="token number">8000</span> --target-port<span class="token operator">=</span><span class="token number">80</span><span class="token comment">## deployment qing-app  --port=8000 暴露的port  指的是service的端口</span><span class="token comment">## --target-port=80  映射目标的port  指的是pods的端口</span><span class="token comment">## 后面存在默认参数 --type=ClusterIP</span><span class="token comment"># 查看服务 </span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get <span class="token function">service</span><span class="token comment"># 使用标签检索Pod</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod -l <span class="token assign-left variable">app</span><span class="token operator">=</span>qing-app<span class="token comment"># 查询pod的标签</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod --show-labels<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#测试</span><span class="token comment"># 进入容器内部，修改/usr/share/nginx/html/index.html 文件来进行测试</span><span class="token punctuation">[</span>root@qing-tomcat-bxx<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token number">1111</span> <span class="token operator">&gt;</span> /usr/share/nginx/html/index.html<span class="token comment">## 将多个pod设置为不同的值</span><span class="token comment"># 在宿主机上</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">curl</span> ip:8000<span class="token comment"># 可以访问到 nginx pod的80端口的内容</span><span class="token comment"># 在容器内使用域名访问</span><span class="token punctuation">[</span>root@qing-tomcat-bxx<span class="token punctuation">]</span>$ <span class="token function">curl</span> qing-app.kube-qing.svc:8000<span class="token comment"># 组成规则 qing-app.kube-qing.svc:8000 -&gt; 服务名.命名空间.svc     -&gt; svc:service</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="YAMl操作"><a href="#YAMl操作" class="headerlink" title="YAMl操作"></a>YAMl操作</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service <span class="token comment"># 资源名称</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app <span class="token comment"># 筛选指定的pod  名为：app  值为：qing-app</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span> <span class="token comment"># 一组port，可以配置多个</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8000</span>  <span class="token comment"># 暴露的端口号 指的是service的端口</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP <span class="token comment"># 端口协议</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span> <span class="token comment"># 目标端口  指的是pods的端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h3><blockquote><p>集群IP，只能在集群中访问。</p><p>service中操作时，默认的类型就是 clusterIP。</p></blockquote><h4 id="命令行操作-4"><a href="#命令行操作-4" class="headerlink" title="命令行操作"></a>命令行操作</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl expose deployment qing-app --port<span class="token operator">=</span><span class="token number">8000</span> --target-port<span class="token operator">=</span><span class="token number">80</span> --type<span class="token operator">=</span>ClusterIP <span class="token comment"># 只能在集群内通过 CLUSTER-IP 访问</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="YAMl操作-1"><a href="#YAMl操作-1" class="headerlink" title="YAMl操作"></a>YAMl操作</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8000</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app  <span class="token key atrule">type</span><span class="token punctuation">:</span> ClusterIP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h3><blockquote><p>节点ip，集群外面也可以访问，即可以在公网中访问。</p></blockquote><h4 id="命令行操作-5"><a href="#命令行操作-5" class="headerlink" title="命令行操作"></a>命令行操作</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl expose deployment qing-app --port<span class="token operator">=</span><span class="token number">8000</span> --target-port<span class="token operator">=</span><span class="token number">80</span> --type<span class="token operator">=</span>NodePort <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2022/04/30/cs-dev-ops/kubernetes/0009.png" class="" title="服务列表"><p>可以看出<code>qing-app</code>的<code>PORT</code>部分多出来一个<code>30002</code>端口，由kubernetes开启，并且在所以的<code>pod</code>上面均开启。 此时就可以通过 <code>公网IP:30002</code>进行访问了</p><blockquote><p>NodePort默认范围在 30000 - 32767之间</p></blockquote><h4 id="YAMl操作-2"><a href="#YAMl操作-2" class="headerlink" title="YAMl操作"></a>YAMl操作</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app  <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8000</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>app  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><blockquote><p>流量入口，是Service的统一网关入口</p><p>基于nginx实现</p><p>安装时用的<code>ingress yaml</code>只是一个声明，本身不做任何事情。如果需要实际的<code>ingress</code>功能，就需要部署<code>ingress controller</code>。这个 <code>controller</code> 也使用了 <code>LoadBalancer service type</code>，使得集群外流量通过 <code>Cloud LB</code> 可以被转发到 <code>ingress controller</code> 上。</p></blockquote><img src="/2022/04/30/cs-dev-ops/kubernetes/0010.png" class="" title="ingress"><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">wget</span> https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.47.0/deploy/static/provider/baremetal/deploy.yaml<span class="token comment"># 如果其中镜像下载过慢，可以修改改yaml文件中images的值，指定为从国内的镜像仓库中下载</span><span class="token comment"># 检查安装的结果</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get pod,svc -n ingress-nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>附本人github复制文件下载链接：<a href="https://github.com/RobertSunq/data/blob/master/qing/blog/hexo/kubernetes/ingress_v0.47.yaml" title="v0.47.0 ingress.yaml 下载链接 ">ingress</a></p><p>出现两个端口，分别用于 <code>http</code> 和 <code>https</code></p></blockquote><img src="/2022/04/30/cs-dev-ops/kubernetes/0011.png" class="" title="安装会创建service"><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><blockquote><p>官方手册：<a href="https://kubernetes.github.io/ingress-nginx/">https://kubernetes.github.io/ingress-nginx/</a></p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 创建测试环境</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">vi</span> ingress-server.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server        <span class="token comment"># todo  待修改</span>        <span class="token key atrule">image</span><span class="token punctuation">:</span> robertsunq/hello<span class="token punctuation">-</span>server        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">9000</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8000</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server  <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8000</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">9000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>域名访问</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 访问规则</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">vi</span> ingress—test.yaml<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl apply -f ingress—test.yaml<span class="token comment"># 执行后，查看ingress</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get ingress<span class="token comment"># 注意需要将下方测试的域名映射填入到/etc/hosts文件中</span><span class="token comment"># master_ip  hello.qing.com</span><span class="token comment"># master_ip  demo.qing.com</span><span class="token comment"># 测试完后可以修改下 demo.qing.com 的映射path为 path: "/nginx"</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl edit ing ingress-host-bar<span class="token comment"># ing  ingress的缩写</span><span class="token comment"># ingress-host-bar 对应的ingress name</span><span class="token comment">#### 此时访问 demo.qing.com:31063 页面为  404 nignx</span><span class="token comment">#### 此时访问 demo.qing.com:31063/nginx 页面为  404 nignx/1.21.1</span><span class="token comment">##### 会发现第二个下面会带有版本号，</span><span class="token comment">##### 原因在于第一次访问是由ingress的nginx代理的 没有找到对应的服务pod所以返回的是ingress的404页面</span><span class="token comment">##### 第二次访问由ingress的代理找到了下属的服务nginx-demo  所以返回的是下属的服务nginx-demo对应的404页面也就是带有版本号的</span><span class="token comment"># 可以进入到nginx-demo部署下面的一个pod中</span><span class="token punctuation">[</span>root@qing nginx-demo-xxxx<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> /usr/share/nginx/html<span class="token punctuation">[</span>root@qing nginx-demo-xxxx<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token number">1111</span> <span class="token operator">&gt;</span> nginx<span class="token comment"># 此时再去访问demo.qing.com:31063/nginx 就可以看到哥哥添加的文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress  <span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>host<span class="token punctuation">-</span>bar<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ingressClassName</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token comment"># 指定域名,</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">"hello.qing.com"</span>    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token comment"># 路径模式为 前缀</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/"</span>        <span class="token comment"># 转发给对应服务</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">8000</span>  <span class="token comment"># 指定域名</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">"demo.qing.com"</span>    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/"</span>        <span class="token comment"># path: "/nginx" # 第二次修改修改为此path 对比两次的区别 </span>        <span class="token comment">## 会将请求路径/nginx转给下面的nginx-demo服务 如果此时nginx-demo不能处理路径/nginx就会出现 404</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">8000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2022/04/30/cs-dev-ops/kubernetes/0012.png" class="" title="ingress测试示例"><p><strong>路径重写</strong></p><blockquote><p>官方示例：<a href="https://kubernetes.github.io/ingress-nginx/examples/rewrite/">https://kubernetes.github.io/ingress-nginx/examples/rewrite/</a></p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token comment">## 重写路径  /$2  部分  即下方(/|$)(.*)捕获的部分都赋予$2</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/rewrite-target</span><span class="token punctuation">:</span> /$2        <span class="token comment">## 指定该部分路径是否只可以通过SSL访问</span>    <span class="token comment"># nginx.ingress.kubernetes.io/ssl-redirect: true </span>    <span class="token comment">## 指定在未启用TLS下，也强制重定向到HTTPS</span>    <span class="token comment"># nginx.ingress.kubernetes.io/force-ssl-redirect: true</span>    <span class="token comment">## 定义重定向 上下文到 root 即访问rewrite.qing.com将重定向到 rewrite.qing.com/app1</span>    <span class="token comment"># nginx.ingress.kubernetes.io/app-root: /app1</span>    <span class="token comment">## 路径上知否使用正则</span>    <span class="token comment"># nginx.ingress.kubernetes.io/use-regex: true</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> rewrite  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ingressClassName</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> rewrite.qing.com    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /something(/<span class="token punctuation">|</span>$)(.<span class="token important">*)</span>        <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo            <span class="token key atrule">port</span><span class="token punctuation">:</span>               <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重写后的效果为：</p><ul><li>rewrite.qing.com/something   -&gt; rewrite.qing.com/</li><li>rewrite.qing.com/something/   -&gt; rewrite.qing.com/</li><li>rewrite.qing.com/something/new   -&gt; rewrite.qing.com/new</li></ul><p><strong>流量限制</strong></p><blockquote><p>官方示例：<a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#rate-limiting">https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#rate-limiting</a></p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>limit<span class="token punctuation">-</span>rate  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/limit-rps</span><span class="token punctuation">:</span> <span class="token string">"1"</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ingressClassName</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">"haha.qing.com"</span>    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>        <span class="token comment"># 精确模式</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Exact        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/"</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">8000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="网络模型简述"><a href="#网络模型简述" class="headerlink" title="网络模型简述"></a>网络模型简述</h3><ul><li>所有的<code>Pod</code>属于<code>Pod</code>层，相互之间是网络共同的，其<code>IP</code>地址的区间为上面设置主节点配置时设置<code>--pod-network-cidr=192.168.0.0/16</code></li><li>根据<code>Pod</code>的功能属性氛围不同的<code>service</code>，<code>service</code>之间的网络也是相关联通的，而且与所有的<code>pod</code>之间网络联通，，其<code>IP</code>地址的区间为上面设置主节点配置时设置<code>--service-cidr=10.96.0.0/16</code></li><li><code>pod</code>之间可以相互直接访问，也可以通过其所属的<code>service</code>访问其他的<code>pod</code></li><li>外部请求流量通常是经由<code>LB</code>之后到达<code>Ingress</code>层做网关流量管控，之后在发送给对应的<code>serivce</code>来调用其具体的<code>pod</code>功能支持</li></ul><img src="/2022/04/30/cs-dev-ops/kubernetes/0013.png" class="" title="网络简述"><h3 id="存储抽象"><a href="#存储抽象" class="headerlink" title="存储抽象"></a>存储抽象</h3><p>原始的容器挂载目录在宿主机上，但是现在<code>kubernetes</code>在集群环境下，在不同的机器上启动<code>pod</code>，如果其中<code>C</code>机器上的一个<code>pod</code>出现问题退出了，由于故障转移的机制<code>kubernetes</code>可能会在<code>B</code>机器上新建这个出问题的<code>pod</code>，这时<code>pod</code>所挂载的目录就是在两台机器上了，存在物理上的隔离。</p><img src="/2022/04/30/cs-dev-ops/kubernetes/0014.png" class="" title="内存抽象"><p><strong>环境准备</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 所有机器安装 nfs文件管理工具</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ yum <span class="token function">install</span> -y nfs-utils<span class="token comment"># 主节点设置 </span><span class="token comment">############</span><span class="token comment"># 挂载nfs，以下是配置</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"/nfs/data/ *(insecure,rw,sync,no_root_squash)"</span> <span class="token operator">&gt;</span> /etc/exports<span class="token comment"># /nfs/data/ 需要暴露的目录 </span><span class="token comment"># * 所有人可以同步</span><span class="token comment"># insecure,rw,sync,no_root_squash 同步的方式</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p /nfs/data<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> rpcbind --now<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ systemctl <span class="token builtin class-name">enable</span> nfs-server --now<span class="token comment"># 配置生效</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ exportfs -r<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ exportfs/nfs/data<span class="token operator">&lt;</span>world<span class="token operator">&gt;</span><span class="token comment">############</span><span class="token comment"># 从节点设置,挂载主节点的nfs目录</span><span class="token comment">############</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ showmount -e <span class="token punctuation">{</span><span class="token punctuation">{</span>主节点IP<span class="token punctuation">}</span><span class="token punctuation">}</span>Export list <span class="token keyword">for</span> <span class="token number">172.1</span>.1.1/nfs/data *<span class="token comment">#挂载 nfs 服务器上的共享目录到本机路径 /root/nfsmount</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p /nfs/data_bak<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mount</span> -t nfs <span class="token punctuation">{</span><span class="token punctuation">{</span>主节点IP<span class="token punctuation">}</span><span class="token punctuation">}</span>:/nfs/data /nfs/data_bak<span class="token comment"># {{主节点IP}}:/nfs/data 挂载到当前机器的 /nfs/data_bak目录</span><span class="token comment"># 写入一个测试文件</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token string">"hello nfs server"</span> <span class="token operator">&gt;</span> /nfs/data/test.txt<span class="token comment">############</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="原生方式数据挂载"><a href="#原生方式数据挂载" class="headerlink" title="原生方式数据挂载"></a>原生方式数据挂载</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pv<span class="token punctuation">-</span>demo  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pv<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token comment"># 数量</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pv<span class="token punctuation">-</span>demo  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pv<span class="token punctuation">-</span>demo    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token comment"># nginx 镜像容器</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token comment"># 卷挂载</span>        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html          <span class="token comment"># 容器的内部目录</span>          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html          <span class="token comment"># 挂载方式  nfs</span>          <span class="token key atrule">nfs</span><span class="token punctuation">:</span>            <span class="token key atrule">server</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>主节点IP<span class="token punctuation">}</span><span class="token punctuation">}</span>            <span class="token comment"># 宿主机的目标路径</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data/nginx<span class="token punctuation">-</span>pv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>执行可能会出错，提示/nfs/data/nginx-pv不存在， 需要在宿主机上创建该目录重启</p></blockquote><h4 id="PV-amp-PVC"><a href="#PV-amp-PVC" class="headerlink" title="PV&amp;PVC"></a>PV&amp;PVC</h4><blockquote><p>PV：持久卷（Persistent Volume），将应用需要持久化的数据保存到指定位置</p><p>PVC：持久卷申明（Persistent Volume Claim），申明需要使用到持久卷规格，用来在PV中申请区间，也可以删除该申明来从PV中删除存储的内容</p></blockquote><h5 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h5><p><strong>创建PV池</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 主节点创建几块目录</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p /nfs/data/01<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p /nfs/data/02<span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p /nfs/data/03<span class="token comment"># 查询当前所有的PV</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kebectl get <span class="token function">pv</span><span class="token comment"># pv PersistentVolume</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>创建PV</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume <span class="token comment"># 持久化卷</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv01<span class="token punctuation">-</span>10m<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token comment"># 容量, 静态供应，容量固定</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 10M  <span class="token comment"># 权限模式</span>  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteMany  <span class="token comment"># 存储空间明</span>  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token comment"># 路径</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data/01    <span class="token key atrule">server</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>主节点IP<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment"># 通过 --- 分割每部分的内容</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv02<span class="token punctuation">-</span>1gi<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteMany  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data/02    <span class="token key atrule">server</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>主节点IP<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv03<span class="token punctuation">-</span>3gi<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 3Gi  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteMany  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data/03    <span class="token key atrule">server</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>主节点IP<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="PVC"><a href="#PVC" class="headerlink" title="PVC"></a>PVC</h5><p><strong>创建PVC</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim <span class="token comment"># 资源类型 申请书</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pvc<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteMany  <span class="token key atrule">resources</span><span class="token punctuation">:</span>    <span class="token key atrule">requests</span><span class="token punctuation">:</span>      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 200Mi  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs  <span class="token comment"># 与PV中穿件的存储空间名字相同</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>创建Pod绑定PVC</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deploy<span class="token punctuation">-</span>pvc  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deploy<span class="token punctuation">-</span>pvc<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deploy<span class="token punctuation">-</span>pvc  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deploy<span class="token punctuation">-</span>pvc    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html         <span class="token comment"># 不是指定nfs 而是指定PVC去挂载申请到的目录</span>          <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>            <span class="token key atrule">claimName</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pvc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><blockquote><p>配置集，抽取应用配置，并且可以自动更新</p><ol><li>现将需要使用的配置 制作成 configMap</li><li>创建pod时饮用配置集</li></ol></blockquote><ol><li>将配置文件创建为ConfigMap</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 创建文件</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ <span class="token function">tee</span> ./redis.conf <span class="token operator">&lt;&lt;-</span><span class="token string">EOF# rddis 数据需要持久化存储appendonly yesEOF</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create cm redis-conf --from-file<span class="token operator">=</span>redis.conf<span class="token comment"># cm   --&gt; comfigMap 缩写</span><span class="token comment"># --from-file  由什么文件制作配置集</span><span class="token comment"># 查询配置集</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get cmNAME               DATA   AGEredis-conf   <span class="token number">1</span>      8s<span class="token comment"># 查询配置集</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get cm redis-conf -oyaml<span class="token comment"># -oyaml 以 yaml形式 输出 redis-conf 配置集</span><span class="token comment"># 下面为该命令的输出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token comment"># data配置下 才是真实的数据 key -&gt; 文件名，value -&gt; 配置文件</span><span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token comment"># 默认是文件名 </span>  <span class="token key atrule">redis.conf</span><span class="token punctuation">:</span> <span class="token punctuation">|</span>  <span class="token comment"># 下方是配置文件中的内容</span>    <span class="token comment"># redis 数据需要持久化存储</span>    appendonly yes<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap  <span class="token comment"># 资源类型为配置集</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">creationTimestamp</span><span class="token punctuation">:</span> <span class="token string">"2022-05-11T11:16:32Z"</span> <span class="token comment"># 创建时间</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>conf  <span class="token comment"># 创建配置的名称</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default <span class="token comment"># 命名空间</span>  <span class="token key atrule">resourceVersion</span><span class="token punctuation">:</span> <span class="token string">"439924"</span>  <span class="token key atrule">uid</span><span class="token punctuation">:</span> adf679dd<span class="token punctuation">-</span>f040<span class="token punctuation">-</span>437c<span class="token punctuation">-</span>bffd<span class="token punctuation">-</span>7f5effb521ec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>创建Pod</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 使用docker 加载自定义的配置启动</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker run -v /data/redis/redis.conf:/etc/redis/redis.conf <span class="token punctuation">\</span>-v /data/redis/data:/data <span class="token punctuation">\</span>-d --name myredis <span class="token punctuation">\</span>-p <span class="token number">6379</span>:6379 <span class="token punctuation">\</span>redis:latest redis-server /etc/redis/redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> kubernetes yaml文件版</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">apiVersion: v1kind: Podmetadata:  name: redisspec:  containers:  - name: redis    image: redis    command:      - redis-server      <span class="token comment"># redis容器内部的位置 加载的配置文件</span>      - <span class="token string">"/redis-master/redis.conf"</span>      ports:    - containerPort: <span class="token number">6379</span>    <span class="token comment"># 卷挂载</span>    volumeMounts:    <span class="token comment"># 容器内的数据目录 /data</span>    - mountPath: /data      name: data    <span class="token comment"># 容器内的配置目录 挂载方式在下方定义</span>    - mountPath: /redis-master      name: config  <span class="token comment"># 宿主机中的卷</span>  volumes:    <span class="token comment"># 宿主机的对应配置</span>    - name: data      <span class="token comment"># 随机分配一个空目录</span>      emptyDir: <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token comment"># 对应上面 名为 config 的配置文件挂载</span>    - name: config      <span class="token comment"># 配置文件是从配置集中获取</span>      configMap:        <span class="token comment"># 要使用的配置集名称</span>        name: redis-conf        <span class="token comment"># 获取配置集中 data的那些项</span>        items:        <span class="token comment"># 引入 redis-conf 配置集中 data 下 key为 redis.conf的配置</span>        - key: redis.conf          <span class="token comment"># 指定上方通过key获取到的配置 放到什么目录下,在容器的/redis-master创建redis.conf</span>          path: redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2022/04/30/cs-dev-ops/kubernetes/0015.png" class="" title="配置集图示"><ol start="3"><li>检查默认配置</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> -it redis -- redis-cli<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> CONFIG GET appendonly<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> CONFIG GET requirepass<span class="token comment"># 修改配置集</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl edit cm redis-conf<span class="token comment">#####  以下为修改后的内容  ######</span>apiVersion: v1<span class="token comment"># data配置下 才是真实的数据 key -&gt; 文件名，value -&gt; 配置文件</span>data:  <span class="token comment"># 默认是文件名 </span>  redis.conf: <span class="token operator">|</span>  <span class="token comment"># 下方是配置文件中的内容</span>    <span class="token comment"># redis 数据需要持久化存储</span>    appendonly <span class="token function">yes</span>    <span class="token comment"># 添加密码配置</span>    requirepass <span class="token number">123456</span>kind: ConfigMap  <span class="token comment"># 资源类型为配置集</span>metadata:  creationTimestamp: <span class="token string">"2022-05-11T11:16:32Z"</span> <span class="token comment"># 创建时间</span>  name: redis-conf  <span class="token comment"># 创建配置的名称</span>  namespace: default <span class="token comment"># 命名空间</span>  resourceVersion: <span class="token string">"439924"</span>  uid: adf679dd-f040-437c-bffd-7f5effb521ec<span class="token comment">#####  以上为修改后的内容  ######</span><span class="token comment"># 修改后等待片刻 重启完成后就可以看到修改</span><span class="token comment"># 进入容器内 </span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> -it redis -- bin/bash<span class="token comment"># 查看配置文件，可以看到Pod具有热更新的能力</span><span class="token punctuation">[</span>root@qing redis-xxxx<span class="token punctuation">]</span> <span class="token function">cat</span> /redis-master/redis.conf  <span class="token comment"># 或者可以直接进入容器的 的 redis 客户端</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl <span class="token builtin class-name">exec</span> -it redis -- redis-cli<span class="token comment"># 输入下面的命令</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> CONFIG GET appendonly<span class="token comment"># 这里没有更新 是因为pod需要重启 redis才可以生效，</span><span class="token comment"># pod中部署的 中间件 自己没有热更新的能力</span><span class="token number">27.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> CONFIG GET requirepass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h3><blockquote><p>Secret 对象类型用来保存敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 将这些信息放在 secret 中比放在 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a> 的定义或者 <a href="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-image">容器镜像</a>中来说更加安全和灵活。</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># kubectl create secret 创建密钥信息</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create secret docker-registry qing-docker <span class="token punctuation">\</span>--docker-username<span class="token operator">=</span>qing <span class="token punctuation">\</span>--docker-password<span class="token operator">=</span>qing123456 <span class="token punctuation">\</span>--docker-email<span class="token operator">=</span><span class="token number">111111</span>@qq.com<span class="token comment">### 格式说明</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl create secret docker-registry regcred <span class="token punctuation">\</span>  --docker-server<span class="token operator">=</span><span class="token operator">&lt;</span>镜像仓库服务器<span class="token operator">&gt;</span> <span class="token punctuation">\</span>  --docker-username<span class="token operator">=</span><span class="token operator">&lt;</span>用户名<span class="token operator">&gt;</span> <span class="token punctuation">\</span>  --docker-password<span class="token operator">=</span><span class="token operator">&lt;</span>密码<span class="token operator">&gt;</span> <span class="token punctuation">\</span>  --docker-email<span class="token operator">=</span><span class="token operator">&lt;</span>邮箱地址<span class="token operator">&gt;</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get secret<span class="token comment"># 查看对应的yaml文件 可以发现是被加密的</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ kubectl get secret qing-docker -oyaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> private<span class="token punctuation">-</span>nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> private<span class="token punctuation">-</span>nginx    <span class="token comment"># 该镜像为私有 需要账号密码下载</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> qing/privatengin<span class="token punctuation">:</span>v1.0  <span class="token key atrule">imagePullSecrets</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> qing<span class="token punctuation">-</span>docker <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p>【尚硅谷】 <a href="https://b23.tv/D8L82Jz">https://b23.tv/D8L82Jz</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> cs-dev-ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> command </tag>
            
            <tag> note </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker compose教程</title>
      <link href="/2022/01/05/cs-dev-ops/docker-compose/"/>
      <url>/2022/01/05/cs-dev-ops/docker-compose/</url>
      
        <content type="html"><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>Docker Compose<ul><li>安装</li><li>Demo测试</li><li>compose yaml规则</li><li>测试开源项目</li><li>简单实战</li></ul></li></ul><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><blockquote><p>来轻松高效的管理容器，对多个容器进行管理，批量容器编排。</p><p>通过docker-compose编写yaml配置文件，进行一键启动多个相互配置的镜像以及网络配置。</p></blockquote><hr><p>Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose, see <a href="https://docs.docker.com/compose/#features">the list of features</a>.</p><p>Compose works in all environments: production, staging, development, testing, as well as CI workflows. You can learn more about each case in <a href="https://docs.docker.com/compose/#common-use-cases">Common Use Cases</a>.</p><p>Using Compose is basically a three-step process:</p><ol><li>Define your app’s environment with a <code>Dockerfile</code> so it can be reproduced anywhere.</li><li>Define the services that make up your app in <code>docker-compose.yml</code> so they can be run together in an isolated environment.</li><li>Run <code>docker compose up</code> and the <a href="https://docs.docker.com/compose/cli-command/">Docker compose command</a> starts and runs your entire app. You can alternatively run <code>docker-compose up</code> using the docker-compose binary.</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.9"</span>  <span class="token comment"># optional since v1.27.0</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">web</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span> .    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> .<span class="token punctuation">:</span>/code      <span class="token punctuation">-</span> logvolume01<span class="token punctuation">:</span>/var/log    <span class="token key atrule">links</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> redis  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token key atrule">logvolume01</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>概念说明</strong></p><ul><li>服务services：容器，应用。（web、redis、mysql……）</li><li>项目project：一组关联的容器组成一个完整的业务单元<ul><li>通过使用docker-compose up来启动多个服务是的项目的正常运行</li></ul></li></ul><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p>其他平台的安装详见官网：<a href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a></p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 下载[root@qing centos]$ curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose# 下载过慢时，备用地址[root@qing centos]$ curl -L https://get.daocloud.io/docker/compose/releases/download/v2.2.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose# 授权[root@qing centos]$ chmod +x /usr/local/bin/docker-compose# 查看版本，验证是否安装成功[root@qing centos]$ docker-compose versionDocker Compose version v2.2.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Demo测试"><a href="#Demo测试" class="headerlink" title="Demo测试"></a>Demo测试</h3><blockquote><p>demo来自官网文档：<a href="https://docs.docker.com/compose/gettingstarted/">https://docs.docker.com/compose/gettingstarted/</a></p></blockquote><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><ol><li><p>创建项目目录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ cd /home/qing[root@qing centos]$ mkdir composetest[root@qing centos]$ cd composetest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>创建python应用<code>app.py</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ vim app.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该项目Demo中，<code>redis</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> redis <span class="token comment"># 导入redis</span><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flaskapp <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>cache <span class="token operator">=</span> redis<span class="token punctuation">.</span>Redis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'redis'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">)</span> <span class="token comment"># 使用redis缓存 端口号为6379</span><span class="token keyword">def</span> <span class="token function">get_hit_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 对cache进行自增</span>    retries <span class="token operator">=</span> <span class="token number">5</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> cache<span class="token punctuation">.</span>incr<span class="token punctuation">(</span><span class="token string">'hits'</span><span class="token punctuation">)</span>        <span class="token keyword">except</span> redis<span class="token punctuation">.</span>exceptions<span class="token punctuation">.</span>ConnectionError <span class="token keyword">as</span> exc<span class="token punctuation">:</span>            <span class="token keyword">if</span> retries <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">raise</span> exc            retries <span class="token operator">-=</span> <span class="token number">1</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token comment"># 访问页面返回字符串 并调用cache自增</span><span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> get_hit_count<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">'Hello World! I have been seen {} times.\n'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建依赖说明<code>requirements.txt</code></p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">flaskredis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h4 id="创建Dockerfile"><a href="#创建Dockerfile" class="headerlink" title="创建Dockerfile"></a>创建Dockerfile</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ vim Dockerfile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># syntax=docker/dockerfile:1FROM python:3.7-alpine # 基本环境包WORKDIR /code # 工作目录ENV FLASK_APP=app.py # 环境ENV FLASK_RUN_HOST=0.0.0.0RUN apk add --no-cache gcc musl-dev linux-headers # 运行COPY requirements.txt requirements.txt # 复制文件RUN pip install --upgrade pipRUN pip install -r requirements.txt # 使用pip安装EXPOSE 5000 # 暴露端口COPY . .CMD ["flask", "run"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="在Compose-file中定义服务"><a href="#在Compose-file中定义服务" class="headerlink" title="在Compose file中定义服务"></a>在Compose file中定义服务</h4><p>创建一个<code>docker-compose.yml</code>文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ vim docker-compose.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.9"</span> <span class="token comment"># 说明版本</span><span class="token key atrule">services</span><span class="token punctuation">:</span> <span class="token comment"># 两个服务 web和redis</span>  <span class="token key atrule">web</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span> . <span class="token comment"># 通 docker build 使用Dockerfile生成一个镜像</span>    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"redis:alpine"</span> <span class="token comment"># 使用官方提供的镜像</span><span class="token comment"># 该compose定义了两个服务 web redis</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用Compose构建并启动应用"><a href="#使用Compose构建并启动应用" class="headerlink" title="使用Compose构建并启动应用"></a>使用Compose构建并启动应用</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ docker-compose up # 使用compose启动引用并运行##### 此处输出细节由于部分原因未保存，故不作具体展示，大概过程如下##### 下载redis镜像##### 根据Dockefile生成镜像##### 启动两个应用##### composetest-redis-1  | 1:M 06 Jan 2022 15:14:00.396 * Ready to accept connections##### composetest-web-1    |  * Running on http://172.19.0.2:5000/ (Press CTRL+C to quit)# 新打开ssh连接[root@qing centos]$ docker ps # 可以查看到两个容器正在运行CONTAINER ID   IMAGE             COMMAND                  CREATED        STATUS         PORTS                                       NAMESeab226264027   redis:alpine      "docker-entrypoint.s…"   23 hours ago   Up 4 minutes   6379/tcp                                    composetest-redis-1df7060ac4312   composetest_web   "flask run"              23 hours ago   Up 4 minutes   0.0.0.0:5000-&gt;5000/tcp, :::5000-&gt;5000/tcp   composetest-web-1[root@qing centos]$ curl localhost:5000Hello World! I have been seen 1 times.  # 测试访问，服务正常[root@qing centos]$ curl localhost:5000Hello World! I have been seen 2 times.[root@qing centos]$ docker images # 会自动根据配置下载镜像，而不用手动的一个一个去pullREPOSITORY        TAG                IMAGE ID       CREATED         SIZEcomposetest_web   latest             29a58f03ba24   23 hours ago    185MBredis             alpine             3900abf41552   5 weeks ago     32.4MBpython            3.7-alpine         a1034fd13493   5 weeks ago     41.8MB[root@qing centos]$ docker network ls # 通过compose启动的容器实例会自动创建一个网络，把所有的容器放在同一个容器下NETWORK ID     NAME                  DRIVER    SCOPE7d8581eaa5e7   composetest_default   bridge    local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>因此，在<code>app.py</code>中，可以通过redis的服务名来进行连接，因为在同一个网络下。</p></blockquote><img src="/2022/01/05/cs-dev-ops/docker-compose/0001.png" class="" title="示例"><h4 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 在工作目录下[root@qing centos]$ cd /home/qing/composetest# 方式一[root@qing centos]$ docker-compose stop # 方式二[root@qing centos]$ docker-compose down --volumes# 方式三# 在启动的地方 Ctrl+C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="compose-yaml规则"><a href="#compose-yaml规则" class="headerlink" title="compose yaml规则"></a>compose yaml规则</h3><blockquote><p>官网文档说明：<a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 三层结构</span><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.9"</span> <span class="token comment"># 版本号</span><span class="token key atrule">services</span><span class="token punctuation">:</span> <span class="token comment"># 服务</span>  <span class="token comment"># 服务配置</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span>alpine <span class="token comment"># 镜像</span>    <span class="token key atrule">ports</span><span class="token punctuation">:</span> <span class="token comment"># 暴露的端口号(多)</span>      <span class="token punctuation">-</span> <span class="token string">"6379"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span> <span class="token comment"># 设置要加入的网络(多)，网络配置文件中配置，也可以基于已有网络？</span>      <span class="token punctuation">-</span> frontend      <span class="token punctuation">-</span> other<span class="token punctuation">-</span>network    <span class="token key atrule">deploy</span><span class="token punctuation">:</span> <span class="token comment"># 部署运行时的配置</span>      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span> <span class="token comment"># 副本，指定给定时间内的容器运行数量</span>      <span class="token key atrule">update_config</span><span class="token punctuation">:</span> <span class="token comment"># 配置服务如何更新</span>        <span class="token key atrule">parallelism</span><span class="token punctuation">:</span> <span class="token number">2</span> <span class="token comment"># 一次更新的容器数量</span>        <span class="token key atrule">delay</span><span class="token punctuation">:</span> 10s <span class="token comment"># 更新一组容器间的等待时间</span>      <span class="token key atrule">restart_policy</span><span class="token punctuation">:</span> <span class="token comment"># 配置如何重启服务</span>        <span class="token key atrule">condition</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure <span class="token comment"># 失败是，eg. none/any</span>  <span class="token comment"># 服务配置</span>  <span class="token key atrule">db</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> postgres<span class="token punctuation">:</span><span class="token number">9.4</span> <span class="token comment"># 镜像</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span> <span class="token comment"># 配置挂载卷  宿主机 : 容器目录</span>      <span class="token punctuation">-</span> db<span class="token punctuation">-</span>data<span class="token punctuation">:</span>/var/lib/postgresql/data <span class="token comment"># 该方式需要在下方定义 交予docker默认挂载卷下管理 即具名挂载  通过 docker volume管理</span>      <span class="token comment"># - /data/qing/postgresql/data:/var/lib/postgresql/data # 也可以设置直接路径</span>      <span class="token comment"># - $PWD:/var/lib/postgresql/data # 特殊用法 $PWD 宿主机当前目录</span>      <span class="token comment"># - $(pwd):/var/lib/postgresql/data # 特殊用法 $(pwd)宿主机当前目录</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span> <span class="token comment"># 设置要加入的网络(多)</span>      <span class="token punctuation">-</span> backend    <span class="token key atrule">deploy</span><span class="token punctuation">:</span> <span class="token comment"># 部署运行时的配置</span>      <span class="token key atrule">placement</span><span class="token punctuation">:</span> <span class="token comment"># 设置约束和首选项</span>        <span class="token key atrule">max_replicas_per_node</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment"># 限制一个节点上运行的副本数量</span>        <span class="token key atrule">constraints</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token string">"node.role==manager"</span> <span class="token comment"># 通过约束表达式，限制节点的容器</span>  <span class="token comment"># 服务配置</span>  <span class="token key atrule">vote</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> dockersamples/examplevotingapp_vote<span class="token punctuation">:</span>before    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"5000:80"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> frontend    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span> <span class="token comment"># 依赖关系，在启动该服务之前，保证以下服务在其之前启动</span>      <span class="token punctuation">-</span> redis    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>      <span class="token key atrule">update_config</span><span class="token punctuation">:</span>        <span class="token key atrule">parallelism</span><span class="token punctuation">:</span> <span class="token number">2</span>      <span class="token key atrule">restart_policy</span><span class="token punctuation">:</span>        <span class="token key atrule">condition</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure  <span class="token comment"># 服务配置</span>  <span class="token key atrule">result</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> dockersamples/examplevotingapp_result<span class="token punctuation">:</span>before    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"5001:80"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> backend    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span> <span class="token comment"># 依赖关系，在启动该服务之前，保证以下服务在其之前启动</span>      <span class="token punctuation">-</span> db    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>      <span class="token key atrule">update_config</span><span class="token punctuation">:</span>        <span class="token key atrule">parallelism</span><span class="token punctuation">:</span> <span class="token number">2</span>        <span class="token key atrule">delay</span><span class="token punctuation">:</span> 10s      <span class="token key atrule">restart_policy</span><span class="token punctuation">:</span>        <span class="token key atrule">condition</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure  <span class="token comment"># 服务配置</span>  <span class="token key atrule">worker</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> dockersamples/examplevotingapp_worker    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> frontend      <span class="token punctuation">-</span> backend    <span class="token key atrule">deploy</span><span class="token punctuation">:</span> <span class="token comment"># 部署</span>      <span class="token key atrule">mode</span><span class="token punctuation">:</span> replicated      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>APP=VOTING<span class="token punctuation">]</span>      <span class="token key atrule">restart_policy</span><span class="token punctuation">:</span>        <span class="token key atrule">condition</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure        <span class="token key atrule">delay</span><span class="token punctuation">:</span> 10s        <span class="token key atrule">max_attempts</span><span class="token punctuation">:</span> <span class="token number">3</span>        <span class="token key atrule">window</span><span class="token punctuation">:</span> 120s      <span class="token key atrule">placement</span><span class="token punctuation">:</span>        <span class="token key atrule">constraints</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token string">"node.role==manager"</span>  <span class="token comment"># 服务配置</span>  <span class="token key atrule">visualizer</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> dockersamples/visualizer<span class="token punctuation">:</span>stable    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"8080:8080"</span>    <span class="token key atrule">stop_grace_period</span><span class="token punctuation">:</span> 1m30s    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"/var/run/docker.sock:/var/run/docker.sock"</span>    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>      <span class="token key atrule">placement</span><span class="token punctuation">:</span>        <span class="token key atrule">constraints</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token string">"node.role==manager"</span><span class="token comment"># 网络配置</span><span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token key atrule">frontend</span><span class="token punctuation">:</span>  <span class="token key atrule">backend</span><span class="token punctuation">:</span><span class="token comment"># 挂载卷配置</span><span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token key atrule">db-data</span><span class="token punctuation">:</span>    <span class="token comment"># external: true # 指定此卷是已存在的，docker不尝试自动创建，如果不存在则引发错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>服务中的配置项，可以在官网上查看</p></blockquote><img src="/2022/01/05/cs-dev-ops/docker-compose/0002.png" class="" title="示例"><h3 id="测试开源项目"><a href="#测试开源项目" class="headerlink" title="测试开源项目"></a>测试开源项目</h3><h4 id="WordPress"><a href="#WordPress" class="headerlink" title="WordPress"></a>WordPress</h4><blockquote><p>官网连接：<a href="https://docs.docker.com/samples/wordpress/">https://docs.docker.com/samples/wordpress/</a></p></blockquote><h5 id="创建项目文件夹"><a href="#创建项目文件夹" class="headerlink" title="创建项目文件夹"></a>创建项目文件夹</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ cd /home/qing[root@qing centos]$ mkdir word_press[root@qing centos]$ cd word_press<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="编写docker-compose-yml"><a href="#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写docker-compose.yml</h5><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ vim docker<span class="token punctuation">-</span>compose.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># docker-compose.yml</span><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.9"</span>    <span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">db</span><span class="token punctuation">:</span> <span class="token comment"># 数据库服务</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span><span class="token number">5.7</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> db_data<span class="token punctuation">:</span>/var/lib/mysql    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always <span class="token comment"># 重启规则 总是重启</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span> <span class="token comment"># 环境配置 key-value 数据库的账号密码等配置</span>      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> somewordpress      <span class="token key atrule">MYSQL_DATABASE</span><span class="token punctuation">:</span> wordpress      <span class="token key atrule">MYSQL_USER</span><span class="token punctuation">:</span> wordpress      <span class="token key atrule">MYSQL_PASSWORD</span><span class="token punctuation">:</span> wordpress      <span class="token key atrule">wordpress</span><span class="token punctuation">:</span> <span class="token comment"># wordpress服务</span>    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span> <span class="token comment"># 依赖关系，基于db服务启动</span>      <span class="token punctuation">-</span> db    <span class="token key atrule">image</span><span class="token punctuation">:</span> wordpress<span class="token punctuation">:</span>latest <span class="token comment"># 镜像</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> wordpress_data<span class="token punctuation">:</span>/var/www/html    <span class="token key atrule">ports</span><span class="token punctuation">:</span> <span class="token comment"># 暴露端口 映射</span>      <span class="token punctuation">-</span> <span class="token string">"8000:80"</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always <span class="token comment"># 重启规则 总是重启</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span> <span class="token comment"># 环境配置 key-value 连接的数据库配置</span>      <span class="token key atrule">WORDPRESS_DB_HOST</span><span class="token punctuation">:</span> db      <span class="token key atrule">WORDPRESS_DB_USER</span><span class="token punctuation">:</span> wordpress      <span class="token key atrule">WORDPRESS_DB_PASSWORD</span><span class="token punctuation">:</span> wordpress      <span class="token key atrule">WORDPRESS_DB_NAME</span><span class="token punctuation">:</span> wordpress<span class="token key atrule">volumes</span><span class="token punctuation">:</span> <span class="token comment"># 挂载卷设置</span>  <span class="token key atrule">db_data</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token key atrule">wordpress_data</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="编写自定义的Dockerfile"><a href="#编写自定义的Dockerfile" class="headerlink" title="编写自定义的Dockerfile"></a>编写自定义的Dockerfile</h5><blockquote><p>根据需求可选</p></blockquote><h5 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ docker-compose up -d # 后台运行<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后便可以访问自己的地址来查看</p><h3 id="简单实战"><a href="#简单实战" class="headerlink" title="简单实战"></a>简单实战</h3><ol><li><p>编写项目微服务</p><blockquote><p><a href="https://github.com/RobertSunq/data/blob/master/qing/blog/hexo/docker_compose/docker_compose_demo.zip" title="下载链接">demo</a></p></blockquote></li><li><p>dockerfile构建镜像</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM java:8 # 基本环境COPY ./*.jar /app/app.jar # 从宿主机拷贝jar包CMD ["--server.port=12233"] # 设置端口号EXPOSE 12233 # 暴露端口号ENTRYPOINT ["java", "-Xmx500m", "-jar", "-Dspring.profiles.active=docker", "/app/app.jar"] # 启动jar包<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>docker-compose.yml编排项目</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.8'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">qingdemo</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span> .<span class="token comment">#      dockerfile: Dockerfile # 指定使用的dockerfile文件 默认为当前目录下Dockerfile</span><span class="token comment">#      image: qingdemo # 指定镜像 查找不到将使用dockerfile编译镜像</span>    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> redis_a      <span class="token punctuation">-</span> db    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"12233:12233"</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"redis"</span>  <span class="token key atrule">db</span><span class="token punctuation">:</span> <span class="token comment"># 数据库服务</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"mysql:5.7"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> db_data<span class="token punctuation">:</span>/var/lib/mysql    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"3306:3306"</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always <span class="token comment"># 重启规则 总是重启</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span> <span class="token comment"># 环境配置 key-value 数据库的账号密码等配置</span>      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> qing<span class="token important">&amp;123456</span>      <span class="token key atrule">MYSQL_DATABASE</span><span class="token punctuation">:</span> demo_dev      <span class="token key atrule">MYSQL_USER</span><span class="token punctuation">:</span> qing      <span class="token key atrule">MYSQL_PASSWORD</span><span class="token punctuation">:</span> qing<span class="token important">&amp;123456</span>      <span class="token key atrule">MYSQL_ROOT_HOST</span><span class="token punctuation">:</span> <span class="token string">'%'</span> <span class="token comment"># 所有ip均可链接当前数据库</span><span class="token comment"># 挂载卷配置</span><span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token key atrule">db-data</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>放入到服务器</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ pwd/home/qing/demo_app[root@qing centos]$ lsdemo.jar  docker-compose.yml  Dockerfile[root@qing centos]$ docker-compose up -d # 后台运行 以下为日志输出# Sending build context to Docker daemon  60.95MB# Step 1/5 : FROM java:8#  ---&gt; d23bdf5b1b1b# Step 2/5 : COPY ./*.jar /app/app.jar#  ---&gt; Using cache#  ---&gt; fb647c018662# Step 3/5 : CMD ["--server.port=12233"]#  ---&gt; Using cache#  ---&gt; 8599345e23f4# Step 4/5 : EXPOSE 12233#  ---&gt; Using cache#  ---&gt; 11fd92f27368# Step 5/5 : ENTRYPOINT ["java", "-Xmx500m", "-jar", "-Dspring.profiles.active=docker", "/app/app.jar"]#  ---&gt; Running in 3dd19ac03609#  ---&gt; e930ce4c5f6f# Successfully built e930ce4c5f6f# Successfully tagged demo_app_qingdemo:latest# Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them# [+] Running 4/4#  ⠿ Network demo_app_default       Created                                                                                                   0.2s#  ⠿ Container demo_app-db-1        Started                                                                                                   1.0s#  ⠿ Container demo_app-redis-1     Started                                                                                                   0.9s#  ⠿ Container demo_app-qingdemo-1  Started                                                                                                   1.9s[root@qing centos]$ docker-compose logs -f # 查看启动日志 如果启动失败可以根据启动日志排查错误[root@qing centos]$ docker-compose down # 停止服务[root@qing centos]$ docker images # 查看镜像# 如果需要重新部署打包[root@qing centos]$ docker-compose up --build # 重新给构建<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><p><strong>完</strong></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?from=search&amp;seid=8833819761241839370">狂神说Docker</a> ：<a href="https://www.bilibili.com/video/BV1og4y1q7M4?share_source=copy_web">https://www.bilibili.com/video/BV1og4y1q7M4?share_source=copy_web</a></p>]]></content>
      
      
      <categories>
          
          <category> cs-dev-ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> docker </tag>
            
            <tag> command </tag>
            
            <tag> note </tag>
            
            <tag> docker-compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令备忘录</title>
      <link href="/2021/12/30/cs/command-note/"/>
      <url>/2021/12/30/cs/command-note/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由书籍、博客、网络、同事传授等整理而来，部分会附带转载学习来源。</p><p>由于是逐渐补充型文章，所以排版、标题分类上可能比较乱以及随时变更，敬请见谅。</p></blockquote><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><hr><blockquote><p>该部分命令多数不针对发行版本区分，由于内核版本、linux版本不同而有所不同。</p><p>${}  —&gt; 表示变量替换</p></blockquote><h3 id="使用SSH建立远程连接"><a href="#使用SSH建立远程连接" class="headerlink" title="使用SSH建立远程连接"></a>使用SSH建立远程连接</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 最简连接方式[root@qing centos]$ ssh username@hostname # 然后输入密码username@hostname's password:# 指定端口连接, 不指定时默认端口为22[root@qing centos]$ ssh -p 2233 username@hostnameusername@hostname's password:# 如何查看与修改ssh配置# mac linux系统中 SSH的配置文件在/etc/ssh/sshd_config# win 待查[root@qing centos]$ cat /etc/ssh/sshd_config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="maven-surefire单元测试"><a href="#maven-surefire单元测试" class="headerlink" title="maven-surefire单元测试"></a>maven-surefire单元测试</h3><blockquote><p>部分命令对版本有所要求，请注意。</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 根据配置文件，运行范围内的所有单元测试[root@qing centos]$ mvn test# 指定某个包下面的所有用例# [root@qing centos]$ mvn test -Dtest=${包完整路径}.*# 最后的 .* 是通配符表示运行该包下所有用例[root@qing centos]$ mvn test -Dtest=cn.qing.demo.*# 指定某个测试用例类# [root@qing centos]$ mvn test -Dtest=${包完整路径}.${测试用例类名}[root@qing centos]$ mvn test -Dtest=cn.qing.demo.DemoTest# 指定运行多个测试用例类# [root@qing centos]$ mvn test -Dtest=${测试用例类名1},${测试用例类名2}[root@qing centos]$ mvn test -Dtest=cn.qing.demo.DemoTest1, cn.qing.demo.DemoTest2# 指定运行测试用例类中的一个方法# [root@qing centos]$ mvn test -Dtest=${类路径}#${方法名}[root@qing centos]$ mvn test -Dtest=cn.qing.demo.DemoTest#demoTest# 以上方法可使用 * 进行通配# mvn test -Dtest=cn.qing.demo.DemoTest#demo_*# 上面的命令意思为 运行DemoTest测试类中的以demo_为开头的方法。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="系统编码-x2F-语言"><a href="#系统编码-x2F-语言" class="headerlink" title="系统编码/语言"></a>系统编码/语言</h3><blockquote><p>windows的默认编码为GBK，Linux的默认编码为UTF-8</p><p>因为在windows下编辑的中文，在linux下会显示为乱码。</p></blockquote><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ localeLANG=zh_CN.UTF-8# 系统语言   zh_CN.UTF-8 ----&gt; 中文,编码为UTF-8LC_CTYPE="zh_CN.UTF-8"# 语言符号与分类LC_NUMERIC="zh_CN.UTF-8"# 数字LC_TIME="zh_CN.UTF-8"# 时间显示格式LC_COLLATE="zh_CN.UTF-8"# 比较和排序LC_MONETARY="zh_CN.UTF-8"# 货币的单位LC_MESSAGES="zh_CN.UTF-8"# 信息的提示,eg. 提示信息、错误信息、状态信息、标题等LC_PAPER="zh_CN.UTF-8"# 打印纸张设置LC_NAME="zh_CN.UTF-8"# 姓名书LC_ADDRESS="zh_CN.UTF-8"# 地址LC_TELEPHONE="zh_CN.UTF-8"# 电话号码LC_MEASUREMENT="zh_CN.UTF-8"  # 度量衡LC_IDENTIFICATION="zh_CN.UTF-8"# 对locale自身信息对描述LC_ALL=# 分类属性的优先级上为: LC_ALL &gt; LC_* &gt; LANG<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ vim /etc/locale.conf # centos7[root@qing centos]$ vim /etc/sysconfig/i18n # centos6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="重新加载配置文件"><a href="#重新加载配置文件" class="headerlink" title="重新加载配置文件"></a>重新加载配置文件</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ source /etc/locale.conf # centos7[root@qing centos]$ source /etc/sysconfig/i18n # centos7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><h4 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># [root@qing centos]$ cp [option] ${source_file_path} ${target_file_path}[root@qing centos]$ cp /tmp/qing/source.log /tmp/qing/source.log-a archive 复制所有的目录# -d 源文件为连接文件时，则复制连接文件属性而非文件本身# -f 强制复制，如果遇到重复或者其他疑问，不会进行询问而强制复制# -i 若目标文件已存在，在覆盖时先询问是否真的操作# -I 建立硬连接的连接文件，而非复制文件本身# -p 与文件的属性一起复制，而非使用默认属性# -r 递归复制，用于目录的复制操作# -s 复制成符号连接文件，“快捷方式”# -u 若目标文件必源文件旧，则更新目标文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="强制复制"><a href="#强制复制" class="headerlink" title="强制复制"></a>强制复制</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 复制时，如果遇到重复或者其他疑问，不会进行询问而强制复制[root@qing centos]$ cp -f /tmp/qing/source.log /tmp/qing/source.log# 上述命令如果还是会询问，则可能是cp命令属于 其他命令组合的别名# 使用alias 查看[root@qing centos]$ aliasalias cp='cp -i'# 此配置即为还会进行提示# -f的替换方案## 使用命令 \cp    反斜杠来强制复制[root@qing centos]$ \cp /tmp/qing/source.log /tmp/qing/source.log## 修改别名  ### todo 待查证[root@qing centos]$ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>loading…</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><hr><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><p>loading…</p><h3 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h3><h4 id="转至管理员模式"><a href="#转至管理员模式" class="headerlink" title="转至管理员模式"></a>转至管理员模式</h4><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 在powershell中输入，会打开一个新的管理员模式的窗口</span><span class="token function">PS</span> G:\&gt; <span class="token function">Start-Process</span> powershell <span class="token operator">-</span>Verb runAs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MacOs"><a href="#MacOs" class="headerlink" title="MacOs"></a>MacOs</h2><hr><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>loading…</p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><h4 id="not-module的小总结"><a href="#not-module的小总结" class="headerlink" title="not module的小总结"></a>not module的小总结</h4><ol><li><p>环境中存在多个python与其对应的pip，按照的时候指定错误安装到其他版本的lib里面去了。eg. 使用pip2按照依赖到python2，但是需要在python3中使用。</p> <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@qing centos]$ /opt/local/qing/python/lib/python -m pip list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>依赖所在的site地址，没有被加载到python的path。</p></li><li><p>安装的依赖，没有被加载到对应python的modules中</p></li></ol>   <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 进入到python命令界面查看 $ /opt/local/qing/python/lib/python</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token builtin">help</span><span class="token punctuation">(</span><span class="token string">'modules'</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li>没有安装这个依赖</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 进入到python命令界面查看 $ /opt/local/qing/python/lib/python</span><span class="token comment"># 查看python的lib路径</span><span class="token comment">## 引入依赖</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> site<span class="token comment">## 查看用户site-packages路径</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> site<span class="token punctuation">.</span>getusersitepackages<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'/home/robert/.local/lib/python2.7/site-packages'</span><span class="token comment">## 查看全局site-packages路径</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> site<span class="token punctuation">.</span>getsitepackages<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'/usr/lib64/python2.7/site-packages'</span><span class="token punctuation">,</span> <span class="token string">'/usr/lib/python2.7/site-packages'</span><span class="token punctuation">,</span> <span class="token string">'/usr/lib/site-python'</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 待续 </tag>
            
            <tag> command </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程基础版</title>
      <link href="/2021/12/25/cs-dev-ops/docker-notes/"/>
      <url>/2021/12/25/cs-dev-ops/docker-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>Docker概述</li><li>Docker安装</li><li>Docker命令<ul><li>镜像命令</li><li>容器命令</li><li>操作命令</li><li>….</li></ul></li><li>Docker镜像</li><li>容器数据卷</li><li>DockerFile</li><li>Docker网络原理</li><li>IDEA整合Docker</li></ul><blockquote><p>Docker Compose、Docker Swarm （简化版K8s）、CI/CD Jenkins进阶版</p></blockquote><h2 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h2><h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><p>开发、测试、预生产、生产环境搭建的成本和一致性问题。在进行集群拓展的时候，每个机器上都要进行环境的部署安装（Reids ES Hadoop……）等费时费力，而且还可能因为机器的不同而产生各种各样的不一致问题。</p><p>针对java开发来说，一般通过jar/war包来部署的，但是运行jar包所需要的其他环境依赖，比如：JDK、Tomcat、Mysql、Redis这些都需要在机器上事先的安装配置完成。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>可以通过发包的时候直接带上软件运行所需要的环境和对环境的配置进行打包 “jar+”（app + jdk + mysql + redis + es），这样可以保证 开发 → 打包 → 部署 → 上线 所具有的环境保持一致，同时也可以避免在对新机器进行部署的时候，还需要进行复杂的环境配置。</p><p>Docker 便是这么一个类似的过程：打包项目带上环境（镜像） → 发布（Docker仓库）→ 下载发布的镜像 → 直接运行（容器）。</p><h4 id="虚拟机技术"><a href="#虚拟机技术" class="headerlink" title="虚拟机技术"></a>虚拟机技术</h4><p>虚拟化技术。可以直接通过虚拟机镜像文件，直接虚拟出一个具有完整环境的虚拟电脑，在其上面在运行所需要的App。</p><p><strong>缺点：</strong></p><p>对物理服务器资源的消耗，在物理服务器创建一台虚拟机时，便需要虚拟出一套硬件并在上面运行完整的操作系统，每台虚拟机都占用许多的服务器资源。是在<strong>物理层面上的隔离</strong>，启动慢 占用内存大，分钟级启动。当需要启动多个虚拟机时需要花费很大的时间</p><p><strong>物理资源层面上的隔离</strong></p><img src="/2021/12/25/cs-dev-ops/docker-notes/0012.png" class="" title="虚拟机结构示意图"><h4 id="Docker容器化技术"><a href="#Docker容器化技术" class="headerlink" title="Docker容器化技术"></a>Docker容器化技术</h4><p>也是一种虚拟化技术。镜像：包含所需要的最基础环境（最核心的Linux环境4M + 其他环境），没有其他额外的文件，只集成需要的便可以做到很小巧，启动运行镜像也十分快速，秒级别启动。</p><p><strong>优点：</strong></p><ul><li><p>传统虚拟机，虚拟出硬件，运行一个完整的操作系统，然后再这个系统上安装和运行软件，Docker并不是选择去模拟一个完整的操作系统</p></li><li><p>容器内的应用直接运行在宿主机的内核，容器时没有自己的内核的，并不去虚拟硬件所以十分的轻便</p></li><li><p>每个容器是相互隔离，每个容器都有一套自己的文件系统，互相不影响</p></li><li><p>更快速的交付和部署</p><ul><li>打包镜像发布测试 一键运行</li></ul></li><li><p>更便捷的升级和扩缩容</p><ul><li>在不同的机器上直接运行相同的镜像来扩容</li></ul></li><li><p>更简单的系统运维</p><ul><li>开发测试生产环境高度一致</li></ul></li><li><p>更高效的计算机资源利用</p></li></ul><p><strong>缺点：</strong></p><p>由于是<strong>操作系统进程层面上的隔离</strong>不是绝对的物理隔离，所以在安全性上时低于虚拟机的。</p><p><strong>操作系统进程层面上的隔离</strong></p><img src="/2021/12/25/cs-dev-ops/docker-notes/0013.png" class="" title="docker多容器结构"><h4 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h4><p>C/S模式：docker-client，docker-service</p><img src="/2021/12/25/cs-dev-ops/docker-notes/0000.png" class="" title="基本组成"><p>Docker daemon（守护进程）：Docker Client通过命令行与Docker Damon通信，完成Docker相关操作</p><p>Images（镜像）：类似于软件安装包</p><p>Containers（容器）：软件的运行</p><p><strong>镜像（image）：</strong></p><p>在docker中，镜像就类似于一个模板，可以通过这个模板来创建容器服务，同时也可以通过这个镜像去创建多个容器（最终服务运行或者项目运行就是在容器中）。</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TDA<span class="token text string">[tomcat镜像]</span> <span class="token arrow operator">--&gt;</span> B<span class="token text string">[run]</span>B <span class="token arrow operator">--&gt;</span> C<span class="token text string">[tomcat 1容器&lt;提供服务器&gt;]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>容器（container）：</strong></p><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建。</p><p>启动、停止、删除等基本命令！</p><p><strong>仓库（repository）：</strong></p><p>即存放镜像的地方，仓库分为私用仓库与公有仓库。但Docker Hub默认为国外服务器，所有可以通过配置为阿里云下镜像仓库来加速下载公用镜像。</p><h3 id="底层原理概述"><a href="#底层原理概述" class="headerlink" title="底层原理概述"></a>底层原理概述</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><ul><li>镜像<ul><li>将所有需要的内容放到不同的镜像（集装箱）中，需要哪些环境就直接拿哪个镜像（集装箱）就可以</li></ul></li><li>标准化<ul><li>镜像管理标准化，所有的镜像都放置于仓库中统一管理，当需要某些环境需要哪些镜像就使用docker去仓库中获取。</li><li>命令标准化，Docker提供了一系列的命令，来帮助我们对镜像进行一系列的操作</li></ul></li><li>隔离性<ul><li>运行镜像中的内容（容器）时，会在Linux的内核中单独开辟一片空间，这片空间不会影响到其他程序</li></ul></li></ul><h4 id="基本工作原理概述"><a href="#基本工作原理概述" class="headerlink" title="基本工作原理概述"></a>基本工作原理概述</h4><ol><li><p>Docker 是一个Client - Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！</p></li><li><p>DockerServer接收到Docker-Client的指令，就会执行这个命令！</p></li><li><p>容器内部的端口号是私有独立的，如果外部的想要访问，就需要通过linux服务器的端口号进行端口映射。</p></li></ol><img src="/2021/12/25/cs-dev-ops/docker-notes/0002.png" class="" title="工作原理"><p>Docker 为什么比VM快</p><ol><li><p>docker更少的抽象层</p></li><li><p>docker利用的是宿主机的内核，vm需要的是Guest OS</p></li></ol><img src="/2021/12/25/cs-dev-ops/docker-notes/0003.png" class="" title="对比图1"><p>所以新建一个容器的时候，docker 不需要像虚拟机一样重新加载操作系统内核，避免引导。虚拟机时加载Guest OS，分钟级别的，而docker时利用宿主机的操作系统，省略了这个复杂的过程，秒级。</p><img src="/2021/12/25/cs-dev-ops/docker-notes/0004.png" class="" title="对比图2"><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><h4 id="环境查看"><a href="#环境查看" class="headerlink" title="环境查看"></a>环境查看</h4><p>已在centos7上进行安装为例</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看系统内核版本</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">uname</span> -r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看系统版本</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/os-release<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h4><p><a href="https://docs.docker.com/engine/install/" title="install">官方手册</a> <a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 1、卸载历史版本的docker</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ yum remove docker <span class="token punctuation">\</span>                  docker-client <span class="token punctuation">\</span>                  docker-client-latest <span class="token punctuation">\</span>                  docker-common <span class="token punctuation">\</span>                  docker-latest <span class="token punctuation">\</span>                  docker-latest-logrotate <span class="token punctuation">\</span>                  docker-logrotate <span class="token punctuation">\</span>                  docker-engine                  <span class="token comment"># 2、安装基础安装包</span><span class="token punctuation">[</span>root@centos7<span class="token punctuation">]</span>$ yum <span class="token function">install</span> -y yum-utils <span class="token comment"># 3、设置镜像仓库</span><span class="token comment"># yum-config-manager \</span><span class="token comment">#    --add-repo \</span><span class="token comment">#     https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外仓库</span>    <span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ yum-config-manager <span class="token punctuation">\</span>    --add-repo <span class="token punctuation">\</span>    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo <span class="token comment"># 阿里云的镜像地址</span>    <span class="token comment"># 4、更新yum</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ yum makecache fast<span class="token comment"># 5、安装 ce--社区，ee--企业  核心、客户端、容器</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> docker-ce docker-ce-cli containerd.io<span class="token comment"># 指定版本 yum install docker-ce--&lt;VERSION_STRING&gt; docker-ce-cli--&lt;VERSION_STRING&gt; containerd.io</span><span class="token comment"># 查看其他版本</span><span class="token comment"># [root@centos7 ~]$ yum list docker-ce --showduplicates | sort -r</span><span class="token comment"># 6、启动</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ systemctl start docker<span class="token comment"># 7、验证docker是否启动成功</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ docker version<span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ docker run hello-world<span class="token comment"># 8、查看下载的镜像</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    d1165f221234   <span class="token number">4</span> months ago   <span class="token number">13</span>.3kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/12/25/cs-dev-ops/docker-notes/0001.png" class="" title="输出"><h4 id="快速卸载"><a href="#快速卸载" class="headerlink" title="快速卸载"></a>快速卸载</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 1、卸载依赖 </span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ yum remove docker-ce docker-ce-cli containerd.io<span class="token comment"># 2、删除资源</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> -rf /var/lib/docker<span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> -rf /var/lib/containerd<span class="token comment"># /var/lib/docker docker的默认工作路径</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 以阿里云为列</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p /etc/docker <span class="token comment"># 创建文件</span><span class="token comment"># 编写配置文件 下面的地址需要换成阿里云中自己实例中创建的</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'{"registry-mirrors":["https://qiyb9988.mirror.aliyuncs.com"]}EOF</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ systemctl daemon-reload <span class="token comment"># 编译配置文件</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ systemctl restart docker <span class="token comment"># 重启docker</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><h4 id="基本帮助"><a href="#基本帮助" class="headerlink" title="基本帮助"></a>基本帮助</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token comment">## 帮助文档 https://docs.docker.com/reference/</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ docker version <span class="token comment">#  显示docker版本信息</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ docker info <span class="token comment"># 显示docker的系统信息，包括镜像和容器的数量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h4><p><a href="https://docs.docker.com/reference/" title="reference">官方命令说明</a>  <a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p><p><a href="https://hub.docker.com/" title="dockerHub">官方仓库</a>    <a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p><strong>查看与搜索镜像</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker images REPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    d1165f221234   <span class="token number">4</span> months ago   <span class="token number">13</span>.3kB<span class="token comment">#################################</span><span class="token comment"># REPOSITORY镜像的仓库源</span><span class="token comment"># TAG镜像的标签</span><span class="token comment"># IMAGE ID镜像的ID</span><span class="token comment"># CREATED镜像的创建时间</span><span class="token comment"># SIZE镜像的大小</span><span class="token comment"># 可选项</span><span class="token comment">#--all , -a查看所有镜像</span><span class="token comment">#--quiet , -q只显示镜像ID</span><span class="token comment">#################################</span><span class="token comment">########################################################################</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker search mysql  <span class="token comment"># 搜索镜像</span>NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDmysql                             MySQL is a widely used, open-source relation…   <span class="token number">11099</span>     <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       mariadb                           MariaDB Server is a high performing <span class="token function">open</span> sou…   <span class="token number">4209</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       <span class="token comment"># 可选项，通过搜索来过滤</span>--filter<span class="token operator">=</span>STARS<span class="token operator">=</span><span class="token number">3000</span> <span class="token comment"># 搜索出来的镜像是STARS大于3000的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>下载镜像</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker pull mysql  <span class="token comment"># 下载镜像</span>Using default tag: latest  <span class="token comment"># 不声明tag，默认时 latest</span>latest: Pulling from library/mysqlb4d181a07f80: Download complete  <span class="token comment"># 分层下载，docker image的核心 联合文件系统？</span>a462b60610f5: Download complete 578fafb77ab8: Download complete <span class="token number">524046006037</span>: Download complete d0cbe54c8855: Download complete aa18e05cc46d: Download complete 32ca814c833f: Download complete 9ecc8abdb7f5: Download complete ad042b682e0f: Download complete 71d327c6bb78: Download complete 165d1d10a3fa: Download complete 2f40c47d0626: Download complete Digest: sha256:52b8406e4c32b8cf0557f1b74517e14c5393aff5cf0384eff62d9e81f4985d4b <span class="token comment">#签名</span>Status: Downloaded newer image <span class="token keyword">for</span> mysql:latestdocker.io/library/mysql:latest<span class="token comment"># 真实地址</span><span class="token comment">######## 等价于</span><span class="token comment"># docker pull musql</span><span class="token comment"># docker pull docker.io/library/mysql:latest</span><span class="token comment">################################</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker pull mysql:5.7  <span class="token comment"># 指定版本</span><span class="token number">5.7</span>: Pulling from library/mysqlb4d181a07f80: Already exists <span class="token comment"># 共用分层文件，节省空间和下载速度，不用重复下载</span>a462b60610f5: Already exists 578fafb77ab8: Already exists <span class="token number">524046006037</span>: Already exists d0cbe54c8855: Already exists aa18e05cc46d: Already exists 32ca814c833f: Already exists 52645b4af634: Pull complete bca6a5b14385: Pull complete 309f36297c75: Pull complete 7d75cacde0f8: Pull complete Digest: sha256:1a2f9cd257e75cc80e9118b303d1648366bc2049101449bf2c8d82b022ea86b7Status: Downloaded newer image <span class="token keyword">for</span> mysql:5.7docker.io/library/mysql:5.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除镜像</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 删除镜像 rmi -&gt; remove image</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker rmi -f <span class="token punctuation">[</span>image id<span class="token punctuation">]</span>  <span class="token comment"># 删除指定镜像</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker rmi -f <span class="token variable"><span class="token variable">$(</span>docker images -aq<span class="token variable">)</span></span>  <span class="token comment"># 删除所有，${} 传递参数，查出所有的image id</span><span class="token comment"># [root@qing centos]$ docker rmi -f (mysql5.7) 会发现只删除了mysql5.7不同的文件，和mysql8公用的部分并没有删除 </span><span class="token comment"># 待确定？注意这里删除的是镜像，运行过的镜像创建的容器并没有被删除 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><blockquote><p>通过镜像来创建容器</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 以下载并启动 centos镜像为列子</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker pull centos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>新建容器并启动</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker run <span class="token punctuation">[</span>可选参数<span class="token punctuation">]</span> image<span class="token comment">###################################################</span><span class="token comment"># --name="name"容器名字 tomcat01 tomcat02，用来区分容器</span><span class="token comment"># -d后台方式运行 ja nohup</span><span class="token comment"># -it使用交互方式运行，进入容器查看内容</span><span class="token comment"># -t交互式操作</span><span class="token comment"># -i终端</span><span class="token comment"># -p指定容器的端口 -p 8080:8080</span><span class="token comment"># -p 主机端口：容器端口  (常用)</span><span class="token comment"># -p ip:主机端口:容器端口</span><span class="token comment"># -p 容器端口</span><span class="token comment"># 容器端口</span><span class="token comment"># -P随机指定端口</span><span class="token comment">###################################################</span><span class="token comment"># 启动并进入容器</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker run -it centos /bin/bash<span class="token comment"># 放在镜像名后的是命令，打开一个交互式 Shell，因此用的是 /bin/bash。</span><span class="token punctuation">[</span>root@75dcc58b2b3d /<span class="token punctuation">]</span>$ <span class="token function">ls</span><span class="token comment"># 此时主机已经指向启动的容器，此时centos为基础版本。</span>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<span class="token punctuation">[</span>root@75dcc58b2b3d /<span class="token punctuation">]</span>$ <span class="token builtin class-name">exit</span><span class="token comment"># 从容器中退出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/12/25/cs-dev-ops/docker-notes/0014.png" class="" title="运行流程"><p><strong>查看所有运行的容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token comment"># 查看运行中的容器</span><span class="token comment">###################################################</span><span class="token comment">#列出当前正在运行的容器</span><span class="token comment"># -a列出当前正在运行的容器+历史运行过的容器</span><span class="token comment"># -n=?显示最近创建的容器个数</span><span class="token comment"># -q只显示容器的编号</span><span class="token comment">###################################################</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span> -a<span class="token comment"># 查看所有运行过的容器</span>CONTAINER ID   IMAGE         COMMAND       CREATED         STATUS                       PORTS     NAMES3c8ef01a7eb6   centos        <span class="token string">"/bin/bash"</span>   <span class="token number">6</span> minutes ago   Exited <span class="token punctuation">(</span><span class="token number">130</span><span class="token punctuation">)</span> <span class="token number">5</span> minutes ago             nice_austinceafc51e6972   hello-world   <span class="token string">"/hello"</span>      <span class="token number">2</span> days ago      Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">2</span> days ago                  focused_burnell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>退出容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># exit 停止当前容器并退出</span><span class="token comment"># Ctrl + P + Q 仅退出当前容器，不停止运行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>删除容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">rm</span> 容器id<span class="token comment"># 删除指定容器，不能删除正在运行的容器 rm -f 强制删除</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -aq<span class="token variable">)</span></span><span class="token comment"># 删除所有容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span> -a -q<span class="token operator">|</span><span class="token function">xargs</span> docker <span class="token function">rm</span><span class="token comment"># 删除所有的容器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>启动和停止容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker start 容器id<span class="token comment"># 启动容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker restart 容器id<span class="token comment"># 重启容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stop 容器id<span class="token comment"># 停止当前正在运行的容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">kill</span> 容器id<span class="token comment"># 强制停止容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker start 容器id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><strong>后台启动</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 命令 docker run -d 镜像名！</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d centos<span class="token comment"># 后台启动</span><span class="token comment"># 输入docker ps ， 发现centos停止了</span><span class="token comment"># 常见的坑：</span><span class="token comment"># docker容器使用后台运行，就必须要有一个前台的进程，docker发现没有应用，就会自动停止</span><span class="token comment"># nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就没有程序了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看日志</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker logs --help<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker logs-tf --tail <span class="token number">10</span> 容器id<span class="token comment"># -f 保留打印窗口，-t 添加时间戳 --tail 10 最后10行</span><span class="token comment"># 自定义shell脚本</span><span class="token comment"># "while true;do echo qing;sleep 1; done"</span><span class="token comment"># [root@qing /]$ docker run -d centos /bin/sh -c "while true;do echo qing;sleep 1;done"</span><span class="token comment"># -c 执行命令</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">top</span> 容器id<span class="token comment"># 查看容器内进程信息</span><span class="token environment constant">UID</span>                 PID                 <span class="token environment constant">PPID</span>                C                   STIME               TTY                 TIME                CMDroot                <span class="token number">32718</span>               <span class="token number">32697</span>               <span class="token number">33</span>                  <span class="token number">23</span>:07               ?                   00:00:23            /bin/sh -c <span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token builtin class-name">echo</span> qing<span class="token punctuation">;</span>sheep <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看容器元数据</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect 容器id<span class="token comment"># 查看容器信息</span><span class="token comment"># "Id" 比通过ps查询到的要长，ps中只是对其进行了部分截取</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><details>  <summary>      <mark>          <font color="green">详细输出</font>      </mark>    </summary>  <p>[root@qing /]$ docker inspect ${container id}</p>  <pre>  <code>  [    {        "Id": "2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4",        "Created": "2021-12-28T15:07:57.17357075Z",        "Path": "/bin/sh",        "Args": [            "-c",            "while true;do echo qing;sheep 1;done"        ],        "State": {            "Status": "running",            "Running": true,            "Paused": false,            "Restarting": false,            "OOMKilled": false,            "Dead": false,            "Pid": 32718,            "ExitCode": 0,            "Error": "",            "StartedAt": "2021-12-28T15:07:57.691697573Z",            "FinishedAt": "0001-01-01T00:00:00Z"        },        "Image": "sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6",        "ResolvConfPath": "/var/lib/docker/containers/2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4/resolv.conf",        "HostnamePath": "/var/lib/docker/containers/2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4/hostname",        "HostsPath": "/var/lib/docker/containers/2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4/hosts",        "LogPath": "/var/lib/docker/containers/2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4/2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4-json.log",        "Name": "/jovial_davinci",        "RestartCount": 0,        "Driver": "overlay2",        "Platform": "linux",        "MountLabel": "",        "ProcessLabel": "",        "AppArmorProfile": "",        "ExecIDs": null,        "HostConfig": {            "Binds": null,            "ContainerIDFile": "",            "LogConfig": {                "Type": "json-file",                "Config": {}            },            "NetworkMode": "default",            "PortBindings": {},            "RestartPolicy": {                "Name": "no",                "MaximumRetryCount": 0            },            "AutoRemove": false,            "VolumeDriver": "",            "VolumesFrom": null,            "CapAdd": null,            "CapDrop": null,            "CgroupnsMode": "host",            "Dns": [],            "DnsOptions": [],            "DnsSearch": [],            "ExtraHosts": null,            "GroupAdd": null,            "IpcMode": "private",            "Cgroup": "",            "Links": null,            "OomScoreAdj": 0,            "PidMode": "",            "Privileged": false,            "PublishAllPorts": false,            "ReadonlyRootfs": false,            "SecurityOpt": null,            "UTSMode": "",            "UsernsMode": "",            "ShmSize": 67108864,            "Runtime": "runc",            "ConsoleSize": [                0,                0            ],            "Isolation": "",            "CpuShares": 0,            "Memory": 0,            "NanoCpus": 0,            "CgroupParent": "",            "BlkioWeight": 0,            "BlkioWeightDevice": [],            "BlkioDeviceReadBps": null,            "BlkioDeviceWriteBps": null,            "BlkioDeviceReadIOps": null,            "BlkioDeviceWriteIOps": null,            "CpuPeriod": 0,            "CpuQuota": 0,            "CpuRealtimePeriod": 0,            "CpuRealtimeRuntime": 0,            "CpusetCpus": "",            "CpusetMems": "",            "Devices": [],            "DeviceCgroupRules": null,            "DeviceRequests": null,            "KernelMemory": 0,            "KernelMemoryTCP": 0,            "MemoryReservation": 0,            "MemorySwap": 0,            "MemorySwappiness": null,            "OomKillDisable": false,            "PidsLimit": null,            "Ulimits": null,            "CpuCount": 0,            "CpuPercent": 0,            "IOMaximumIOps": 0,            "IOMaximumBandwidth": 0,            "MaskedPaths": [                "/proc/asound",                "/proc/acpi",                "/proc/kcore",                "/proc/keys",                "/proc/latency_stats",                "/proc/timer_list",                "/proc/timer_stats",                "/proc/sched_debug",                "/proc/scsi",                "/sys/firmware"            ],            "ReadonlyPaths": [                "/proc/bus",                "/proc/fs",                "/proc/irq",                "/proc/sys",                "/proc/sysrq-trigger"            ]        },        "GraphDriver": {            "Data": {                "LowerDir": "/var/lib/docker/overlay2/5070e57b3b1ab1533ba4b1a8cb7de79e3655f6d78ba43c4640c2d25cedb00fa5-init/diff:/var/lib/docker/overlay2/0e6d8ab67489cffea7560a7fdc382658d599dc415839d4bf5f4d6c2b71dadf79/diff",                "MergedDir": "/var/lib/docker/overlay2/5070e57b3b1ab1533ba4b1a8cb7de79e3655f6d78ba43c4640c2d25cedb00fa5/merged",                "UpperDir": "/var/lib/docker/overlay2/5070e57b3b1ab1533ba4b1a8cb7de79e3655f6d78ba43c4640c2d25cedb00fa5/diff",                "WorkDir": "/var/lib/docker/overlay2/5070e57b3b1ab1533ba4b1a8cb7de79e3655f6d78ba43c4640c2d25cedb00fa5/work"            },            "Name": "overlay2"        },        "Mounts": [],        "Config": {            "Hostname": "2d2c8f54b427",            "Domainname": "",            "User": "",            "AttachStdin": false,            "AttachStdout": false,            "AttachStderr": false,            "Tty": false,            "OpenStdin": false,            "StdinOnce": false,            "Env": [                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"            ],            "Cmd": [                "/bin/sh",                "-c",                "while true;do echo qing;sheep 1;done"            ],            "Image": "centos",            "Volumes": null,            "WorkingDir": "",            "Entrypoint": null,            "OnBuild": null,            "Labels": {                "org.label-schema.build-date": "20210915",                "org.label-schema.license": "GPLv2",                "org.label-schema.name": "CentOS Base Image",                "org.label-schema.schema-version": "1.0",                "org.label-schema.vendor": "CentOS"            }        },        "NetworkSettings": {            "Bridge": "",            "SandboxID": "6ef9320864e6daa4195b284e3c60fb56edb95be77010eda7cff755ab315cffeb",            "HairpinMode": false,            "LinkLocalIPv6Address": "",            "LinkLocalIPv6PrefixLen": 0,            "Ports": {},            "SandboxKey": "/var/run/docker/netns/6ef9320864e6",            "SecondaryIPAddresses": null,            "SecondaryIPv6Addresses": null,            "EndpointID": "3d08880669d8a5f2ad913bef248471a0377eeeb7793f83450cd514d0b43e7a39",            "Gateway": "172.18.0.1",            "GlobalIPv6Address": "",            "GlobalIPv6PrefixLen": 0,            "IPAddress": "172.18.0.2",            "IPPrefixLen": 16,            "IPv6Gateway": "",            "MacAddress": "02:42:ac:12:00:02",            "Networks": {                "bridge": {                    "IPAMConfig": null,                    "Links": null,                    "Aliases": null,                    "NetworkID": "73abca2ea3673a8f7f4919d8141708a47bc0851025083aefa25a3bec6286704d",                    "EndpointID": "3d08880669d8a5f2ad913bef248471a0377eeeb7793f83450cd514d0b43e7a39",                    "Gateway": "172.18.0.1",                    "IPAddress": "172.18.0.2",                    "IPPrefixLen": 16,                    "IPv6Gateway": "",                    "GlobalIPv6Address": "",                    "GlobalIPv6PrefixLen": 0,                    "MacAddress": "02:42:ac:12:00:02",                    "DriverOpts": null                }            }        }    }]  </code>  </pre></details><p><strong>进入当前正在运行的容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 通常容器都是使用后台方式运行的，需要进入容器修改一些配置</span><span class="token comment"># -it  通过交互模式运行</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it 容器id /bin/bash  <span class="token comment"># 进入后台运行的容器，/bin/bash 位置开启一个新的终端，可以进行一些操作(常用)</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker attach 容器id<span class="token comment">#  进入正在执行的容器进入正在运行的中断，不会启动新的进程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>从容器内拷贝文件到宿主机</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">cp</span> 容器id:容器内路径目的主机路径<span class="token comment"># 容器内文件拷贝到主机</span><span class="token comment"># test 进入之前启动的centos容器内</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker attach <span class="token variable">${id}</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ls</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> /home<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">touch</span> test.java<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token builtin class-name">exit</span> <span class="token comment"># 注意 此处是退出了容器，容器停止运行，但是在没有被清理时容器的数据依旧存在</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span> -a<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">cp</span> <span class="token variable">${id}</span>:/home/test.java /home <span class="token comment"># 类似与socp命令</span><span class="token comment">## 拷贝时一个手动的过程，后期使用中可以通过 -v 卷的方式，实现自动同步，将容器中的目录与宿主机的进行同步</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其他</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker --help<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2021/12/25/cs-dev-ops/docker-notes/0005.png" class="" title="命令简图"><h4 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker attach      <span class="token comment"># Attach local standard input, output, and error streams to a running container</span><span class="token comment"># 当前shell下attach连接指定运行镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build<span class="token comment"># Build an image from a Dockerfile</span><span class="token comment"># 通过Dockerfile 定制镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker commit<span class="token comment"># Create a new image from a container's changes</span><span class="token comment"># 提交当前容器为新的镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">cp</span><span class="token comment"># Copy files/folders between a container and the local filesystem</span><span class="token comment"># 从容器中拷贝指定文件或目录到宿主机中</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker create<span class="token comment"># Create a new container</span><span class="token comment"># 创建一个新的容器，同run，但不启动容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">diff</span><span class="token comment"># Inspect changes to files or directories on a container's filesystem</span><span class="token comment"># 查看docker容器的变化</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker events<span class="token comment"># Get real time events from the server</span><span class="token comment"># 从docker服务获取容器实时事件</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span><span class="token comment"># Run a command in a running container</span><span class="token comment"># 在已存在的容器上运行命令</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">export</span><span class="token comment"># Export a container's filesystem as a tar archive</span><span class="token comment"># 到处容器的内容流作为一个tar归档文件，对应import</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">history</span><span class="token comment"># Show the history of an image</span><span class="token comment"># 查看一个镜像的历史</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker images<span class="token comment"># List images</span><span class="token comment"># 列出当前系统中所有的镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">import</span><span class="token comment"># Import the contents from a tarball to create a filesystem image</span><span class="token comment"># 从tar包中的内容创建一个新的文件系统，对应export</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker info<span class="token comment"># Display system-wide information</span><span class="token comment"># 显示系统相关信息</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect<span class="token comment"># Return low-level information on Docker objects</span><span class="token comment"># 查看容器详细信息</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">kill</span><span class="token comment"># Kill one or more running containers</span><span class="token comment"># kill指定docker容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker load<span class="token comment"># Load an image from a tar archive or STDIN</span><span class="token comment"># 从一个tar包中加载一个镜像，对应save</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker login<span class="token comment"># Log in to a Docker registry</span><span class="token comment"># 注册或者登录一个docker源服务器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">logout</span><span class="token comment"># Log out from a Docker registry</span><span class="token comment"># 从当前docker registry退出</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker logs<span class="token comment"># Fetch the logs of a container</span><span class="token comment"># 输出当前容器日志信息</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker pause<span class="token comment"># Pause all processes within one or more containers</span><span class="token comment"># 暂停容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker port<span class="token comment"># List port mappings or a specific mapping for the container</span><span class="token comment"># 查看映射端口对应容器内幕源端口</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token comment"># List containers</span><span class="token comment"># 列出容器列表</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker pull<span class="token comment"># Pull an image or a repository from a registry</span><span class="token comment"># 从docker镜像源服务器拉取指定镜像或者库镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker push<span class="token comment"># Push an image or a repository to a registry</span><span class="token comment"># 推送指定镜像或者库镜像到dicker源服务器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">rename</span><span class="token comment"># Rename a container</span><span class="token comment"># 对容器重命名</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker restart<span class="token comment"># Restart one or more containers</span><span class="token comment"># 重启运行的容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">rm</span><span class="token comment"># Remove one or more containers</span><span class="token comment"># 移除一个或者多个容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker rmi<span class="token comment"># Remove one or more images</span><span class="token comment"># 移除一个或者多个镜像，五容器使用该镜像才可删除，否则需要删除相关容器才可以或者强制删除</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run<span class="token comment"># Run a command in a new container</span><span class="token comment"># 创建一个新的容器并运行一个命令</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker save<span class="token comment"># Save one or more images to a tar archive (streamed to STDOUT by default)</span><span class="token comment"># 保存一个镜像为一个tar包，对应load</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker search<span class="token comment"># Search the Docker Hub for images</span><span class="token comment"># 在docker hub中搜索镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker start<span class="token comment"># Start one or more stopped containers</span><span class="token comment"># 启动容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stats<span class="token comment"># Display a live stream of container(s) resource usage statistics</span><span class="token comment"># 显示容器资源的状态</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stop<span class="token comment"># Stop one or more running containers</span><span class="token comment"># 停止容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker tag<span class="token comment"># Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><span class="token comment"># 给源镜像打一个标签</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">top</span><span class="token comment"># Display the running processes of a container</span><span class="token comment"># 查看容器中运行的进程信息</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker unpause<span class="token comment"># Unpause all processes within one or more containers</span><span class="token comment"># 取消暂停容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker update<span class="token comment"># Update configuration of one or more containers</span><span class="token comment"># 更新一个或者多个容器的配置</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker version<span class="token comment"># Show the Docker version information</span><span class="token comment"># 查看docker版本号</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">wait</span><span class="token comment"># Block until one or more containers stop, then print their exit codes</span><span class="token comment"># 截取容器停止时的退出状态值。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><h4 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker search nginx<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker pull nginx<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d --name nginx00 -p <span class="token number">2233</span>:80 nginx<span class="token comment"># 后台启动nginx 并设置名称 nginx00 映射端口 宿主机2233 -&gt; 容器80</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:2233<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it nginx00 /bin/bashroot@fca2fac49368:/$ <span class="token function">whereis</span> nginx <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>存在问题</strong></p><p>每次改动nignx配置文件，都需要进入容器内部，十分的麻烦</p><p><strong>解决方案</strong></p><p>在容器外部宿主机上提供一个映射路径，达到在容器外修改文件，容器内不就可以修改的目的，-v 数据卷</p></blockquote><h4 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a><strong>tomcat</strong></h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it --rm tomcat:9.0 <span class="token comment"># 一般用来测试，用完就删除，及--rm</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker search tomcat<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker pull tomcat:9.0<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d --name tomcat9.0_00 -p <span class="token number">2233</span>:8080 tomcat:9.0<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:2233root@714059eea83c$ docker <span class="token builtin class-name">exec</span> -it tomcat9.0_00 /bin/bash<span class="token function">ls</span> -al<span class="token builtin class-name">cd</span> /usr/local/tomcat<span class="token function">cp</span> -r webapps.dist/* webapps<span class="token comment"># 实际上，这里启动的时阉割版镜像，及默认最小的镜像，所以不必要的都被剔除掉了</span><span class="token comment"># 故：linux命令少，没有webapps。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>存在问题</p><p>每次部署项目，需要进入到容器进行拷贝文件十分麻烦。如果所有的文件都放到容器内部，eg. mysql 如果删除了镜像或者容器，导致所有数据丢失？</p><p>解决方案</p><p>同上</p></blockquote><h4 id="es-kibana"><a href="#es-kibana" class="headerlink" title="es+kibana"></a><strong>es+kibana</strong></h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># elasticsearch 暴露的端口很多、十分的耗内存、数据一般需要放置到安全目录 挂载</span><span class="token comment"># 官方启动命令</span><span class="token comment"># $ docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:tag</span><span class="token comment"># --net somenetwork ？ docker的网络配置</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d --name elasticsearch -p <span class="token number">9200</span>:9200 -p <span class="token number">9300</span>:9300 -e <span class="token string">"discovery.type=single-node"</span> elasticsearch:7.6.2<span class="token comment"># 启动后十分的卡 docker stats 查看cpu状态</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stats  <span class="token variable">${id}</span>?<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stop elasticsearch<span class="token comment"># 添加限制的启动</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d --name elasticsearch -p <span class="token number">9200</span>:9200 -p <span class="token number">9300</span>:9300 -e <span class="token string">"discovery.type=single-node"</span> -e <span class="token assign-left variable">ES_JAVA_OPTS</span><span class="token operator">=</span><span class="token string">"-Xms64m -Xmax512m"</span> elasticsearch:7.6.2<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:9200<span class="token comment">####################################</span><span class="token comment"># kibana 连接  es</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><ul><li>portainer</li><li>rancher（CI/CD）</li></ul><h4 id="portainer"><a href="#portainer" class="headerlink" title="portainer"></a>portainer</h4><p>Docker图像化管理工具，提供了一个后台面板</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">root@qing /<span class="token punctuation">]</span>$ docker run -d -p <span class="token number">8088</span>:9000 <span class="token punctuation">\</span>--restart<span class="token operator">=</span>always -v /var/run/docker.sock:/var/run/docker.sock --privileged<span class="token operator">=</span>true portainer/portainer<span class="token comment"># -v 挂载  宿主机:容器</span><span class="token comment"># --privileged 授权</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h3 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h3><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时的库、环境变量和配置文件</p><p>所有的应用，直接打包docker镜像，就可以直接跑起来</p><ul><li>从远程仓库pull</li><li>拷贝文件</li><li>自己制作一个镜像 dockerFile</li></ul><h3 id="Docker镜像加速原理"><a href="#Docker镜像加速原理" class="headerlink" title="Docker镜像加速原理"></a>Docker镜像加速原理</h3><blockquote><p>UnionFS（联合文件系统）</p></blockquote><p>UnionFS（联合文件系统）：Union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual file system）。Union文件系统时Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><blockquote><p>Docker镜像加载原理</p></blockquote><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层就是bootfs。这一层与我们典型的Linux/Unix系统一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已有bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs（root file system），在bootfs之上，包含典型Linux系统中的/dev 、/proc、/bin、/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版本，eg. Ubuntu Centos…</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect 镜像id<span class="token comment"># 查看镜像信息</span><span class="token comment"># rootFS</span><span class="token comment">#  "RootFS": {</span><span class="token comment">#             "Type": "layers",</span><span class="token comment">#             "Layers": [</span><span class="token comment">#                 "sha256:764055ebc9a7a290b64d17cf9ea550f1099c202d83795aa967428ebdf335c9f7",</span><span class="token comment">#                 "sha256:71a14cc55692a4edac5da18be420acf085c681ec95f7af5ff64bb1c236440d59",</span><span class="token comment">#                 "sha256:50854886015e8e202f3197c6a95ae60632a432aba673188bb7c3f9ee80ed2f30",</span><span class="token comment">#                 "sha256:1952fb2b0eb4d355f05a815c6d804243f089e05c0b8f3b1c1eaf0a1109e8293a",</span><span class="token comment">#                 "sha256:893f6aea2ce23f813c44180ccb7a41e8a4d151cb02f7c365cc4e837c0872b211",</span><span class="token comment">#                 "sha256:b8d0aeaeeee8ed55cb6bfc7e061d0bb0491e91024790c45d0c56b07c29cea080",</span><span class="token comment">#                 "sha256:d7cde20f3f6895bd6e6b2ef5767ee60d7034babe62093340ac22df5c8622db74",</span><span class="token comment">#                 "sha256:ae8fcba6091c17b6691f9a1c49621f193e2f475b3eee44d83b4f78b0d0fd31ae",</span><span class="token comment">#                 "sha256:1a4de2199d77be12009ed995b8db1c5a85d9a9b5e19673a8af4824de03f4ce0a",</span><span class="token comment">#                 "sha256:eeabd280c12ee308111950fd99ba8ffdd75130b6d948ba6a34fe6221b82f20dd",</span><span class="token comment">#                 "sha256:cd0c4980990f734130353adfa00f88ba57bc946b868468d633eeb75abd465fa0",</span><span class="token comment">#                 "sha256:027a41439ba438753333f44da1bc57b86e2211f708ace53343cc733151dc2380"</span><span class="token comment">#             ]</span><span class="token comment">#         },</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>精简后的OS，rootfs可以很小，只包含最基本的命令，工具和程序库就可以了，因为底层直接用Host到Kernel，自己只需要提供rootfs就可以了。达到公用bootfs的目的。</p><img src="/2021/12/25/cs-dev-ops/docker-notes/0006.png" class="" title="多层文件1"><img src="/2021/12/25/cs-dev-ops/docker-notes/0007.png" class="" title="多层文件2"><blockquote><p>进一步说明</p></blockquote><p>所有的Docker镜像都起始于一个既相互镜像层，当进行修改或者增加新的内容时，就会在当前镜像层之上，创建一个新的镜像层。</p><img src="/2021/12/25/cs-dev-ops/docker-notes/0008.png" class="" title="示意图"><p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合。及每个镜像层包含了3个文件，而镜像包含了来及两个镜像层的六个文件</p><img src="/2021/12/25/cs-dev-ops/docker-notes/0009.png" class="" title="示意图"><p>一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，因为最上层中的app2.0是app1.0的一个更新版本。</p><img src="/2021/12/25/cs-dev-ops/docker-notes/0010.png" class="" title="示意图"><p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件，使得文件的更新版本作为一个新镜像层添加到镜像中。</p><p>Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一 文件系统。</p><p>Linux上可用的存储引擎由AUFS、Overlay2、Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于Linux中对应的文件系统或者块设备技术，并且每种存储引擎都有其独特的性能特点</p><p>Docker在Windows上仅支持windowsfilter一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW [①]。</p><p>所有镜像层堆叠合并后，对外统一提供如上图所示的合并图</p><blockquote><p>特点</p></blockquote><p>Docker镜像都是只读的，当容器启动是，一个新的可写层被加载到镜像的顶部，这一层就是容器层，容器之下的都是叫镜像层。（无限套娃？？？）</p><h3 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 提交容器成为一个新的副本容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker commit<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker commit -m<span class="token operator">=</span><span class="token string">"description"</span> -a<span class="token operator">=</span><span class="token string">"author"</span> 容器id 目标镜像:<span class="token punctuation">[</span>TAG<span class="token punctuation">]</span><span class="token comment"># test</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it -p <span class="token number">8080</span>:8080 tomcat<span class="token comment"># new terminal</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it <span class="token variable">${id}</span> /bin/bashroot@sdfj0adf98 /$ <span class="token builtin class-name">cd</span> /usr/local/tomcatroot@sdfj0adf98 /$ <span class="token function">cp</span> -r webapps.dist/* webapps <span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker commit -m<span class="token operator">=</span><span class="token string">"description"</span> -a<span class="token operator">=</span><span class="token string">"author"</span> 容器id 目标镜像:<span class="token punctuation">[</span>TAG<span class="token punctuation">]</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker images<span class="token comment"># 将镜像保存为压缩包</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker save -o qing.tar qing:v1.0<span class="token comment"># 在别的机器上加载该镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker load -i qing.tar<span class="token comment"># 将旧镜像名称修改为新版名称</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker tag qing:v1.0 sunq/qing:v1.0<span class="token comment"># 登录到docker hub</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker login<span class="token comment"># 推送至仓库</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker push sunq/qing:v1.0<span class="token comment"># 完成推送后，退出登录</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">logout</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/12/25/cs-dev-ops/docker-notes/0011.png" class="" title="示意图"><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><p>Q：数据可用放在容器里面么？</p><p>A：不能，因为容器如果被删除，会导致数据永久的丢失，所以需要<strong>数据持久化</strong></p><p>所以就有了容器的卷技术，容器之间可用有一个数据共享，将Docker容器中产生的数据同步到本地中 —— 目录挂载，将我们容器内的目录，挂载到Linux上面。将宿主机的内存共享给容器，双向绑定。</p><p><strong>容器持久化和同步操作，容器间也可以数据共享。</strong></p><h3 id="挂载链接"><a href="#挂载链接" class="headerlink" title="挂载链接"></a>挂载链接</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 直接使用命令来挂载 -v</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it 主机目录:容器目录 （镜像）<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it -v /home/ceshi:/home centos /bin/bash<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect 容器Id<span class="token comment"># “Mounts”</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> /home/ceshi<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ls</span><span class="token comment"># 在容器内创建文件</span><span class="token punctuation">[</span>root@sdfuo098sadf /<span class="token punctuation">]</span>$ <span class="token function">ls</span> /home<span class="token punctuation">[</span>root@sdfuo098sadf /<span class="token punctuation">]</span>$ <span class="token function">touch</span> test.java<span class="token comment"># 在宿主机中查看是否文件被同步创建</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ls</span> /home/ceshi<span class="token comment"># [root@qing /]$ docker exec -it 容器id /bin/bash  # 进入后台运行的容器，/bin/bash 位置开启一个新的终端，可以进行一些操作(常用)</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker attach 容器id<span class="token comment">#  进入正在执行的容器进入正在运行的中断，不会启动新的进程</span><span class="token punctuation">[</span>root@sdfuo098sadf /<span class="token punctuation">]</span>$ <span class="token builtin class-name">exit</span><span class="token comment"># 退出容器后，在宿主机上修改文件</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> /home/ceshi/test.java<span class="token comment"># 重新启动容器，查看容器中的该文件是被同步修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 拉取镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker pull mysql:5.7<span class="token comment"># 官方的启动命令</span><span class="token comment"># 启动容器时挂载目录, 配置密码</span><span class="token comment"># -e 环境配置</span><span class="token comment"># $ docker run -it --network some-network --rm mysql mysql -hsome-mysql -uexample-user -p</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -p <span class="token number">2233</span>:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> --name mysql01 mysql:5.7<span class="token comment"># 可用连接创建数据库查看是否持久化成功。</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">rm</span> -f mysql01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 不指定主机目录，会自动挂载</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$  docker run -d -P --name nginx01 -v /etc/nginx nginx<span class="token comment"># 注意 -v 后不添加/ 表明不是目录</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$  docker run -d -P --name nginx02 -v juming_nginx:/etc/nginx nginx<span class="token comment"># 查看所有的卷情况</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker volume <span class="token function">ls</span>DRIVER    VOLUME NAME<span class="token builtin class-name">local</span>     0a99e217ac4ba4842c205b7fe1aae0146425e56b96df7628d78e10198f1337ce<span class="token builtin class-name">local</span>     juming_nginx<span class="token comment"># 可用看出，第一个就是匿名挂载，在 -v 之后只写了容器内的路径，没有写宿主机的路径</span><span class="token comment"># 第二个就是具名挂载 -v 卷名:容器内路径 </span><span class="token comment"># 查看卷的所在目录</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker volume inspect juming_nginx<span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"CreatedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-12-29T23:28:25+08:00"</span>,        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,        <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> null,        <span class="token string">"Mountpoint"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/volumes/juming_nginx/_data"</span>,        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"juming_nginx"</span>,        <span class="token string">"Options"</span><span class="token builtin class-name">:</span> null,        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token comment"># Mountpoint 就是挂载的目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的docker容器内的卷，没有指定目录的情况下都是在 <code>/var/lib/docker/volumes/xxxxxx/_data</code></p><p>通过具名挂载可用很方便的找到一个卷，通常情况下都是使用具名挂载</p><h4 id="挂载小总结"><a href="#挂载小总结" class="headerlink" title="挂载小总结"></a>挂载小总结</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 具名挂载、匿名挂载、指定路径挂载</span>-v 容器内路径<span class="token comment"># 匿名挂载</span>-v 卷名:容器内路径<span class="token comment"># 具名挂载</span>-v /宿主机路径:容器内路径<span class="token comment"># 指定路径挂载</span><span class="token comment"># 通过 -v 容器内路径:ro rw 改变读写权限</span><span class="token comment"># 一旦设置了容器权限，容器对我们挂载出来的容器就有了限定 </span><span class="token comment"># ro 这个路径就只能通过宿主机来操作，容器内部是无法操作的</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name nginx03: -v juming_nginx:/etc/nginx:ro nginx<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name nginx04 -v juming_nginx:/etc/nginx:rw nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dockerFile实现挂载"><a href="#dockerFile实现挂载" class="headerlink" title="dockerFile实现挂载"></a>dockerFile实现挂载</h3><p>命令脚本，可用通过这个脚本来生成镜像，镜像是一层一层的卷，脚本就是一个一个的命令，每个命令就是一层！</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> /home/docker-test-volume<span class="token comment"># 创建dockerFile文件</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> dockerFile1<span class="token comment">#############################dockerFile1##############</span>FROM centosVOLUME <span class="token punctuation">[</span><span class="token string">"volume01"</span>,<span class="token string">"volume02"</span><span class="token punctuation">]</span>CMD <span class="token builtin class-name">echo</span> <span class="token string">"------end------"</span>CMD /bin/bash<span class="token comment">############################dockerFile1##############</span><span class="token comment"># 根据dockerFile 生成镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build -f ./dockerFile1 -t qing/centos:1.0 <span class="token builtin class-name">.</span>Sending build context to Docker daemon  <span class="token number">240</span>.7MBStep <span class="token number">1</span>/4 <span class="token builtin class-name">:</span> FROM centos ---<span class="token operator">&gt;</span> 5d0da3dc9764Step <span class="token number">2</span>/4 <span class="token builtin class-name">:</span> VOLUME <span class="token punctuation">[</span><span class="token string">"volume01"</span>,<span class="token string">"volume02"</span><span class="token punctuation">]</span> ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> eb142d0e83adRemoving intermediate container eb142d0e83ad ---<span class="token operator">&gt;</span> ba3e07adb20bStep <span class="token number">3</span>/4 <span class="token builtin class-name">:</span> CMD <span class="token builtin class-name">echo</span> <span class="token string">"------end------"</span> ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 372a86750520Removing intermediate container 372a86750520 ---<span class="token operator">&gt;</span> 8feb17962dffStep <span class="token number">4</span>/4 <span class="token builtin class-name">:</span> CMD /bin/bash ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> b198098a4925Removing intermediate container b198098a4925 ---<span class="token operator">&gt;</span> 0a15ea858d6bSuccessfully built 0a15ea858d6bSuccessfully tagged qing/centos:1.0<span class="token comment"># 查看镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker imagesREPOSITORY    TAG       IMAGE ID       CREATED         SIZEqing/centos   <span class="token number">1.0</span>       0a15ea858d6b   <span class="token number">6</span> seconds ago   231MB<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it qing/centos:1.0 <span class="token function">bash</span><span class="token punctuation">[</span>root@ef4ca52a471a /<span class="token punctuation">]</span><span class="token comment"># ls</span>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01volume02<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect ef4ca52a471a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="容器间共享数据"><a href="#容器间共享数据" class="headerlink" title="容器间共享数据"></a>容器间共享数据</h3><p>通过数据卷容器来达到容器间的共享</p><img src="/2021/12/25/cs-dev-ops/docker-notes/0015.png" class="" title="示意图"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 启动父容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it --name docker01 qing/centos:1.0 <span class="token function">bash</span><span class="token comment"># 启动第二个</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it --name docker02 --volumes-from docker01 qing/centos:1.0 <span class="token function">bash</span><span class="token comment"># 在父容器中创建文件 会被同步到子容器中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：这里其实是容器都挂载到宿主机的同一个目录下了，并不是多个目录之间在同步，如果删除宿主机下的这个目录的文件，容器内的数据就会消失</p><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><p>dockerFile 是用来构建docker镜像的构建脚本。</p><p>大致步骤</p><ol><li>编写一个dockerFile文件</li><li>docker build 构建一个镜像</li><li>docker  run 运行镜像</li><li>docker push 发布镜像</li></ol><blockquote><p>每个保留关键字（指令）都是大写</p><p>执行从上到下顺序执行</p><p>/# 表示注释</p><p>每个指令都会创建提交一个新的镜像层，并提交。</p></blockquote><img src="/2021/12/25/cs-dev-ops/docker-notes/0016.png" class="" title="示意图"><h3 id="指令简述"><a href="#指令简述" class="headerlink" title="指令简述"></a>指令简述</h3><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>基础镜像，从这里开始</td></tr><tr><td>MAINTAINER</td><td>镜像的作者</td></tr><tr><td>RUN</td><td>镜像构建的时候需要运行的命令</td></tr><tr><td>ADD</td><td>编译镜像时复制文本到镜像中</td></tr><tr><td>COPY</td><td>类似ADD，将文件拷贝到镜像中</td></tr><tr><td>WORKDIR</td><td>镜像的工作目录，设置RUN CMD ENTRYPOINT COPY ADD指令的工作目录</td></tr><tr><td>LABEL</td><td>设置镜像的标签</td></tr><tr><td>VOLUME</td><td>挂载的目录</td></tr><tr><td>EXPOSE</td><td>设置镜像暴露的端口</td></tr><tr><td>CMD</td><td>指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被代替</td></tr><tr><td>ENTRYPOINT</td><td>指定这个容器启动的时候要运行的命令，可用追加命令</td></tr><tr><td>ONBUILD</td><td>当构建一个被继承DockerFile这个时候就会运行onbuild的指令，触发指令</td></tr><tr><td>ARG</td><td>设置编译镜像时加入的参数</td></tr><tr><td>ENV</td><td>构建的时候设置的环境变量</td></tr><tr><td>USER</td><td>设置运行RUN CMD ENTRYPOINT的用户名</td></tr><tr><td>STOPSIGNAL</td><td>设置容器的退出信号量</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><p>Docker Hub中99%镜像都是从一个基础镜像scratch过来的。</p><blockquote><p>FROM scratch</p></blockquote><h4 id="制作一个简单的centos扩展镜像"><a href="#制作一个简单的centos扩展镜像" class="headerlink" title="制作一个简单的centos扩展镜像"></a>制作一个简单的centos扩展镜像</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> docker_file_centos<span class="token comment">############################docker_file_centos##############</span>FROM centosMAINTAINER qing<span class="token operator">&lt;</span><span class="token number">111</span>@qq.com<span class="token operator">&gt;</span>ENV MYPATH /usr/localWORKDIR <span class="token variable">$MYPATH</span>RUN yum -y <span class="token function">install</span> <span class="token function">vim</span>RUN yum -y insatll net-toolsEXPOSE <span class="token number">80</span>CMD <span class="token builtin class-name">echo</span> <span class="token string">"------end-----"</span>CMD /bin/bash<span class="token comment">############################docker_file_centos##############</span><span class="token comment"># 在官方的centos基础上添加了vim 和 net-tools</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build -f home/doker_files/docker_file_centos -t qing/centos:1.1 <span class="token builtin class-name">.</span><span class="token comment"># 可用启动测试下 ipconfig vim 命令</span><span class="token comment"># 查看下镜像构建的历史</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">history</span> 镜像id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用tar制作tomcat镜像"><a href="#使用tar制作tomcat镜像" class="headerlink" title="使用tar制作tomcat镜像"></a>使用tar制作tomcat镜像</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ls</span>apache-tomcat-9.0.56.tar.gz jdk1.8.0_181<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">touch</span> readme.md<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> Dockerfile <span class="token comment"># 该命令 build是会自动讯在，不用-f指定 </span><span class="token comment">############################Dockerfile##############</span>FROM centosMAINTAINER qing<span class="token operator">&lt;</span><span class="token number">111</span>@qq.com<span class="token operator">&gt;</span>COPY readme.md /usr/local/readme.txt<span class="token comment"># 直接复制</span>COPY jdk1.8.0_181/ /usr/local/jdk1.8.0_181/<span class="token comment"># 会自动解压</span>ADD apache-tomcat-9.0.56.tar /usr/local/RUN yum -y <span class="token function">install</span> <span class="token function">vim</span> ENV MYPATH /usr/localWORKDIR <span class="token variable">$MYPATH</span>ENV JAVA_HOME /usr/local/jdk1.8.0_181ENV CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.56ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.56ENV <span class="token environment constant">PATH</span> <span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$JAVA_HOEM</span>/bin:<span class="token variable">$CATALINA_HOME</span>/lib:<span class="token variable">$CATALINA_HOME</span>/binEXPOSE <span class="token number">8080</span>CMD /usr/local/apache-tomcat-9.0.56/bin/startup.sh <span class="token operator">&amp;&amp;</span> <span class="token function">tail</span> -F /url/localapache-tomcat-9.0.56/bin/logs/catalina.out<span class="token comment">############################Dockerfile##############</span><span class="token comment"># 构建启动</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build -t qing/tomcat:1.0 <span class="token builtin class-name">.</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker images<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -p <span class="token number">2233</span>:8080 --name qingtomcat -v /home/qing/tomcat/test:/usr/local/apache-tomcat-9.0.56/webapps/test -v /home/qing/tomcat/logs:/usr/local/apache-tomcat-9.0.56/logs qing/tomcat:1.0<span class="token comment"># 测试</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:2233<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root@qing /]$ mkdir /home/qing/tomcat/test/EB-INF[root@qing /]$ cd /home/qing/tomcat/test/EB-INF[root@qing /]$ vim web.xml############################web.xml##############&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee                             http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"         ersion="2.5"&gt;&lt;/web-app&gt;  ############################web.xml##############[root@qing /]$ cd ..[root@qing /]$ vim index.jsp############################index.jsp##############&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;br/&gt;&lt;%System.out.println("Your IP address is " + request.getRemoteAddr());%&gt;&lt;/body&gt;&lt;/html&gt;############################index.jsp##############<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h3><h4 id="CMD和ENTRYPOINT的区别"><a href="#CMD和ENTRYPOINT的区别" class="headerlink" title="CMD和ENTRYPOINT的区别"></a>CMD和ENTRYPOINT的区别</h4><ul><li>CMD<ul><li>启动的时候如果在最后追加了命令会替换掉镜像中的命令</li></ul></li><li>ENRYPOINT<ul><li>启动后如果在最后追加了命令，不会替换镜像中的命令，而是在其后追加</li></ul></li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> docker_file_cmd<span class="token comment">############################docker_file_cmd##############</span>FROM centosCMD <span class="token punctuation">[</span><span class="token string">"ls"</span>,<span class="token string">"-a"</span><span class="token punctuation">]</span><span class="token comment">############################docker_file_cmd##############</span><span class="token comment"># 在官方的centos基础上添加了vim 和 net-tools</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build -f home/doker_files/docker_file_cmd -t qing/centos:1.2 <span class="token builtin class-name">.</span><span class="token comment"># 直接运行会发现 ls -a 执行了</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span><span class="token variable">$dovker</span> run centos:1.2<span class="token comment"># 追加命令执行</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span><span class="token variable">$dovker</span> run centos:1.2 -lerror<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> docker_file_entrypoint<span class="token comment">############################docker_file_entrypoint##############</span>FROM centosENTRYPOINT <span class="token punctuation">[</span><span class="token string">"ls"</span>,<span class="token string">"-a"</span><span class="token punctuation">]</span><span class="token comment">############################docker_file_entrypoint##############</span><span class="token comment"># 在官方的centos基础上添加了vim 和 net-tools</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build -f home/doker_files/docker_file_entrypoint -t qing/centos:1.3 <span class="token builtin class-name">.</span><span class="token comment"># 直接运行会发现 ls -a 执行了</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ dovker run centos:1.2<span class="token comment"># 追加命令执行，会发现 执行了 ls -a -l</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ dovker run centos:1.2 -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h3><h4 id="DockerHub"><a href="#DockerHub" class="headerlink" title="DockerHub"></a>DockerHub</h4><ol><li><p>地址<a href="http://hub.docker.com/">http://hub.docker.com/</a> 注册自己的账号</p></li><li><p>在服务器上提交自己的镜像</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 登录自己账户号</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker login -u qingPassword:Login Succeeded<span class="token comment"># 提交镜像 尽量带上自己的版本号</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker push  qing/tomcat:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="阿里云容器镜像服务"><a href="#阿里云容器镜像服务" class="headerlink" title="阿里云容器镜像服务"></a>阿里云容器镜像服务</h4><ol><li>登录阿里云，找到容器镜像服务</li><li>根据需求创建命名空间、</li><li>创建容器镜像</li><li>根据阿里云上的操作指南进行提交</li></ol><h2 id="流程小结"><a href="#流程小结" class="headerlink" title="流程小结"></a>流程小结</h2><img src="/2021/12/25/cs-dev-ops/docker-notes/0017.png" class="" title="流程图"><h2 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h2><h3 id="实验查看"><a href="#实验查看" class="headerlink" title="实验查看"></a>实验查看</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看IP地址</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ip</span> addr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2021/12/25/cs-dev-ops/docker-notes/0018.png" class="" title="输出说明"><p>Q：docker如何处理容器网络访问的？</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat01 tomcat<span class="token comment"># 查看容器的内部Ip地址</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat01 <span class="token function">ip</span> addr<span class="token comment">## 如果 报错 OCI runtime exec failed: </span><span class="token comment">## 因为该tomcat镜像为了最小化，可能没有安装ip addr命令，故需要安装 iproute2</span><span class="token comment"># [root@qing /]$ docker exec -it tomcat01 bash</span><span class="token comment"># root@bd19d226252e $ apt update &amp;&amp; apt install -y iproute2</span><span class="token comment"># 再次输入</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat01 <span class="token function">ip</span> addr<span class="token comment"># 查看一下容器的内部网络地址，发现容器启动的时候会得到一个eth0@if61的ip地址，该地址是由docker分配的 详细见 图0019</span>       <span class="token comment"># 可用通过宿主机ping 改ip</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ping</span> <span class="token number">172.18</span>.0.2<span class="token comment"># 与图片0018中的 docker0 172.18.0.1/16 可用得知该网络与docker0属于同一个网段</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/12/25/cs-dev-ops/docker-notes/0019.png" class="" title="输出说明"><h3 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h3><ol><li><p>每启动一个docker容器，docker就会给docker容器分配一个ip，只要安装了docker，就会有一个网卡docker0。通过桥接模式，使用的技术veth-pair技术进行连接。</p></li><li><p>再次在宿主机测试<code>ip addr</code>，对比图0019和图0020，可以看到了宿主机多了一个网卡，序号上与容器中是对应的</p><blockquote><p>容器带来的网卡都是一对存在的</p><p>veth-pair 就是一对虚拟设备接口，都是成对出现，一段连着协议，一段彼此相连。基于此特性，veth-pair充当一个桥梁，连接各种虚拟网络设备的</p><p>OpenStac、Docker容器之间的连接、OVS的连接，都是使用veth-pair 技术</p></blockquote><img src="/2021/12/25/cs-dev-ops/docker-notes/0020.png" class="" title="输出说明"></li><li><p>所以在启动多个容器的时候，由于都是由docker0分配的网卡的ip都属于同一个网段，所以容器之间也是可以相互访问的。</p></li></ol><img src="/2021/12/25/cs-dev-ops/docker-notes/0021.png" class="" title="示意图"><ol start="4"><li>所以，在启动容器时不指定网络的情况下，都是哟docker来分配一个默认的可用IP，且由docker0来进行路由</li></ol><p><strong>小结</strong></p><blockquote><p>Docker使用的是Linux的桥接，宿主机中的一个网卡docker0就是Docker的网桥 </p><p>docker中的所有网络接口都是虚拟的，虚拟的转发效率高、</p></blockquote><img src="/2021/12/25/cs-dev-ops/docker-notes/0022.png" class="" title="示意图"><h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><h4 id="–Link"><a href="#–Link" class="headerlink" title="–Link"></a>–Link</h4><blockquote><p>但是并不推荐使用 –link 进行容器连接。因为部分的自定义网络不适于使用docker0 进行路由，例如：不支持使用容器名进行连接</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat01 tomcat<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat02 tomcat<span class="token comment"># 直接在容器间进行ping</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat02 <span class="token function">ping</span> tomcat01<span class="token comment">## 如果 报错 OCI runtime exec failed: </span><span class="token comment">## 不支持ping命令时，则需要进入容器手动安装该命令</span><span class="token comment"># [root@qing /]$ docker exec -it tomcat02 bash</span><span class="token comment"># root@bd19d226252e $ apt update &amp;&amp; apt install iputils-ping</span>ping: tomcat01: Name or <span class="token function">service</span> not known  <span class="token comment"># 可知无法与tomcat01进行通信</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat03 --link tomcat02 tomcat<span class="token comment"># 如果不存在ping命令，则需要同上面的方式安装 </span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat03 <span class="token function">ping</span> tomcat02PING tomcat02 <span class="token punctuation">(</span><span class="token number">172.18</span>.0.3<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.<span class="token number">64</span> bytes from tomcat02 <span class="token punctuation">(</span><span class="token number">172.18</span>.0.3<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.104</span> ms<span class="token number">64</span> bytes from tomcat02 <span class="token punctuation">(</span><span class="token number">172.18</span>.0.3<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.059</span> ms<span class="token comment"># 可用发现 通过--link 便可以在容器之间 通过服务名联通(不用指定ip)</span><span class="token comment"># 但是反向却无法ping通</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat02 <span class="token function">ping</span> tomcat03<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里 –link 是将tomcat03对tomcat02的连接添加到了配置项中，所以可用tomcat03可用访问到tomcat02。使用inspect命令查看docker的元数据可以看到如下配置</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect tomcat03<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/12/25/cs-dev-ops/docker-notes/0023.png" class="" title="输出"><blockquote><p>也可以通过查看hosts配置</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat03 <span class="token function">cat</span> /etc/hosts<span class="token comment"># 可以理解为在host文件中添加了域名映射</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2021/12/25/cs-dev-ops/docker-notes/0024.png" class="" title="输出"><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker network <span class="token function">ls</span> <span class="token comment"># 查看所有网络</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/12/25/cs-dev-ops/docker-notes/0025.png" class="" title="输出"><h4 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h4><ul><li>bridge：桥接模式 （docker 默认）</li><li>none：不配置网络</li><li>host：与宿主机共享模式</li><li>container：容器网络连通（局限较大）</li></ul><h4 id="自定义网络-1"><a href="#自定义网络-1" class="headerlink" title="自定义网络"></a>自定义网络</h4><blockquote><p>可以修复docker0中，在不适用–link是，不支持直接使用容器名进行连接</p></blockquote><p><strong>自定义网络选择使用bridge模式</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 直接启动的容器，有一个默认参数为： --net bridge，这里使用的就是docker0</span><span class="token comment"># docker run -d -P --name tomcat01 --net bridge tomcat</span><span class="token comment"># 自定义一个网络</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker network create --driver bridge --subnet <span class="token number">192.168</span>.0.0/16 --gateway <span class="token number">192.168</span>.0.1 mynet<span class="token comment">## --driver 连接模式</span><span class="token comment">## --subnet 子网掩码</span><span class="token comment">## --gateway 路由ip</span><span class="token comment"># 故可以在启动的时候指定使用该自定义的网络</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat-net-01 --net mynet tomcat<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat-net-02 --net mynet tomcat<span class="token comment"># 查看此时自定义网络的元数据</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker network inspect mynet <span class="token comment"># 图片0026中可以看到容器的网络</span><span class="token comment"># 此时使用自定义的网络直接通过容器名进行ping</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat-net-01 <span class="token function">ping</span> tomcat-net-02<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/12/25/cs-dev-ops/docker-notes/0026.png" class="" title="输出"><h4 id="将不同网络连接"><a href="#将不同网络连接" class="headerlink" title="将不同网络连接"></a>将不同网络连接</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 将网络docker0下的tomcat01连接到 mynet网络下（达成一个容器两个ip）</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker network connect mynet tomcat01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2021/12/25/cs-dev-ops/docker-notes/0027.png" class="" title="示意图"><h4 id="demo-redis集群"><a href="#demo-redis集群" class="headerlink" title="demo-redis集群"></a>demo-redis集群</h4><blockquote><p>分片 集群 高可用</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 创建网卡</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker network create redis --subnet <span class="token number">172.38</span>.0.0/16<span class="token comment"># 通过脚本创建六个redis配置</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token keyword">for</span> <span class="token for-or-select variable">port</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> <span class="token number">1</span> <span class="token number">6</span><span class="token variable">)</span></span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token keyword">do</span> <span class="token punctuation">\</span><span class="token function">mkdir</span> -p /data/qing/redis/node-<span class="token variable">${port}</span>/conf<span class="token function">touch</span> /data/qing/redis/node-<span class="token variable">${port}</span>/conf/redis.conf<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span>/data/qing/redis/node-<span class="token variable">${port}</span>/conf/redis.conf</span>port 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1<span class="token variable">${port}</span>cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOF</span><span class="token keyword">done</span><span class="token comment"># 启动六个容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token keyword">for</span> <span class="token for-or-select variable">port</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> <span class="token number">1</span> <span class="token number">6</span><span class="token variable">)</span></span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token keyword">do</span> <span class="token punctuation">\</span>docker run -p <span class="token number">637</span><span class="token variable">${port}</span>:6379 -p <span class="token number">1637</span><span class="token variable">${port}</span>:16379 --name redis-<span class="token variable">${port}</span> <span class="token punctuation">\</span>-v /data/qing/redis/node-<span class="token variable">${port}</span>/data:/data <span class="token punctuation">\</span>-v /data/qing/redis/node-<span class="token variable">${port}</span>/conf/redis.conf:/etc/redis/redis.conf <span class="token punctuation">\</span>-d --net redis --ip <span class="token number">172.38</span>.0.1<span class="token variable">${port}</span> redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token keyword">done</span><span class="token comment"># 进入容器创建集群</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it redis-1 /bin/sh<span class="token comment"># 创建集群</span>/data $ redis-cli --cluster create <span class="token number">172.38</span>.0.11:6379 <span class="token number">172.38</span>.0.12:6379 <span class="token number">172.38</span>.0.13:6379 <span class="token number">172.38</span>.0.14:6379 <span class="token number">172.38</span>.0.15:6379 <span class="token number">172.38</span>.0.16:6379 --cluster-replicas <span class="token number">1</span><span class="token comment">#### 以下为输出 部分省略####</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Performing <span class="token builtin class-name">hash</span> slots allocation on <span class="token number">6</span> nodes<span class="token punctuation">..</span>.Master<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> -<span class="token operator">&gt;</span> Slots <span class="token number">0</span> - <span class="token number">5460</span>Master<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> -<span class="token operator">&gt;</span> Slots <span class="token number">5461</span> - <span class="token number">10922</span>Master<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> -<span class="token operator">&gt;</span> Slots <span class="token number">10923</span> - <span class="token number">16383</span>Adding replica <span class="token number">172.38</span>.0.15:6379 to <span class="token number">172.38</span>.0.11:6379<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All nodes agree about slots configuration.<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Check <span class="token keyword">for</span> <span class="token function">open</span> slots<span class="token punctuation">..</span>.<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Check slots coverage<span class="token punctuation">..</span>.<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All <span class="token number">16384</span> slots covered.<span class="token comment">#### 以上为输出 ####</span><span class="token comment"># 测试</span>/data $ redis-cli -c<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> cluster info<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> cluster nodes<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> a b-<span class="token operator">&gt;</span> Redirected to slot <span class="token punctuation">[</span><span class="token number">15495</span><span class="token punctuation">]</span> located at <span class="token number">172.38</span>.0.13:6379OK <span class="token comment"># 可以看出保存到了3号节点</span><span class="token comment"># 关闭一个容器 测试 172.38.0.13:6379 这里是 13 所以停掉3号</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stop redis-3<span class="token comment"># 在容器内获取刚刚存入的值</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get a-<span class="token operator">&gt;</span> Redirected to slot <span class="token punctuation">[</span><span class="token number">15495</span><span class="token punctuation">]</span> located at <span class="token number">172.38</span>.0.14:6379<span class="token string">"b"</span> <span class="token comment"># 可以看到这里从4号机器中获取</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="IDEA整合Docker"><a href="#IDEA整合Docker" class="headerlink" title="IDEA整合Docker"></a>IDEA整合Docker</h2><ol><li><p>安装插件</p><blockquote><p>为了文件高亮，以及可以直接连接仓库</p></blockquote><img src="/2021/12/25/cs-dev-ops/docker-notes/0028.png" class="" title="示意图"><img src="/2021/12/25/cs-dev-ops/docker-notes/0029.png" class="" title="示意图"></li><li><p>通过package进行打包</p><blockquote><p>通过使用maven 的打包功能进行打包</p></blockquote></li><li><p>编写Dockerfile文件</p><blockquote><p>其他功能暂未研究</p></blockquote><img src="/2021/12/25/cs-dev-ops/docker-notes/0030.png" class="" title="示意图"></li><li><p>通过Dockerfile构建镜像与发布</p></li></ol><hr><p><strong>完</strong></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?from=search&amp;seid=8833819761241839370">狂神说Docker</a> ：<a href="https://www.bilibili.com/video/BV1og4y1q7M4?share_source=copy_web">https://www.bilibili.com/video/BV1og4y1q7M4?share_source=copy_web</a></p>]]></content>
      
      
      <categories>
          
          <category> cs-dev-ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> docker </tag>
            
            <tag> command </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令详解</title>
      <link href="/2021/12/18/cs-frameworks-tools/git-note/"/>
      <url>/2021/12/18/cs-frameworks-tools/git-note/</url>
      
        <content type="html"><![CDATA[<h1 id="Git命令详解"><a href="#Git命令详解" class="headerlink" title="Git命令详解"></a>Git命令详解</h1><h2 id="命令思维导图"><a href="#命令思维导图" class="headerlink" title="命令思维导图"></a>命令思维导图</h2><blockquote><p>鹅厂程序猿常用的 Git 命令思维导图</p></blockquote><img src="/2021/12/18/cs-frameworks-tools/git-note/git-notes-0000.svg" class="" title="脑图"><h2 id="使用笔记"><a href="#使用笔记" class="headerlink" title="使用笔记"></a>使用笔记</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="版本控制的方式"><a href="#版本控制的方式" class="headerlink" title="版本控制的方式"></a>版本控制的方式</h4><ul><li>集中式版本控制工具<ul><li>集中式版本控制工具，版本库是集中存放在中央服务器的，<code>team</code>里每个人<code>work</code>时从中央服务器下载代 码，是必须联网才能工作，局域网或互联网。个人修改后然后提交到中央版本库。</li><li><code>e.g.</code> <code>SVN</code>和<code>CVS</code></li></ul></li><li>分布式版本控制工具<ul><li>分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样工作的时候，无 需要联网了，因为版本库就在你自己的电脑上。多人协作只需要各自的修改推送给对方，就能互相看到对方的 修改了。</li><li><code>e.g.</code> <code>Git</code></li></ul></li></ul><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><p><code>Git</code> 是分布式的，不需要有中心服务器，每台电脑拥有的东西都是一样的。我们使用<code>Git</code>并且有个 中心服务器，仅仅是为了方便交换不同开发人员之间的修改，但是这个服务器的地位和我们每个人的<code>PC</code>是一样的。可以把它当做一个开发者的<code>PC</code>，但是为了大家代码容易交流，并不会关闭。没有它大家一样可以工作，只不 过“<strong>交换</strong>”修改不方便。</p><p><code>Git</code> 是一种版本控制系统，用于跟踪软件代码的变化，并协调多个开发人员的工作。由<code>Linus Torvalds</code>于2005年创建，用于开发<code>Linux</code>内核，但现在已经被广泛采用在其他软件项目中使用。</p><p><code>Git</code>允许开发人员创建代码分支，对这些分支进行更改，并将更改合并回来。这使得多个开发人员可以在同一个代码库上工作而不会干扰彼此的工作。<code>Git</code>还使开发人员能够跟踪代码库的更改历史，并在必要时还原到以前的版本。</p><p><code>Git</code>是一种分布式版本控制系统，这意味着每个开发人员在本地机器上都有代码库的完整副本。这使得开发人员可以离线工作并仍然对代码库进行更改。<code>Git</code>还支持远程存储库，可以托管在像<code>GitHub</code>、<code>GitLab</code>或<code>Bitbucket</code>这样的服务上，并允许多个开发人员从不同地点协同工作在同一个代码库上。</p><img src="/2021/12/18/cs-frameworks-tools/git-note/image-003.png" class="" title="image-003"><h4 id="Git工作流程图"><a href="#Git工作流程图" class="headerlink" title="Git工作流程图"></a>Git工作流程图</h4><img src="/2021/12/18/cs-frameworks-tools/git-note/image-004.png" class="" title="image-004"><ol><li><code>clone</code><ul><li>克隆</li><li>从远程仓库中克隆代码到本地仓库</li></ul></li><li><code>checkout</code><ul><li>检出</li><li>从本地仓库中提交一个仓库分支然后进行修订</li></ul></li><li><code>add</code><ul><li>添加</li><li>再提交前先将代码提交到暂存区</li></ul></li><li><code>commit</code><ul><li>提交</li><li>提交到本地仓库，本地仓库中保存修改的各个历史版本</li></ul></li><li><code>fetch</code><ul><li>抓取</li><li>从远程仓库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少</li></ul></li><li><code>pull</code><ul><li>拉取</li><li>从远程仓库拉到本地仓库，自动进行合并（<code>merge</code>），然后放到工作区，相当于 <code>fetch</code> + <code>merge</code></li></ul></li><li><code>push</code><ul><li>推送</li><li>修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库</li></ul></li></ol><h3 id="Git安装与常用命令"><a href="#Git安装与常用命令" class="headerlink" title="Git安装与常用命令"></a>Git安装与常用命令</h3><h4 id="Git环境配置"><a href="#Git环境配置" class="headerlink" title="Git环境配置"></a>Git环境配置</h4><h5 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h5><p><a href="https://git-scm.com/download" title="点击跳转">Git 下载地址</a> <a href="https://git-scm.com/download">https://git-scm.com/download</a></p><img src="/2021/12/18/cs-frameworks-tools/git-note/image-005.png" class="" title="image-005"><p>根据需要，点击到合适的系统版本，以Linux为例，点击进去后有详细的安装命令与教程，这里不做过多介绍</p><img src="/2021/12/18/cs-frameworks-tools/git-note/image-006.png" class="" title="image-006"><img src="/2021/12/18/cs-frameworks-tools/git-note/image-007.png" class="" title="image-007"><h5 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h5><p>进入系统终端（<code>windows</code>可以使用<code>CMD</code>，或者安装<code>Git</code>后自带的 <code>Git Bash</code>）</p><p>这里设置的是全局配置，可以配置，当然也可以不做配置（通常可以在项目中使用仓库级别的配置）。</p><p>Git中不同配置级别的区别，见下文的 <a href="##Git%E9%85%8D%E7%BD%AE%E7%BA%A7%E5%88%AB%E8%AF%B4%E6%98%8E">Git配置级别说明</a></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 设置全局级别的用户名[git]$ git config --global user.name "git"# 设计全局级别的用户邮箱 [git]$ git config --global user.email "git@email.cn"# 查看刚刚的配置信息[git]$ git config --global user.name[git]$ git config --global user.email<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="解决GitBash乱码问题"><a href="#解决GitBash乱码问题" class="headerlink" title="解决GitBash乱码问题"></a>解决GitBash乱码问题</h5><ol><li><p>打开 Git Bash 执行下面的命令</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[git]$ git config --global core.quotepath false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>${GIT_HOME/etc/bash.bashrc 文件最后加入下面两行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span><span class="token string">"zh_CN.UTF-8"</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">LC_ALL</span></span><span class="token operator">=</span><span class="token string">"zh_CN.UTF-8"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h5 id="获取本地仓库"><a href="#获取本地仓库" class="headerlink" title="获取本地仓库"></a>获取本地仓库</h5><p>要使用Git对我们的文件进行版本控制，首先需要获取一个本地仓库。</p><ol><li><p>在所需要的位置创建一个空目录</p></li><li><p>打开一个中断，进入该目录</p></li><li><p>执行命令 <code>git init</code>，初始化一个仓库</p><img src="/2021/12/18/cs-frameworks-tools/git-note/image-008.png" class="" title="image-008"><img src="/2021/12/18/cs-frameworks-tools/git-note/image-009.png" class="" title="image-20230514202933082"></li><li><p>创建成功后，可以在该文件夹下看到一个名为 <code>.git</code> 的隐藏目录。</p></li></ol><h4 id="基础操作指令"><a href="#基础操作指令" class="headerlink" title="基础操作指令"></a>基础操作指令</h4><p>Git 工作目录下对于文件的增加、删除、更新会存在几个状态，这些修改的状态会随着执行Git的命令而变化，具体状态转换如下图所示</p><img src="/2021/12/18/cs-frameworks-tools/git-note/image-010.png" class="" title="image-010"><p>下面主要是说明用命令控制这些状态之间的转换</p><ul><li><code>git add</code><ul><li>工作区 -&gt; 暂存区</li></ul></li><li><code>git commit</code> <ul><li>暂存区 -&gt; 本地仓库</li></ul></li></ul><h5 id="查看修改的状态"><a href="#查看修改的状态" class="headerlink" title="查看修改的状态"></a>查看修改的状态</h5><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 查看修改的状态（暂存区、工作区）[git]$ git status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="添加工作区到暂存区"><a href="#添加工作区到暂存区" class="headerlink" title="添加工作区到暂存区"></a>添加工作区到暂存区</h5><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 添加工作区一个或多个文件的修改到暂存区, git add 单个文件|通配符[git]$ git add a.txt[git]$ git add a.*[git]$ git add . # 添加所有修改到暂存区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="提交暂存区到本地仓库"><a href="#提交暂存区到本地仓库" class="headerlink" title="提交暂存区到本地仓库"></a>提交暂存区到本地仓库</h5><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[git]$ git commit -m ’注释信息‘<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h5><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 查看提交记录[git]$ git log [option]# --all 显示所有分支# --pretty=oneline 将提交信息显示为一行# --abbrev-commit 使食醋胡的commit id 更简短# --graph 以图的形式显示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h5><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 切换版本[git]$ git reset --hard &lt;commitId&gt;# commitId 可以使用 git log 或 git log --pretty=oneline --all --graph --abbrev-commit 查看[git]$ git reflog# 看到已经删除的提交记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="添加文件至忽略列表"><a href="#添加文件至忽略列表" class="headerlink" title="添加文件至忽略列表"></a>添加文件至忽略列表</h5><p>通常，会有一些文件不需要纳入<code>Git</code>管理，也不希望总出现在未跟踪文件列表。比如日志文件，临时测试脚本等。这种情况下，可以在工作目录中创建一个名为<code>.gitignore</code>的文件(必须是这个名字)，列出要忽略的文件模式，示例如下</p><pre class="line-numbers language-.gitignore" data-language=".gitignore"><code class="language-.gitignore"># 忽略以 .log 为结尾的文件*.log# 强制跟踪文件 a.log 即使在上面被忽略了!a.log# 只忽略当前目录中的 TODO 文件，而不是 TODO 目录。/TODO# 忽略 build 目录中的所有文件build/# 忽略 doc/ 目录下 所有以 .txt 为结尾的文件，但是不包含其子目录中以 .txt 为结尾的文件doc/*.txt# 忽略 doc/ 目录下 所有以 .pdf 为结尾的文件，包括其子目录中以 .pdf 为几位的文件doc/**/*.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p><code>Git</code> 使用分支来管理不同的开发流程和功能。分支是指向某个提交的指针，通常称为“分支头”。每个分支都拥有自己的提交历史记录，它们可以同时存在于同一个 <code>Git</code> 存储库中，而不会相互干扰。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 查看本地分支[git]$ git branch# 列出所有本地分支。在分支名后添加 # -r 参数可以查看远程分支# -a 参数可以查看所有分支（即本地和远程）# -m &lt;old-branch-name&gt; &lt;new-branch-name&gt;  重命名指定的分支# 创建本地分支[git]$ git branch &lt;分支名&gt;# 切换分支[git]$ git checkout &lt;分支名&gt;# 还可以直接切换到一个不存在的分支[git]$ git checkout -b 分支名# 合并分支[git]$ git merge &lt;分支名称&gt;# 一个分支上的提交可以合并到另一个分支# 删除分支[git]$ git branch -d &lt;b1&gt; # 删除分支时，需要做各种检查[git]$ git branch -D &lt;b1&gt; # 不做任何检查，强制删除# 不能删除当前分支，只能删除其他分支# 当前分支的提交移到指定分支之后[git]$ git rebase &lt;分支名称&gt;# 这通常用于将当前分支的提交插入到指定分支的提交历史记录中# 将指定的提交应用到当前分支[git]$ git cherry-pick &lt;commitId&gt;# 这通常用于将其他分支上的更改应用到当前分支中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h5><p>当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决冲突步骤如下：</p><ol><li>处理文件中冲突的地方</li><li>将解决完冲突的文件加入暂存区（<code>add</code>）</li><li>提交到仓库（<code>commit</code>）</li></ol><p>解决冲突的示例如下：</p><img src="/2021/12/18/cs-frameworks-tools/git-note/image-011.png" class="" title="image-011"><p><code>commit</code>时需要修改的提交信息详情</p><img src="/2021/12/18/cs-frameworks-tools/git-note/image-012.png" class="" title="image-012"><h5 id="开发中分支使用原则与流程推荐"><a href="#开发中分支使用原则与流程推荐" class="headerlink" title="开发中分支使用原则与流程推荐"></a>开发中分支使用原则与流程推荐</h5><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支可以把你的工作从开发主线上分离开来，在其他分支进行重大的<code>Bug</code>修改、开发新的功能，以免影响开发主线。</p><p>一般推荐如下，当然最重要的还是要根据自己的项目需求设计：</p><ul><li><code>master</code><ul><li>主分支，及是生产分支。</li></ul></li><li><code>dev</code><ul><li>开发分支</li></ul></li><li><code>feature</code><ul><li>未来功能分支</li></ul></li><li><code>test</code><ul><li>测试分支</li></ul></li><li>当然还有其他根据需求创建的分支</li></ul><h3 id="Git远程仓库"><a href="#Git远程仓库" class="headerlink" title="Git远程仓库"></a>Git远程仓库</h3><h4 id="常用的托管服务"><a href="#常用的托管服务" class="headerlink" title="常用的托管服务"></a>常用的托管服务</h4><p>Git中存在两种的仓库，即本地仓库和远程仓库。而远程仓库通常是使用网上的代码托管服务，比较常用的是 <code>GitHUb</code>、<code>Gitee</code>、码云、<code>GitLab</code>、<code>Gitee</code>等。</p><p><a href="https://github.com/" title="点击跳转">Github</a>是一个面向开源以及私有软件项目的托管平台，地址为：<a href="https://github.com/">https://github.com/</a></p><p><a href="https://about.gitlab.com/" title="点击跳转">GitLab</a>是一个用于仓库管理的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务，一般用于在企业、学校内部网络搭建<code>Git</code>私服。地址为：<a href="https://about.gitlab.com/">https://about.gitlab.com/</a></p><p><a href="https://gitea.io/en-us/" title="点击跳转">Gitea</a>与<code>GitLab</code>类似，也是一个适用于搭建<code>Git</code>私服，不过更加的小型，地址为：<a href="https://gitea.io/en-us/">https://gitea.io/en-us/</a></p><h4 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h4><p>不同软件有不同的注册方式，但是基本大同小异，这里就不做介绍了</p><h4 id="配置SSH密钥"><a href="#配置SSH密钥" class="headerlink" title="配置SSH密钥"></a>配置SSH密钥</h4><p>查看本完整后续的章节 <a href="##SSH%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE">SSH连接配置</a></p><h4 id="操作远程仓库"><a href="#操作远程仓库" class="headerlink" title="操作远程仓库"></a>操作远程仓库</h4><h5 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h5><p>以先初始化本地仓库，然后与已创建的远程库进行对接</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[git]$ git remote add &lt;远端名称&gt; &lt;仓库路径&gt;# e.g. git remote add origin git@gitea.com:robert.sunq/test_git.git# 远端名称默认是 origin 取决于远端服务器设置# 仓库路径从远端服务器获取此URL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h5><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 查看远程仓库[git]$ git remote<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h5><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[git]$ git push [-f] [--set-upstream] [远端名称 [本地分支名][:远端分支名]]# 如果远程分支名和本地分支名相同，则可以只写本地分支名 git push origin master# -f 表示强制覆盖# --set-upstream推送到远端的同时并且撞见起和远端分支的关联关系## git push --set-upstream origin master# 如果当前分支已经和远端分支关联，则可以省略分支名和远端名## git push <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/12/18/cs-frameworks-tools/git-note/image-013.png" class="" title="image-013"><h5 id="本地分支与远程分支的关联关系"><a href="#本地分支与远程分支的关联关系" class="headerlink" title="本地分支与远程分支的关联关系"></a>本地分支与远程分支的关联关系</h5><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 列出所有本地分支及其对应的远程跟踪分支，并显示它们之间的关联关系。[git]$ git branch -vv#-v选项表示“详细模式”.它会显示每个本地分支的最后一次提交信息和与其关联的远程跟踪分支。如果分支没有关联的远程跟踪分支，则该信息为空。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2021/12/18/cs-frameworks-tools/git-note/image-014.png" class="" title="image-014"><h5 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h5><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 如果已经有一个远端仓库，可以直接clone到本地[git]$ git clone &lt;仓库路径&gt; [本地目录]# 本地目录 不添加的时候会在当前的目录下，自动生成一个项目名的目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2021/12/18/cs-frameworks-tools/git-note/image-015.png" class="" title="image-015"><h5 id="从远程仓库中抓取和拉取"><a href="#从远程仓库中抓取和拉取" class="headerlink" title="从远程仓库中抓取和拉取"></a>从远程仓库中抓取和拉取</h5><p>远程分支和本地的分支一样，可以进行merge操作，只是需要先把远端仓库里的更新都下载到本地，在进程操作</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 将仓库里的更新都抓取到本地，不会进行合并[root]$ git fetch [remote name] [branch name]# 如果不指定远端名称和分支名，则抓取所有分支# 将远端仓库的修改拉到本地并自动机械能合并，等同于 fetch + merge[git]$ git pull [remote name] [branch name]# 如果不指定远端名称和分支名，则抓取所有并更新当前分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h5><p>远程分支也是分支，所以合并时冲突的解决方式也和解决本地分支冲突相同。</p><h3 id="几条铁令"><a href="#几条铁令" class="headerlink" title="几条铁令"></a>几条铁令</h3><ul><li><strong>切换分支前先提交本地的修改</strong></li><li>代码即使提交，提交过了就不会丢</li></ul><h2 id="Git配置级别说明"><a href="#Git配置级别说明" class="headerlink" title="Git配置级别说明"></a>Git配置级别说明</h2><p><code>git</code>的配置级别主要分为三类</p><blockquote><ol><li>仓库级别 <code>local</code> [优先级最高]<ol><li><code>git</code> 仓库级别对应的配置文件是当前仓库下的<code>.git/config</code>，默认是隐藏的 </li><li><strong><code>git config --local -l</code></strong>  or <strong><code>git config --local --list</code></strong>  [查看仓库级别的配置] </li><li><code>git config --local -e</code> 编辑仓库级别配置文件</li></ol></li><li>用户级别 <code>global</code>[优先级次之]<ol><li><code>git</code> 用户级别对应的配置文件是用户宿主目录下的<code>~/.gitconfig</code>（<code>C:\Users\XXX\.gitconfig</code>）</li><li>**<code>git config --global -l</code>**or <strong><code>git config --global --list</code></strong>  [查看用户级别的配置]</li><li><code>git config --global -e</code> 编辑用户级别配置文件</li></ol></li><li>系统级别 <code>system</code>[优先级最低]<ol><li><code>git</code>系统级别对应的配置文件是git安装目录下的<code> /etc/gitconfig</code>（<code>[install-path]\mingw64\etc\gitconfig</code>）</li><li><strong><code>git config --system -l</code></strong> or <strong><code>git config --system --list</code></strong> [查看系统级别的配置</li><li><code>git config --system -e</code> 编辑系统级别配置文件</li></ol></li><li>查看全部<ol><li><strong><code>git config -l</code></strong> or <strong><code>git config --list</code></strong> </li><li>其中的分类为<ul><li><code>core.XXX</code>为仓库级配置</li><li><code>user.XXX</code>    为用户级配置</li><li><code>http.XXX</code>    为系统级配置</li></ul></li></ol></li></ol></blockquote><blockquote><p>添加邮箱和用户名</p><ul><li><code>git config --global user.email “XXX@xxx.com” </code>    # 用户级</li><li><code>git config --global user.name “XXX” </code>                # 用户级</li></ul></blockquote><h2 id="SSH连接配置"><a href="#SSH连接配置" class="headerlink" title="SSH连接配置"></a>SSH连接配置</h2><ol><li>首先确保用户名与账号的配置完成</li><li>生成密钥对</li></ol><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ ssh-keygen -t rsa -C "xxx@xxx.com" # 生成秘钥, 如果不指定目录可以使用默认的路径，当然生成之后可以随意移动到其他目录，密钥不和目录有强关联关系# 之后会又两个输入选项：# 1、第一个是指定生成的密钥文件名(将会放在用户文件目录下)，如果不指定，则使用默认的文件名称# id_rsa.pub  公钥id_rsa  私钥# 2、第二个是指定验证密码，不输入则默认为空。设置密码后，每次使用git时都需要输入在此设置的密码# 也可也添加 -f 参数直接指定路径和文件名，如下# ssh-keygen -t rsa -C xxx@xxx.com -f ~/.ssh/id_rsa_gitlab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/12/18/cs-frameworks-tools/git-note/git-notes-0001.png" class="" title="生成密钥"><ol start="3"><li><p>进入到用户宿主目录下，获取公钥 <code>cat ~/.ssh/id_rsa.pub</code>(也可以直接访问id_rsa.pub文件查看)</p></li><li><p>进入<code>github</code>或者其他版本管理系统，添加此处获得的公钥</p></li><li><p>测试访问 <code>ssh -T git@github.com</code> </p><p>​返回如下提示则配置成功 <code>Hi xxxx! You've successfully authenticated, but GitHub does not provide shell access.</code></p><p>​<img src="/2021/12/18/cs-frameworks-tools/git-note/git-notes-0002.png" class="" title="测试连接效果"></p></li><li><p>修改<code>git</code>的<code>remote url</code></p></li></ol><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 查看当前的 remote url$ git remote -vorigin https://github.com/XXX/XXXproject.git (fetch) # 此结果说明 使用https协议进行访问origin https://github.com/XXX/XXXproject.git (push)#  复制SSH链接，进行调整$ git remote set-url origin git@github.com:XXX/XXXproject.git# 之后可再次使用查看 remote url 会发现已经被修改$ git remote -vorigin  git@github.com:XXX/XXXproject.git (fetch)  # git开头则表示是git协议origin  git@github.com:XXX/XXXproject.git (push)# 也可也直接打开配置文件编辑$ git config --local -e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多仓库源多密钥设置"><a href="#多仓库源多密钥设置" class="headerlink" title="多仓库源多密钥设置"></a>多仓库源多密钥设置</h2><p>通过在配置项中指定服务器与对应的密钥对，来达到在同一个机器上对不同的<code>git</code>仓库使用不同的密钥对进行匹配。</p><h3 id="生成Github的密钥认证"><a href="#生成Github的密钥认证" class="headerlink" title="生成Github的密钥认证"></a>生成Github的密钥认证</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ ssh-keygen -t rsa -C 'one@email.com'  -f  ~/.ssh/id_rsa_github# 之后按照上面的教程添加与仓库的认证<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="生成Gitlab的密钥认证"><a href="#生成Gitlab的密钥认证" class="headerlink" title="生成Gitlab的密钥认证"></a>生成Gitlab的密钥认证</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ ssh-keygen -t rsa -C 'two@email.com'  -f  ~/.ssh/id_rsa_gitlab# 之后按照上面的教程添加与仓库的认证<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="生成指定IP的仓库密钥认证"><a href="#生成指定IP的仓库密钥认证" class="headerlink" title="生成指定IP的仓库密钥认证"></a>生成指定IP的仓库密钥认证</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ ssh-keygen -t rsa -C 'three@email.com'# 之后按照上面的教程添加与仓库的认证<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 修改ssh的配置文件，</span>$ <span class="token function">vim</span> ~/.ssh/config<span class="token comment"># 在config文件中增加一下内容</span><span class="token comment"># 别名，可以随便填无所谓</span>Host github.com    <span class="token comment"># 连接的服务地址</span>HostName github.com<span class="token comment"># 用户名. 可以是邮箱，也可也是账号名</span>User one@email.com<span class="token comment"># 密钥文件的地址，私钥, e.g. ~/.ssh/github/id_rsa</span>IdentityFile <span class="token operator">&lt;</span>自定义的目录<span class="token operator">&gt;</span>/id_rsa_github<span class="token comment"># 只使用用户配置的身份验证密钥，避免使用系统中的其他密钥</span>IdentitiesOnly <span class="token function">yes</span><span class="token comment"># 指定了SSH连接时首选的身份验证方法为公钥验证</span>PreferredAuthentications publickey<span class="token comment"># 别名</span>Host gitlab.com    <span class="token comment"># 连接的服务地址</span>HostName github.com<span class="token comment"># 用户名. 可以是邮箱，也可也是账号名</span>User two@email.com<span class="token comment"># 密钥文件的地址，私钥, e.g. ~/.ssh/github/id_rsa</span>IdentityFile <span class="token operator">&lt;</span>自定义的目录<span class="token operator">&gt;</span>/id_rsa_gitlab<span class="token comment"># 只使用用户配置的身份验证密钥，避免使用系统中的其他密钥</span>IdentitiesOnly <span class="token function">yes</span><span class="token comment"># 指定了SSH连接时首选的身份验证方法为公钥验证</span>PreferredAuthentications publickey<span class="token comment"># 别名</span>Host <span class="token number">192.10</span>.1.123    <span class="token comment"># 连接的服务地址</span>HostName <span class="token number">192.10</span>.1.123<span class="token comment"># 用户名. 可以是邮箱，也可也是账号名</span>User three<span class="token comment"># 密钥文件的地址，私钥, e.g. ~/.ssh/github/id_rsa</span>IdentityFile <span class="token operator">&lt;</span>自定义的目录<span class="token operator">&gt;</span>/id_rsa<span class="token comment"># 只使用用户配置的身份验证密钥，避免使用系统中的其他密钥</span>IdentitiesOnly <span class="token function">yes</span><span class="token comment"># 指定了SSH连接时首选的身份验证方法为公钥验证</span>PreferredAuthentications publickey<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当然，每个不同的仓库之间可以设置相同的名称和邮箱，或者不同的名称和邮箱，然后设置仓库基本的配置来搭配不同的仓库，只要保证按照等级推延能拿到对应仓库中的账号和用户名即可。</p></blockquote><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ ssh -T git@github.com$ ssh -T git@gitlab.com$ ssh -T git@192.10.1.123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.processon.com/view/link/5c6e2755e4b03334b523ffc3#map">脑图来源</a>：<a href="https://www.processon.com/view/link/5c6e2755e4b03334b523ffc3#map">https://www.processon.com/view/link/5c6e2755e4b03334b523ffc3#map</a></p><p><a href="https://www.bilibili.com/video/BV1MU4y1Y7h5/?p=5&amp;spm_id_from=pageDriver&amp;vd_source=524a1f1a08bc3654682c93e61bb0b959" title="点击跳转">使用笔记参考来源</a>：<a href="https://www.bilibili.com/video/BV1MU4y1Y7h5/?p=5&amp;spm_id_from=pageDriver&amp;vd_source=524a1f1a08bc3654682c93e61bb0b959">https://www.bilibili.com/video/BV1MU4y1Y7h5/?p=5&amp;spm_id_from=pageDriver&amp;vd_source=524a1f1a08bc3654682c93e61bb0b959</a></p>]]></content>
      
      
      <categories>
          
          <category> cs-frameworks-tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 待续 </tag>
            
            <tag> tools </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> configuration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/12/12/hello-world/hello-world/"/>
      <url>/2021/12/12/hello-world/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hello-world </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello-world </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
