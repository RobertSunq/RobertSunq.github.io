<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>命令备忘录</title>
      <link href="/2021/12/30/note/command-note/"/>
      <url>/2021/12/30/note/command-note/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><hr><p>loading…</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><hr><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><p>loading…</p><h3 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h3><h4 id="转至管理员模式"><a href="#转至管理员模式" class="headerlink" title="转至管理员模式"></a>转至管理员模式</h4><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 在powershell中输入，会打开一个新的管理员模式的窗口</span><span class="token function">PS</span> G:\&gt; <span class="token function">Start-Process</span> powershell <span class="token operator">-</span>Verb runAs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MacOs"><a href="#MacOs" class="headerlink" title="MacOs"></a>MacOs</h2><hr><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>loading…</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> command </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程初版</title>
      <link href="/2021/12/25/devops/docker-notes/"/>
      <url>/2021/12/25/devops/docker-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>Docker概述</li><li>Docker安装</li><li>Docker命令<ul><li>镜像命令</li><li>容器命令</li><li>操作命令</li><li>….</li></ul></li><li>Docker镜像</li><li>容器数据卷</li><li>DockerFile</li><li>Docker网络原理</li><li>IDEA整合Docker</li></ul><ul><li>Docker Compose</li><li>Docker Swarm （简化版K8s）</li><li>CI/CD Jenkins</li></ul><h2 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h2><h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><p>开发、测试、预生产、生产环境搭建的成本和一致性问题。在进行集群拓展的时候，每个机器上都要进行环境的部署安装（Reids ES Hadoop……）等费时费力，而且还可能因为机器的不同而产生各种各样的不一致问题。</p><p>针对java开发来说，一般通过jar/war包来部署的，但是运行jar包所需要的其他环境依赖，比如：JDK、Tomcat、Mysql、Redis这些都需要在机器上事先的安装配置完成。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>可以通过发包的时候直接带上软件运行所需要的环境和对环境的配置进行打包 “jar+”（app + jdk + mysql + redis + es），这样可以保证 开发 → 打包 → 部署 → 上线 所具有的环境保持一致，同时也可以避免在对新机器进行部署的时候，还需要进行复杂的环境配置。</p><p>Docker 便是这么一个类似的过程：打包项目带上环境（镜像） → 发布（Docker仓库）→ 下载发布的镜像 → 直接运行（容器）。</p><h4 id="虚拟机技术"><a href="#虚拟机技术" class="headerlink" title="虚拟机技术"></a>虚拟机技术</h4><p>虚拟化技术。可以直接通过虚拟机镜像文件，直接虚拟出一个具有完整环境的虚拟电脑，在其上面在运行所需要的App。</p><p><strong>缺点：</strong></p><p>对物理服务器资源的消耗，在物理服务器创建一台虚拟机时，便需要虚拟出一套硬件并在上面运行完整的操作系统，每台虚拟机都占用许多的服务器资源。是在<strong>物理层面上的隔离</strong>，启动慢 占用内存大，分钟级启动。当需要启动多个虚拟机时需要花费很大的时间</p><p><strong>物理资源层面上的隔离</strong></p><p><img src="/2021/12/25/devops/docker-notes/0012.png" alt="0012"></p><h4 id="Docker容器化技术"><a href="#Docker容器化技术" class="headerlink" title="Docker容器化技术"></a>Docker容器化技术</h4><p>也是一种虚拟化技术。镜像：包含所需要的最基础环境（最核心的Linux环境4M + 其他环境），没有其他额外的文件，只集成需要的便可以做到很小巧，启动运行镜像也十分快速，秒级别启动。</p><p><strong>优点：</strong></p><ul><li><p>传统虚拟机，虚拟出硬件，运行一个完整的操作系统，然后再这个系统上安装和运行软件，Docker并不是选择去模拟一个完整的操作系统</p></li><li><p>容器内的应用直接运行在宿主机的内核，容器时没有自己的内核的，并不去虚拟硬件所以十分的轻便</p></li><li><p>每个容器是相互隔离，每个容器都有一套自己的文件系统，互相不影响</p></li><li><p>更快速的交付和部署</p><ul><li>打包镜像发布测试 一键运行</li></ul></li><li><p>更便捷的升级和扩缩容</p><ul><li>在不同的机器上直接运行相同的镜像来扩容</li></ul></li><li><p>更简单的系统运维</p><ul><li>开发测试生产环境高度一致</li></ul></li><li><p>更高效的计算机资源利用</p></li></ul><p><strong>缺点：</strong></p><p>由于是<strong>操作系统进程层面上的隔离</strong>不是绝对的物理隔离，所以在安全性上时低于虚拟机的。</p><p><strong>操作系统进程层面上的隔离</strong></p><p><img src="/2021/12/25/devops/docker-notes/0013.png" alt="0013"></p><h4 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h4><p>C/S模式：docker-client，docker-service</p><p><img src="/2021/12/25/devops/docker-notes/0000.png" alt="0000"></p><p>Docker daemon（守护进程）：Docker Client通过命令行与Docker Damon通信，完成Docker相关操作</p><p>Images（镜像）：类似于软件安装包</p><p>Containers（容器）：软件的运行</p><p><strong>镜像（image）：</strong></p><p>在docker中，镜像就类似于一个模板，可以通过这个模板来创建容器服务，同时也可以通过这个镜像去创建多个容器（最终服务运行或者项目运行就是在容器中）。</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TDA<span class="token text string">[tomcat镜像]</span> <span class="token arrow operator">--&gt;</span> B<span class="token text string">[run]</span>B <span class="token arrow operator">--&gt;</span> C<span class="token text string">[tomcat 1容器&lt;提供服务器&gt;]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>容器（container）：</strong></p><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建。</p><p>启动、停止、删除等基本命令！</p><p><strong>仓库（repository）：</strong></p><p>即存放镜像的地方，仓库分为私用仓库与公有仓库。但Docker Hub默认为国外服务器，所有可以通过配置为阿里云下镜像仓库来加速下载公用镜像。</p><h3 id="底层原理概述"><a href="#底层原理概述" class="headerlink" title="底层原理概述"></a>底层原理概述</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><ul><li>镜像<ul><li>将所有需要的内容放到不同的镜像（集装箱）中，需要哪些环境就直接拿哪个镜像（集装箱）就可以</li></ul></li><li>标准化<ul><li>镜像管理标准化，所有的镜像都放置于仓库中统一管理，当需要某些环境需要哪些镜像就使用docker去仓库中获取。</li><li>命令标准化，Docker提供了一系列的命令，来帮助我们对镜像进行一系列的操作</li></ul></li><li>隔离性<ul><li>运行镜像中的内容（容器）时，会在Linux的内核中单独开辟一片空间，这片空间不会影响到其他程序</li></ul></li></ul><h4 id="基本工作原理概述"><a href="#基本工作原理概述" class="headerlink" title="基本工作原理概述"></a>基本工作原理概述</h4><ol><li><p>Docker 是一个Client - Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！</p></li><li><p>DockerServer接收到Docker-Client的指令，就会执行这个命令！</p></li><li><p>容器内部的端口号是私有独立的，如果外部的想要访问，就需要通过linux服务器的端口号进行端口映射。</p></li></ol><p><img src="/2021/12/25/devops/docker-notes/0002.png" alt="0002"></p><p>Docker 为什么比VM快</p><ol><li><p>docker更少的抽象层</p></li><li><p>docker利用的是宿主机的内核，vm需要的是Guest OS</p></li></ol><p><img src="/2021/12/25/devops/docker-notes/0003.png" alt="0003"></p><p>所以新建一个容器的时候，docker 不需要像虚拟机一样重新加载操作系统内核，避免引导。虚拟机时加载Guest OS，分钟级别的，而docker时利用宿主机的操作系统，省略了这个复杂的过程，秒级。</p><p><img src="/2021/12/25/devops/docker-notes/0004.png" alt="0004"></p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><h4 id="环境查看"><a href="#环境查看" class="headerlink" title="环境查看"></a>环境查看</h4><p>已在centos7上进行安装为例</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看系统内核版本</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">uname</span> -r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看系统版本</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> /etc/os-release<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h4><p><a href="https://docs.docker.com/engine/install/" title="install">官方手册</a> <a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 1、卸载历史版本的docker</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ yum remove docker <span class="token punctuation">\</span>                  docker-client <span class="token punctuation">\</span>                  docker-client-latest <span class="token punctuation">\</span>                  docker-common <span class="token punctuation">\</span>                  docker-latest <span class="token punctuation">\</span>                  docker-latest-logrotate <span class="token punctuation">\</span>                  docker-logrotate <span class="token punctuation">\</span>                  docker-engine                  <span class="token comment"># 2、安装基础安装包</span><span class="token punctuation">[</span>root@centos7<span class="token punctuation">]</span>$ yum <span class="token function">install</span> -y yum-utils <span class="token comment"># 3、设置镜像仓库</span><span class="token comment"># yum-config-manager \</span><span class="token comment">#    --add-repo \</span><span class="token comment">#     https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外仓库</span>    <span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ yum-config-manager <span class="token punctuation">\</span>    --add-repo <span class="token punctuation">\</span>    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo <span class="token comment"># 阿里云的镜像地址</span>    <span class="token comment"># 4、更新yum</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ yum makecache fast<span class="token comment"># 5、安装 ce--社区，ee--企业  核心、客户端、容器</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ yum <span class="token function">install</span> docker-ce docker-ce-cli containerd.io<span class="token comment"># 指定版本 yum install docker-ce--&lt;VERSION_STRING&gt; docker-ce-cli--&lt;VERSION_STRING&gt; containerd.io</span><span class="token comment"># 查看其他版本</span><span class="token comment"># [root@centos7 ~]$ yum list docker-ce --showduplicates | sort -r</span><span class="token comment"># 6、启动</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ systemctl start docker<span class="token comment"># 7、验证docker是否启动成功</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ docker version<span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ docker run hello-world<span class="token comment"># 8、查看下载的镜像</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    d1165f221234   <span class="token number">4</span> months ago   <span class="token number">13</span>.3kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/12/25/devops/docker-notes/0001.png" alt="0001"></p><h4 id="快速卸载"><a href="#快速卸载" class="headerlink" title="快速卸载"></a>快速卸载</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 1、卸载依赖 </span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ yum remove docker-ce docker-ce-cli containerd.io<span class="token comment"># 2、删除资源</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> -rf /var/lib/docker<span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">rm</span> -rf /var/lib/containerd<span class="token comment"># /var/lib/docker docker的默认工作路径</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 以阿里云为列</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> -p /etc/docker <span class="token comment"># 创建文件</span><span class="token comment"># 编写配置文件 下面的地址需要换成阿里云中自己实例中创建的</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'{"registry-mirrors":["https://qiyb9988.mirror.aliyuncs.com"]}EOF</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ systemctl daemon-reload <span class="token comment"># 编译配置文件</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ systemctl restart docker <span class="token comment"># 重启docker</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><h4 id="基本帮助"><a href="#基本帮助" class="headerlink" title="基本帮助"></a>基本帮助</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ <span class="token comment">## 帮助文档 https://docs.docker.com/reference/</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ docker version <span class="token comment">#  显示docker版本信息</span><span class="token punctuation">[</span>root@centos7 ~<span class="token punctuation">]</span>$ docker info <span class="token comment"># 显示docker的系统信息，包括镜像和容器的数量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h4><p><a href="https://docs.docker.com/reference/" title="reference">官方命令说明</a>  <a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p><p><a href="https://hub.docker.com/" title="dockerHub">官方仓库</a>    <a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p><strong>查看与搜索镜像</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker images REPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    d1165f221234   <span class="token number">4</span> months ago   <span class="token number">13</span>.3kB<span class="token comment">#################################</span><span class="token comment"># REPOSITORY镜像的仓库源</span><span class="token comment"># TAG镜像的标签</span><span class="token comment"># IMAGE ID镜像的ID</span><span class="token comment"># CREATED镜像的创建时间</span><span class="token comment"># SIZE镜像的大小</span><span class="token comment"># 可选项</span><span class="token comment">#--all , -a查看所有镜像</span><span class="token comment">#--quiet , -q只显示镜像ID</span><span class="token comment">#################################</span><span class="token comment">########################################################################</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker search mysql  <span class="token comment"># 搜索镜像</span>NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDmysql                             MySQL is a widely used, open-source relation…   <span class="token number">11099</span>     <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       mariadb                           MariaDB Server is a high performing <span class="token function">open</span> sou…   <span class="token number">4209</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       <span class="token comment"># 可选项，通过搜索来过滤</span>--filter<span class="token operator">=</span>STARS<span class="token operator">=</span><span class="token number">3000</span> <span class="token comment"># 搜索出来的镜像是STARS大于3000的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>下载镜像</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker pull mysql  <span class="token comment"># 下载镜像</span>Using default tag: latest  <span class="token comment"># 不声明tag，默认时 latest</span>latest: Pulling from library/mysqlb4d181a07f80: Download complete  <span class="token comment"># 分层下载，docker image的核心 联合文件系统？</span>a462b60610f5: Download complete 578fafb77ab8: Download complete <span class="token number">524046006037</span>: Download complete d0cbe54c8855: Download complete aa18e05cc46d: Download complete 32ca814c833f: Download complete 9ecc8abdb7f5: Download complete ad042b682e0f: Download complete 71d327c6bb78: Download complete 165d1d10a3fa: Download complete 2f40c47d0626: Download complete Digest: sha256:52b8406e4c32b8cf0557f1b74517e14c5393aff5cf0384eff62d9e81f4985d4b <span class="token comment">#签名</span>Status: Downloaded newer image <span class="token keyword">for</span> mysql:latestdocker.io/library/mysql:latest<span class="token comment"># 真实地址</span><span class="token comment">######## 等价于</span><span class="token comment"># docker pull musql</span><span class="token comment"># docker pull docker.io/library/mysql:latest</span><span class="token comment">################################</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker pull mysql:5.7  <span class="token comment"># 指定版本</span><span class="token number">5.7</span>: Pulling from library/mysqlb4d181a07f80: Already exists <span class="token comment"># 共用分层文件，节省空间和下载速度，不用重复下载</span>a462b60610f5: Already exists 578fafb77ab8: Already exists <span class="token number">524046006037</span>: Already exists d0cbe54c8855: Already exists aa18e05cc46d: Already exists 32ca814c833f: Already exists 52645b4af634: Pull complete bca6a5b14385: Pull complete 309f36297c75: Pull complete 7d75cacde0f8: Pull complete Digest: sha256:1a2f9cd257e75cc80e9118b303d1648366bc2049101449bf2c8d82b022ea86b7Status: Downloaded newer image <span class="token keyword">for</span> mysql:5.7docker.io/library/mysql:5.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除镜像</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 删除镜像 rmi -&gt; remove image</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker rmi -f <span class="token punctuation">[</span>image id<span class="token punctuation">]</span>  <span class="token comment"># 删除指定镜像</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker rmi -f <span class="token variable"><span class="token variable">$(</span>docker images -aq<span class="token variable">)</span></span>  <span class="token comment"># 删除所有，${} 传递参数，查出所有的image id</span><span class="token comment"># [root@qing centos]$ docker rmi -f (mysql5.7) 会发现只删除了mysql5.7不同的文件，和mysql8公用的部分并没有删除 </span><span class="token comment"># 待确定？注意这里删除的是镜像，运行过的镜像创建的容器并没有被删除 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><blockquote><p>通过镜像来创建容器</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 以下载并启动 centos镜像为列子</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker pull centos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>新建容器并启动</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker run <span class="token punctuation">[</span>可选参数<span class="token punctuation">]</span> image<span class="token comment">###################################################</span><span class="token comment"># --name="name"容器名字 tomcat01 tomcat02，用来区分容器</span><span class="token comment"># -d后台方式运行 ja nohup</span><span class="token comment"># -it使用交互方式运行，进入容器查看内容</span><span class="token comment"># -t交互式操作</span><span class="token comment"># -i终端</span><span class="token comment"># -p指定容器的端口 -p 8080:8080</span><span class="token comment"># -p 主机端口：容器端口  (常用)</span><span class="token comment"># -p ip:主机端口:容器端口</span><span class="token comment"># -p 容器端口</span><span class="token comment"># 容器端口</span><span class="token comment"># -P随机指定端口</span><span class="token comment">###################################################</span><span class="token comment"># 启动并进入容器</span><span class="token punctuation">[</span>root@qing centos<span class="token punctuation">]</span>$ docker run -it centos /bin/bash<span class="token comment"># 放在镜像名后的是命令，打开一个交互式 Shell，因此用的是 /bin/bash。</span><span class="token punctuation">[</span>root@75dcc58b2b3d /<span class="token punctuation">]</span>$ <span class="token function">ls</span><span class="token comment"># 此时主机已经指向启动的容器，此时centos为基础版本。</span>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<span class="token punctuation">[</span>root@75dcc58b2b3d /<span class="token punctuation">]</span>$ <span class="token builtin class-name">exit</span><span class="token comment"># 从容器中退出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/12/25/devops/docker-notes/0014.png" alt="0014"></p><p><strong>查看所有运行的容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token comment"># 查看运行中的容器</span><span class="token comment">###################################################</span><span class="token comment">#列出当前正在运行的容器</span><span class="token comment"># -a列出当前正在运行的容器+历史运行过的容器</span><span class="token comment"># -n=?显示最近创建的容器个数</span><span class="token comment"># -q只显示容器的编号</span><span class="token comment">###################################################</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span> -a<span class="token comment"># 查看所有运行过的容器</span>CONTAINER ID   IMAGE         COMMAND       CREATED         STATUS                       PORTS     NAMES3c8ef01a7eb6   centos        <span class="token string">"/bin/bash"</span>   <span class="token number">6</span> minutes ago   Exited <span class="token punctuation">(</span><span class="token number">130</span><span class="token punctuation">)</span> <span class="token number">5</span> minutes ago             nice_austinceafc51e6972   hello-world   <span class="token string">"/hello"</span>      <span class="token number">2</span> days ago      Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">2</span> days ago                  focused_burnell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>退出容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># exit 停止当前容器并退出</span><span class="token comment"># Ctrl + P + Q 仅退出当前容器，不停止运行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>删除容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">rm</span> 容器id<span class="token comment"># 删除指定容器，不能删除正在运行的容器 rm -f 强制删除</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -aq<span class="token variable">)</span></span><span class="token comment"># 删除所有容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span> -a -q<span class="token operator">|</span><span class="token function">xargs</span> docker <span class="token function">rm</span><span class="token comment"># 删除所有的容器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>启动和停止容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker start 容器id<span class="token comment"># 启动容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker restart 容器id<span class="token comment"># 重启容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stop 容器id<span class="token comment"># 停止当前正在运行的容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">kill</span> 容器id<span class="token comment"># 强制停止容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker start 容器id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><strong>后台启动</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 命令 docker run -d 镜像名！</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d centos<span class="token comment"># 后台启动</span><span class="token comment"># 输入docker ps ， 发现centos停止了</span><span class="token comment"># 常见的坑：</span><span class="token comment"># docker容器使用后台运行，就必须要有一个前台的进程，docker发现没有应用，就会自动停止</span><span class="token comment"># nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就没有程序了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看日志</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker logs --help<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker logs-tf --tail <span class="token number">10</span> 容器id<span class="token comment"># -f 保留打印窗口，-t 添加时间戳 --tail 10 最后10行</span><span class="token comment"># 自定义shell脚本</span><span class="token comment"># "while true;do echo qing;sleep 1; done"</span><span class="token comment"># [root@qing /]$ docker run -d centos /bin/sh -c "while true;do echo qing;sleep 1;done"</span><span class="token comment"># -c 执行命令</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">top</span> 容器id<span class="token comment"># 查看容器内进程信息</span><span class="token environment constant">UID</span>                 PID                 <span class="token environment constant">PPID</span>                C                   STIME               TTY                 TIME                CMDroot                <span class="token number">32718</span>               <span class="token number">32697</span>               <span class="token number">33</span>                  <span class="token number">23</span>:07               ?                   00:00:23            /bin/sh -c <span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token builtin class-name">echo</span> qing<span class="token punctuation">;</span>sheep <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看容器元数据</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect 容器id<span class="token comment"># 查看容器信息</span><span class="token comment"># "Id" 比通过ps查询到的要长，ps中只是对其进行了部分截取</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><details>  <summary>      <mark>          <font color="green">详细输出</font>      </mark>    </summary>  <p>[root@qing /]$ docker inspect ${container id}</p>  <pre>  <code>  [    {        "Id": "2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4",        "Created": "2021-12-28T15:07:57.17357075Z",        "Path": "/bin/sh",        "Args": [            "-c",            "while true;do echo qing;sheep 1;done"        ],        "State": {            "Status": "running",            "Running": true,            "Paused": false,            "Restarting": false,            "OOMKilled": false,            "Dead": false,            "Pid": 32718,            "ExitCode": 0,            "Error": "",            "StartedAt": "2021-12-28T15:07:57.691697573Z",            "FinishedAt": "0001-01-01T00:00:00Z"        },        "Image": "sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6",        "ResolvConfPath": "/var/lib/docker/containers/2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4/resolv.conf",        "HostnamePath": "/var/lib/docker/containers/2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4/hostname",        "HostsPath": "/var/lib/docker/containers/2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4/hosts",        "LogPath": "/var/lib/docker/containers/2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4/2d2c8f54b427a6bfe6add93ab155be8879bbe54e0a7f5de66f5f3a79810ac0a4-json.log",        "Name": "/jovial_davinci",        "RestartCount": 0,        "Driver": "overlay2",        "Platform": "linux",        "MountLabel": "",        "ProcessLabel": "",        "AppArmorProfile": "",        "ExecIDs": null,        "HostConfig": {            "Binds": null,            "ContainerIDFile": "",            "LogConfig": {                "Type": "json-file",                "Config": {}            },            "NetworkMode": "default",            "PortBindings": {},            "RestartPolicy": {                "Name": "no",                "MaximumRetryCount": 0            },            "AutoRemove": false,            "VolumeDriver": "",            "VolumesFrom": null,            "CapAdd": null,            "CapDrop": null,            "CgroupnsMode": "host",            "Dns": [],            "DnsOptions": [],            "DnsSearch": [],            "ExtraHosts": null,            "GroupAdd": null,            "IpcMode": "private",            "Cgroup": "",            "Links": null,            "OomScoreAdj": 0,            "PidMode": "",            "Privileged": false,            "PublishAllPorts": false,            "ReadonlyRootfs": false,            "SecurityOpt": null,            "UTSMode": "",            "UsernsMode": "",            "ShmSize": 67108864,            "Runtime": "runc",            "ConsoleSize": [                0,                0            ],            "Isolation": "",            "CpuShares": 0,            "Memory": 0,            "NanoCpus": 0,            "CgroupParent": "",            "BlkioWeight": 0,            "BlkioWeightDevice": [],            "BlkioDeviceReadBps": null,            "BlkioDeviceWriteBps": null,            "BlkioDeviceReadIOps": null,            "BlkioDeviceWriteIOps": null,            "CpuPeriod": 0,            "CpuQuota": 0,            "CpuRealtimePeriod": 0,            "CpuRealtimeRuntime": 0,            "CpusetCpus": "",            "CpusetMems": "",            "Devices": [],            "DeviceCgroupRules": null,            "DeviceRequests": null,            "KernelMemory": 0,            "KernelMemoryTCP": 0,            "MemoryReservation": 0,            "MemorySwap": 0,            "MemorySwappiness": null,            "OomKillDisable": false,            "PidsLimit": null,            "Ulimits": null,            "CpuCount": 0,            "CpuPercent": 0,            "IOMaximumIOps": 0,            "IOMaximumBandwidth": 0,            "MaskedPaths": [                "/proc/asound",                "/proc/acpi",                "/proc/kcore",                "/proc/keys",                "/proc/latency_stats",                "/proc/timer_list",                "/proc/timer_stats",                "/proc/sched_debug",                "/proc/scsi",                "/sys/firmware"            ],            "ReadonlyPaths": [                "/proc/bus",                "/proc/fs",                "/proc/irq",                "/proc/sys",                "/proc/sysrq-trigger"            ]        },        "GraphDriver": {            "Data": {                "LowerDir": "/var/lib/docker/overlay2/5070e57b3b1ab1533ba4b1a8cb7de79e3655f6d78ba43c4640c2d25cedb00fa5-init/diff:/var/lib/docker/overlay2/0e6d8ab67489cffea7560a7fdc382658d599dc415839d4bf5f4d6c2b71dadf79/diff",                "MergedDir": "/var/lib/docker/overlay2/5070e57b3b1ab1533ba4b1a8cb7de79e3655f6d78ba43c4640c2d25cedb00fa5/merged",                "UpperDir": "/var/lib/docker/overlay2/5070e57b3b1ab1533ba4b1a8cb7de79e3655f6d78ba43c4640c2d25cedb00fa5/diff",                "WorkDir": "/var/lib/docker/overlay2/5070e57b3b1ab1533ba4b1a8cb7de79e3655f6d78ba43c4640c2d25cedb00fa5/work"            },            "Name": "overlay2"        },        "Mounts": [],        "Config": {            "Hostname": "2d2c8f54b427",            "Domainname": "",            "User": "",            "AttachStdin": false,            "AttachStdout": false,            "AttachStderr": false,            "Tty": false,            "OpenStdin": false,            "StdinOnce": false,            "Env": [                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"            ],            "Cmd": [                "/bin/sh",                "-c",                "while true;do echo qing;sheep 1;done"            ],            "Image": "centos",            "Volumes": null,            "WorkingDir": "",            "Entrypoint": null,            "OnBuild": null,            "Labels": {                "org.label-schema.build-date": "20210915",                "org.label-schema.license": "GPLv2",                "org.label-schema.name": "CentOS Base Image",                "org.label-schema.schema-version": "1.0",                "org.label-schema.vendor": "CentOS"            }        },        "NetworkSettings": {            "Bridge": "",            "SandboxID": "6ef9320864e6daa4195b284e3c60fb56edb95be77010eda7cff755ab315cffeb",            "HairpinMode": false,            "LinkLocalIPv6Address": "",            "LinkLocalIPv6PrefixLen": 0,            "Ports": {},            "SandboxKey": "/var/run/docker/netns/6ef9320864e6",            "SecondaryIPAddresses": null,            "SecondaryIPv6Addresses": null,            "EndpointID": "3d08880669d8a5f2ad913bef248471a0377eeeb7793f83450cd514d0b43e7a39",            "Gateway": "172.18.0.1",            "GlobalIPv6Address": "",            "GlobalIPv6PrefixLen": 0,            "IPAddress": "172.18.0.2",            "IPPrefixLen": 16,            "IPv6Gateway": "",            "MacAddress": "02:42:ac:12:00:02",            "Networks": {                "bridge": {                    "IPAMConfig": null,                    "Links": null,                    "Aliases": null,                    "NetworkID": "73abca2ea3673a8f7f4919d8141708a47bc0851025083aefa25a3bec6286704d",                    "EndpointID": "3d08880669d8a5f2ad913bef248471a0377eeeb7793f83450cd514d0b43e7a39",                    "Gateway": "172.18.0.1",                    "IPAddress": "172.18.0.2",                    "IPPrefixLen": 16,                    "IPv6Gateway": "",                    "GlobalIPv6Address": "",                    "GlobalIPv6PrefixLen": 0,                    "MacAddress": "02:42:ac:12:00:02",                    "DriverOpts": null                }            }        }    }]  </code>  </pre></details><p><strong>进入当前正在运行的容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 通常容器都是使用后台方式运行的，需要进入容器修改一些配置</span><span class="token comment"># -it  通过交互模式运行</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it 容器id /bin/bash  <span class="token comment"># 进入后台运行的容器，/bin/bash 位置开启一个新的终端，可以进行一些操作(常用)</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker attach 容器id<span class="token comment">#  进入正在执行的容器进入正在运行的中断，不会启动新的进程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>从容器内拷贝文件到宿主机</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">cp</span> 容器id:容器内路径目的主机路径<span class="token comment"># 容器内文件拷贝到主机</span><span class="token comment"># test 进入之前启动的centos容器内</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker attach <span class="token variable">${id}</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ls</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> /home<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">touch</span> test.java<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token builtin class-name">exit</span> <span class="token comment"># 注意 此处是退出了容器，容器停止运行，但是在没有被清理时容器的数据依旧存在</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span> -a<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">cp</span> <span class="token variable">${id}</span>:/home/test.java /home <span class="token comment"># 类似与socp命令</span><span class="token comment">## 拷贝时一个手动的过程，后期使用中可以通过 -v 卷的方式，实现自动同步，将容器中的目录与宿主机的进行同步</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其他</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker --help<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2021/12/25/devops/docker-notes/0005.png" alt="0005"></p><h4 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker attach      <span class="token comment"># Attach local standard input, output, and error streams to a running container</span><span class="token comment"># 当前shell下attach连接指定运行镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build<span class="token comment"># Build an image from a Dockerfile</span><span class="token comment"># 通过Dockerfile 定制镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker commit<span class="token comment"># Create a new image from a container's changes</span><span class="token comment"># 提交当前容器为新的镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">cp</span><span class="token comment"># Copy files/folders between a container and the local filesystem</span><span class="token comment"># 从容器中拷贝指定文件或目录到宿主机中</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker create<span class="token comment"># Create a new container</span><span class="token comment"># 创建一个新的容器，同run，但不启动容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">diff</span><span class="token comment"># Inspect changes to files or directories on a container's filesystem</span><span class="token comment"># 查看docker容器的变化</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker events<span class="token comment"># Get real time events from the server</span><span class="token comment"># 从docker服务获取容器实时事件</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span><span class="token comment"># Run a command in a running container</span><span class="token comment"># 在已存在的容器上运行命令</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">export</span><span class="token comment"># Export a container's filesystem as a tar archive</span><span class="token comment"># 到处容器的内容流作为一个tar归档文件，对应import</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">history</span><span class="token comment"># Show the history of an image</span><span class="token comment"># 查看一个镜像的历史</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker images<span class="token comment"># List images</span><span class="token comment"># 列出当前系统中所有的镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">import</span><span class="token comment"># Import the contents from a tarball to create a filesystem image</span><span class="token comment"># 从tar包中的内容创建一个新的文件系统，对应export</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker info<span class="token comment"># Display system-wide information</span><span class="token comment"># 显示系统相关信息</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect<span class="token comment"># Return low-level information on Docker objects</span><span class="token comment"># 查看容器详细信息</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">kill</span><span class="token comment"># Kill one or more running containers</span><span class="token comment"># kill指定docker容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker load<span class="token comment"># Load an image from a tar archive or STDIN</span><span class="token comment"># 从一个tar包中加载一个镜像，对应save</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker login<span class="token comment"># Log in to a Docker registry</span><span class="token comment"># 注册或者登录一个docker源服务器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">logout</span><span class="token comment"># Log out from a Docker registry</span><span class="token comment"># 从当前docker registry退出</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker logs<span class="token comment"># Fetch the logs of a container</span><span class="token comment"># 输出当前容器日志信息</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker pause<span class="token comment"># Pause all processes within one or more containers</span><span class="token comment"># 暂停容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker port<span class="token comment"># List port mappings or a specific mapping for the container</span><span class="token comment"># 查看映射端口对应容器内幕源端口</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token comment"># List containers</span><span class="token comment"># 列出容器列表</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker pull<span class="token comment"># Pull an image or a repository from a registry</span><span class="token comment"># 从docker镜像源服务器拉取指定镜像或者库镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker push<span class="token comment"># Push an image or a repository to a registry</span><span class="token comment"># 推送指定镜像或者库镜像到dicker源服务器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">rename</span><span class="token comment"># Rename a container</span><span class="token comment"># 对容器重命名</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker restart<span class="token comment"># Restart one or more containers</span><span class="token comment"># 重启运行的容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">rm</span><span class="token comment"># Remove one or more containers</span><span class="token comment"># 移除一个或者多个容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker rmi<span class="token comment"># Remove one or more images</span><span class="token comment"># 移除一个或者多个镜像，五容器使用该镜像才可删除，否则需要删除相关容器才可以或者强制删除</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run<span class="token comment"># Run a command in a new container</span><span class="token comment"># 创建一个新的容器并运行一个命令</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker save<span class="token comment"># Save one or more images to a tar archive (streamed to STDOUT by default)</span><span class="token comment"># 保存一个镜像为一个tar包，对应load</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker search<span class="token comment"># Search the Docker Hub for images</span><span class="token comment"># 在docker hub中搜索镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker start<span class="token comment"># Start one or more stopped containers</span><span class="token comment"># 启动容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stats<span class="token comment"># Display a live stream of container(s) resource usage statistics</span><span class="token comment"># 显示容器资源的状态</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stop<span class="token comment"># Stop one or more running containers</span><span class="token comment"># 停止容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker tag<span class="token comment"># Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><span class="token comment"># 给源镜像打一个标签</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">top</span><span class="token comment"># Display the running processes of a container</span><span class="token comment"># 查看容器中运行的进程信息</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker unpause<span class="token comment"># Unpause all processes within one or more containers</span><span class="token comment"># 取消暂停容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker update<span class="token comment"># Update configuration of one or more containers</span><span class="token comment"># 更新一个或者多个容器的配置</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker version<span class="token comment"># Show the Docker version information</span><span class="token comment"># 查看docker版本号</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">wait</span><span class="token comment"># Block until one or more containers stop, then print their exit codes</span><span class="token comment"># 截取容器停止时的退出状态值。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><h4 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker search nginx<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker pull nginx<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d --name nginx00 -p <span class="token number">2233</span>:80 nginx<span class="token comment"># 后台启动nginx 并设置名称 nginx00 映射端口 宿主机2233 -&gt; 容器80</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:2233<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it nginx00 /bin/bashroot@fca2fac49368:/$ <span class="token function">whereis</span> nginx <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>存在问题</strong></p><p>每次改动nignx配置文件，都需要进入容器内部，十分的麻烦</p><p><strong>解决方案</strong></p><p>在容器外部宿主机上提供一个映射路径，达到在容器外修改文件，容器内不就可以修改的目的，-v 数据卷</p></blockquote><h4 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a><strong>tomcat</strong></h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it --rm tomcat:9.0 <span class="token comment"># 一般用来测试，用完就删除，及--rm</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker search tomcat<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker pull tomcat:9.0<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d --name tomcat9.0_00 -p <span class="token number">2233</span>:8080 tomcat:9.0<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:2233root@714059eea83c$ docker <span class="token builtin class-name">exec</span> -it tomcat9.0_00 /bin/bash<span class="token function">ls</span> -al<span class="token builtin class-name">cd</span> /usr/local/tomcat<span class="token function">cp</span> -r webapps.dist/* webapps<span class="token comment"># 实际上，这里启动的时阉割版镜像，及默认最小的镜像，所以不必要的都被剔除掉了</span><span class="token comment"># 故：linux命令少，没有webapps。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>存在问题</p><p>每次部署项目，需要进入到容器进行拷贝文件十分麻烦。如果所有的文件都放到容器内部，eg. mysql 如果删除了镜像或者容器，导致所有数据丢失？</p><p>解决方案</p><p>同上</p></blockquote><h4 id="es-kibana"><a href="#es-kibana" class="headerlink" title="es+kibana"></a><strong>es+kibana</strong></h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># elasticsearch 暴露的端口很多、十分的耗内存、数据一般需要放置到安全目录 挂载</span><span class="token comment"># 官方启动命令</span><span class="token comment"># $ docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:tag</span><span class="token comment"># --net somenetwork ？ docker的网络配置</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d --name elasticsearch -p <span class="token number">9200</span>:9200 -p <span class="token number">9300</span>:9300 -e <span class="token string">"discovery.type=single-node"</span> elasticsearch:7.6.2<span class="token comment"># 启动后十分的卡 docker stats 查看cpu状态</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stats  <span class="token variable">${id}</span>?<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stop elasticsearch<span class="token comment"># 添加限制的启动</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d --name elasticsearch -p <span class="token number">9200</span>:9200 -p <span class="token number">9300</span>:9300 -e <span class="token string">"discovery.type=single-node"</span> -e <span class="token assign-left variable">ES_JAVA_OPTS</span><span class="token operator">=</span><span class="token string">"-Xms64m -Xmax512m"</span> elasticsearch:7.6.2<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:9200<span class="token comment">####################################</span><span class="token comment"># kibana 连接  es</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><ul><li>portainer</li><li>rancher（CI/CD）</li></ul><h4 id="portainer"><a href="#portainer" class="headerlink" title="portainer"></a>portainer</h4><p>Docker图像化管理工具，提供了一个后台面板</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">root@qing /<span class="token punctuation">]</span>$ docker run -d -p <span class="token number">8088</span>:9000 <span class="token punctuation">\</span>--restart<span class="token operator">=</span>always -v /var/run/docker.sock:/var/run/docker.sock --privileged<span class="token operator">=</span>true portainer/portainer<span class="token comment"># -v 挂载  宿主机:容器</span><span class="token comment"># --privileged 授权</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h3 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h3><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时的库、环境变量和配置文件</p><p>所有的应用，直接打包docker镜像，就可以直接跑起来</p><ul><li>从远程仓库pull</li><li>拷贝文件</li><li>自己制作一个镜像 dockerFile</li></ul><h3 id="Docker镜像加速原理"><a href="#Docker镜像加速原理" class="headerlink" title="Docker镜像加速原理"></a>Docker镜像加速原理</h3><blockquote><p>UnionFS（联合文件系统）</p></blockquote><p>UnionFS（联合文件系统）：Union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual file system）。Union文件系统时Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><blockquote><p>Docker镜像加载原理</p></blockquote><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层就是bootfs。这一层与我们典型的Linux/Unix系统一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已有bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs（root file system），在bootfs之上，包含典型Linux系统中的/dev 、/proc、/bin、/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版本，eg. Ubuntu Centos…</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect 镜像id<span class="token comment"># 查看镜像信息</span><span class="token comment"># rootFS</span><span class="token comment">#  "RootFS": {</span><span class="token comment">#             "Type": "layers",</span><span class="token comment">#             "Layers": [</span><span class="token comment">#                 "sha256:764055ebc9a7a290b64d17cf9ea550f1099c202d83795aa967428ebdf335c9f7",</span><span class="token comment">#                 "sha256:71a14cc55692a4edac5da18be420acf085c681ec95f7af5ff64bb1c236440d59",</span><span class="token comment">#                 "sha256:50854886015e8e202f3197c6a95ae60632a432aba673188bb7c3f9ee80ed2f30",</span><span class="token comment">#                 "sha256:1952fb2b0eb4d355f05a815c6d804243f089e05c0b8f3b1c1eaf0a1109e8293a",</span><span class="token comment">#                 "sha256:893f6aea2ce23f813c44180ccb7a41e8a4d151cb02f7c365cc4e837c0872b211",</span><span class="token comment">#                 "sha256:b8d0aeaeeee8ed55cb6bfc7e061d0bb0491e91024790c45d0c56b07c29cea080",</span><span class="token comment">#                 "sha256:d7cde20f3f6895bd6e6b2ef5767ee60d7034babe62093340ac22df5c8622db74",</span><span class="token comment">#                 "sha256:ae8fcba6091c17b6691f9a1c49621f193e2f475b3eee44d83b4f78b0d0fd31ae",</span><span class="token comment">#                 "sha256:1a4de2199d77be12009ed995b8db1c5a85d9a9b5e19673a8af4824de03f4ce0a",</span><span class="token comment">#                 "sha256:eeabd280c12ee308111950fd99ba8ffdd75130b6d948ba6a34fe6221b82f20dd",</span><span class="token comment">#                 "sha256:cd0c4980990f734130353adfa00f88ba57bc946b868468d633eeb75abd465fa0",</span><span class="token comment">#                 "sha256:027a41439ba438753333f44da1bc57b86e2211f708ace53343cc733151dc2380"</span><span class="token comment">#             ]</span><span class="token comment">#         },</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>精简后的OS，rootfs可以很小，只包含最基本的命令，工具和程序库就可以了，因为底层直接用Host到Kernel，自己只需要提供rootfs就可以了。达到公用bootfs的目的。</p><p><img src="/2021/12/25/devops/docker-notes/0006.png" alt="0006"></p><p><img src="/2021/12/25/devops/docker-notes/0007.png" alt="0007"></p><blockquote><p>进一步说明</p></blockquote><p>所有的Docker镜像都起始于一个既相互镜像层，当进行修改或者增加新的内容时，就会在当前镜像层之上，创建一个新的镜像层。</p><p><img src="/2021/12/25/devops/docker-notes/0008.png" alt="0008"></p><p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合。及每个镜像层包含了3个文件，而镜像包含了来及两个镜像层的六个文件</p><p><img src="/2021/12/25/devops/docker-notes/0009.png" alt="0009"></p><p>一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，因为最上层中的app2.0是app1.0的一个更新版本。</p><p><img src="/2021/12/25/devops/docker-notes/0010.png" alt="0010"></p><p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件，使得文件的更新版本作为一个新镜像层添加到镜像中。</p><p>Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一 文件系统。</p><p>Linux上可用的存储引擎由AUFS、Overlay2、Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于Linux中对应的文件系统或者块设备技术，并且每种存储引擎都有其独特的性能特点</p><p>Docker在Windows上仅支持windowsfilter一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW [①]。</p><p>所有镜像层堆叠合并后，对外统一提供如上图所示的合并图</p><blockquote><p>特点</p></blockquote><p>Docker镜像都是只读的，当容器启动是，一个新的可写层被加载到镜像的顶部，这一层就是容器层，容器之下的都是叫镜像层。（无限套娃？？？）</p><h3 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 提交容器成为一个新的副本容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker commit<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker commit -m<span class="token operator">=</span><span class="token string">"description"</span> -a<span class="token operator">=</span><span class="token string">"author"</span> 容器id 目标镜像:<span class="token punctuation">[</span>TAG<span class="token punctuation">]</span><span class="token comment"># test</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it -p <span class="token number">8080</span>:8080 tomcat<span class="token comment"># new terminal</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">ps</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it <span class="token variable">${id}</span> /bin/bashroot@sdfj0adf98 /$ <span class="token builtin class-name">cd</span> /usr/local/tomcatroot@sdfj0adf98 /$ <span class="token function">cp</span> -r webapps.dist/* webapps <span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker commit -m<span class="token operator">=</span><span class="token string">"description"</span> -a<span class="token operator">=</span><span class="token string">"author"</span> 容器id 目标镜像:<span class="token punctuation">[</span>TAG<span class="token punctuation">]</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker images<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/12/25/devops/docker-notes/0011.png" alt="0011"></p><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><p>Q：数据可用放在容器里面么？</p><p>A：不能，因为容器如果被删除，会导致数据永久的丢失，所以需要<strong>数据持久化</strong></p><p>所以就有了容器的卷技术，容器之间可用有一个数据共享，将Docker容器中产生的数据同步到本地中 —— 目录挂载，将我们容器内的目录，挂载到Linux上面。将宿主机的内存共享给容器，双向绑定。</p><p><strong>容器持久化和同步操作，容器间也可以数据共享。</strong></p><h3 id="挂载链接"><a href="#挂载链接" class="headerlink" title="挂载链接"></a>挂载链接</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 直接使用命令来挂载 -v</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it 主机目录:容器目录 （镜像）<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it -v /home/ceshi:/home centos /bin/bash<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect 容器Id<span class="token comment"># “Mounts”</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token builtin class-name">cd</span> /home/ceshi<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ls</span><span class="token comment"># 在容器内创建文件</span><span class="token punctuation">[</span>root@sdfuo098sadf /<span class="token punctuation">]</span>$ <span class="token function">ls</span> /home<span class="token punctuation">[</span>root@sdfuo098sadf /<span class="token punctuation">]</span>$ <span class="token function">touch</span> test.java<span class="token comment"># 在宿主机中查看是否文件被同步创建</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ls</span> /home/ceshi<span class="token comment"># [root@qing /]$ docker exec -it 容器id /bin/bash  # 进入后台运行的容器，/bin/bash 位置开启一个新的终端，可以进行一些操作(常用)</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker attach 容器id<span class="token comment">#  进入正在执行的容器进入正在运行的中断，不会启动新的进程</span><span class="token punctuation">[</span>root@sdfuo098sadf /<span class="token punctuation">]</span>$ <span class="token builtin class-name">exit</span><span class="token comment"># 退出容器后，在宿主机上修改文件</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> /home/ceshi/test.java<span class="token comment"># 重新启动容器，查看容器中的该文件是被同步修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 拉取镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker pull mysql:5.7<span class="token comment"># 官方的启动命令</span><span class="token comment"># 启动容器时挂载目录, 配置密码</span><span class="token comment"># -e 环境配置</span><span class="token comment"># $ docker run -it --network some-network --rm mysql mysql -hsome-mysql -uexample-user -p</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -p <span class="token number">2233</span>:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> --name mysql01 mysql:5.7<span class="token comment"># 可用连接创建数据库查看是否持久化成功。</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">rm</span> -f mysql01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 不指定主机目录，会自动挂载</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$  docker run -d -P --name nginx01 -v /etc/nginx nginx<span class="token comment"># 注意 -v 后不添加/ 表明不是目录</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$  docker run -d -P --name nginx02 -v juming_nginx:/etc/nginx nginx<span class="token comment"># 查看所有的卷情况</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker volume <span class="token function">ls</span>DRIVER    VOLUME NAME<span class="token builtin class-name">local</span>     0a99e217ac4ba4842c205b7fe1aae0146425e56b96df7628d78e10198f1337ce<span class="token builtin class-name">local</span>     juming_nginx<span class="token comment"># 可用看出，第一个就是匿名挂载，在 -v 之后只写了容器内的路径，没有写宿主机的路径</span><span class="token comment"># 第二个就是具名挂载 -v 卷名:容器内路径 </span><span class="token comment"># 查看卷的所在目录</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker volume inspect juming_nginx<span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"CreatedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-12-29T23:28:25+08:00"</span>,        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,        <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> null,        <span class="token string">"Mountpoint"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/volumes/juming_nginx/_data"</span>,        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"juming_nginx"</span>,        <span class="token string">"Options"</span><span class="token builtin class-name">:</span> null,        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token comment"># Mountpoint 就是挂载的目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的docker容器内的卷，没有指定目录的情况下都是在 <code>/var/lib/docker/volumes/xxxxxx/_data</code></p><p>通过具名挂载可用很方便的找到一个卷，通常情况下都是使用具名挂载</p><h4 id="挂载小总结"><a href="#挂载小总结" class="headerlink" title="挂载小总结"></a>挂载小总结</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 具名挂载、匿名挂载、指定路径挂载</span>-v 容器内路径<span class="token comment"># 匿名挂载</span>-v 卷名:容器内路径<span class="token comment"># 具名挂载</span>-v /宿主机路径:容器内路径<span class="token comment"># 指定路径挂载</span><span class="token comment"># 通过 -v 容器内路径:ro rw 改变读写权限</span><span class="token comment"># 一旦设置了容器权限，容器对我们挂载出来的容器就有了限定 </span><span class="token comment"># ro 这个路径就只能通过宿主机来操作，容器内部是无法操作的</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name nginx03: -v juming_nginx:/etc/nginx:ro nginx<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name nginx04 -v juming_nginx:/etc/nginx:rw nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dockerFile实现挂载"><a href="#dockerFile实现挂载" class="headerlink" title="dockerFile实现挂载"></a>dockerFile实现挂载</h3><p>命令脚本，可用通过这个脚本来生成镜像，镜像是一层一层的卷，脚本就是一个一个的命令，每个命令就是一层！</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> /home/docker-test-volume<span class="token comment"># 创建dockerFile文件</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> dockerFile1<span class="token comment">#############################dockerFile1##############</span>FROM centosVOLUME <span class="token punctuation">[</span><span class="token string">"volume01"</span>,<span class="token string">"volume02"</span><span class="token punctuation">]</span>CMD <span class="token builtin class-name">echo</span> <span class="token string">"------end------"</span>CMD /bin/bash<span class="token comment">############################dockerFile1##############</span><span class="token comment"># 根据dockerFile 生成镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build -f ./dockerFile1 -t qing/centos:1.0 <span class="token builtin class-name">.</span>Sending build context to Docker daemon  <span class="token number">240</span>.7MBStep <span class="token number">1</span>/4 <span class="token builtin class-name">:</span> FROM centos ---<span class="token operator">&gt;</span> 5d0da3dc9764Step <span class="token number">2</span>/4 <span class="token builtin class-name">:</span> VOLUME <span class="token punctuation">[</span><span class="token string">"volume01"</span>,<span class="token string">"volume02"</span><span class="token punctuation">]</span> ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> eb142d0e83adRemoving intermediate container eb142d0e83ad ---<span class="token operator">&gt;</span> ba3e07adb20bStep <span class="token number">3</span>/4 <span class="token builtin class-name">:</span> CMD <span class="token builtin class-name">echo</span> <span class="token string">"------end------"</span> ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 372a86750520Removing intermediate container 372a86750520 ---<span class="token operator">&gt;</span> 8feb17962dffStep <span class="token number">4</span>/4 <span class="token builtin class-name">:</span> CMD /bin/bash ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> b198098a4925Removing intermediate container b198098a4925 ---<span class="token operator">&gt;</span> 0a15ea858d6bSuccessfully built 0a15ea858d6bSuccessfully tagged qing/centos:1.0<span class="token comment"># 查看镜像</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker imagesREPOSITORY    TAG       IMAGE ID       CREATED         SIZEqing/centos   <span class="token number">1.0</span>       0a15ea858d6b   <span class="token number">6</span> seconds ago   231MB<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it qing/centos:1.0 <span class="token function">bash</span><span class="token punctuation">[</span>root@ef4ca52a471a /<span class="token punctuation">]</span><span class="token comment"># ls</span>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01volume02<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect ef4ca52a471a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="容器间共享数据"><a href="#容器间共享数据" class="headerlink" title="容器间共享数据"></a>容器间共享数据</h3><p>通过数据卷容器来达到容器间的共享</p><p><img src="/2021/12/25/devops/docker-notes/0015.png" alt="0015"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 启动父容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it --name docker01 qing/centos:1.0 <span class="token function">bash</span><span class="token comment"># 启动第二个</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -it --name docker02 --volumes-from docker01 qing/centos:1.0 <span class="token function">bash</span><span class="token comment"># 在父容器中创建文件 会被同步到子容器中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：这里其实是容器都挂载到宿主机的同一个目录下了，并不是多个目录之间在同步，如果删除宿主机下的这个目录的文件，容器内的数据就会消失</p><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><p>dockerFile 是用来构建docker镜像的构建脚本。</p><p>大致步骤</p><ol><li>编写一个dockerFile文件</li><li>docker build 构建一个镜像</li><li>docker  run 运行镜像</li><li>docker push 发布镜像 </li></ol><blockquote><p>每个保留关键字（指令）都是大写</p><p>执行从上到下顺序执行</p><p>/# 表示注释</p><p>每个指令都会创建提交一个新的镜像层，并提交。</p></blockquote><p><img src="/2021/12/25/devops/docker-notes/0016.png" alt="0016"></p><h3 id="指令简述"><a href="#指令简述" class="headerlink" title="指令简述"></a>指令简述</h3><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>基础镜像，从这里开始</td></tr><tr><td>MAINTAINER</td><td>镜像的作者</td></tr><tr><td>RUN</td><td>镜像构建的时候需要运行的命令</td></tr><tr><td>ADD</td><td>编译镜像时复制文本到镜像中</td></tr><tr><td>COPY</td><td>类似ADD，将文件拷贝到镜像中</td></tr><tr><td>WORKDIR</td><td>镜像的工作目录，设置RUN CMD ENTRYPOINT COPY ADD指令的工作目录</td></tr><tr><td>LABEL</td><td>设置镜像的标签</td></tr><tr><td>VOLUME</td><td>挂载的目录</td></tr><tr><td>EXPOSE</td><td>设置镜像暴露的端口</td></tr><tr><td>CMD</td><td>指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被代替</td></tr><tr><td>ENTRYPOINT</td><td>指定这个容器启动的时候要运行的命令，可用追加命令</td></tr><tr><td>ONBUILD</td><td>当构建一个被继承DockerFile这个时候就会运行onbuild的指令，触发指令</td></tr><tr><td>ARG</td><td>设置编译镜像时加入的参数</td></tr><tr><td>ENV</td><td>构建的时候设置的环境变量</td></tr><tr><td>USER</td><td>设置运行RUN CMD ENTRYPOINT的用户名</td></tr><tr><td>STOPSIGNAL</td><td>设置容器的退出信号量</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><p>Docker Hub中99%镜像都是从一个基础镜像scratch过来的。</p><blockquote><p>FROM scratch</p></blockquote><h4 id="制作一个简单的centos扩展镜像"><a href="#制作一个简单的centos扩展镜像" class="headerlink" title="制作一个简单的centos扩展镜像"></a>制作一个简单的centos扩展镜像</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> docker_file_centos<span class="token comment">############################docker_file_centos##############</span>FROM centosMAINTAINER qing<span class="token operator">&lt;</span><span class="token number">111</span>@qq.com<span class="token operator">&gt;</span>ENV MYPATH /usr/localWORKDIR <span class="token variable">$MYPATH</span>RUN yum -y <span class="token function">install</span> <span class="token function">vim</span>RUN yum -y insatll net-toolsEXPOSE <span class="token number">80</span>CMD <span class="token builtin class-name">echo</span> <span class="token string">"------end-----"</span>CMD /bin/bash<span class="token comment">############################docker_file_centos##############</span><span class="token comment"># 在官方的centos基础上添加了vim 和 net-tools</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build -f home/doker_files/docker_file_centos -t qing/centos:1.1 <span class="token builtin class-name">.</span><span class="token comment"># 可用启动测试下 ipconfig vim 命令</span><span class="token comment"># 查看下镜像构建的历史</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token function">history</span> 镜像id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用tar制作tomcat镜像"><a href="#使用tar制作tomcat镜像" class="headerlink" title="使用tar制作tomcat镜像"></a>使用tar制作tomcat镜像</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ls</span>apache-tomcat-9.0.56.tar.gz jdk1.8.0_181<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">touch</span> readme.md<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> Dockerfile <span class="token comment"># 该命令 build是会自动讯在，不用-f指定 </span><span class="token comment">############################Dockerfile##############</span>FROM centosMAINTAINER qing<span class="token operator">&lt;</span><span class="token number">111</span>@qq.com<span class="token operator">&gt;</span>COPY readme.md /usr/local/readme.txt<span class="token comment"># 直接复制</span>COPY jdk1.8.0_181/ /usr/local/jdk1.8.0_181/<span class="token comment"># 会自动解压</span>ADD apache-tomcat-9.0.56.tar /usr/local/RUN yum -y <span class="token function">install</span> <span class="token function">vim</span> ENV MYPATH /usr/localWORKDIR <span class="token variable">$MYPATH</span>ENV JAVA_HOME /usr/local/jdk1.8.0_181ENV CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.56ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.56ENV <span class="token environment constant">PATH</span> <span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$JAVA_HOEM</span>/bin:<span class="token variable">$CATALINA_HOME</span>/lib:<span class="token variable">$CATALINA_HOME</span>/binEXPOSE <span class="token number">8080</span>CMD /usr/local/apache-tomcat-9.0.56/bin/startup.sh <span class="token operator">&amp;&amp;</span> <span class="token function">tail</span> -F /url/localapache-tomcat-9.0.56/bin/logs/catalina.out<span class="token comment">############################Dockerfile##############</span><span class="token comment"># 构建启动</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build -t qing/tomcat:1.0 <span class="token builtin class-name">.</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker images<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -p <span class="token number">2233</span>:8080 --name qingtomcat -v /home/qing/tomcat/test:/usr/local/apache-tomcat-9.0.56/webapps/test -v /home/qing/tomcat/logs:/usr/local/apache-tomcat-9.0.56/logs qing/tomcat:1.0<span class="token comment"># 测试</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">curl</span> localhost:2233<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root@qing /]$ mkdir /home/qing/tomcat/test/EB-INF[root@qing /]$ cd /home/qing/tomcat/test/EB-INF[root@qing /]$ vim web.xml############################web.xml##############&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee                             http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"         ersion="2.5"&gt;&lt;/web-app&gt;  ############################web.xml##############[root@qing /]$ cd ..[root@qing /]$ vim index.jsp############################index.jsp##############&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;br/&gt;&lt;%System.out.println("Your IP address is " + request.getRemoteAddr());%&gt;&lt;/body&gt;&lt;/html&gt;############################index.jsp##############<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h3><h4 id="CMD和ENTRYPOINT的区别"><a href="#CMD和ENTRYPOINT的区别" class="headerlink" title="CMD和ENTRYPOINT的区别"></a>CMD和ENTRYPOINT的区别</h4><ul><li>CMD<ul><li>启动的时候如果在最后追加了命令会替换掉镜像中的命令</li></ul></li><li>ENRYPOINT<ul><li>启动后如果在最后追加了命令，不会替换镜像中的命令，而是在其后追加</li></ul></li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> docker_file_cmd<span class="token comment">############################docker_file_cmd##############</span>FROM centosCMD <span class="token punctuation">[</span><span class="token string">"ls"</span>,<span class="token string">"-a"</span><span class="token punctuation">]</span><span class="token comment">############################docker_file_cmd##############</span><span class="token comment"># 在官方的centos基础上添加了vim 和 net-tools</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build -f home/doker_files/docker_file_cmd -t qing/centos:1.2 <span class="token builtin class-name">.</span><span class="token comment"># 直接运行会发现 ls -a 执行了</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span><span class="token variable">$dovker</span> run centos:1.2<span class="token comment"># 追加命令执行</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span><span class="token variable">$dovker</span> run centos:1.2 -lerror<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">vim</span> docker_file_entrypoint<span class="token comment">############################docker_file_entrypoint##############</span>FROM centosENTRYPOINT <span class="token punctuation">[</span><span class="token string">"ls"</span>,<span class="token string">"-a"</span><span class="token punctuation">]</span><span class="token comment">############################docker_file_entrypoint##############</span><span class="token comment"># 在官方的centos基础上添加了vim 和 net-tools</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker build -f home/doker_files/docker_file_entrypoint -t qing/centos:1.3 <span class="token builtin class-name">.</span><span class="token comment"># 直接运行会发现 ls -a 执行了</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ dovker run centos:1.2<span class="token comment"># 追加命令执行，会发现 执行了 ls -a -l</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ dovker run centos:1.2 -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h3><h4 id="DockerHub"><a href="#DockerHub" class="headerlink" title="DockerHub"></a>DockerHub</h4><ol><li><p>地址<a href="http://hub.docker.com/">http://hub.docker.com/</a> 注册自己的账号</p></li><li><p>在服务器上提交自己的镜像</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 登录自己账户号</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker login -u qingPassword:Login Succeeded<span class="token comment"># 提交镜像 尽量带上自己的版本号</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker push  qing/tomcat:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="阿里云容器镜像服务"><a href="#阿里云容器镜像服务" class="headerlink" title="阿里云容器镜像服务"></a>阿里云容器镜像服务</h4><ol><li>登录阿里云，找到容器镜像服务</li><li>根据需求创建命名空间、</li><li>创建容器镜像</li><li>根据阿里云上的操作指南进行提交</li></ol><h2 id="流程小结"><a href="#流程小结" class="headerlink" title="流程小结"></a>流程小结</h2><p><img src="/2021/12/25/devops/docker-notes/0017.png" alt="0017"></p><h2 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h2><h3 id="实验查看"><a href="#实验查看" class="headerlink" title="实验查看"></a>实验查看</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看IP地址</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ip</span> addr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2021/12/25/devops/docker-notes/0018.png" alt="0018"></p><p>Q：docker如何处理容器网络访问的？</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat01 tomcat<span class="token comment"># 查看容器的内部Ip地址</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat01 <span class="token function">ip</span> addr<span class="token comment">## 如果 报错 OCI runtime exec failed: </span><span class="token comment">## 因为该tomcat镜像为了最小化，可能没有安装ip addr命令，故需要安装 iproute2</span><span class="token comment"># [root@qing /]$ docker exec -it tomcat01 bash</span><span class="token comment"># root@bd19d226252e $ apt update &amp;&amp; apt install -y iproute2</span><span class="token comment"># 再次输入</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat01 <span class="token function">ip</span> addr<span class="token comment"># 查看一下容器的内部网络地址，发现容器启动的时候会得到一个eth0@if61的ip地址，该地址是由docker分配的 详细见 图0019</span>       <span class="token comment"># 可用通过宿主机ping 改ip</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token function">ping</span> <span class="token number">172.18</span>.0.2<span class="token comment"># 与图片0018中的 docker0 172.18.0.1/16 可用得知该网络与docker0属于同一个网段</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/12/25/devops/docker-notes/0019.png" alt="0019"></p><h3 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h3><ol><li><p>每启动一个docker容器，docker就会给docker容器分配一个ip，只要安装了docker，就会有一个网卡docker0。通过桥接模式，使用的技术veth-pair技术进行连接。</p></li><li><p>再次在宿主机测试<code>ip addr</code>，对比图0019和图0020，可以看到了宿主机多了一个网卡，序号上与容器中是对应的</p><blockquote><p>容器带来的网卡都是一对存在的</p><p>veth-pair 就是一对虚拟设备接口，都是成对出现，一段连着协议，一段彼此相连。基于此特性，veth-pair充当一个桥梁，连接各种虚拟网络设备的</p><p>OpenStac、Docker容器之间的连接、OVS的连接，都是使用veth-pair 技术</p></blockquote><p><img src="/2021/12/25/devops/docker-notes/0020.png" alt="0020"></p></li><li><p>所以在启动多个容器的时候，由于都是由docker0分配的网卡的ip都属于同一个网段，所以容器之间也是可以相互访问的。</p></li></ol><p><img src="/2021/12/25/devops/docker-notes/0021.png" alt="0021"></p><ol start="4"><li>所以，在启动容器时不指定网络的情况下，都是哟docker来分配一个默认的可用IP，且由docker0来进行路由</li></ol><p><strong>小结</strong></p><blockquote><p>Docker使用的是Linux的桥接，宿主机中的一个网卡docker0就是Docker的网桥 </p><p>docker中的所有网络接口都是虚拟的，虚拟的转发效率高、</p></blockquote><p><img src="/2021/12/25/devops/docker-notes/0022.png" alt="0022"></p><h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><h4 id="–Link"><a href="#–Link" class="headerlink" title="–Link"></a>–Link</h4><blockquote><p>但是并不推荐使用 –link 进行容器连接。因为部分的自定义网络不适于使用docker0 进行路由，例如：不支持使用容器名进行连接</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat01 tomcat<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat02 tomcat<span class="token comment"># 直接在容器间进行ping</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat02 <span class="token function">ping</span> tomcat01<span class="token comment">## 如果 报错 OCI runtime exec failed: </span><span class="token comment">## 不支持ping命令时，则需要进入容器手动安装该命令</span><span class="token comment"># [root@qing /]$ docker exec -it tomcat02 bash</span><span class="token comment"># root@bd19d226252e $ apt update &amp;&amp; apt install iputils-ping</span>ping: tomcat01: Name or <span class="token function">service</span> not known  <span class="token comment"># 可知无法与tomcat01进行通信</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat03 --link tomcat02 tomcat<span class="token comment"># 如果不存在ping命令，则需要同上面的方式安装 </span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat03 <span class="token function">ping</span> tomcat02PING tomcat02 <span class="token punctuation">(</span><span class="token number">172.18</span>.0.3<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.<span class="token number">64</span> bytes from tomcat02 <span class="token punctuation">(</span><span class="token number">172.18</span>.0.3<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.104</span> ms<span class="token number">64</span> bytes from tomcat02 <span class="token punctuation">(</span><span class="token number">172.18</span>.0.3<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.059</span> ms<span class="token comment"># 可用发现 通过--link 便可以在容器之间 通过服务名联通(不用指定ip)</span><span class="token comment"># 但是反向却无法ping通</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat02 <span class="token function">ping</span> tomcat03<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里 –link 是将tomcat03对tomcat02的连接添加到了配置项中，所以可用tomcat03可用访问到tomcat02。使用inspect命令查看docker的元数据可以看到如下配置</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker inspect tomcat03<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/12/25/devops/docker-notes/0023.png" alt="0023"></p><blockquote><p>也可以通过查看hosts配置</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat03 <span class="token function">cat</span> /etc/hosts<span class="token comment"># 可以理解为在host文件中添加了域名映射</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2021/12/25/devops/docker-notes/0024.png" alt="0024"></p><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker network <span class="token function">ls</span> <span class="token comment"># 查看所有网络</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/12/25/devops/docker-notes/0025.png" alt="0025"></p><h4 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h4><ul><li>bridge：桥接模式 （docker 默认）</li><li>none：不配置网络</li><li>host：与宿主机共享模式</li><li>container：容器网络连通（局限较大）</li></ul><h4 id="自定义网络-1"><a href="#自定义网络-1" class="headerlink" title="自定义网络"></a>自定义网络</h4><blockquote><p>可以修复docker0中，在不适用–link是，不支持直接使用容器名进行连接</p></blockquote><p><strong>自定义网络选择使用bridge模式</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 直接启动的容器，有一个默认参数为： --net bridge，这里使用的就是docker0</span><span class="token comment"># docker run -d -P --name tomcat01 --net bridge tomcat</span><span class="token comment"># 自定义一个网络</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker network create --driver bridge --subnet <span class="token number">192.168</span>.0.0/16 --gateway <span class="token number">192.168</span>.0.1 mynet<span class="token comment">## --driver 连接模式</span><span class="token comment">## --subnet 子网掩码</span><span class="token comment">## --gateway 路由ip</span><span class="token comment"># 故可以在启动的时候指定使用该自定义的网络</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat-net-01 --net mynet tomcat<span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker run -d -P --name tomcat-net-02 --net mynet tomcat<span class="token comment"># 查看此时自定义网络的元数据</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker network inspect mynet <span class="token comment"># 图片0026中可以看到容器的网络</span><span class="token comment"># 此时使用自定义的网络直接通过容器名进行ping</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it tomcat-net-01 <span class="token function">ping</span> tomcat-net-02<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/12/25/devops/docker-notes/0026.png" alt="0026"></p><h4 id="将不同网络连接"><a href="#将不同网络连接" class="headerlink" title="将不同网络连接"></a>将不同网络连接</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 将网络docker0下的tomcat01连接到 mynet网络下（达成一个容器两个ip）</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker network connect mynet tomcat01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2021/12/25/devops/docker-notes/0027.png" alt="0027"></p><h4 id="demo-redis集群"><a href="#demo-redis集群" class="headerlink" title="demo-redis集群"></a>demo-redis集群</h4><blockquote><p>分片 集群 高可用</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 创建网卡</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker network create redis --subnet <span class="token number">172.38</span>.0.0/16<span class="token comment"># 通过脚本创建六个redis配置</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token keyword">for</span> <span class="token for-or-select variable">port</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> <span class="token number">1</span> <span class="token number">6</span><span class="token variable">)</span></span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token keyword">do</span> <span class="token punctuation">\</span><span class="token function">mkdir</span> -p /data/qing/redis/node-<span class="token variable">${port}</span>/conf<span class="token function">touch</span> /data/qing/redis/node-<span class="token variable">${port}</span>/conf/redis.conf<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span>/data/qing/redis/node-<span class="token variable">${port}</span>/conf/redis.conf</span>port 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1<span class="token variable">${port}</span>cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOF</span><span class="token keyword">done</span><span class="token comment"># 启动六个容器</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ <span class="token keyword">for</span> <span class="token for-or-select variable">port</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> <span class="token number">1</span> <span class="token number">6</span><span class="token variable">)</span></span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token keyword">do</span> <span class="token punctuation">\</span>docker run -p <span class="token number">637</span><span class="token variable">${port}</span>:6379 -p <span class="token number">1637</span><span class="token variable">${port}</span>:16379 --name redis-<span class="token variable">${port}</span> <span class="token punctuation">\</span>-v /data/qing/redis/node-<span class="token variable">${port}</span>/data:/data <span class="token punctuation">\</span>-v /data/qing/redis/node-<span class="token variable">${port}</span>/conf/redis.conf:/etc/redis/redis.conf <span class="token punctuation">\</span>-d --net redis --ip <span class="token number">172.38</span>.0.1<span class="token variable">${port}</span> redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token keyword">done</span><span class="token comment"># 进入容器创建集群</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker <span class="token builtin class-name">exec</span> -it redis-1 /bin/sh<span class="token comment"># 创建集群</span>/data $ redis-cli --cluster create <span class="token number">172.38</span>.0.11:6379 <span class="token number">172.38</span>.0.12:6379 <span class="token number">172.38</span>.0.13:6379 <span class="token number">172.38</span>.0.14:6379 <span class="token number">172.38</span>.0.15:6379 <span class="token number">172.38</span>.0.16:6379 --cluster-replicas <span class="token number">1</span><span class="token comment">#### 以下为输出 部分省略####</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Performing <span class="token builtin class-name">hash</span> slots allocation on <span class="token number">6</span> nodes<span class="token punctuation">..</span>.Master<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> -<span class="token operator">&gt;</span> Slots <span class="token number">0</span> - <span class="token number">5460</span>Master<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> -<span class="token operator">&gt;</span> Slots <span class="token number">5461</span> - <span class="token number">10922</span>Master<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> -<span class="token operator">&gt;</span> Slots <span class="token number">10923</span> - <span class="token number">16383</span>Adding replica <span class="token number">172.38</span>.0.15:6379 to <span class="token number">172.38</span>.0.11:6379<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All nodes agree about slots configuration.<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Check <span class="token keyword">for</span> <span class="token function">open</span> slots<span class="token punctuation">..</span>.<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Check slots coverage<span class="token punctuation">..</span>.<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All <span class="token number">16384</span> slots covered.<span class="token comment">#### 以上为输出 ####</span><span class="token comment"># 测试</span>/data $ redis-cli -c<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> cluster info<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> cluster nodes<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> a b-<span class="token operator">&gt;</span> Redirected to slot <span class="token punctuation">[</span><span class="token number">15495</span><span class="token punctuation">]</span> located at <span class="token number">172.38</span>.0.13:6379OK <span class="token comment"># 可以看出保存到了3号节点</span><span class="token comment"># 关闭一个容器 测试 172.38.0.13:6379 这里是 13 所以停掉3号</span><span class="token punctuation">[</span>root@qing /<span class="token punctuation">]</span>$ docker stop redis-3<span class="token comment"># 在容器内获取刚刚存入的值</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get a-<span class="token operator">&gt;</span> Redirected to slot <span class="token punctuation">[</span><span class="token number">15495</span><span class="token punctuation">]</span> located at <span class="token number">172.38</span>.0.14:6379<span class="token string">"b"</span> <span class="token comment"># 可以看到这里从4号机器中获取</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> command </tag>
            
            <tag> note </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令详解</title>
      <link href="/2021/12/18/tool/git-note/"/>
      <url>/2021/12/18/tool/git-note/</url>
      
        <content type="html"><![CDATA[<h2 id="命令脑图"><a href="#命令脑图" class="headerlink" title="命令脑图"></a>命令脑图</h2><blockquote><p>鹅厂程序猿常用的 Git 命令思维导图</p></blockquote><p><img src="/2021/12/18/tool/git-note/git-notes-0000.svg" alt="脑图"></p><h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="配置级别"><a href="#配置级别" class="headerlink" title="配置级别"></a>配置级别</h3><p><code>git</code>的配置级别主要分为三类</p><blockquote><ol><li>仓库级别 <code>local</code> [优先级最高]<ol><li><code>git</code> 仓库级别对应的配置文件是当前仓库下的<code>.git/config</code>，默认是隐藏的 </li><li><strong><code>git config --local -l</code></strong>  or <strong><code>git config --local --list</code></strong>  [查看仓库级别的配置] </li><li><code>git config --local -e</code> 编辑仓库级别配置文件</li></ol></li><li>用户级别 <code>global</code>[优先级次之]<ol><li><code>git</code> 用户级别对应的配置文件是用户宿主目录下的<code>~/.gitconfig</code>（<code>C:\Users\XXX\.gitconfig</code>）</li><li>**<code>git config --global -l</code>**or <strong><code>git config --global --list</code></strong>  [查看用户级别的配置]</li><li><code>git config --global -e</code> 编辑用户级别配置文件</li></ol></li><li>系统级别 <code>system</code>[优先级最低]<ol><li><code>git</code>系统级别对应的配置文件是git安装目录下的<code> /etc/gitconfig</code>（<code>[install-path]\mingw64\etc\gitconfig</code>）</li><li><strong><code>git config --system -l</code></strong> or <strong><code>git config --system --list</code></strong> [查看系统级别的配置</li><li><code>git config --system -e</code> 编辑系统级别配置文件</li></ol></li><li>查看全部<ol><li><strong><code>git config -l</code></strong> or <strong><code>git config --list</code></strong> </li><li>其中的分类为<ul><li><code>core.XXX</code>    为仓库级配置</li><li><code>user.XXX</code>    为用户级配置</li><li><code>http.XXX</code>    为系统级配置</li></ul></li></ol></li></ol></blockquote><blockquote><p>添加邮箱和用户名</p><ul><li><code>git config --global user.email “XXX@xxx.com” </code>    # 用户级</li><li><code>git config --global user.name “XXX” </code>                # 用户级</li></ul></blockquote><h2 id="功能性配置"><a href="#功能性配置" class="headerlink" title="功能性配置"></a>功能性配置</h2><h3 id="通用SSH配置"><a href="#通用SSH配置" class="headerlink" title="通用SSH配置"></a>通用SSH配置</h3><ol><li>首先确保用户名与账号的配置完成</li><li>生成密钥对</li></ol><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"> $ ssh-keygen -t rsa -C "xxx@xxx.com" # 生成秘钥# 之后会又两个输入选项：# 1、第一个是指定生成的密钥文件名(将会放在用户文件目录下)，如果不指定，则使用默认的文件名称# id_rsa.pub  公钥id_rsa  私钥# 2、第二个是指定验证密码，不输入则默认为空。设置密码后，每次使用git时都需要输入在此设置的密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/12/18/tool/git-note/git-notes-0001.png" alt="生成密钥"></p><ol start="3"><li><p>进入到用户宿主目录下，获取公钥 <code>cat ~/.ssh/id_rsa.pub</code>    (也可以直接访问id_rsa.pub文件查看)</p></li><li><p>进入github或者其他版本管理系统，添加此处获得的公钥</p></li><li><p>测试访问 <code>ssh -T git@github.com</code> </p><p>​        返回如下提示则配置成功 <code>Hi xxxx! You've successfully authenticated, but GitHub does not provide shell access.</code></p><p>​        <img src="/2021/12/18/tool/git-note/git-notes-0002.png" alt="测试连接效果"></p></li><li><p>修改<code>git</code>的<code>remote url</code></p></li></ol><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 查看当前的 remote url$ git remote -vorigin https://github.com/XXX/XXXproject.git (fetch) # 此结果说明 使用https协议进行访问origin https://github.com/XXX/XXXproject.git (push)#  复制SSH链接，进行调整$ git remote set-url origin git@github.com:XXX/XXXproject.git# 之后可再次使用查看 remote url 会发现已经被修改$ git remote -vorigin  git@github.com:XXX/XXXproject.git (fetch)  # git开头则表示是git协议origin  git@github.com:XXX/XXXproject.git (push)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多仓库源多密钥设置"><a href="#多仓库源多密钥设置" class="headerlink" title="多仓库源多密钥设置"></a>多仓库源多密钥设置</h3><p>通过在配置项中指定服务器与对应的密钥对，来达到在同一个机器上对不同的git仓库使用不同的密钥对进行匹配。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">% vim ~/.ssh/config# 在config文件中增加一下内容Host github.comHostName github.comUser 账号IdentityFile &lt;自定义的目录&gt;/id_rsaIdentitiesOnly yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.processon.com/view/link/5c6e2755e4b03334b523ffc3#map">脑图来源</a>：<a href="https://www.processon.com/view/link/5c6e2755e4b03334b523ffc3#map">https://www.processon.com/view/link/5c6e2755e4b03334b523ffc3#map</a></p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> tool </tag>
            
            <tag> github </tag>
            
            <tag> configuration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/12/12/helloworld/hello-world/"/>
      <url>/2021/12/12/helloworld/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> HelloWorld </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HelloWorld </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
